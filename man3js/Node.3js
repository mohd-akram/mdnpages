'\" t
.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Node" "JS" "July 12, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Node \- Node
.SH SYNOPSIS
The DOM \f[B]\f[CB]Node\f[B]\f[R] interface is an abstract base class
upon which many other DOM API objects are based, thus letting those
object types to be used similarly and often interchangeably.
As an abstract class, there is no such thing as a plain \f[CR]Node\f[R]
object.
All objects that implement \f[CR]Node\f[R] functionality are based on
one of its subclasses.
Most notable are \f[CR]Document\f[R], \f[CR]Element\f[R], and
\f[CR]DocumentFragment\f[R].
.PP
In addition, every kind of DOM node is represented by an interface based
on \f[CR]Node\f[R].
These include \f[CR]Attr\f[R], \f[CR]CharacterData\f[R] (which
\f[CR]Text\f[R], \f[CR]Comment\f[R], \f[CR]CDATASection\f[R] and
\f[CR]ProcessingInstruction\f[R] are all based on), and
\f[CR]DocumentType\f[R].
.PP
In some cases, a particular feature of the base \f[CR]Node\f[R]
interface may not apply to one of its child interfaces; in that case,
the inheriting node may return \f[CR]null\f[R] or throw an exception,
depending on circumstances.
For example, attempting to add children to a node type that cannot have
children will throw an exception.
.SH INSTANCE PROPERTIES
\f[I]In addition to the properties below, \f[CI]Node\f[I] inherits
properties from its parent, \f[CI]EventTarget\f[I]\f[R].
.TP
\f[B]Node.baseURI\f[R] \f[I](read\-only)\f[R]
Returns a string representing the base URL of the document containing
the \f[CR]Node\f[R].
.TP
\f[B]Node.childNodes\f[R] \f[I](read\-only)\f[R]
Returns a live \f[CR]NodeList\f[R] containing all the children of this
node (including elements, text and comments).
\f[CR]NodeList\f[R] being live means that if the children of the
\f[CR]Node\f[R] change, the \f[CR]NodeList\f[R] object is automatically
updated.
.TP
\f[B]Node.firstChild\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]Node\f[R] representing the first direct child node of
the node, or \f[CR]null\f[R] if the node has no child.
.TP
\f[B]Node.isConnected\f[R] \f[I](read\-only)\f[R]
A boolean indicating whether or not the Node is connected (directly or
indirectly) to the context object, e.g.\ the \f[CR]Document\f[R] object
in the case of the normal DOM, or the \f[CR]ShadowRoot\f[R] in the case
of a shadow DOM.
.TP
\f[B]Node.lastChild\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]Node\f[R] representing the last direct child node of the
node, or \f[CR]null\f[R] if the node has no child.
.TP
\f[B]Node.nextSibling\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]Node\f[R] representing the next node in the tree, or
\f[CR]null\f[R] if there isn\[cq]t such node.
.TP
\f[B]Node.nodeName\f[R] \f[I](read\-only)\f[R]
Returns a string containing the name of the \f[CR]Node\f[R].
The structure of the name will differ with the node type.
E.g.
An \f[CR]HTMLElement\f[R] will contain the name of the corresponding
tag, like \f[CR]\[aq]AUDIO\[aq]\f[R] for an \f[CR]HTMLAudioElement\f[R],
a \f[CR]Text\f[R] node will have the \f[CR]\[aq]#text\[aq]\f[R] string,
or a \f[CR]Document\f[R] node will have the
\f[CR]\[aq]#document\[aq]\f[R] string.
.TP
\f[B]Node.nodeType\f[R] \f[I](read\-only)\f[R]
Returns an \f[CR]unsigned short\f[R] representing the type of the node.
Possible values are:
.RS
.PP
.TS
tab(@);
l l.
T{
Name
T}@T{
Value
T}
_
T{
\f[CR]ELEMENT_NODE\f[R]
T}@T{
\f[CR]1\f[R]
T}
T{
\f[CR]ATTRIBUTE_NODE\f[R]
T}@T{
\f[CR]2\f[R]
T}
T{
\f[CR]TEXT_NODE\f[R]
T}@T{
\f[CR]3\f[R]
T}
T{
\f[CR]CDATA_SECTION_NODE\f[R]
T}@T{
\f[CR]4\f[R]
T}
T{
\f[CR]PROCESSING_INSTRUCTION_NODE\f[R]
T}@T{
\f[CR]7\f[R]
T}
T{
\f[CR]COMMENT_NODE\f[R]
T}@T{
\f[CR]8\f[R]
T}
T{
\f[CR]DOCUMENT_NODE\f[R]
T}@T{
\f[CR]9\f[R]
T}
T{
\f[CR]DOCUMENT_TYPE_NODE\f[R]
T}@T{
\f[CR]10\f[R]
T}
T{
\f[CR]DOCUMENT_FRAGMENT_NODE\f[R]
T}@T{
\f[CR]11\f[R]
T}
.TE
.RE
.TP
\f[B]Node.nodeValue\f[R]
Returns / Sets the value of the current node.
.TP
\f[B]Node.ownerDocument\f[R] \f[I](read\-only)\f[R]
Returns the \f[CR]Document\f[R] that this node belongs to.
If the node is itself a document, returns \f[CR]null\f[R].
.TP
\f[B]Node.parentNode\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]Node\f[R] that is the parent of this node.
If there is no such node, like if this node is the top of the tree or if
doesn\[cq]t participate in a tree, this property returns
\f[CR]null\f[R].
.TP
\f[B]Node.parentElement\f[R] \f[I](read\-only)\f[R]
Returns an \f[CR]Element\f[R] that is the parent of this node.
If the node has no parent, or if that parent is not an
\f[CR]Element\f[R], this property returns \f[CR]null\f[R].
.TP
\f[B]Node.previousSibling\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]Node\f[R] representing the previous node in the tree, or
\f[CR]null\f[R] if there isn\[cq]t such node.
.TP
\f[B]Node.textContent\f[R]
Returns / Sets the textual content of an element and all its
descendants.
.SH INSTANCE METHODS
\f[I]In addition to the methods below, \f[CI]Node\f[I] inherits methods
from its parent, \f[CI]EventTarget\f[I].\f[R]
.TP
\f[B]Node.appendChild()\f[R]
Adds the specified \f[CR]childNode\f[R] argument as the last child to
the current node.
If the argument referenced an existing node on the DOM tree, the node
will be detached from its current position and attached at the new
position.
.TP
\f[B]Node.cloneNode()\f[R]
Clone a \f[CR]Node\f[R], and optionally, all of its contents.
By default, it clones the content of the node.
.TP
\f[B]Node.compareDocumentPosition()\f[R]
Compares the position of the current node against another node in any
other document.
.TP
\f[B]Node.contains()\f[R]
Returns \f[CR]true\f[R] or \f[CR]false\f[R] value indicating whether or
not a node is a descendant of the calling node.
.TP
\f[B]Node.getRootNode()\f[R]
Returns the context object\[cq]s root which optionally includes the
shadow root if it is available.
.TP
\f[B]Node.hasChildNodes()\f[R]
Returns a boolean value indicating whether or not the element has any
child nodes.
.TP
\f[B]Node.insertBefore()\f[R]
Inserts a \f[CR]Node\f[R] before the reference node as a child of a
specified parent node.
.TP
\f[B]Node.isDefaultNamespace()\f[R]
Accepts a namespace URI as an argument and returns a boolean value with
a value of \f[CR]true\f[R] if the namespace is the default namespace on
the given node or \f[CR]false\f[R] if not.
.TP
\f[B]Node.isEqualNode()\f[R]
Returns a boolean value which indicates whether or not two nodes are of
the same type and all their defining data points match.
.TP
\f[B]Node.isSameNode()\f[R]
Returns a boolean value indicating whether or not the two nodes are the
same (that is, they reference the same object).
.TP
\f[B]Node.lookupPrefix()\f[R]
Returns a string containing the prefix for a given namespace URI, if
present, and \f[CR]null\f[R] if not.
When multiple prefixes are possible, the result is
implementation\-dependent.
.TP
\f[B]Node.lookupNamespaceURI()\f[R]
Accepts a prefix and returns the namespace URI associated with it on the
given node if found (and \f[CR]null\f[R] if not).
Supplying \f[CR]null\f[R] for the prefix will return the default
namespace.
.TP
\f[B]Node.normalize()\f[R]
Clean up all the text nodes under this element (merge adjacent, remove
empty).
.TP
\f[B]Node.removeChild()\f[R]
Removes a child node from the current element, which must be a child of
the current node.
.TP
\f[B]Node.replaceChild()\f[R]
Replaces one child \f[CR]Node\f[R] of the current one with the second
one given in parameter.
.SH EXAMPLES
.SS Remove all children nested within a node
This function remove each first child of an element, until there are
none left.
.IP
.EX
\f[B]function\f[R] removeAllChildren(element) {
  \f[B]while\f[R] (element.firstChild) {
    element.removeChild(element.firstChild);
  }
}
.EE
.PP
Using this function is a single call.
Here we empty the body of the document:
.IP
.EX
removeAllChildren(document.body);
.EE
.PP
An alternative could be to set the textContent to the empty string:
\f[CR]document.body.textContent = \[dq]\[dq]\f[R].
.SS Recurse through child nodes
The following function recursively calls a callback function for each
node contained by a root node (including the root itself):
.IP
.EX
\f[B]function\f[R] eachNode(rootNode, callback) {
  \f[B]if\f[R] (!callback) {
    \f[B]const\f[R] nodes = [];
    eachNode(rootNode, (node) \f[B]=>\f[R] {
      nodes.push(node);
    });
    \f[B]return\f[R] nodes;
  }

  \f[B]if\f[R] (callback(rootNode) === \f[B]false\f[R]) {
    \f[B]return\f[R] \f[B]false\f[R];
  }

  \f[B]if\f[R] (rootNode.hasChildNodes()) {
    \f[B]for\f[R] (\f[B]const\f[R] node \f[B]of\f[R] rootNode.childNodes) {
      \f[B]if\f[R] (eachNode(node, callback) === \f[B]false\f[R]) {
        \f[B]return\f[R];
      }
    }
  }
}
.EE
.PP
The function recursively calls a function for each descendant node of
\f[CR]rootNode\f[R] (including the root itself).
.PP
If \f[CR]callback\f[R] is omitted, the function returns an
\f[CR]Array\f[R] instead, which contains \f[CR]rootNode\f[R] and all
nodes contained within.
.PP
If \f[CR]callback\f[R] is provided, and it returns \f[CR]false\f[R] when
called, the current recursion level is aborted, and the function resumes
execution at the last parent\[cq]s level.
This can be used to abort loops once a node has been found (such as
searching for a text node which contains a certain string).
.PP
The function has two parameters:
.TP
\f[B]rootNode\f[R]
The \f[CR]Node\f[R] object whose descendants will be recursed through.
.TP
\f[B]callback\f[R] \f[I](optional)\f[R]
An optional callback function that receives a \f[CR]Node\f[R] as its
only argument.
If omitted, \f[CR]eachNode\f[R] returns an \f[CR]Array\f[R] of every
node contained within \f[CR]rootNode\f[R] (including the root itself).
.PP
The following demonstrates a real\-world use of the
\f[CR]eachNode()\f[R] function: searching for text on a web\-page.
.PP
We use a wrapper function named \f[CR]grep\f[R] to do the searching:
.IP
.EX
\f[B]function\f[R] grep(parentNode, pattern) {
  \f[B]let\f[R] matches = [];
  \f[B]let\f[R] endScan = \f[B]false\f[R];

  eachNode(parentNode, (node) \f[B]=>\f[R] {
    \f[B]if\f[R] (endScan) {
      \f[B]return\f[R] \f[B]false\f[R];
    }

    \f[I]// Ignore anything which isn\[aq]t a text node\f[R]
    \f[B]if\f[R] (node.nodeType !== Node.TEXT_NODE) {
      \f[B]return\f[R];
    }

    \f[B]if\f[R] (\f[B]typeof\f[R] pattern === \[dq]string\[dq] && node.textContent.includes(pattern)) {
      matches.push(node);
    } \f[B]else\f[R] \f[B]if\f[R] (pattern.test(node.textContent)) {
      \f[B]if\f[R] (!pattern.global) {
        endScan = \f[B]true\f[R];
        matches = node;
      } \f[B]else\f[R] {
        matches.push(node);
      }
    }
  });

  \f[B]return\f[R] matches;
}
.EE
