.\" Automatically generated by Pandoc 3.4
.\"
.TH "SubtleCrypto.sign" "JS" "September 25, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SubtleCrypto.sign \- SubtleCrypto: sign() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]sign()\f[B]\f[R] method of the \f[CR]SubtleCrypto\f[R]
interface generates a digital signature.
.PP
It takes as its arguments a key to sign with, some algorithm\-specific
parameters, and the data to sign.
It returns a \f[CR]Promise\f[R] which will be fulfilled with the
signature.
.PP
You can use the corresponding \f[CR]SubtleCrypto.verify()\f[R] method to
verify the signature.
.SH SYNTAX
.IP
.EX
sign(algorithm, key, data)
.EE
.SS Parameters
.TP
\f[B]algorithm\f[R]
A string or object that specifies the signature algorithm to use and its
parameters:
.RS
.IP \[bu] 2
To use RSASSA\-PKCS1\-v1_5, pass the string
\f[CR]RSASSA\-PKCS1\-v1_5\f[R] or an object of the form
\f[CR]{ name: \[dq]RSASSA\-PKCS1\-v1_5\[dq] }\f[R].
.IP \[bu] 2
To use RSA\-PSS, pass an \f[CR]RsaPssParams\f[R] object.
.IP \[bu] 2
To use ECDSA, pass an \f[CR]EcdsaParams\f[R] object.
.IP \[bu] 2
To use HMAC, pass the string \f[CR]HMAC\f[R] or an object of the form
\f[CR]{ name: \[dq]HMAC\[dq] }\f[R].
.IP \[bu] 2
To use Ed25519, pass the string \f[CR]Ed25519\f[R] or an object of the
form \f[CR]{ name: \[dq]Ed25519\[dq] }\f[R].
.RE
.TP
\f[B]key\f[R]
A \f[CR]CryptoKey\f[R] object containing the key to be used for signing.
If \f[CR]algorithm\f[R] identifies a public\-key cryptosystem, this is
the private key.
.TP
\f[B]data\f[R]
An \f[CR]ArrayBuffer\f[R], a \f[CR]TypedArray\f[R] or a
\f[CR]DataView\f[R] object containing the data to be signed.
.SS Return value
A \f[CR]Promise\f[R] that fulfills with an \f[CR]ArrayBuffer\f[R]
containing the signature.
.SS Exceptions
The promise is rejected when the following exception is encountered:
.TP
\f[B]InvalidAccessError\f[R] \f[B]DOMException\f[R]
Raised when the signing key is not a key for the request signing
algorithm or when trying to use an algorithm that is either unknown or
isn\[cq]t suitable for signing.
.SH SUPPORTED ALGORITHMS
The Web Crypto API provides the following algorithms that can be used
for signing and signature verification.
.PP
RSASSA\-PKCS1\-v1_5, RSA\-PSS, ECDSA, and Ed25519 are public\-key
cryptosystems that use the private key for signing and the public key
for verification.
These systems all use a digest algorithm to hash the message to a short
fixed size before signing.
.IP \[bu] 2
For RSASSA\-PKCS1\-v1_5 and RSA\-PSS, the choice of digest algorithm is
passed into the \f[CR]generateKey()\f[R] or \f[CR]importKey()\f[R]
functions.
.IP \[bu] 2
For ECDSA the choice of digest algorithm is included in the
\f[CR]algorithm\f[R] parameter passed into the \f[CR]sign()\f[R]
function.
.IP \[bu] 2
For Ed25519 the digest algorithm is always SHA\-512.
.PP
The HMAC algorithm differs from the others in that it is not a
public\-key cryptosystem: it uses the same algorithm and key for signing
and for verification.
This means that the verification key must be kept secret, which in turn
means that this algorithm is not suitable for many signature use cases.
It can be a good choice however when the signer and verifier are the
same entity.
.SS RSASSA\-PKCS1\-v1_5
The RSASSA\-PKCS1\-v1_5 algorithm is specified in \c
.UR https://datatracker.ietf.org/doc/html/rfc3447
RFC 3447
.UE \c
\&.
.SS RSA\-PSS
The RSA\-PSS algorithm is specified in \c
.UR https://datatracker.ietf.org/doc/html/rfc3447
RFC 3447
.UE \c
\&.
.PP
It\[cq]s different from RSASSA\-PKCS1\-v1_5 in that it incorporates a
random salt in the signature operation, so the same message signed with
the same key will not result in the same signature each time.
An extra property, defining the salt length, is passed into the
\f[CR]sign()\f[R] and \f[CR]verify()\f[R] functions when they are
invoked.
.SS ECDSA
ECDSA (Elliptic Curve Digital Signature Algorithm) is a variant of the
Digital Signature Algorithm, specified in \c
.UR https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
FIPS\-186
.UE \c
, that uses Elliptic Curve Cryptography (\c
.UR https://datatracker.ietf.org/doc/html/rfc6090
RFC 6090
.UE \c
).
.PP
Signatures are encoded as the \f[CR]s1\f[R] and \f[CR]s2\f[R] values
specified in RFC 6090 (known respectively as \f[CR]r\f[R] and
\f[CR]s\f[R] in \c
.UR https://datatracker.ietf.org/doc/html/rfc4754#section-3
RFC 4754
.UE \c
), each in big\-endian byte arrays, with their length the bit size of
the curve rounded up to a whole number of bytes.
These values are concatenated together in this order.
.PP
This encoding was also proposed by the \c
.UR https://standards.ieee.org/ieee/1363/2049/
IEEE 1363\-2000
.UE \c
\ standard, and is sometimes referred to as the IEEE P1363 format.
It differs from the \c
.UR https://www.itu.int/rec/T-REC-X.509
X.509
.UE \c
\ signature structure, which is the default format produced by some
tools and libraries such as \c
.UR https://www.openssl.org/
OpenSSL
.UE \c
\&.
.SS Ed25519
Ed25519 is a digital signature algorithm built on the \c
.UR https://en.wikipedia.org/wiki/Curve25519
Curve25519
.UE \c
\ elliptic curve, which is part of the Edwards\-Curve Digital Signature
Algorithm (EdDSA) family of algorithms defined in RFC 8032.
.SS HMAC
The HMAC algorithm calculates and verifies hash\-based message
authentication codes according to the \c
.UR https://csrc.nist.gov/files/pubs/fips/198-1/final/docs/fips-198-1_final.pdf
FIPS 198\-1 standard (PDF)
.UE \c
\&.
.PP
The digest algorithm to use is specified in the
\f[CR]HmacKeyGenParams\f[R] object that you pass into
\f[CR]generateKey()\f[R], or the \f[CR]HmacImportParams\f[R] object that
you pass into \f[CR]importKey()\f[R].
.PP
The HMAC algorithm uses the same algorithm and key for signing and for
verification: this means that the verification key must be kept secret,
which in turn means that this algorithm is not suitable for many
signature use cases.
It can be a good choice however when the signer and verifier are the
same entity.
.SH EXAMPLES
.RS
.PP
\f[B]Note:\f[R] You can \c
.UR https://mdn.github.io/dom-examples/web-crypto/sign-verify/index.html
try the working examples
.UE \c
\ out on GitHub.
.RE
.SS RSASSA\-PKCS1\-v1_5
This code fetches the contents of a text box, encodes it for signing,
and signs it with a private key.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/sign-verify/rsassa-pkcs1.js
See the complete source code on GitHub.
.UE \c
.IP
.EX
\f[I]/*\f[R]
\f[I]Fetch the contents of the \[dq]message\[dq] textbox, and encode it\f[R]
\f[I]in a form we can use for the sign operation.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getMessageEncoding() {
  \f[B]const\f[R] messageBox = document.querySelector(\[dq].rsassa\-pkcs1 #message\[dq]);
  \f[B]let\f[R] message = messageBox.value;
  \f[B]let\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] enc.encode(message);
}

\f[B]let\f[R] encoded = getMessageEncoding();
\f[B]let\f[R] signature = \f[B]await\f[R] window.crypto.subtle.sign(
  \[dq]RSASSA\-PKCS1\-v1_5\[dq],
  privateKey,
  encoded,
);
.EE
.SS RSA\-PSS
This code fetches the contents of a text box, encodes it for signing,
and signs it with a private key.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/sign-verify/rsa-pss.js
See the complete source code on GitHub.
.UE \c
.IP
.EX
\f[I]/*\f[R]
\f[I]Fetch the contents of the \[dq]message\[dq] textbox, and encode it\f[R]
\f[I]in a form we can use for the sign operation.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getMessageEncoding() {
  \f[B]const\f[R] messageBox = document.querySelector(\[dq].rsa\-pss #message\[dq]);
  \f[B]let\f[R] message = messageBox.value;
  \f[B]let\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] enc.encode(message);
}

\f[B]let\f[R] encoded = getMessageEncoding();
\f[B]let\f[R] signature = \f[B]await\f[R] window.crypto.subtle.sign(
  {
    name: \[dq]RSA\-PSS\[dq],
    saltLength: 32,
  },
  privateKey,
  encoded,
);
.EE
.SS ECDSA
This code fetches the contents of a text box, encodes it for signing,
and signs it with a private key.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/sign-verify/ecdsa.js
See the complete source code on GitHub.
.UE \c
.IP
.EX
\f[I]/*\f[R]
\f[I]Fetch the contents of the \[dq]message\[dq] textbox, and encode it\f[R]
\f[I]in a form we can use for the sign operation.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getMessageEncoding() {
  \f[B]const\f[R] messageBox = document.querySelector(\[dq].ecdsa #message\[dq]);
  \f[B]let\f[R] message = messageBox.value;
  \f[B]let\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] enc.encode(message);
}

\f[B]let\f[R] encoded = getMessageEncoding();
\f[B]let\f[R] signature = \f[B]await\f[R] window.crypto.subtle.sign(
  {
    name: \[dq]ECDSA\[dq],
    hash: { name: \[dq]SHA\-384\[dq] },
  },
  privateKey,
  encoded,
);
.EE
.SS HMAC
This code fetches the contents of a text box, encodes it for signing,
and signs it with a secret key.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/sign-verify/hmac.js
See the complete source code on GitHub.
.UE \c
.IP
.EX
\f[I]/*\f[R]
\f[I]Fetch the contents of the \[dq]message\[dq] textbox, and encode it\f[R]
\f[I]in a form we can use for the sign operation.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getMessageEncoding() {
  \f[B]const\f[R] messageBox = document.querySelector(\[dq].hmac #message\[dq]);
  \f[B]let\f[R] message = messageBox.value;
  \f[B]let\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] enc.encode(message);
}

\f[B]let\f[R] encoded = getMessageEncoding();
\f[B]let\f[R] signature = \f[B]await\f[R] window.crypto.subtle.sign(\[dq]HMAC\[dq], key, encoded);
.EE
.SS Ed25519 (key generation, signing, and verification)
This code generates an Ed25519 signing key pair, uses the private key to
sign the (encoded) contents of a text \f[CR]<input>\f[R], and then
verifies the signature using the public key.
It is derived from \c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/sign-verify/ed25519.js
this source code on GitHub.
.UE \c
, which you can \c
.UR https://mdn.github.io/dom-examples/web-crypto/sign-verify/
run live here
.UE \c
\&.
.SS HTML
The HTML defines an \f[CR]<input>\f[R] element containing the text to be
signed, and a button that starts the operation to create keys, sign the
text and then verify the signature.
.IP
.EX
<\f[B]label\f[R] for=\[dq]message\[dq]>Enter a message to sign:</\f[B]label\f[R]>
<\f[B]input\f[R]
  type=\[dq]text\[dq]
  id=\[dq]message\[dq]
  name=\[dq]message\[dq]
  size=\[dq]25\[dq]
  value=\[dq]The lion roars near dawn\[dq] />

<\f[B]input\f[R] id=\[dq]sign\-button\[dq] type=\[dq]button\[dq] value=\[dq]Run\[dq] />
.EE
.SS JavaScript
The JavaScript first gets the \f[CR]#sign\-button\f[R] and
\f[CR]#message\f[R] \f[CR]<input>\f[R] elements, then adds a listener
for the \f[CR]click\f[R] event on the button.
The event handler clears the log and runs the other operations passing
the content of the \f[CR]<input>\f[R] element.
.IP
.EX
\f[B]const\f[R] button = document.querySelector(\[dq]#sign\-button\[dq]);
\f[B]const\f[R] input = document.querySelector(\[dq]#message\[dq]);

button.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
  \f[I]// Clear log\f[R]
  logElement.innerText = \[dq]\[dq];
  logElement.scrollTop = logElement.scrollHeight;
  \f[I]// Run test\f[R]
  test(input.value);
});
.EE
.PP
First it generates keys using the Ed25519 algorithm, then it encodes
text and signs that text using the private key.
Finally it calls \f[CR]SubtleCrypto.verify()\f[R] with the public key to
verify the signature.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] test(data) {
  log(\[ga]Message: ${data}\[ga]);
  \f[B]try\f[R] {
    \f[I]// Generate keys\f[R]
    \f[B]const\f[R] { publicKey, privateKey } = \f[B]await\f[R] crypto.subtle.generateKey(
      {
        name: \[dq]Ed25519\[dq],
      },
      \f[B]true\f[R],
      [\[dq]sign\[dq], \[dq]verify\[dq]],
    );

    log(\[ga]publicKey: ${publicKey}, type: ${publicKey.type}\[ga]);
    log(\[ga]privateKey: ${privateKey},  type: ${privateKey.type}\[ga]);

    \f[I]// Encode data prior to signing\f[R]
    \f[B]const\f[R] encoder = \f[B]new\f[R] TextEncoder();
    encodedData = encoder.encode(data);

    \f[I]// Log the first part of the encoded data\f[R]
    \f[B]const\f[R] shorterEncodedBuffer = \f[B]new\f[R] Uint8Array(encodedData.buffer, 0, 14);
    log(
      \[ga]encodedData: ${shorterEncodedBuffer}...[${encodedData.byteLength} bytes total]\[ga],
    );
    \f[I]//log(\[ga]encodedData: ${encodedData}\[ga]);\f[R]

    \f[I]// Sign the data using the private key.\f[R]
    \f[B]const\f[R] signature = \f[B]await\f[R] crypto.subtle.sign(
      {
        name: \[dq]Ed25519\[dq],
      },
      privateKey,
      encodedData,
    );

    \f[I]// Log the first part of the signature data\f[R]
    \f[B]const\f[R] signatureBuffer = \f[B]new\f[R] Uint8Array(signature, 0, 14);
    log(
      \[ga]signature: ${signatureBuffer}...[${signature.byteLength} bytes total]\[ga],
    );

    \f[I]// Verify the signature using the public key\f[R]
    \f[B]const\f[R] verifyResult = \f[B]await\f[R] crypto.subtle.verify(
      {
        name: \[dq]Ed25519\[dq],
      },
      publicKey,
      signature,
      encodedData,
    );

    \f[I]// Log result \- true if the text was signed with the corresponding public key.\f[R]
    log(\[ga]signature verified?: ${verifyResult}\[ga]);
  } \f[B]catch\f[R] (error) {
    log(error);
  }
}
.EE
.SS Result
.SH SEE ALSO
.IP \[bu] 2
\f[CR]SubtleCrypto.verify()\f[R].
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc3447
RFC 3447
.UE \c
\ specifies RSASSA\-PKCS1\-v1_5.
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc3447
RFC 3447
.UE \c
\ specifies RSA\-PSS.
.IP \[bu] 2
\c
.UR https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
FIPS\-186
.UE \c
\ specifies ECDSA.
.IP \[bu] 2
\c
.UR https://csrc.nist.gov/files/pubs/fips/198-1/final/docs/fips-198-1_final.pdf
FIPS 198\-1
.UE \c
\ specifies HMAC.
