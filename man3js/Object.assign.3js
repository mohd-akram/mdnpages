.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "OBJECT.ASSIGN" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.assign \- Object.assign()
.SH SYNOPSIS
The \f[B]\f[CB]Object.assign()\f[B]\f[R] static method copies all
enumerable own properties from one or more \f[I]source objects\f[R] to a
\f[I]target object\f[R].
It returns the modified target object.
.IP
.EX
\f[B]const\f[R] target = { a: 1, b: 2 };
\f[B]const\f[R] source = { b: 4, c: 5 };

\f[B]const\f[R] returnedTarget = Object.assign(target, source);

console.log(target);
\f[I]// Expected output: Object { a: 1, b: 4, c: 5 }\f[R]

console.log(returnedTarget === target);
\f[I]// Expected output: true\f[R]
.EE
.SH SYNTAX
.IP
.EX
Object.assign(target)
Object.assign(target, source1)
Object.assign(target, source1, source2)
Object.assign(target, source1, source2, /* \&..., */ sourceN)
.EE
.SS Parameters
.TP
\f[B]target\f[R]
The target object \(em what to apply the sources\(cq properties to,
which is returned after it is modified.
If a primitive value is provided as the target, it will be converted to
an object.
.TP
\f[B]source1\f[R], \&..., \f[B]sourceN\f[R]
The source object(s) \(em objects containing the properties you want to
apply.
.SS Return value
The target object.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown in one of the following cases:
.RS
.IP \(bu 2
The \f[CR]target\f[R] parameter is \f[CR]null\f[R] or
\f[CR]undefined\f[R].
.IP \(bu 2
Assignment of a property on the target object fails; for example,
because the property is non\-writable on the target object, or because
its setter throws an error.
.RE
.SH DESCRIPTION
Properties in the target object are overwritten by properties in the
sources if they have the same key.
Later sources\(cq properties overwrite earlier ones.
.PP
The \f[CR]Object.assign()\f[R] method only copies \f[I]enumerable\f[R]
and \f[I]own\f[R] properties from a source object to a target object.
It uses \f[CR][[Get]]\f[R] on the source and \f[CR][[Set]]\f[R] on the
target, so it will invoke getters and setters.
Therefore it \f[I]assigns\f[R] properties, versus copying or defining
new properties.
This may make it unsuitable for merging new properties into a prototype
if the merge sources contain getters.
.PP
For copying property definitions (including their enumerability) into
prototypes, use \f[CR]Object.getOwnPropertyDescriptor()\f[R] and
\f[CR]Object.defineProperty()\f[R] instead.
.PP
Both \f[CR]String\f[R] and \f[CR]Symbol\f[R] properties are copied.
.PP
In case of an error, for example if a property is non\-writable, a
\f[CR]TypeError\f[R] is raised, and the \f[CR]target\f[R] object is
changed if any properties are added before the error is raised.
.RS
.PP
\f[B]Note:\f[R] \f[CR]Object.assign()\f[R] does not throw on
\f[CR]null\f[R] or \f[CR]undefined\f[R] sources.
.RE
.SH EXAMPLES
.SS Cloning an object
.IP
.EX
\f[B]const\f[R] obj = { a: 1 };
\f[B]const\f[R] copy = Object.assign({}, obj);
console.log(copy); \f[I]// { a: 1 }\f[R]
.EE
.SS Warning for deep clone
For deep cloning, we need to use alternatives like
\f[CR]structuredClone()\f[R], because \f[CR]Object.assign()\f[R] copies
property values.
.PP
If the source value is a reference to an object, it only copies the
reference value.
.IP
.EX
\f[B]const\f[R] obj1 = { a: 0, b: { c: 0 } };
\f[B]const\f[R] obj2 = Object.assign({}, obj1);
console.log(obj2); \f[I]// { a: 0, b: { c: 0 } }\f[R]

obj1.a = 1;
console.log(obj1); \f[I]// { a: 1, b: { c: 0 } }\f[R]
console.log(obj2); \f[I]// { a: 0, b: { c: 0 } }\f[R]

obj2.a = 2;
console.log(obj1); \f[I]// { a: 1, b: { c: 0 } }\f[R]
console.log(obj2); \f[I]// { a: 2, b: { c: 0 } }\f[R]

obj2.b.c = 3;
console.log(obj1); \f[I]// { a: 1, b: { c: 3 } }\f[R]
console.log(obj2); \f[I]// { a: 2, b: { c: 3 } }\f[R]

\f[I]// Deep Clone\f[R]
\f[B]const\f[R] obj3 = { a: 0, b: { c: 0 } };
\f[B]const\f[R] obj4 = structuredClone(obj3);
obj3.a = 4;
obj3.b.c = 4;
console.log(obj4); \f[I]// { a: 0, b: { c: 0 } }\f[R]
.EE
.SS Merging objects
.IP
.EX
\f[B]const\f[R] o1 = { a: 1 };
\f[B]const\f[R] o2 = { b: 2 };
\f[B]const\f[R] o3 = { c: 3 };

\f[B]const\f[R] obj = Object.assign(o1, o2, o3);
console.log(obj); \f[I]// { a: 1, b: 2, c: 3 }\f[R]
console.log(o1); \f[I]// { a: 1, b: 2, c: 3 }, target object itself is changed.\f[R]
.EE
.SS Merging objects with same properties
.IP
.EX
\f[B]const\f[R] o1 = { a: 1, b: 1, c: 1 };
\f[B]const\f[R] o2 = { b: 2, c: 2 };
\f[B]const\f[R] o3 = { c: 3 };

\f[B]const\f[R] obj = Object.assign({}, o1, o2, o3);
console.log(obj); \f[I]// { a: 1, b: 2, c: 3 }\f[R]
.EE
.PP
The properties are overwritten by other objects that have the same
properties later in the parameters order.
.SS Copying symbol\-typed properties
.IP
.EX
\f[B]const\f[R] o1 = { a: 1 };
\f[B]const\f[R] o2 = { [Symbol(\(dqfoo\(dq)]: 2 };

\f[B]const\f[R] obj = Object.assign({}, o1, o2);
console.log(obj); \f[I]// { a : 1, [Symbol(\(dqfoo\(dq)]: 2 } (cf. bug 1207182 on Firefox)\f[R]
Object.getOwnPropertySymbols(obj); \f[I]// [Symbol(foo)]\f[R]
.EE
.SS Properties on the prototype chain and non\-enumerable properties cannot be copied
.IP
.EX
\f[B]const\f[R] obj = Object.create(
  \f[I]// foo is on obj\(aqs prototype chain.\f[R]
  { foo: 1 },
  {
    bar: {
      value: 2, \f[I]// bar is a non\-enumerable property.\f[R]
    },
    baz: {
      value: 3,
      enumerable: \f[B]true\f[R], \f[I]// baz is an own enumerable property.\f[R]
    },
  },
);

\f[B]const\f[R] copy = Object.assign({}, obj);
console.log(copy); \f[I]// { baz: 3 }\f[R]
.EE
.SS Primitives will be wrapped to objects
.IP
.EX
\f[B]const\f[R] v1 = \(dqabc\(dq;
\f[B]const\f[R] v2 = \f[B]true\f[R];
\f[B]const\f[R] v3 = 10;
\f[B]const\f[R] v4 = Symbol(\(dqfoo\(dq);

\f[B]const\f[R] obj = Object.assign({}, v1, \f[B]null\f[R], v2, \f[B]undefined\f[R], v3, v4);
\f[I]// Primitives will be wrapped, null and undefined will be ignored.\f[R]
\f[I]// Note, only string wrappers can have own enumerable properties.\f[R]
console.log(obj); \f[I]// { \(dq0\(dq: \(dqa\(dq, \(dq1\(dq: \(dqb\(dq, \(dq2\(dq: \(dqc\(dq }\f[R]

\f[I]// Primitives as the target are also wrapped to objects\f[R]
\f[B]const\f[R] number = Object.assign(3, { a: 1 });
console.log(number); \f[I]// Number {3, a: 1}\f[R]
console.log(\f[B]typeof\f[R] number); \f[I]// object\f[R]
console.log(number.a); \f[I]// 1\f[R]

\f[I]// null and undefined as targets throw TypeError\f[R]
\f[B]try\f[R] {
  Object.assign(\f[B]null\f[R], { a: 1 });
} \f[B]catch\f[R] (e) {
  console.log(e.message); \f[I]// \(dqCannot convert undefined or null to object\(dq\f[R]
}
.EE
.SS Exceptions will interrupt the ongoing copying task
.IP
.EX
\f[B]const\f[R] target = Object.defineProperty({}, \(dqfoo\(dq, {
  value: 1,
  writable: \f[B]false\f[R],
}); \f[I]// target.foo is a read\-only property\f[R]

Object.assign(target, { bar: 2 }, { foo2: 3, foo: 3, foo3: 3 }, { baz: 4 });
\f[I]// TypeError: \(dqfoo\(dq is read\-only\f[R]
\f[I]// The Exception is thrown when assigning target.foo\f[R]

console.log(target.bar); \f[I]// 2, the first source was copied successfully.\f[R]
console.log(target.foo2); \f[I]// 3, the first property of the second source was copied successfully.\f[R]
console.log(target.foo); \f[I]// 1, exception is thrown here.\f[R]
console.log(target.foo3); \f[I]// undefined, assign method has finished, foo3 will not be copied.\f[R]
console.log(target.baz); \f[I]// undefined, the third source will not be copied either.\f[R]
.EE
.SS Copying accessors
.IP
.EX
\f[B]const\f[R] obj = {
  foo: 1,
  \f[B]get\f[R] bar() {
    \f[B]return\f[R] 2;
  },
};

\f[B]let\f[R] copy = Object.assign({}, obj);
console.log(copy);
\f[I]// { foo: 1, bar: 2 }\f[R]
\f[I]// The value of copy.bar is obj.bar\(aqs getter\(aqs return value.\f[R]

\f[I]// This is an assign function that copies full descriptors\f[R]
\f[B]function\f[R] completeAssign(target, ...sources) {
  sources.forEach((source) \f[B]=>\f[R] {
    \f[B]const\f[R] descriptors = Object.keys(source).reduce((descriptors, key) \f[B]=>\f[R] {
      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
      \f[B]return\f[R] descriptors;
    }, {});

    \f[I]// By default, Object.assign copies enumerable Symbols, too\f[R]
    Object.getOwnPropertySymbols(source).forEach((sym) \f[B]=>\f[R] {
      \f[B]const\f[R] descriptor = Object.getOwnPropertyDescriptor(source, sym);
      \f[B]if\f[R] (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  \f[B]return\f[R] target;
}

copy = completeAssign({}, obj);
console.log(copy);
\f[I]// { foo:1, get bar() { return 2 } }\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-object
Polyfill of \f[CR]Object.assign\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/object.assign
es\-shims polyfill of \f[CR]Object.assign\f[R]
.UE \c
.IP \(bu 2
\f[CR]Object.defineProperties()\f[R]
.IP \(bu 2
Enumerability and ownership of properties
.IP \(bu 2
Spread in object literals
