.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "REFLECT.DEFINEPROPERTY" "3JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Reflect.defineProperty \- Reflect.defineProperty()
.SH SYNOPSIS
The \f[B]\f[CB]Reflect.defineProperty()\f[B]\f[R] static method is like
\f[CR]Object.defineProperty()\f[R] but returns a \f[CR]Boolean\f[R].
.IP
.EX
\f[B]const\f[R] object1 = {};

\f[B]if\f[R] (Reflect.defineProperty(object1, \(dqproperty1\(dq, { value: 42 })) {
  console.log(\(dqproperty1 created!\(dq);
  \f[I]// Expected output: \(dqproperty1 created!\(dq\f[R]
} \f[B]else\f[R] {
  console.log(\(dqproblem creating property1\(dq);
}

console.log(object1.property1);
\f[I]// Expected output: 42\f[R]
.EE
.SH SYNTAX
.IP
.EX
Reflect.defineProperty(target, propertyKey, attributes)
.EE
.SS Parameters
.TP
\f[B]target\f[R]
The target object on which to define the property.
.TP
\f[B]propertyKey\f[R]
The name of the property to be defined or modified.
.TP
\f[B]attributes\f[R]
The attributes for the property being defined or modified.
.SS Return value
A boolean indicating whether or not the property was successfully
defined.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if \f[CR]target\f[R] or \f[CR]attributes\f[R] is not an object.
.SH DESCRIPTION
\f[CR]Reflect.defineProperty()\f[R] provides the reflective semantic of
defining an own property on an object.
At the very low level, defining a property returns a boolean (as is the
case with the proxy handler).
\f[CR]Object.defineProperty()\f[R] provides nearly the same semantic,
but it throws a \f[CR]TypeError\f[R] if the status is \f[CR]false\f[R]
(the operation was unsuccessful), while
\f[CR]Reflect.defineProperty()\f[R] directly returns the status.
.PP
Many built\-in operations would also define own properties on objects.
The most significant difference between defining properties and setting
them is that setters aren\(cqt invoked.
For example, class fields directly define properties on the instance
without invoking setters.
.IP
.EX
\f[B]class\f[R] B \f[B]extends\f[R] \f[B]class\f[R] A {
  \f[B]set\f[R] a(v) {
    console.log(\(dqSetter called\(dq);
  }
} {
  a = 1; \f[I]// Nothing logged\f[R]
}
.EE
.PP
\f[CR]Reflect.defineProperty()\f[R] invokes the
\f[CR][[DefineOwnProperty]]\f[R] object internal method of
\f[CR]target\f[R].
.SH EXAMPLES
.SS Using Reflect.defineProperty()
.IP
.EX
\f[B]const\f[R] obj = {};
Reflect.defineProperty(obj, \(dqx\(dq, { value: 7 }); \f[I]// true\f[R]
console.log(obj.x); \f[I]// 7\f[R]
.EE
.SS Checking if property definition has been successful
With \f[CR]Object.defineProperty()\f[R], which returns an object if
successful, or throws a \f[CR]TypeError\f[R] otherwise, you would use a
\f[CR]try...catch\f[R] block to catch any error that occurred while
defining a property.
.PP
Because \f[CR]Reflect.defineProperty()\f[R] returns a Boolean success
status, you can just use an \f[CR]if...else\f[R] block here:
.IP
.EX
\f[B]if\f[R] (Reflect.defineProperty(target, property, attributes)) {
  \f[I]// success\f[R]
} \f[B]else\f[R] {
  \f[I]// failure\f[R]
}
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-reflect
Polyfill of \f[CR]Reflect.defineProperty\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\f[CR]Reflect\f[R]
.IP \(bu 2
\f[CR]Object.defineProperty()\f[R]
.IP \(bu 2
\f[CR]handler.defineProperty()\f[R]
