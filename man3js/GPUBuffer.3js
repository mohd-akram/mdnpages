.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPUBUFFER" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPUBuffer \- GPUBuffer
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]GPUBuffer\f[B]\f[R] interface of the WebGPU API
represents a block of memory that can be used to store raw data to use
in GPU operations.
.PP
A \f[CR]GPUBuffer\f[R] object instance is created using the
\f[CR]GPUDevice.createBuffer()\f[R] method.
.SH INSTANCE PROPERTIES
.TP
\f[B]label\f[R]
A string providing a label that can be used to identify the object, for
example in \f[CR]GPUError\f[R] messages or console warnings.
.TP
\f[B]mapState\f[R] \f[I](read\-only)\f[R]
An enumerated value representing the mapped state of the
\f[CR]GPUBuffer\f[R].
.TP
\f[B]size\f[R] \f[I](read\-only)\f[R]
A number representing the length of the \f[CR]GPUBuffer\f[R]\(cqs memory
allocation, in bytes.
.TP
\f[B]usage\f[R] \f[I](read\-only)\f[R]
The bitwise flags representing the allowed usages of the
\f[CR]GPUBuffer\f[R].
.SH INSTANCE METHODS
.TP
\f[B]destroy()\f[R]
Destroys the \f[CR]GPUBuffer\f[R].
.TP
\f[B]getMappedRange()\f[R]
Returns an \f[CR]ArrayBuffer\f[R] containing the mapped contents of the
\f[CR]GPUBuffer\f[R] in the specified range.
.TP
\f[B]mapAsync()\f[R]
Maps the specified range of the \f[CR]GPUBuffer\f[R].
Returns a \f[CR]Promise\f[R] that resolves when the
\f[CR]GPUBuffer\f[R]\(cqs content is ready to be accessed with
\f[CR]GPUBuffer.getMappedRange()\f[R].
.TP
\f[B]unmap()\f[R]
Unmaps the mapped range of the \f[CR]GPUBuffer\f[R], making its contents
available for use by the GPU again.
.SH EXAMPLES
In our \c
.UR https://mdn.github.io/dom-examples/webgpu-compute-demo/
basic compute demo
.UE \c
, we create an output buffer to read GPU calculations to, and a staging
buffer to be mapped for JavaScript access.
.IP
.EX
\f[B]const\f[R] output = device.createBuffer({
  size: BUFFER_SIZE,
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
});

\f[B]const\f[R] stagingBuffer = device.createBuffer({
  size: BUFFER_SIZE,
  usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
});
.EE
.PP
Later on, once the \f[CR]stagingBuffer\f[R] contains the results of the
GPU computation, a combination of \f[CR]GPUBuffer\f[R] methods are used
to read the data back to JavaScript so that it can then be logged to the
console:
.IP \(bu 2
\f[CR]GPUBuffer.mapAsync()\f[R] is used to map the \f[CR]GPUBuffer\f[R]
for reading.
.IP \(bu 2
\f[CR]GPUBuffer.getMappedRange()\f[R] is used to return an
\f[CR]ArrayBuffer\f[R] containing the \f[CR]GPUBuffer\f[R]\(cqs
contents.
.IP \(bu 2
\f[CR]GPUBuffer.unmap()\f[R] is used to unmap the \f[CR]GPUBuffer\f[R]
again, once we have read the content into JavaScript as needed.
.IP
.EX
\f[I]// map staging buffer to read results back to JS\f[R]
\f[B]await\f[R] stagingBuffer.mapAsync(
  GPUMapMode.READ,
  0, \f[I]// Offset\f[R]
  BUFFER_SIZE, \f[I]// Length\f[R]
);

\f[B]const\f[R] copyArrayBuffer = stagingBuffer.getMappedRange(0, BUFFER_SIZE);
\f[B]const\f[R] data = copyArrayBuffer.slice(0);
stagingBuffer.unmap();
console.log(\f[B]new\f[R] Float32Array(data));
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
