.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "CSSMathSum" "JS" "May 14, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
CSSMathSum \- CSSMathSum
.SH SYNOPSIS
The \f[B]\f[CB]CSSMathSum\f[B]\f[R] interface of the CSS Typed Object
Model API represents the result obtained by calling \f[CR]add()\f[R],
\f[CR]sub()\f[R], or \f[CR]toSum()\f[R] on \f[CR]CSSNumericValue\f[R].
.PP
A CSSMathSum is the object type returned when the
\f[CR]StylePropertyMapReadOnly.get()\f[R] method is used on a CSS
property whose value is created with a \f[CR]calc()\f[R] function.
.SH CONSTRUCTOR
.TP
\f[B]CSSMathSum()\f[R] \f[I](experimental)\f[R]
Creates a new \f[CR]CSSMathSum\f[R] object.
.SH INSTANCE PROPERTIES
.TP
\f[B]CSSMathSum.values\f[R]
Returns a \f[CR]CSSNumericArray\f[R] object which contains one or more
\f[CR]CSSNumericValue\f[R] objects.
.SH STATIC METHODS
\f[I]The interface may also inherit methods from its parent interface,
\f[CI]CSSMathValue\f[I].\f[R]
.SH INSTANCE METHODS
\f[I]The interface may also inherit methods from its parent interface,
\f[CI]CSSMathValue\f[I].\f[R]
.SH EXAMPLES
We create an element with a \f[CR]width\f[R] determined using a
\f[CR]calc()\f[R] function, then \f[CR]console.log()\f[R] the
\f[CR]operator\f[R] and \f[CR]values\f[R], and dig into the values a
bit.
.IP
.EX
<\f[B]div\f[R]>has width</\f[B]div\f[R]>
.EE
.PP
We assign a \f[CR]width\f[R]
.IP
.EX
div {
  \f[B]width\f[R]: calc(30% \- 20px);
}
.EE
.PP
We add the JavaScript
.IP
.EX
\f[B]const\f[R] styleMap = document.querySelector(\[dq]div\[dq]).computedStyleMap();

console.log(styleMap.get(\[dq]width\[dq])); \f[I]// CSSMathSum {values: CSSNumericArray, operator: \[dq]sum\[dq]}\f[R]
console.log(styleMap.get(\[dq]width\[dq]).operator); \f[I]// \[aq]sum\[aq]\f[R]
console.log(styleMap.get(\[dq]width\[dq]).values); \f[I]// CSSNumericArray {0: CSSUnitValue, 1: CSSUnitValue, length: 2}\f[R]
console.log(styleMap.get(\[dq]width\[dq]).values[0]); \f[I]// CSSUnitValue {value: 30, unit: \[dq]percent\[dq]}\f[R]
console.log(styleMap.get(\[dq]width\[dq]).values[0].value); \f[I]// 30\f[R]
console.log(styleMap.get(\[dq]width\[dq]).values[0].unit); \f[I]// \[aq]percent\[aq]\f[R]
console.log(styleMap.get(\[dq]width\[dq]).values[1]); \f[I]// CSSUnitValue {value: \-20, unit: \[dq]px\[dq]}\f[R]
console.log(styleMap.get(\[dq]width\[dq]).values[1].value); \f[I]//  \-20\f[R]
console.log(styleMap.get(\[dq]width\[dq]).values[1].unit); \f[I]// \[aq]px\[aq]\f[R]
.EE
.PP
The specification is still evolving.
In the future we may write the last three lines as:
.IP
.EX
console.log(styleMap.get(\[dq]width\[dq]).values[1]); \f[I]// CSSMathNegate {value: CSSUnitValue, operator: \[dq]negate\[dq]}\f[R]
console.log(styleMap.get(\[dq]width\[dq]).values[1].value); \f[I]// CSSUnitValue {value: 20, unit: \[dq]px\[dq]}\f[R]
console.log(styleMap.get(\[dq]width\[dq]).values[1].value.unit); \f[I]// \[aq]px\[aq]\f[R]
.EE
