.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "MATH.POW" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Math.pow \- Math.pow()
.SH SYNOPSIS
The \f[B]\f[CB]Math.pow()\f[B]\f[R] static method returns the value of a
base raised to a power.
That is
.PP
\ 𝙼𝚊𝚝𝚑.𝚙𝚘𝚠(𝚡,𝚢)=xy = x\(hay 
.IP
.EX
console.log(Math.pow(7, 3));
\f[I]// Expected output: 343\f[R]

console.log(Math.pow(4, 0.5));
\f[I]// Expected output: 2\f[R]

console.log(Math.pow(7, \-2));
\f[I]// Expected output: 0.02040816326530612\f[R]
\f[I]//                  (1/49)\f[R]

console.log(Math.pow(\-7, 0.5));
\f[I]// Expected output: NaN\f[R]
.EE
.SH SYNTAX
.IP
.EX
Math.pow(base, exponent)
.EE
.SS Parameters
.TP
\f[B]base\f[R]
The base number.
.TP
\f[B]exponent\f[R]
The exponent number.
.SS Return value
A number representing \f[CR]base\f[R] taken to the power of
\f[CR]exponent\f[R].
Returns \f[CR]NaN\f[R] in one of the following cases:
.IP \(bu 2
\f[CR]exponent\f[R] is \f[CR]NaN\f[R].
.IP \(bu 2
\f[CR]base\f[R] is \f[CR]NaN\f[R] and \f[CR]exponent\f[R] is not
\f[CR]0\f[R].
.IP \(bu 2
\f[CR]base\f[R] is ±1 and \f[CR]exponent\f[R] is ±\f[CR]Infinity\f[R].
.IP \(bu 2
\f[CR]base < 0\f[R] and \f[CR]exponent\f[R] is not an integer.
.SH DESCRIPTION
\f[CR]Math.pow()\f[R] is equivalent to the \f[CR]**\f[R] operator,
except \f[CR]Math.pow()\f[R] only accepts numbers.
.PP
\f[CR]Math.pow(NaN, 0)\f[R] (and the equivalent \f[CR]NaN ** 0\f[R]) is
the only case where \f[CR]NaN\f[R] doesn\(cqt propagate through
mathematical operations \(em it returns \f[CR]1\f[R] despite the operand
being \f[CR]NaN\f[R].
In addition, the behavior where \f[CR]base\f[R] is 1 and
\f[CR]exponent\f[R] is non\-finite (±Infinity or \f[CR]NaN\f[R]) is
different from IEEE 754, which specifies that the result should be 1,
whereas JavaScript returns \f[CR]NaN\f[R] to preserve backward
compatibility with its original behavior.
.PP
Because \f[CR]pow()\f[R] is a static method of \f[CR]Math\f[R], use it
as \f[CR]Math.pow()\f[R], rather than as a method of a \f[CR]Math\f[R]
object you created (\f[CR]Math\f[R] is not a constructor).
.SH EXAMPLES
.SS Using Math.pow()
.IP
.EX
\f[I]// Basic cases\f[R]
Math.pow(7, 2); \f[I]// 49\f[R]
Math.pow(7, 3); \f[I]// 343\f[R]
Math.pow(2, 10); \f[I]// 1024\f[R]

\f[I]// Fractional exponents\f[R]
Math.pow(4, 0.5); \f[I]// 2 (square root of 4)\f[R]
Math.pow(8, 1 / 3); \f[I]// 2 (cube root of 8)\f[R]
Math.pow(2, 0.5); \f[I]// 1.4142135623730951 (square root of 2)\f[R]
Math.pow(2, 1 / 3); \f[I]// 1.2599210498948732 (cube root of 2)\f[R]

\f[I]// Signed exponents\f[R]
Math.pow(7, \-2); \f[I]// 0.02040816326530612 (1/49)\f[R]
Math.pow(8, \-1 / 3); \f[I]// 0.5\f[R]

\f[I]// Signed bases\f[R]
Math.pow(\-7, 2); \f[I]// 49 (squares are positive)\f[R]
Math.pow(\-7, 3); \f[I]// \-343 (cubes can be negative)\f[R]
Math.pow(\-7, 0.5); \f[I]// NaN (negative numbers don\(aqt have a real square root)\f[R]
\f[I]// Due to \(dqeven\(dq and \(dqodd\(dq roots laying close to each other,\f[R]
\f[I]// and limits in the floating number precision,\f[R]
\f[I]// negative bases with fractional exponents always return NaN,\f[R]
\f[I]// even when the mathematical result is real\f[R]
Math.pow(\-7, 1 / 3); \f[I]// NaN\f[R]

\f[I]// Zero and infinity\f[R]
Math.pow(0, 0); \f[I]// 1 (anything ** ±0 is 1)\f[R]
Math.pow(\f[B]Infinity\f[R], 0.1); \f[I]// Infinity (positive exponent)\f[R]
Math.pow(\f[B]Infinity\f[R], \-1); \f[I]// 0 (negative exponent)\f[R]
Math.pow(\-\f[B]Infinity\f[R], 1); \f[I]// \-Infinity (positive odd integer exponent)\f[R]
Math.pow(\-\f[B]Infinity\f[R], 1.5); \f[I]// Infinity (positive exponent)\f[R]
Math.pow(\-\f[B]Infinity\f[R], \-1); \f[I]// \-0 (negative odd integer exponent)\f[R]
Math.pow(\-\f[B]Infinity\f[R], \-1.5); \f[I]// 0 (negative exponent)\f[R]
Math.pow(0, 1); \f[I]// 0 (positive exponent)\f[R]
Math.pow(0, \-1); \f[I]// Infinity (negative exponent)\f[R]
Math.pow(\-0, 1); \f[I]// \-0 (positive odd integer exponent)\f[R]
Math.pow(\-0, 1.5); \f[I]// 0 (positive exponent)\f[R]
Math.pow(\-0, \-1); \f[I]// \-Infinity (negative odd integer exponent)\f[R]
Math.pow(\-0, \-1.5); \f[I]// Infinity (negative exponent)\f[R]
Math.pow(0.9, \f[B]Infinity\f[R]); \f[I]// 0\f[R]
Math.pow(1, \f[B]Infinity\f[R]); \f[I]// NaN\f[R]
Math.pow(1.1, \f[B]Infinity\f[R]); \f[I]// Infinity\f[R]
Math.pow(0.9, \-\f[B]Infinity\f[R]); \f[I]// Infinity\f[R]
Math.pow(1, \-\f[B]Infinity\f[R]); \f[I]// NaN\f[R]
Math.pow(1.1, \-\f[B]Infinity\f[R]); \f[I]// 0\f[R]

\f[I]// NaN: only Math.pow(NaN, 0) does not result in NaN\f[R]
Math.pow(\f[B]NaN\f[R], 0); \f[I]// 1\f[R]
Math.pow(\f[B]NaN\f[R], 1); \f[I]// NaN\f[R]
Math.pow(1, \f[B]NaN\f[R]); \f[I]// NaN\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Math.cbrt()\f[R]
.IP \(bu 2
\f[CR]Math.exp()\f[R]
.IP \(bu 2
\f[CR]Math.log()\f[R]
.IP \(bu 2
\f[CR]Math.sqrt()\f[R]
.IP \(bu 2
Exponentiation (\f[CR]**\f[R])
