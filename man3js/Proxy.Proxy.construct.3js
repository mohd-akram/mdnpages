.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "PROXY.PROXY.CONSTRUCT" "3JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Proxy.Proxy.construct \- handler.construct()
.SH SYNOPSIS
The \f[B]\f[CB]handler.construct()\f[B]\f[R] method is a trap for the
\f[CR][[Construct]]\f[R] object internal method, which is used by
operations such as the \f[CR]new\f[R] operator.
In order for the new operation to be valid on the resulting Proxy
object, the target used to initialize the proxy must itself be a valid
constructor.
.IP
.EX
\f[B]function\f[R] monster1(disposition) {
  \f[B]this\f[R].disposition = disposition;
}

\f[B]const\f[R] handler1 = {
  construct(target, args) {
    console.log(\(gaCreating a ${target.name}\(ga);
    \f[I]// Expected output: \(dqCreating a monster1\(dq\f[R]

    \f[B]return\f[R] \f[B]new\f[R] target(...args);
  },
};

\f[B]const\f[R] proxy1 = \f[B]new\f[R] Proxy(monster1, handler1);

console.log(\f[B]new\f[R] proxy1(\(dqfierce\(dq).disposition);
\f[I]// Expected output: \(dqfierce\(dq\f[R]
.EE
.SH SYNTAX
.IP
.EX
new Proxy(target, {
  construct(target, argumentsList, newTarget) {
  }
})
.EE
.SS Parameters
The following parameters are passed to the \f[CR]construct()\f[R]
method.
\f[CR]this\f[R] is bound to the handler.
.TP
\f[B]target\f[R]
The target constructor object.
.TP
\f[B]argumentsList\f[R]
An \f[CR]Array\f[R] containing the arguments passed to the constructor.
.TP
\f[B]newTarget\f[R]
The constructor that was originally called.
.SS Return value
The \f[CR]construct()\f[R] method must return an object, representing
the newly created object.
.SH DESCRIPTION
.SS Interceptions
This trap can intercept these operations:
.IP \(bu 2
The \f[CR]new\f[R] operator: \f[CR]new myFunction(...args)\f[R]
.IP \(bu 2
\f[CR]Reflect.construct()\f[R]
.PP
Or any other operation that invokes the \f[CR][[Construct]]\f[R]
internal method.
.SS Invariants
The proxy\(cqs \f[CR][[Construct]]\f[R] internal method throws a
\f[CR]TypeError\f[R] if the handler definition violates one of the
following invariants:
.IP \(bu 2
The \f[CR]target\f[R] must be a constructor itself.
.IP \(bu 2
The result must be an \f[CR]Object\f[R].
.SH EXAMPLES
.SS Trapping the new operator
The following code traps the \f[CR]new\f[R] operator.
.IP
.EX
\f[B]const\f[R] p = \f[B]new\f[R] Proxy(\f[B]function\f[R] () {}, {
  construct(target, argumentsList, newTarget) {
    console.log(\(gacalled: ${argumentsList}\(ga);
    \f[B]return\f[R] { value: argumentsList[0] * 10 };
  },
});

console.log(\f[B]new\f[R] p(1).value); \f[I]// \(dqcalled: 1\(dq\f[R]
\f[I]// 10\f[R]
.EE
.PP
The following code violates the invariant.
.PP
\f[B]Bad\f[R]
.IP
.EX
\f[B]const\f[R] p = \f[B]new\f[R] Proxy(\f[B]function\f[R] () {}, {
  construct(target, argumentsList, newTarget) {
    \f[B]return\f[R] 1;
  },
});

\f[B]new\f[R] p(); \f[I]// TypeError is thrown\f[R]
.EE
.PP
The following code improperly initializes the proxy.
The \f[CR]target\f[R] in Proxy initialization must itself be a valid
constructor for the \f[CR]new\f[R] operator.
.PP
\f[B]Bad\f[R]
.IP
.EX
\f[B]const\f[R] p = \f[B]new\f[R] Proxy(
  {},
  {
    construct(target, argumentsList, newTarget) {
      \f[B]return\f[R] {};
    },
  },
);

\f[B]new\f[R] p(); \f[I]// TypeError is thrown, \(dqp\(dq is not a constructor\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Proxy\f[R]
.IP \(bu 2
\f[CR]Proxy()\f[R] constructor
.IP \(bu 2
\f[CR]new\f[R]
.IP \(bu 2
\f[CR]Reflect.construct()\f[R]
