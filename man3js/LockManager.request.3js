.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "LockManager.request" "JS" "March 6, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
LockManager.request \- LockManager: request() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]request()\f[B]\f[R] method of the \f[CR]LockManager\f[R]
interface requests a \f[CR]Lock\f[R] object with parameters specifying
its name and characteristics.
The requested \f[CR]Lock\f[R] is passed to a callback, while the
function itself returns a \f[CR]Promise\f[R] that resolves (or rejects)
with the result of the callback after the lock is released, or rejects
if the request is aborted.
.PP
The \f[CR]mode\f[R] property of the \f[CR]options\f[R] parameter may be
either \f[CR]\[dq]exclusive\[dq]\f[R] or \f[CR]\[dq]shared\[dq]\f[R].
.PP
Request an \f[CR]\[dq]exclusive\[dq]\f[R] lock when it should only be
held by one code instance at a time.
This applies to code in both tabs and workers.
Use this to represent mutually exclusive access to a resource.
When an \f[CR]\[dq]exclusive\[dq]\f[R] lock for a given name is held, no
other lock with the same name can be held.
.PP
Request a \f[CR]\[dq]shared\[dq]\f[R] lock when multiple instances of
the code can share access to a resource.
When a \f[CR]\[dq]shared\[dq]\f[R] lock for a given name is held, other
\f[CR]\[dq]shared\[dq]\f[R] locks for the same name can be granted, but
no \f[CR]\[dq]exclusive\[dq]\f[R] locks with that name can be held or
granted.
.PP
This shared/exclusive lock pattern is common in database transaction
architecture, for example to allow multiple simultaneous readers (each
requests a \f[CR]\[dq]shared\[dq]\f[R] lock) but only one writer (a
single \f[CR]\[dq]exclusive\[dq]\f[R] lock).
This is known as the readers\-writer pattern.
In the IndexedDB API, this is exposed as \f[CR]\[dq]readonly\[dq]\f[R]
and \f[CR]\[dq]readwrite\[dq]\f[R] transactions which have the same
semantics.
.SH SYNTAX
.IP
.EX
request(name, callback)
request(name, options, callback)
.EE
.SS Parameters
.TP
\f[B]name\f[R]
An identifier for the lock you want to request.
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object describing characteristics of the lock you want to create.
Valid values are:
.RS
.TP
\f[B]mode\f[R] \f[I](optional)\f[R]
Either \f[CR]\[dq]exclusive\[dq]\f[R] or \f[CR]\[dq]shared\[dq]\f[R].
The default value is \f[CR]\[dq]exclusive\[dq]\f[R].
.TP
\f[B]ifAvailable\f[R] \f[I](optional)\f[R]
If \f[CR]true\f[R], the lock request will only be granted if it is not
already held.
If it cannot be granted, the callback will be invoked with
\f[CR]null\f[R] instead of a \f[CR]Lock\f[R] instance.
The default value is \f[CR]false\f[R].
.TP
\f[B]steal\f[R] \f[I](optional)\f[R]
If \f[CR]true\f[R], then any held locks with the same name will be
released, and the request will be granted, preempting any queued
requests for it.
The default value is \f[CR]false\f[R].
.RS
.RS
.PP
\f[B]Warning:\f[R] Use with care!
Code that was previously running inside the lock continues to run, and
may clash with the code that now holds the lock.
.RE
.RE
.TP
\f[B]signal\f[R] \f[I](optional)\f[R]
An \f[CR]AbortSignal\f[R] (the \f[CR]signal\f[R] property of an
\f[CR]AbortController\f[R]); if specified and the
\f[CR]AbortController\f[R] is aborted, the lock request is dropped if it
was not already granted.
.RE
.TP
\f[B]callback\f[R]
Method called when the lock is granted.
The lock is automatically released when the callback returns (or an
exception is thrown).
Usually the callback is an async function, which causes the lock to be
released only when the async function has completely finished.
.SS Return value
A \f[CR]Promise\f[R] that resolves (or rejects) with the result of the
callback after the lock is released, or rejects if the request is
aborted.
.SS Exceptions
This method may return a promise rejected with a \f[CR]DOMException\f[R]
of one of the following types:
.TP
\f[B]InvalidStateError\f[R] \f[B]DOMException\f[R]
Thrown if the environments document is not fully active.
.TP
\f[B]SecurityError\f[R] \f[B]DOMException\f[R]
Thrown if a lock manager cannot be obtained for the current environment.
.TP
\f[B]NotSupportedError\f[R] \f[B]DOMException\f[R]
Thrown if \f[CR]name\f[R] starts with a hyphen (\f[CR]\-\f[R]), both
options \f[CR]steal\f[R] and \f[CR]ifAvailable\f[R] are \f[CR]true\f[R],
or if option \f[CR]signal\f[R] exists and \f[I]either\f[R] option
\f[CR]steal\f[R] or \f[CR]ifAvailable\f[R] is \f[CR]true\f[R].
.TP
\f[B]AbortError\f[R] \f[B]DOMException\f[R]
Thrown if the option \f[CR]signal\f[R] exists and is aborted.
.SH EXAMPLES
.SS General Example
The following example shows the basic use of the \f[CR]request()\f[R]
method with an asynchronous function as the callback.
Once the callback is invoked, no other running code on this origin can
hold \f[CR]my_resource\f[R] until the callback returns.
.IP
.EX
\f[B]await\f[R] navigator.locks.request(\[dq]my_resource\[dq], \f[B]async\f[R] (lock) \f[B]=>\f[R] {
  \f[I]// The lock was granted.\f[R]
});
.EE
.SS \f[CR]mode\f[R] example
The following example shows how to use the \f[CR]mode\f[R] option for
readers and writers.
.PP
Notice that both functions use a lock called \f[CR]my_resource\f[R].
The \f[CR]do_read()\f[R] requests a lock in \f[CR]\[aq]shared\[aq]\f[R]
mode meaning that multiple calls may occur simultaneously across
different event handlers, tabs, or workers.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] do_read() {
  \f[B]await\f[R] navigator.locks.request(
    \[dq]my_resource\[dq],
    { mode: \[dq]shared\[dq] },
    \f[B]async\f[R] (lock) \f[B]=>\f[R] {
      \f[I]// Read code here.\f[R]
    },
  );
}
.EE
.PP
The \f[CR]do_write()\f[R] function use the same lock but in
\f[CR]\[aq]exclusive\[aq]\f[R] mode which will delay invocation of the
\f[CR]request()\f[R] call in \f[CR]do_read()\f[R] until the write
operation has completed.
This applies across event handlers, tabs, or workers.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] do_write() {
  \f[B]await\f[R] navigator.locks.request(
    \[dq]my_resource\[dq],
    { mode: \[dq]exclusive\[dq] },
    \f[B]async\f[R] (lock) \f[B]=>\f[R] {
      \f[I]// Write code here.\f[R]
    },
  );
}
.EE
.SS \f[CR]ifAvailable\f[R] example
To grab a lock only if it isn\[cq]t already being held, use the
\f[CR]ifAvailable\f[R] option.
In this function \f[CR]await\f[R] means the method will not return until
the callback is complete.
Since the lock is only granted if it was available, this call avoids
needing to wait on the lock being released elsewhere.
.IP
.EX
\f[B]await\f[R] navigator.locks.request(
  \[dq]my_resource\[dq],
  { ifAvailable: \f[B]true\f[R] },
  \f[B]async\f[R] (lock) \f[B]=>\f[R] {
    \f[B]if\f[R] (!lock) {
      \f[I]// The lock was not granted \- get out fast.\f[R]
      \f[B]return\f[R];
    }

    \f[I]// The lock was granted, and no other running code in this origin is holding\f[R]
    \f[I]// the \[aq]my_res_lock\[aq] lock until this returns.\f[R]
  },
);
.EE
.SS \f[CR]signal\f[R] example
To only wait for a lock for a short period of time, use the
\f[CR]signal\f[R] option.
.IP
.EX
\f[B]const\f[R] controller = \f[B]new\f[R] AbortController();
\f[I]// Wait at most 200ms.\f[R]
setTimeout(() \f[B]=>\f[R] controller.abort(), 200);

\f[B]try\f[R] {
  \f[B]await\f[R] navigator.locks.request(
    \[dq]my_resource\[dq],
    { signal: controller.signal },
    \f[B]async\f[R] (lock) \f[B]=>\f[R] {
      \f[I]// The lock was acquired!\f[R]
    },
  );
} \f[B]catch\f[R] (ex) {
  \f[B]if\f[R] (ex.name === \[dq]AbortError\[dq]) {
    \f[I]// The request aborted before it could be granted.\f[R]
  }
}
.EE
