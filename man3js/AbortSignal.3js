.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "AbortSignal" "JS" "May 7, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
AbortSignal \- AbortSignal
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]AbortSignal\f[B]\f[R] interface represents a signal
object that allows you to communicate with an asynchronous operation
(such as a fetch request) and abort it if required via an
\f[CR]AbortController\f[R] object.
.SH INSTANCE PROPERTIES
\f[I]Also inherits properties from its parent interface,
\f[CI]EventTarget\f[I].\f[R]
.TP
\f[B]AbortSignal.aborted\f[R] \f[I](read\-only)\f[R]
A Boolean that indicates whether the request(s) the signal is
communicating with is/are aborted (\f[CR]true\f[R]) or not
(\f[CR]false\f[R]).
.TP
\f[B]AbortSignal.reason\f[R] \f[I](read\-only)\f[R]
A JavaScript value providing the abort reason, once the signal has
aborted.
.SH STATIC METHODS
\f[I]Also inherits methods from its parent interface,
\f[CI]EventTarget\f[I].\f[R]
.TP
\f[B]AbortSignal.abort()\f[R]
Returns an \f[CR]AbortSignal\f[R] instance that is already set as
aborted.
.TP
\f[B]AbortSignal.any()\f[R]
Returns an \f[CR]AbortSignal\f[R] that aborts when any of the given
abort signals abort.
.TP
\f[B]AbortSignal.timeout()\f[R]
Returns an \f[CR]AbortSignal\f[R] instance that will automatically abort
after a specified time.
.SH INSTANCE METHODS
\f[I]Also inherits methods from its parent interface,
\f[CI]EventTarget\f[I].\f[R]
.TP
\f[B]AbortSignal.throwIfAborted()\f[R]
Throws the signal\[cq]s abort \f[CR]reason\f[R] if the signal has been
aborted; otherwise it does nothing.
.SH EVENTS
\f[I]Also inherits events from its parent interface,
\f[CI]EventTarget\f[I].\f[R]
.PP
Listen to this event using \f[CR]addEventListener()\f[R] or by assigning
an event listener to the \f[CR]oneventname\f[R] property of this
interface.
.TP
\f[B]abort\f[R]
Invoked when the asynchronous operations the signal is communicating
with is/are aborted.
Also available via the \f[CR]onabort\f[R] property.
.SH EXAMPLES
.SS Aborting a fetch operation using an explicit signal
The following snippet shows how we might use a signal to abort
downloading a video using the Fetch API.
.PP
We first create an abort controller using the
\f[CR]AbortController()\f[R] constructor, then grab a reference to its
associated \f[CR]AbortSignal\f[R] object using the
\f[CR]AbortController.signal\f[R] property.
.PP
When the fetch request is initiated, we pass in the
\f[CR]AbortSignal\f[R] as an option inside the request\[cq]s options
object (the \f[CR]{signal}\f[R] below).
This associates the signal and controller with the fetch request, and
allows us to abort it by calling \f[CR]AbortController.abort()\f[R].
Below you can see that the fetch operation is aborted in the second
event listener, which triggered when the abort button
(\f[CR]abortBtn\f[R]) is clicked.
.IP
.EX
\f[B]const\f[R] controller = \f[B]new\f[R] AbortController();
\f[B]const\f[R] signal = controller.signal;

\f[B]const\f[R] url = \[dq]video.mp4\[dq];
\f[B]const\f[R] downloadBtn = document.querySelector(\[dq].download\[dq]);
\f[B]const\f[R] abortBtn = document.querySelector(\[dq].abort\[dq]);

downloadBtn.addEventListener(\[dq]click\[dq], fetchVideo);

abortBtn.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
  controller.abort();
  console.log(\[dq]Download aborted\[dq]);
});

\f[B]function\f[R] fetchVideo() {
  fetch(url, { signal })
    .then((response) \f[B]=>\f[R] {
      console.log(\[dq]Download complete\[dq], response);
    })
    .catch((err) \f[B]=>\f[R] {
      console.error(\[ga]Download error: ${err.message}\[ga]);
    });
}
.EE
.RS
.PP
\f[B]Note:\f[R] When \f[CR]abort()\f[R] is called, the
\f[CR]fetch()\f[R] promise rejects with an
\[lq]\f[CR]AbortError\f[R]\[rq] \f[CR]DOMException\f[R].
.RE
.PP
You can find a \c
.UR https://github.com/mdn/dom-examples/tree/main/abort-api
full working example on GitHub
.UE \c
; you can also see it \c
.UR https://mdn.github.io/dom-examples/abort-api/
running live
.UE \c
\&.
.SS Aborting a fetch operation with a timeout
If you need to abort the operation on timeout then you can use the
static \f[CR]AbortSignal.timeout()\f[R] method.
This returns an \f[CR]AbortSignal\f[R] that will automatically timeout
after a certain number of milliseconds.
.PP
The code snippet below shows how you would either succeed in downloading
a file, or handle a timeout error after 5 seconds.
Note that when there is a timeout the \f[CR]fetch()\f[R] promise rejects
with a \[lq]\f[CR]TimeoutError\f[R]\[rq] \f[CR]DOMException\f[R].
This allows code to differentiate between timeouts (for which user
notification is probably required), and user aborts.
.IP
.EX
\f[B]const\f[R] url = \[dq]video.mp4\[dq];

\f[B]try\f[R] {
  \f[B]const\f[R] res = \f[B]await\f[R] fetch(url, { signal: AbortSignal.timeout(5000) });
  \f[B]const\f[R] result = \f[B]await\f[R] res.blob();
  \f[I]// \&...\f[R]
} \f[B]catch\f[R] (err) {
  \f[B]if\f[R] (err.name === \[dq]TimeoutError\[dq]) {
    console.error(\[dq]Timeout: It took more than 5 seconds to get the result!\[dq]);
  } \f[B]else\f[R] \f[B]if\f[R] (err.name === \[dq]AbortError\[dq]) {
    console.error(
      \[dq]Fetch aborted by user action (browser stop button, closing tab, etc.\[dq],
    );
  } \f[B]else\f[R] \f[B]if\f[R] (err.name === \[dq]TypeError\[dq]) {
    console.error(\[dq]AbortSignal.timeout() method is not supported\[dq]);
  } \f[B]else\f[R] {
    \f[I]// A network error, or some other problem.\f[R]
    console.error(\[ga]Error: type: ${err.name}, message: ${err.message}\[ga]);
  }
}
.EE
.SS Aborting a fetch with timeout or explicit abort
If you want to abort from multiple signals, you can use
\f[CR]AbortSignal.any()\f[R] to combine them into a single signal.
The following example shows this using \f[CR]fetch\f[R]:
.IP
.EX
\f[B]try\f[R] {
  \f[B]const\f[R] controller = \f[B]new\f[R] AbortController();
  \f[B]const\f[R] timeoutSignal = AbortSignal.timeout(5000);
  \f[B]const\f[R] res = \f[B]await\f[R] fetch(url, {
    \f[I]// This will abort the fetch when either signal is aborted\f[R]
    signal: AbortSignal.any([controller.signal, timeoutSignal]),
  });
  \f[B]const\f[R] body = \f[B]await\f[R] res.json();
} \f[B]catch\f[R] (e) {
  \f[B]if\f[R] (e.name === \[dq]AbortError\[dq]) {
    \f[I]// Notify the user of abort.\f[R]
  } \f[B]else\f[R] \f[B]if\f[R] (e.name === \[dq]TimeoutError\[dq]) {
    \f[I]// Notify the user of timeout\f[R]
  } \f[B]else\f[R] {
    \f[I]// A network error, or some other problem.\f[R]
    console.log(\[ga]Type: ${e.name}, Message: ${e.message}\[ga]);
  }
}
.EE
.RS
.PP
\f[B]Note:\f[R] Unlike when using \f[CR]AbortSignal.timeout()\f[R],
there is no way to tell whether the final abort was caused by a timeout.
.RE
.SS Implementing an abortable API
An API that needs to support aborting can accept an
\f[CR]AbortSignal\f[R] object, and use its state to trigger abort signal
handling when needed.
.PP
A \f[CR]Promise\f[R]\-based API should respond to the abort signal by
rejecting any unsettled promise with the \f[CR]AbortSignal\f[R] abort
\f[CR]reason\f[R].
For example, consider the following \f[CR]myCoolPromiseAPI\f[R], which
takes a signal and returns a promise.
The promise is rejected immediately if the signal is already aborted, or
if the abort event is detected.
Otherwise it completes normally and then resolves the promise.
.IP
.EX
\f[B]function\f[R] myCoolPromiseAPI(\f[I]/* \&..., */\f[R] { signal }) {
  \f[B]return\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
    \f[I]// If the signal is already aborted, immediately throw in order to reject the promise.\f[R]
    \f[B]if\f[R] (signal.aborted) {
      reject(signal.reason);
    }

    \f[I]// Perform the main purpose of the API\f[R]
    \f[I]// Call resolve(result) when done.\f[R]

    \f[I]// Watch for \[aq]abort\[aq] signals\f[R]
    signal.addEventListener(\[dq]abort\[dq], () \f[B]=>\f[R] {
      \f[I]// Stop the main operation\f[R]
      \f[I]// Reject the promise with the abort reason.\f[R]
      reject(signal.reason);
    });
  });
}
.EE
.PP
The API might then be used as shown.
Note that \f[CR]AbortController.abort()\f[R] is called to abort the
operation.
.IP
.EX
\f[B]const\f[R] controller = \f[B]new\f[R] AbortController();
\f[B]const\f[R] signal = controller.signal;

startSpinner();

myCoolPromiseAPI({ \f[I]/* \&..., */\f[R] signal })
  .then((result) \f[B]=>\f[R] {})
  .catch((err) \f[B]=>\f[R] {
    \f[B]if\f[R] (err.name === \[dq]AbortError\[dq]) \f[B]return\f[R];
    showUserErrorMessage();
  })
  .then(() \f[B]=>\f[R] stopSpinner());

controller.abort();
.EE
.PP
APIs that do not return promises might react in a similar manner.
In some cases it may make sense to absorb the signal.
.SH SEE ALSO
.IP \[bu] 2
Fetch API
.IP \[bu] 2
\c
.UR https://developer.chrome.com/blog/abortable-fetch/
Abortable Fetch
.UE \c
\ by Jake Archibald
