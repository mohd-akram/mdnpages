.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Array.from" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.from \- Array.from()
.SH SYNOPSIS
The \f[B]\f[CB]Array.from()\f[B]\f[R] static method creates a new,
shallow\-copied \f[CR]Array\f[R] instance from an iterable or
array\-like object.
.IP
.EX
console.log(Array.from(\[dq]foo\[dq]));
\f[I]// Expected output: Array [\[dq]f\[dq], \[dq]o\[dq], \[dq]o\[dq]]\f[R]

console.log(Array.from([1, 2, 3], (x) \f[B]=>\f[R] x + x));
\f[I]// Expected output: Array [2, 4, 6]\f[R]
.EE
.SH SYNTAX
.IP
.EX
Array.from(arrayLike)
Array.from(arrayLike, mapFn)
Array.from(arrayLike, mapFn, thisArg)
.EE
.SS Parameters
.TP
\f[B]arrayLike\f[R]
An iterable or array\-like object to convert to an array.
.TP
\f[B]mapFn\f[R] \f[I](optional)\f[R]
A function to call on every element of the array.
If provided, every value to be added to the array is first passed
through this function, and \f[CR]mapFn\f[R]\[cq]s return value is added
to the array instead.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
Value to use as \f[CR]this\f[R] when executing \f[CR]mapFn\f[R].
.SS Return value
A new \f[CR]Array\f[R] instance.
.SH DESCRIPTION
\f[CR]Array.from()\f[R] lets you create \f[CR]Array\f[R]s from:
.IP \[bu] 2
iterable objects (objects such as \f[CR]Map\f[R] and \f[CR]Set\f[R]);
or, if the object is not iterable,
.IP \[bu] 2
array\-like objects (objects with a \f[CR]length\f[R] property and
indexed elements).
.PP
To convert an ordinary object that\[cq]s not iterable or array\-like to
an array (by enumerating its property keys, values, or both), use
\f[CR]Object.keys()\f[R], \f[CR]Object.values()\f[R], or
\f[CR]Object.entries()\f[R].
To convert an async iterable to an array, use
\f[CR]Array.fromAsync()\f[R].
.PP
\f[CR]Array.from()\f[R] never creates a sparse array.
If the \f[CR]arrayLike\f[R] object is missing some index properties,
they become \f[CR]undefined\f[R] in the new array.
.PP
\f[CR]Array.from()\f[R] has an optional parameter \f[CR]mapFn\f[R],
which allows you to execute a function on each element of the array
being created, similar to \f[CR]map()\f[R].
More clearly, \f[CR]Array.from(obj, mapFn, thisArg)\f[R] has the same
result as \f[CR]Array.from(obj).map(mapFn, thisArg)\f[R], except that it
does not create an intermediate array, and \f[CR]mapFn\f[R] only
receives two arguments (\f[CR]element\f[R], \f[CR]index\f[R]) without
the whole array, because the array is still under construction.
.RS
.PP
\f[B]Note:\f[R] This behavior is more important for typed arrays, since
the intermediate array would necessarily have values truncated to fit
into the appropriate type.
\f[CR]Array.from()\f[R] is implemented to have the same signature as
\f[CR]TypedArray.from()\f[R].
.RE
.PP
The \f[CR]Array.from()\f[R] method is a generic factory method.
For example, if a subclass of \f[CR]Array\f[R] inherits the
\f[CR]from()\f[R] method, the inherited \f[CR]from()\f[R] method will
return new instances of the subclass instead of \f[CR]Array\f[R]
instances.
In fact, the \f[CR]this\f[R] value can be any constructor function that
accepts a single argument representing the length of the new array.
When an iterable is passed as \f[CR]arrayLike\f[R], the constructor is
called with no arguments; when an array\-like object is passed, the
constructor is called with the normalized length of the array\-like
object.
The final \f[CR]length\f[R] will be set again when iteration finishes.
If the \f[CR]this\f[R] value is not a constructor function, the plain
\f[CR]Array\f[R] constructor is used instead.
.SH EXAMPLES
.SS Array from a String
.IP
.EX
Array.from(\[dq]foo\[dq]);
\f[I]// [ \[dq]f\[dq], \[dq]o\[dq], \[dq]o\[dq] ]\f[R]
.EE
.SS Array from a Set
.IP
.EX
\f[B]const\f[R] \f[B]set\f[R] = \f[B]new\f[R] Set([\[dq]foo\[dq], \[dq]bar\[dq], \[dq]baz\[dq], \[dq]foo\[dq]]);
Array.from(\f[B]set\f[R]);
\f[I]// [ \[dq]foo\[dq], \[dq]bar\[dq], \[dq]baz\[dq] ]\f[R]
.EE
.SS Array from a Map
.IP
.EX
\f[B]const\f[R] map = \f[B]new\f[R] Map([
  [1, 2],
  [2, 4],
  [4, 8],
]);
Array.from(map);
\f[I]// [[1, 2], [2, 4], [4, 8]]\f[R]

\f[B]const\f[R] mapper = \f[B]new\f[R] Map([
  [\[dq]1\[dq], \[dq]a\[dq]],
  [\[dq]2\[dq], \[dq]b\[dq]],
]);
Array.from(mapper.values());
\f[I]// [\[aq]a\[aq], \[aq]b\[aq]];\f[R]

Array.from(mapper.keys());
\f[I]// [\[aq]1\[aq], \[aq]2\[aq]];\f[R]
.EE
.SS Array from a NodeList
.IP
.EX
\f[I]// Create an array based on a property of DOM Elements\f[R]
\f[B]const\f[R] images = document.querySelectorAll(\[dq]img\[dq]);
\f[B]const\f[R] sources = Array.from(images, (image) \f[B]=>\f[R] image.src);
\f[B]const\f[R] insecureSources = sources.filter((link) \f[B]=>\f[R] link.startsWith(\[dq]http://\[dq]));
.EE
.SS Array from an Array\-like object (arguments)
.IP
.EX
\f[B]function\f[R] f() {
  \f[B]return\f[R] Array.from(\f[B]arguments\f[R]);
}

f(1, 2, 3);

\f[I]// [ 1, 2, 3 ]\f[R]
.EE
.SS Using arrow functions and Array.from()
.IP
.EX
\f[I]// Using an arrow function as the map function to\f[R]
\f[I]// manipulate the elements\f[R]
Array.from([1, 2, 3], (x) \f[B]=>\f[R] x + x);
\f[I]// [2, 4, 6]\f[R]

\f[I]// Generate a sequence of numbers\f[R]
\f[I]// Since the array is initialized with \[ga]undefined\[ga] on each position,\f[R]
\f[I]// the value of \[ga]v\[ga] below will be \[ga]undefined\[ga]\f[R]
Array.from({ length: 5 }, (v, i) \f[B]=>\f[R] i);
\f[I]// [0, 1, 2, 3, 4]\f[R]
.EE
.SS Sequence generator (range)
.IP
.EX
\f[I]// Sequence generator function (commonly referred to as \[dq]range\[dq], cf. Python, Clojure, etc.)\f[R]
\f[B]const\f[R] range = (start, stop, step) \f[B]=>\f[R]
  Array.from(
    { length: Math.ceil((stop \- start) / step) },
    (_, i) \f[B]=>\f[R] start + i * step,
  );

\f[I]// Generate a sequence of numbers from 0 (inclusive) to 5 (exclusive), incrementing by 1\f[R]
range(0, 5, 1);
\f[I]// [0, 1, 2, 3, 4]\f[R]

\f[I]// Generate a sequence of numbers from 1 (inclusive) to 10 (exclusive), incrementing by 2\f[R]
range(1, 10, 2);
\f[I]// [1, 3, 5, 7, 9]\f[R]

\f[I]// Generate the Latin alphabet making use of it being ordered as a sequence\f[R]
range(\[dq]A\[dq].charCodeAt(0), \[dq]Z\[dq].charCodeAt(0) + 1, 1).map((x) \f[B]=>\f[R]
  String.fromCharCode(x),
);
\f[I]// [\[dq]A\[dq], \[dq]B\[dq], \[dq]C\[dq], \[dq]D\[dq], \[dq]E\[dq], \[dq]F\[dq], \[dq]G\[dq], \[dq]H\[dq], \[dq]I\[dq], \[dq]J\[dq], \[dq]K\[dq], \[dq]L\[dq], \[dq]M\[dq], \[dq]N\[dq], \[dq]O\[dq], \[dq]P\[dq], \[dq]Q\[dq], \[dq]R\[dq], \[dq]S\[dq], \[dq]T\[dq], \[dq]U\[dq], \[dq]V\[dq], \[dq]W\[dq], \[dq]X\[dq], \[dq]Y\[dq], \[dq]Z\[dq]]\f[R]
.EE
.SS Calling from() on non\-array constructors
The \f[CR]from()\f[R] method can be called on any constructor function
that accepts a single argument representing the length of the new array.
.IP
.EX
\f[B]function\f[R] NotArray(len) {
  console.log(\[dq]NotArray called with length\[dq], len);
}

\f[I]// Iterable\f[R]
console.log(Array.from.call(NotArray, \f[B]new\f[R] Set([\[dq]foo\[dq], \[dq]bar\[dq], \[dq]baz\[dq]])));
\f[I]// NotArray called with length undefined\f[R]
\f[I]// NotArray { \[aq]0\[aq]: \[aq]foo\[aq], \[aq]1\[aq]: \[aq]bar\[aq], \[aq]2\[aq]: \[aq]baz\[aq], length: 3 }\f[R]

\f[I]// Array\-like\f[R]
console.log(Array.from.call(NotArray, { length: 1, 0: \[dq]foo\[dq] }));
\f[I]// NotArray called with length 1\f[R]
\f[I]// NotArray { \[aq]0\[aq]: \[aq]foo\[aq], length: 1 }\f[R]
.EE
.PP
When the \f[CR]this\f[R] value is not a constructor, a plain
\f[CR]Array\f[R] object is returned.
.IP
.EX
console.log(Array.from.call({}, { length: 1, 0: \[dq]foo\[dq] })); \f[I]// [ \[aq]foo\[aq] ]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.from\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Indexed collections guide
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array()\f[R]
.IP \[bu] 2
\f[CR]Array.of()\f[R]
.IP \[bu] 2
\f[CR]Array.fromAsync()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.map()\f[R]
.IP \[bu] 2
\f[CR]TypedArray.from()\f[R]
