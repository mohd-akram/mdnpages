.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ARRAY.FROM" "3JS" "March 5, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.from \- Array.from()
.SH SYNOPSIS
The \f[B]\f[CB]Array.from()\f[B]\f[R] static method creates a new,
shallow\-copied \f[CR]Array\f[R] instance from an iterable or
array\-like object.
.IP
.EX
console.log(Array.from(\(dqfoo\(dq));
\f[I]// Expected output: Array [\(dqf\(dq, \(dqo\(dq, \(dqo\(dq]\f[R]

console.log(Array.from([1, 2, 3], (x) \f[B]=>\f[R] x + x));
\f[I]// Expected output: Array [2, 4, 6]\f[R]
.EE
.SH SYNTAX
.IP
.EX
Array.from(arrayLike)
Array.from(arrayLike, mapFn)
Array.from(arrayLike, mapFn, thisArg)
.EE
.SS Parameters
.TP
\f[B]arrayLike\f[R]
An iterable or array\-like object to convert to an array.
.TP
\f[B]mapFn\f[R] \f[I](optional)\f[R]
A function to call on every element of the array.
If provided, every value to be added to the array is first passed
through this function, and \f[CR]mapFn\f[R]\(cqs return value is added
to the array instead.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
Value to use as \f[CR]this\f[R] when executing \f[CR]mapFn\f[R].
.SS Return value
A new \f[CR]Array\f[R] instance.
.SH DESCRIPTION
\f[CR]Array.from()\f[R] lets you create \f[CR]Array\f[R]s from:
.IP \(bu 2
iterable objects (objects such as \f[CR]Map\f[R] and \f[CR]Set\f[R]);
or, if the object is not iterable,
.IP \(bu 2
array\-like objects (objects with a \f[CR]length\f[R] property and
indexed elements).
.PP
To convert an ordinary object that\(cqs not iterable or array\-like to
an array (by enumerating its property keys, values, or both), use
\f[CR]Object.keys()\f[R], \f[CR]Object.values()\f[R], or
\f[CR]Object.entries()\f[R].
To convert an async iterable to an array, use
\f[CR]Array.fromAsync()\f[R].
.PP
\f[CR]Array.from()\f[R] never creates a sparse array.
If the \f[CR]arrayLike\f[R] object is missing some index properties,
they become \f[CR]undefined\f[R] in the new array.
.PP
\f[CR]Array.from()\f[R] has an optional parameter \f[CR]mapFn\f[R],
which allows you to execute a function on each element of the array
being created, similar to \f[CR]map()\f[R].
More clearly, \f[CR]Array.from(obj, mapFn, thisArg)\f[R] has the same
result as \f[CR]Array.from(obj).map(mapFn, thisArg)\f[R], except that it
does not create an intermediate array, and \f[CR]mapFn\f[R] only
receives two arguments (\f[CR]element\f[R], \f[CR]index\f[R]) without
the whole array, because the array is still under construction.
.RS
.PP
\f[B]Note:\f[R] This behavior is more important for typed arrays, since
the intermediate array would necessarily have values truncated to fit
into the appropriate type.
\f[CR]Array.from()\f[R] is implemented to have the same signature as
\f[CR]TypedArray.from()\f[R].
.RE
.PP
The \f[CR]Array.from()\f[R] method is a generic factory method.
For example, if a subclass of \f[CR]Array\f[R] inherits the
\f[CR]from()\f[R] method, the inherited \f[CR]from()\f[R] method will
return new instances of the subclass instead of \f[CR]Array\f[R]
instances.
In fact, the \f[CR]this\f[R] value can be any constructor function that
accepts a single argument representing the length of the new array.
When an iterable is passed as \f[CR]arrayLike\f[R], the constructor is
called with no arguments; when an array\-like object is passed, the
constructor is called with the normalized length of the array\-like
object.
The final \f[CR]length\f[R] will be set again when iteration finishes.
If the \f[CR]this\f[R] value is not a constructor function, the plain
\f[CR]Array\f[R] constructor is used instead.
.SH EXAMPLES
.SS Array from a String
.IP
.EX
Array.from(\(dqfoo\(dq);
\f[I]// [ \(dqf\(dq, \(dqo\(dq, \(dqo\(dq ]\f[R]
.EE
.SS Array from a Set
.IP
.EX
\f[B]const\f[R] \f[B]set\f[R] = \f[B]new\f[R] Set([\(dqfoo\(dq, \(dqbar\(dq, \(dqbaz\(dq, \(dqfoo\(dq]);
Array.from(\f[B]set\f[R]);
\f[I]// [ \(dqfoo\(dq, \(dqbar\(dq, \(dqbaz\(dq ]\f[R]
.EE
.SS Array from a Map
.IP
.EX
\f[B]const\f[R] map = \f[B]new\f[R] Map([
  [1, 2],
  [2, 4],
  [4, 8],
]);
Array.from(map);
\f[I]// [[1, 2], [2, 4], [4, 8]]\f[R]

\f[B]const\f[R] mapper = \f[B]new\f[R] Map([
  [\(dq1\(dq, \(dqa\(dq],
  [\(dq2\(dq, \(dqb\(dq],
]);
Array.from(mapper.values());
\f[I]// [\(aqa\(aq, \(aqb\(aq];\f[R]

Array.from(mapper.keys());
\f[I]// [\(aq1\(aq, \(aq2\(aq];\f[R]
.EE
.SS Array from a NodeList
.IP
.EX
\f[I]// Create an array based on a property of DOM Elements\f[R]
\f[B]const\f[R] images = document.querySelectorAll(\(dqimg\(dq);
\f[B]const\f[R] sources = Array.from(images, (image) \f[B]=>\f[R] image.src);
\f[B]const\f[R] insecureSources = sources.filter((link) \f[B]=>\f[R] link.startsWith(\(dqhttp://\(dq));
.EE
.SS Array from an Array\-like object (arguments)
.IP
.EX
\f[B]function\f[R] f() {
  \f[B]return\f[R] Array.from(\f[B]arguments\f[R]);
}

f(1, 2, 3);

\f[I]// [ 1, 2, 3 ]\f[R]
.EE
.SS Using arrow functions and Array.from()
.IP
.EX
\f[I]// Using an arrow function as the map function to\f[R]
\f[I]// manipulate the elements\f[R]
Array.from([1, 2, 3], (x) \f[B]=>\f[R] x + x);
\f[I]// [2, 4, 6]\f[R]

\f[I]// Generate a sequence of numbers\f[R]
\f[I]// Since the array is initialized with \(gaundefined\(ga on each position,\f[R]
\f[I]// the value of \(gav\(ga below will be \(gaundefined\(ga\f[R]
Array.from({ length: 5 }, (v, i) \f[B]=>\f[R] i);
\f[I]// [0, 1, 2, 3, 4]\f[R]
.EE
.SS Sequence generator (range)
.IP
.EX
\f[I]// Sequence generator function (commonly referred to as \(dqrange\(dq, cf. Python, Clojure, etc.)\f[R]
\f[B]const\f[R] range = (start, stop, step) \f[B]=>\f[R]
  Array.from(
    { length: Math.ceil((stop \- start) / step) },
    (_, i) \f[B]=>\f[R] start + i * step,
  );

\f[I]// Generate a sequence of numbers from 0 (inclusive) to 5 (exclusive), incrementing by 1\f[R]
range(0, 5, 1);
\f[I]// [0, 1, 2, 3, 4]\f[R]

\f[I]// Generate a sequence of numbers from 1 (inclusive) to 10 (exclusive), incrementing by 2\f[R]
range(1, 10, 2);
\f[I]// [1, 3, 5, 7, 9]\f[R]

\f[I]// Generate the Latin alphabet making use of it being ordered as a sequence\f[R]
range(\(dqA\(dq.charCodeAt(0), \(dqZ\(dq.charCodeAt(0) + 1, 1).map((x) \f[B]=>\f[R]
  String.fromCharCode(x),
);
\f[I]// [\(dqA\(dq, \(dqB\(dq, \(dqC\(dq, \(dqD\(dq, \(dqE\(dq, \(dqF\(dq, \(dqG\(dq, \(dqH\(dq, \(dqI\(dq, \(dqJ\(dq, \(dqK\(dq, \(dqL\(dq, \(dqM\(dq, \(dqN\(dq, \(dqO\(dq, \(dqP\(dq, \(dqQ\(dq, \(dqR\(dq, \(dqS\(dq, \(dqT\(dq, \(dqU\(dq, \(dqV\(dq, \(dqW\(dq, \(dqX\(dq, \(dqY\(dq, \(dqZ\(dq]\f[R]
.EE
.SS Calling from() on non\-array constructors
The \f[CR]from()\f[R] method can be called on any constructor function
that accepts a single argument representing the length of the new array.
.IP
.EX
\f[B]function\f[R] NotArray(len) {
  console.log(\(dqNotArray called with length\(dq, len);
}

\f[I]// Iterable\f[R]
console.log(Array.from.call(NotArray, \f[B]new\f[R] Set([\(dqfoo\(dq, \(dqbar\(dq, \(dqbaz\(dq])));
\f[I]// NotArray called with length undefined\f[R]
\f[I]// NotArray { \(aq0\(aq: \(aqfoo\(aq, \(aq1\(aq: \(aqbar\(aq, \(aq2\(aq: \(aqbaz\(aq, length: 3 }\f[R]

\f[I]// Array\-like\f[R]
console.log(Array.from.call(NotArray, { length: 1, 0: \(dqfoo\(dq }));
\f[I]// NotArray called with length 1\f[R]
\f[I]// NotArray { \(aq0\(aq: \(aqfoo\(aq, length: 1 }\f[R]
.EE
.PP
When the \f[CR]this\f[R] value is not a constructor, a plain
\f[CR]Array\f[R] object is returned.
.IP
.EX
console.log(Array.from.call({}, { length: 1, 0: \(dqfoo\(dq })); \f[I]// [ \(aqfoo\(aq ]\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.from\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/array.from
es\-shims polyfill of \f[CR]Array.from\f[R]
.UE \c
.IP \(bu 2
Indexed collections guide
.IP \(bu 2
\f[CR]Array\f[R]
.IP \(bu 2
\f[CR]Array()\f[R]
.IP \(bu 2
\f[CR]Array.of()\f[R]
.IP \(bu 2
\f[CR]Array.fromAsync()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.map()\f[R]
.IP \(bu 2
\f[CR]TypedArray.from()\f[R]
