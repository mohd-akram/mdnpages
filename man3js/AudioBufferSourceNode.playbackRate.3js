.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "AUDIOBUFFERSOURCENODE.PLAYBACKRATE" "3JS" "April 10, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
AudioBufferSourceNode.playbackRate \- AudioBufferSourceNode:
playbackRate property
.SH SYNOPSIS
The \f[B]\f[CB]playbackRate\f[B]\f[R] property of the
\f[CR]AudioBufferSourceNode\f[R] interface Is a k\-rate
\f[CR]AudioParam\f[R] that defines the speed at which the audio asset
will be played.
.PP
A value of 1.0 indicates it should play at the same speed as its
sampling rate, values less than 1.0 cause the sound to play more slowly,
while values greater than 1.0 result in audio playing faster than
normal.
The default value is \f[CR]1.0\f[R].
When set to another value, the \f[CR]AudioBufferSourceNode\f[R]
resamples the audio before sending it to the output.
.SH VALUE
An \f[CR]AudioParam\f[R] whose \f[CR]value\f[R] is a floating\-point
value indicating the playback rate of the audio as a decimal proportion
of the original sampling rate.
.PP
Consider a sound buffer containing audio sampled at 44.1 kHz (44,100
samples per second).
Let\(cqs see what a few values of \f[CR]playbackRate\f[R] do:
.IP \(bu 2
A \f[CR]playbackRate\f[R] of 1.0 plays the audio at full speed, or
44,100 Hz.
.IP \(bu 2
A \f[CR]playbackRate\f[R] of 0.5 plays the audio at half speed, or
22,050 Hz.
.IP \(bu 2
A \f[CR]playbackRate\f[R] of 2.0 doubles the audio\(cqs playback rate to
88,200 Hz.
.SH EXAMPLES
.SS Setting \f[CR]playbackRate\f[R]
In this example, when the user presses \(lqPlay\(rq, we load an audio
track, decode it, and put it into an \f[CR]AudioBufferSourceNode\f[R].
.PP
The example then sets the \f[CR]loop\f[R] property to \f[CR]true\f[R],
so the track loops, and plays the track.
.PP
The user can set the \f[CR]playbackRate\f[R] property using a range
control.
.RS
.PP
\f[B]Note:\f[R] You can \c
.UR https://mdn.github.io/webaudio-examples/audio-buffer-source-node/playbackrate/
run the full example live
.UE \c
\ (or \c
.UR https://github.com/mdn/webaudio-examples/tree/main/audio-buffer-source-node/playbackrate
view the source
.UE \c
\&.)
.RE
.IP
.EX
\f[B]let\f[R] audioCtx;
\f[B]let\f[R] buffer;
\f[B]let\f[R] source;

\f[B]const\f[R] play = document.getElementById(\(dqplay\(dq);
\f[B]const\f[R] stop = document.getElementById(\(dqstop\(dq);

\f[B]const\f[R] playbackControl = document.getElementById(\(dqplayback\-rate\-control\(dq);
\f[B]const\f[R] playbackValue = document.getElementById(\(dqplayback\-rate\-value\(dq);

\f[B]async\f[R] \f[B]function\f[R] loadAudio() {
  \f[B]try\f[R] {
    \f[I]// Load an audio file\f[R]
    \f[B]const\f[R] response = \f[B]await\f[R] fetch(\(dqrnb\-lofi\-melody\-loop.wav\(dq);
    \f[I]// Decode it\f[R]
    buffer = \f[B]await\f[R] audioCtx.decodeAudioData(\f[B]await\f[R] response.arrayBuffer());
  } \f[B]catch\f[R] (err) {
    console.error(\(gaUnable to fetch the audio file. Error: ${err.message}\(ga);
  }
}

play.addEventListener(\(dqclick\(dq, \f[B]async\f[R] () \f[B]=>\f[R] {
  \f[B]if\f[R] (!audioCtx) {
    audioCtx = \f[B]new\f[R] AudioContext();
    \f[B]await\f[R] loadAudio();
  }
  source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(audioCtx.destination);
  source.loop = \f[B]true\f[R];
  source.playbackRate.value = playbackControl.value;
  source.start();
  play.disabled = \f[B]true\f[R];
  stop.disabled = \f[B]false\f[R];
  playbackControl.disabled = \f[B]false\f[R];
});

stop.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
  source.stop();
  play.disabled = \f[B]false\f[R];
  stop.disabled = \f[B]true\f[R];
  playbackControl.disabled = \f[B]true\f[R];
});

playbackControl.oninput = () \f[B]=>\f[R] {
  source.playbackRate.value = playbackControl.value;
  playbackValue.textContent = playbackControl.value;
};
.EE
.SH SEE ALSO
.IP \(bu 2
Using the Web Audio API
.IP \(bu 2
Web Audio API
