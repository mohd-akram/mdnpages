.\" Automatically generated by Pandoc 3.4
.\"
.TH "Window.setInterval" "JS" "October 16, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Window.setInterval \- Window: setInterval() method
.SH SYNOPSIS
The \f[B]\f[CB]setInterval()\f[B]\f[R] method of the \f[CR]Window\f[R]
interface repeatedly calls a function or executes a code snippet, with a
fixed time delay between each call.
.PP
This method returns an interval ID which uniquely identifies the
interval, so you can remove it later by calling
\f[CR]clearInterval()\f[R].
.SH SYNTAX
.IP
.EX
setInterval(code)
setInterval(code, delay)

setInterval(func)
setInterval(func, delay)
setInterval(func, delay, arg1)
setInterval(func, delay, arg1, arg2)
setInterval(func, delay, arg1, arg2, /* \&..., */ argN)
.EE
.SS Parameters
.TP
\f[B]func\f[R]
A \f[CR]function\f[R] to be executed every \f[CR]delay\f[R]
milliseconds.
The first execution happens after \f[CR]delay\f[R] milliseconds.
.TP
\f[B]code\f[R]
An optional syntax allows you to include a string instead of a function,
which is compiled and executed every \f[CR]delay\f[R] milliseconds.
This syntax is \f[I]not recommended\f[R] for the same reasons that make
using \f[CR]eval()\f[R] a security risk.
.TP
\f[B]delay\f[R] \f[I](optional)\f[R]
The time, in milliseconds (thousandths of a second), the timer should
delay in between executions of the specified function or code.
Defaults to 0 if not specified.
See Delay restrictions below for details on the permitted range of
\f[CR]delay\f[R] values.
.TP
\f[B]arg1\f[R], \&..., \f[B]argN\f[R] \f[I](optional)\f[R]
Additional arguments which are passed through to the function specified
by \f[I]func\f[R] once the timer expires.
.SS Return value
The returned \f[CR]intervalID\f[R] is a numeric, non\-zero value which
identifies the timer created by the call to \f[CR]setInterval()\f[R];
this value can be passed to \f[CR]clearInterval()\f[R] to cancel the
interval.
.PP
It may be helpful to be aware that \f[CR]setInterval()\f[R] and
\f[CR]setTimeout()\f[R] share the same pool of IDs, and that
\f[CR]clearInterval()\f[R] and \f[CR]clearTimeout()\f[R] can technically
be used interchangeably.
For clarity, however, you should try to always match them to avoid
confusion when maintaining your code.
.RS
.PP
\f[B]Note:\f[R] The \f[CR]delay\f[R] argument is converted to a signed
32\-bit integer.
This effectively limits \f[CR]delay\f[R] to 2147483647 ms, roughly 24.8
days, since it\[cq]s specified as a signed integer in the IDL.
.RE
.SH EXAMPLES
.SS Example 1: Basic syntax
The following example demonstrates \f[CR]setInterval()\f[R]\[cq]s basic
syntax.
.IP
.EX
\f[B]const\f[R] intervalID = setInterval(myCallback, 500, \[dq]Parameter 1\[dq], \[dq]Parameter 2\[dq]);

\f[B]function\f[R] myCallback(a, b) {
  \f[I]// Your code here\f[R]
  \f[I]// Parameters are purely optional.\f[R]
  console.log(a);
  console.log(b);
}
.EE
.SS Example 2: Alternating two colors
The following example calls the \f[CR]flashtext()\f[R] function once a
second until the Stop button is pressed.
.SS HTML
.IP
.EX
<\f[B]div\f[R] id=\[dq]my_box\[dq]>
  <\f[B]h3\f[R]>Hello World</\f[B]h3\f[R]>
</\f[B]div\f[R]>
<\f[B]button\f[R] id=\[dq]start\[dq]>Start</\f[B]button\f[R]>
<\f[B]button\f[R] id=\[dq]stop\[dq]>Stop</\f[B]button\f[R]>
.EE
.SS CSS
.IP
.EX
\&.go {
  \f[B]color\f[R]: green;
}
\&.stop {
  \f[B]color\f[R]: red;
}
.EE
.SS JavaScript
.IP
.EX
\f[I]// variable to store our intervalID\f[R]
\f[B]let\f[R] intervalId;

\f[B]function\f[R] changeColor() {
  \f[I]// check if an interval has already been set up\f[R]
  \f[B]if\f[R] (!intervalId) {
    intervalId = setInterval(flashText, 1000);
  }
}

\f[B]function\f[R] flashText() {
  \f[B]const\f[R] oElem = document.getElementById(\[dq]my_box\[dq]);
  oElem.className = oElem.className === \[dq]go\[dq] ? \[dq]stop\[dq] : \[dq]go\[dq];
}

\f[B]function\f[R] stopTextColor() {
  clearInterval(intervalId);
  \f[I]// release our intervalId from the variable\f[R]
  intervalId = \f[B]null\f[R];
}

document.getElementById(\[dq]start\[dq]).addEventListener(\[dq]click\[dq], changeColor);
document.getElementById(\[dq]stop\[dq]).addEventListener(\[dq]click\[dq], stopTextColor);
.EE
.SS Result
.SH THE \[lq]THIS\[rq] PROBLEM
When you pass a method to \f[CR]setInterval()\f[R] or any other
function, it is invoked with the wrong \f[CR]this\f[R] value.
This problem is explained in detail in the JavaScript reference.
.SS Explanation
Code executed by \f[CR]setInterval()\f[R] runs in a separate execution
context than the function from which it was called.
As a consequence, the \f[CR]this\f[R] keyword for the called function is
set to the \f[CR]window\f[R] (or \f[CR]global\f[R]) object, it is not
the same as the \f[CR]this\f[R] value for the function that called
\f[CR]setTimeout\f[R].
See the following example (which uses \f[CR]setTimeout()\f[R] instead of
\f[CR]setInterval()\f[R] \[en] the problem, in fact, is the same for
both timers):
.IP
.EX
myArray = [\[dq]zero\[dq], \[dq]one\[dq], \[dq]two\[dq]];

myArray.myMethod = \f[B]function\f[R] (sProperty) {
  alert(\f[B]arguments\f[R].length > 0 ? \f[B]this\f[R][sProperty] : \f[B]this\f[R]);
};

myArray.myMethod(); \f[I]// prints \[dq]zero,one,two\[dq]\f[R]
myArray.myMethod(1); \f[I]// prints \[dq]one\[dq]\f[R]
setTimeout(myArray.myMethod, 1000); \f[I]// prints \[dq][object Window]\[dq] after 1 second\f[R]
setTimeout(myArray.myMethod, 1500, \[dq]1\[dq]); \f[I]// prints \[dq]undefined\[dq] after 1.5 seconds\f[R]

\f[I]// Passing the \[aq]this\[aq] object with .call won\[aq]t work\f[R]
\f[I]// because this will change the value of this inside setTimeout itself\f[R]
\f[I]// while we want to change the value of this inside myArray.myMethod.\f[R]
\f[I]// In fact, it will be an error because setTimeout code expects this to be the window object:\f[R]
setTimeout.call(myArray, myArray.myMethod, 2000); \f[I]// error: \[dq]NS_ERROR_XPC_BAD_OP_ON_WN_PROTO: Illegal operation on WrappedNative prototype object\[dq]\f[R]
setTimeout.call(myArray, myArray.myMethod, 2500, 2); \f[I]// same error\f[R]
.EE
.PP
As you can see there are no ways to pass the \f[CR]this\f[R] object to
the callback function in the legacy JavaScript.
.SS A possible solution
All modern JavaScript runtimes (in browsers and elsewhere) support arrow
functions, with lexical \f[CR]this\f[R] \[em] allowing us to write
\f[CR]setInterval(() => this.myMethod())\f[R] if we\[cq]re inside the
\f[CR]myArray\f[R] method.
.PP
If you need to support IE, use the \f[CR]Function.prototype.bind()\f[R]
method, which lets you specify the value that should be used as
\f[CR]this\f[R] for all calls to a given function.
That lets you easily bypass problems where it\[cq]s unclear what
\f[CR]this\f[R] will be, depending on the context from which your
function was called.
.SH USAGE NOTES
The \f[CR]setInterval()\f[R] function is commonly used to set a delay
for functions that are executed again and again, such as animations.
You can cancel the interval using \f[CR]clearInterval()\f[R].
.PP
If you wish to have your function called \f[I]once\f[R] after the
specified delay, use \f[CR]setTimeout()\f[R].
.SS Delay restrictions
It\[cq]s possible for intervals to be nested; that is, the callback for
\f[CR]setInterval()\f[R] can in turn call \f[CR]setInterval()\f[R] to
start another interval running, even though the first one is still
going.
To mitigate the potential impact this can have on performance, once
intervals are nested beyond five levels deep, the browser will
automatically enforce a 4 ms minimum value for the interval.
Attempts to specify a value less than 4 ms in deeply\-nested calls to
\f[CR]setInterval()\f[R] will be pinned to 4 ms.
.PP
Browsers may enforce even more stringent minimum values for the interval
under some circumstances, although these should not be common.
Note also that the actual amount of time that elapses between calls to
the callback may be longer than the given \f[CR]delay\f[R]; see Reasons
for delays longer than specified for examples.
.SS Ensure that execution duration is shorter than interval frequency
If there is a possibility that your logic could take longer to execute
than the interval time, it is recommended that you recursively call a
named function using \f[CR]setTimeout()\f[R].
For example, if using \f[CR]setInterval()\f[R] to poll a remote server
every 5 seconds, network latency, an unresponsive server, and a host of
other issues could prevent the request from completing in its allotted
time.
As such, you may find yourself with queued up XHR requests that
won\[cq]t necessarily return in order.
.PP
In these cases, a recursive \f[CR]setTimeout()\f[R] pattern is
preferred:
.IP
.EX
(\f[B]function\f[R] loop() {
  setTimeout(() \f[B]=>\f[R] {
    \f[I]// Your logic here\f[R]

    loop();
  }, delay);
})();
.EE
.PP
In the above snippet, a named function \f[CR]loop()\f[R] is declared and
is immediately executed.
\f[CR]loop()\f[R] is recursively called inside \f[CR]setTimeout()\f[R]
after the logic has completed executing.
While this pattern does not guarantee execution on a fixed interval, it
does guarantee that the previous interval has completed before
recursing.
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#settimeout-and-setinterval
Polyfill of \f[CR]setInterval\f[R] which allows passing arguments to the
callback in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Window.clearInterval()\f[R]
.IP \[bu] 2
\f[CR]WorkerGlobalScope.setInterval()\f[R]
.IP \[bu] 2
\f[CR]Window.setTimeout()\f[R]
.IP \[bu] 2
\f[CR]Window.requestAnimationFrame()\f[R]
