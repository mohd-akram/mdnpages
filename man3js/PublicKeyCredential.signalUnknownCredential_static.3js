.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "PUBLICKEYCREDENTIAL.SIGNALUNKNOWNCREDENTIAL_STATIC" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
PublicKeyCredential.signalUnknownCredential_static \-
PublicKeyCredential: signalUnknownCredential() static method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
The \f[B]\f[CB]signalUnknownCredential()\f[B]\f[R] static method of the
\f[CR]PublicKeyCredential\f[R] interface signals to the authenticator
that a credential ID was not recognized by the \c
.UR https://en.wikipedia.org/wiki/Relying_party
relying party
.UE \c
\ (RP) server.
.PP
This allows the authenticator to remove credentials that are not allowed
by the RP, such as those for deleted accounts, or accounts that were
created and stored on the authenticator but not properly updated on the
server.
Generally the method is called after sign in fails because the account
details were not available to the RP.
It can be used even when the current user is not authenticated because
it does not expose sensitive information.
.SH SYNTAX
.IP
.EX
signalUnknownCredential(options)
.EE
.SS Parameters
.TP
\f[B]options\f[R]
An object representing the unrecognized credential, which contains the
following properties:
.RS
.TP
\f[B]credentialId\f[R]
A base64url\-encoded string representing the \f[CR]id\f[R] of the
credential that was unrecognized.
.TP
\f[B]rpId\f[R]
A string representing the \f[CR]id\f[R] of the RP that sent the signal.
.RE
.SS Return value
A \f[CR]Promise\f[R] that resolves to \f[CR]undefined\f[R].
.SS Exceptions
The promise rejects with the following exceptions:
.TP
\f[B]SecurityError\f[R] \f[B]DOMException\f[R]
The RP domain is not valid.
.TP
\f[B]TypeError\f[R] \f[B]DOMException\f[R]
The \f[CR]credentialId\f[R] is not a valid base64url\-encoded string.
.SH DESCRIPTION
It is possible for the information stored in a user\(cqs authenticator
about a discoverable credential (for example, \c
.UR https://passkeys.dev/
a passkey
.UE \c
) to go out sync with the RP server.
This usually occurs when the user deletes a credential from the RP web
app without updating the authenticator.
.PP
When a user attempts to log in using discoverable credentials, they are
presented with a set of credentials from the authenticator to choose
from, and the selected credential is returned to the RP web app to log
in with.
If the user selects a credential that has been deleted from the RP
server, it won\(cqt be recognized, and the login will fail.
This is a confusing experience for users, who expect to only be offered
credentials that should succeed.
.PP
To mitigate this issue, \f[CR]signalUnknownCredential()\f[R] should be
called on the RP web app each time a discoverable credential\-based
sign\-in fails, to inform the authenticator that the credential ID was
not recognized.
.PP
It is up to the authenticator how to handle this information, but the
expectation is that it will delete the relevant credential so that there
is no mismatch in the data stored on the authenticator and relying
party.
.PP
In addition, \f[CR]signalUnknownCredential()\f[R] might also be called
if a web app is able to create a discoverable credential on the
authenticator but is, for any reason, unable to upload the credential
information to the server.
.PP
\f[CR]signalUnknownCredential()\f[R] can be called even when the current
user is not authenticated because it does not expose sensitive
information.
.SH EXAMPLES
.SS Signaling an unknown credential
In this example, a login attempt is made using discoverable credentials
via a \f[CR]get()\f[R] call.
The credential is returned successfully, and the credential ID and
payload are stored in constants.
.PP
The payload is sent to the RP server via a \f[CR]fetch()\f[R] request to
log the user in, but the request fails with a \f[CR]404\f[R] response
because the RP doesn\(cqt recognize that user (for example because that
credential was previously deleted from the RP).
.PP
As a result of this, we invoke the \f[CR]signalUnknownCredential()\f[R]
method, passing it the \f[CR]rpId\f[R] and credential ID, to inform the
authenticator that the credential is unknown to the RP.
The authenticator should then delete the credential so it does not cause
the same problem again.
.IP
.EX
\f[B]const\f[R] credential = \f[B]await\f[R] navigator.credentials.get({
  challenge: \f[B]new\f[R] Uint8Array([139, 66, 181, 87, 7, 203 \f[I]/* \&... */\f[R]]),
  rpId: \(dqexample.com\(dq,
  allowCredentials: [],
  \f[I]// Empty allowCredentials list means only discoverable\f[R]
  \f[I]// credentials are presented to the user\f[R]
});

\f[I]// Retrieve base64url\-encoded credential ID,\f[R]
\f[I]// such as \(dqvI0qOggiE3OT01ZRWBYz5l4MEgU0c7PmAA\(dq\f[R]
\f[B]const\f[R] credID = credential.id;
\f[I]// Retrieve payload to send to the RP server\f[R]
\f[B]const\f[R] payload = credential.toJSON();

\f[B]const\f[R] result = \f[B]await\f[R] fetch(\(dq/login\(dq, {
  \f[I]// fetch() options, will include the payload in the request body\f[R]
});

\f[I]// Detect authentication failure due to lack of the credential\f[R]
\f[B]if\f[R] (result.status === 404) {
  \f[B]if\f[R] (PublicKeyCredential.signalUnknownCredential) {
    \f[B]await\f[R] PublicKeyCredential.signalUnknownCredential({
      rpId: \(dqexample.com\(dq,
      credentialId: credID,
    });
  } \f[B]else\f[R] {
    \f[I]// Encourage the user to delete the credential from the authenticator\f[R]
  }
}
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]PublicKeyCredential.signalAllAcceptedCredentials()\f[R]
.IP \(bu 2
\f[CR]PublicKeyCredential.signalCurrentUserDetails()\f[R]
.IP \(bu 2
\c
.UR https://developer.chrome.com/docs/identity/webauthn-signal-api
Keep passkeys consistent with credentials on your server with the Signal
API
.UE \c
\ on developer.chrome.com (2024)
