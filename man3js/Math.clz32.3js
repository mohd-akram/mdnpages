.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Math.clz32" "JS" "April 12, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Math.clz32 \- Math.clz32()
.SH SYNOPSIS
The \f[B]\f[CB]Math.clz32()\f[B]\f[R] static method returns the number
of leading zero bits in the 32\-bit binary representation of a number.
.SH SYNTAX
.IP
.EX
Math.clz32(x)
.EE
.SS Parameters
.TP
\f[B]x\f[R]
A number.
.SS Return value
The number of leading zero bits in the 32\-bit binary representation of
\f[CR]x\f[R].
.SH DESCRIPTION
\f[CR]clz32\f[R] is short for
\f[B]C\f[R]ount\f[B]L\f[R]eading\f[B]Z\f[R]eros\f[B]32\f[R].
.PP
If \f[CR]x\f[R] is not a number, it will be converted to a number first,
then converted to a 32\-bit unsigned integer.
.PP
If the converted 32\-bit unsigned integer is \f[CR]0\f[R], \f[CR]32\f[R]
is returned, because all bits are \f[CR]0\f[R].
If the most significant bit is \f[CR]1\f[R] (i.e.\ the number is greater
than or equal to 231), \f[CR]0\f[R] is returned.
.PP
This function is particularly useful for systems that compile to JS,
like \c
.UR https://emscripten.org
Emscripten
.UE \c
\&.
.SH EXAMPLES
.SS Using Math.clz32()
.IP
.EX
Math.clz32(1); // 31
Math.clz32(1000); // 22
Math.clz32(); // 32

const stuff = [
  NaN,
  Infinity,
  \-Infinity,
  0,
  \-0,
  false,
  null,
  undefined,
  \[dq]foo\[dq],
  {},
  [],
];
stuff.every((n) => Math.clz32(n) === 32); // true

Math.clz32(true); // 31
Math.clz32(3.5); // 30
.EE
.SS Implementing Count Leading Ones and beyond
At present, there is no \f[CR]Math.clon\f[R] for \[lq]Count Leading
Ones\[rq] (named \[lq]clon\[rq], not \[lq]clo\[rq], because
\[lq]clo\[rq] and \[lq]clz\[rq] are too similar especially for
non\-English\-speaking people).
However, a \f[CR]clon\f[R] function can easily be created by inverting
the bits of a number and passing the result to \f[CR]Math.clz32\f[R].
Doing this will work because the inverse of 1 is 0 and vice versa.
Thus, inverting the bits will inverse the measured quantity of 0\[cq]s
(from \f[CR]Math.clz32\f[R]), thereby making \f[CR]Math.clz32\f[R] count
the number of ones instead of counting the number of zeros.
.PP
Consider the following 32\-bit word:
.IP
.EX
const a = 32776; // 00000000000000001000000000001000 (16 leading zeros)
Math.clz32(a); // 16

const b = \[ti]32776; // 11111111111111110111111111110111 (32776 inverted, 0 leading zeros)
Math.clz32(b); // 0 (this is equal to how many leading one\[aq]s there are in a)
.EE
.PP
Using this logic, a \f[CR]clon\f[R] function can be created as follows:
.IP
.EX
const clz = Math.clz32;

function clon(integer) {
  return clz(\[ti]integer);
}
.EE
.PP
Further, this technique could be extended to create a jumpless
\[lq]Count Trailing Zeros\[rq] function, as seen below.
The \f[CR]ctrz\f[R] function takes a bitwise AND of the integer with its
two\[cq]s complement.
By how two\[cq]s complement works, all trailing zeros will be converted
to ones, and then when adding 1, it would be carried over until the
first \f[CR]0\f[R] (which was originally a \f[CR]1\f[R]) is reached.
All bits higher than this one stay the same and are inverses of the
original integer\[cq]s bits.
Therefore, when doing bitwise AND with the original integer, all higher
bits become \f[CR]0\f[R], which can be counted with \f[CR]clz\f[R].
The number of trailing zeros, plus the first \f[CR]1\f[R] bit, plus the
leading bits that were counted by \f[CR]clz\f[R], total to 32.
.IP
.EX
function ctrz(integer) {
  integer >>>= 0; // coerce to Uint32
  if (integer === 0) {
    // skipping this step would make it return \-1
    return 32;
  }
  integer &= \-integer; // equivalent to \[ga]int = int & (\[ti]int + 1)\[ga]
  return 31 \- clz(integer);
}
.EE
.PP
Then we can define a \[lq]Count Trailing Ones\[rq] function like so:
.IP
.EX
function ctron(integer) {
  return ctrz(\[ti]integer);
}
.EE
.PP
These helper functions can be made into an asm.js module for a potential
performance improvement.
.IP
.EX
const countTrailsMethods = (function (stdlib, foreign, heap) {
  \[dq]use asm\[dq];
  const clz = stdlib.Math.clz32;

  // count trailing zeros
  function ctrz(integer) {
    integer = integer | 0; // coerce to an integer
    if ((integer | 0) == 0) {
      // skipping this step would make it return \-1
      return 32;
    }
    // Note: asm.js doesn\[aq]t have compound assignment operators such as &=
    integer = integer & \-integer; // equivalent to \[ga]int = int & (\[ti]int + 1)\[ga]
    return (31 \- clz(integer)) | 0;
  }

  // count trailing ones
  function ctron(integer) {
    integer = integer | 0; // coerce to an integer
    return ctrz(\[ti]integer) | 0;
  }

  // asm.js demands plain objects:
  return { ctrz: ctrz, ctron: ctron };
})(window, null, null);

const { ctrz, ctron } = countTrailsMethods;
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-math
Polyfill of \f[CR]Math.clz32\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Math\f[R]
.IP \[bu] 2
\f[CR]Math.imul\f[R]
