.\" Automatically generated by Pandoc 3.4
.\"
.TH "Math.clz32" "JS" "August 8, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Math.clz32 \- Math.clz32()
.SH SYNOPSIS
The \f[B]\f[CB]Math.clz32()\f[B]\f[R] static method returns the number
of leading zero bits in the 32\-bit binary representation of a number.
.SH SYNTAX
.IP
.EX
Math.clz32(x)
.EE
.SS Parameters
.TP
\f[B]x\f[R]
A number.
.SS Return value
The number of leading zero bits in the 32\-bit binary representation of
\f[CR]x\f[R].
.SH DESCRIPTION
\f[CR]clz32\f[R] is short for
\f[B]C\f[R]ount\f[B]L\f[R]eading\f[B]Z\f[R]eros\f[B]32\f[R].
.PP
If \f[CR]x\f[R] is not a number, it will be converted to a number first,
then converted to a 32\-bit unsigned integer.
.PP
If the converted 32\-bit unsigned integer is \f[CR]0\f[R], \f[CR]32\f[R]
is returned, because all bits are \f[CR]0\f[R].
If the most significant bit is \f[CR]1\f[R] (i.e.\ the number is greater
than or equal to 2\[ha]31), \f[CR]0\f[R] is returned.
.PP
This function is particularly useful for systems that compile to JS,
like \c
.UR https://emscripten.org/
Emscripten
.UE \c
\&.
.SH EXAMPLES
.SS Using Math.clz32()
.IP
.EX
Math.clz32(1); \f[I]// 31\f[R]
Math.clz32(1000); \f[I]// 22\f[R]
Math.clz32(); \f[I]// 32\f[R]

\f[B]const\f[R] stuff = [
  \f[B]NaN\f[R],
  \f[B]Infinity\f[R],
  \-\f[B]Infinity\f[R],
  0,
  \-0,
  \f[B]false\f[R],
  \f[B]null\f[R],
  \f[B]undefined\f[R],
  \[dq]foo\[dq],
  {},
  [],
];
stuff.every((n) \f[B]=>\f[R] Math.clz32(n) === 32); \f[I]// true\f[R]

Math.clz32(\f[B]true\f[R]); \f[I]// 31\f[R]
Math.clz32(3.5); \f[I]// 30\f[R]
.EE
.SS Implementing Count Leading Ones and beyond
At present, there is no \f[CR]Math.clon\f[R] for \[lq]Count Leading
Ones\[rq] (named \[lq]clon\[rq], not \[lq]clo\[rq], because
\[lq]clo\[rq] and \[lq]clz\[rq] are too similar especially for
non\-English\-speaking people).
However, a \f[CR]clon\f[R] function can easily be created by inverting
the bits of a number and passing the result to \f[CR]Math.clz32\f[R].
Doing this will work because the inverse of 1 is 0 and vice versa.
Thus, inverting the bits will inverse the measured quantity of 0\[cq]s
(from \f[CR]Math.clz32\f[R]), thereby making \f[CR]Math.clz32\f[R] count
the number of ones instead of counting the number of zeros.
.PP
Consider the following 32\-bit word:
.IP
.EX
\f[B]const\f[R] a = 32776; \f[I]// 00000000000000001000000000001000 (16 leading zeros)\f[R]
Math.clz32(a); \f[I]// 16\f[R]

\f[B]const\f[R] b = \[ti]32776; \f[I]// 11111111111111110111111111110111 (32776 inverted, 0 leading zeros)\f[R]
Math.clz32(b); \f[I]// 0 (this is equal to how many leading one\[aq]s there are in a)\f[R]
.EE
.PP
Using this logic, a \f[CR]clon\f[R] function can be created as follows:
.IP
.EX
\f[B]const\f[R] clz = Math.clz32;

\f[B]function\f[R] clon(integer) {
  \f[B]return\f[R] clz(\[ti]integer);
}
.EE
.PP
Further, this technique could be extended to create a jumpless
\[lq]Count Trailing Zeros\[rq] function, as seen below.
The \f[CR]ctrz\f[R] function takes a bitwise AND of the integer with its
two\[cq]s complement.
By how two\[cq]s complement works, all trailing zeros will be converted
to ones, and then when adding 1, it would be carried over until the
first \f[CR]0\f[R] (which was originally a \f[CR]1\f[R]) is reached.
All bits higher than this one stay the same and are inverses of the
original integer\[cq]s bits.
Therefore, when doing bitwise AND with the original integer, all higher
bits become \f[CR]0\f[R], which can be counted with \f[CR]clz\f[R].
The number of trailing zeros, plus the first \f[CR]1\f[R] bit, plus the
leading bits that were counted by \f[CR]clz\f[R], total to 32.
.IP
.EX
\f[B]function\f[R] ctrz(integer) {
  integer >>>= 0; \f[I]// coerce to Uint32\f[R]
  \f[B]if\f[R] (integer === 0) {
    \f[I]// skipping this step would make it return \-1\f[R]
    \f[B]return\f[R] 32;
  }
  integer &= \-integer; \f[I]// equivalent to \[ga]int = int & (\[ti]int + 1)\[ga]\f[R]
  \f[B]return\f[R] 31 \- clz(integer);
}
.EE
.PP
Then we can define a \[lq]Count Trailing Ones\[rq] function like so:
.IP
.EX
\f[B]function\f[R] ctron(integer) {
  \f[B]return\f[R] ctrz(\[ti]integer);
}
.EE
.PP
These helper functions can be made into an asm.js module for a potential
performance improvement.
.IP
.EX
\f[B]const\f[R] countTrailsMethods = (\f[B]function\f[R] (stdlib, foreign, heap) {
  \[dq]use asm\[dq];
  \f[B]const\f[R] clz = stdlib.Math.clz32;

  \f[I]// count trailing zeros\f[R]
  \f[B]function\f[R] ctrz(integer) {
    integer = integer | 0; \f[I]// coerce to an integer\f[R]
    \f[B]if\f[R] ((integer | 0) == 0) {
      \f[I]// skipping this step would make it return \-1\f[R]
      \f[B]return\f[R] 32;
    }
    \f[I]// Note: asm.js doesn\[aq]t have compound assignment operators such as &=\f[R]
    integer = integer & \-integer; \f[I]// equivalent to \[ga]int = int & (\[ti]int + 1)\[ga]\f[R]
    \f[B]return\f[R] (31 \- clz(integer)) | 0;
  }

  \f[I]// count trailing ones\f[R]
  \f[B]function\f[R] ctron(integer) {
    integer = integer | 0; \f[I]// coerce to an integer\f[R]
    \f[B]return\f[R] ctrz(\[ti]integer) | 0;
  }

  \f[I]// asm.js demands plain objects:\f[R]
  \f[B]return\f[R] { ctrz: ctrz, ctron: ctron };
})(window, \f[B]null\f[R], \f[B]null\f[R]);

\f[B]const\f[R] { ctrz, ctron } = countTrailsMethods;
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-math
Polyfill of \f[CR]Math.clz32\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Math\f[R]
.IP \[bu] 2
\f[CR]Math.imul\f[R]
