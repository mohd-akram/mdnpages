'\" t
.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "MATH.ATAN2" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Math.atan2 \- Math.atan2()
.SH SYNOPSIS
The \f[B]\f[CB]Math.atan2()\f[B]\f[R] static method returns the angle in
the plane (in radians) between the positive x\-axis and the ray from (0,
0) to the point (x, y), for \f[CR]Math.atan2(y, x)\f[R].
.IP
.EX
\f[B]function\f[R] calcAngleDegrees(x, y) {
  \f[B]return\f[R] (Math.atan2(y, x) * 180) / Math.PI;
}

console.log(calcAngleDegrees(5, 5));
\f[I]// Expected output: 45\f[R]

console.log(calcAngleDegrees(10, 10));
\f[I]// Expected output: 45\f[R]

console.log(calcAngleDegrees(0, 10));
\f[I]// Expected output: 90\f[R]
.EE
.SH SYNTAX
.IP
.EX
Math.atan2(y, x)
.EE
.SS Parameters
.TP
\f[B]y\f[R]
The y coordinate of the point.
.TP
\f[B]x\f[R]
The x coordinate of the point.
.SS Return value
The angle in radians (between \-π and π, inclusive) between the positive
x\-axis and the ray from (0, 0) to the point (x, y).
.SH DESCRIPTION
The \f[CR]Math.atan2()\f[R] method measures the counterclockwise angle
θ, in radians, between the positive x\-axis and the point
\f[CR](x, y)\f[R].
Note that the arguments to this function pass the y\-coordinate first
and the x\-coordinate second.
[IMAGE: A diagram showing the angle returned by atan2(y, x)]
A diagram showing the angle returned by atan2(y, x)
.PP
\f[CR]Math.atan2()\f[R] is passed separate \f[CR]x\f[R] and \f[CR]y\f[R]
arguments, while \f[CR]Math.atan()\f[R] is passed the ratio of those two
arguments.
\f[CR]Math.atan2(y, x)\f[R] differs from \f[CR]Math.atan(y / x)\f[R] in
the following cases:
.PP
.TS
tab(@);
lw(20.9n) lw(11.5n) lw(18.8n) lw(18.8n).
T{
\f[CR]x\f[R]
T}@T{
\f[CR]y\f[R]
T}@T{
\f[CR]Math.atan2(y, x)\f[R]
T}@T{
\f[CR]Math.atan(y / x)\f[R]
T}
_
T{
\f[CR]Infinity\f[R]
T}@T{
\f[CR]Infinity\f[R]
T}@T{
π / 4
T}@T{
\f[CR]NaN\f[R]
T}
T{
\f[CR]Infinity\f[R]
T}@T{
\f[CR]\-Infinity\f[R]
T}@T{
\-π / 4
T}@T{
\f[CR]NaN\f[R]
T}
T{
\f[CR]\-Infinity\f[R]
T}@T{
\f[CR]Infinity\f[R]
T}@T{
3π / 4
T}@T{
\f[CR]NaN\f[R]
T}
T{
\f[CR]\-Infinity\f[R]
T}@T{
\f[CR]\-Infinity\f[R]
T}@T{
\-3π / 4
T}@T{
\f[CR]NaN\f[R]
T}
T{
0
T}@T{
0
T}@T{
0
T}@T{
\f[CR]NaN\f[R]
T}
T{
0
T}@T{
\-0
T}@T{
\-0
T}@T{
\f[CR]NaN\f[R]
T}
T{
< 0 (including \f[CR]\-0\f[R])
T}@T{
0
T}@T{
π
T}@T{
0
T}
T{
< 0 (including \f[CR]\-0\f[R])
T}@T{
\-0
T}@T{
\-π
T}@T{
0
T}
T{
\f[CR]\-Infinity\f[R]
T}@T{
> 0
T}@T{
π
T}@T{
\-0
T}
T{
\-0
T}@T{
> 0
T}@T{
π / 2
T}@T{
\-π / 2
T}
T{
\f[CR]\-Infinity\f[R]
T}@T{
< 0
T}@T{
\-π
T}@T{
0
T}
T{
\-0
T}@T{
< 0
T}@T{
\-π / 2
T}@T{
π / 2
T}
.TE
.PP
In addition, for points in the second and third quadrants
(\f[CR]x < 0\f[R]), \f[CR]Math.atan2()\f[R] would output an angle less
than \-π2\- or greater than π2.
.PP
Because \f[CR]atan2()\f[R] is a static method of \f[CR]Math\f[R], you
always use it as \f[CR]Math.atan2()\f[R], rather than as a method of a
\f[CR]Math\f[R] object you created (\f[CR]Math\f[R] is not a
constructor).
.SH EXAMPLES
.SS Using Math.atan2()
.IP
.EX
Math.atan2(90, 15); \f[I]// 1.4056476493802699\f[R]
Math.atan2(15, 90); \f[I]// 0.16514867741462683\f[R]
.EE
.SS Difference between Math.atan2(y, x) and Math.atan(y / x)
The following script prints all inputs that produce a difference between
\f[CR]Math.atan2(y, x)\f[R] and \f[CR]Math.atan(y / x)\f[R].
.IP
.EX
\f[B]const\f[R] formattedNumbers = \f[B]new\f[R] Map([
  [\-Math.PI, \(dq\-π\(dq],
  [(\-3 * Math.PI) / 4, \(dq\-3π/4\(dq],
  [\-Math.PI / 2, \(dq\-π/2\(dq],
  [\-Math.PI / 4, \(dq\-π/4\(dq],
  [Math.PI / 4, \(dqπ/4\(dq],
  [Math.PI / 2, \(dqπ/2\(dq],
  [(3 * Math.PI) / 4, \(dq3π/4\(dq],
  [Math.PI, \(dqπ\(dq],
  [\-\f[B]Infinity\f[R], \(dq\-∞\(dq],
  [\f[B]Infinity\f[R], \(dq∞\(dq],
]);

\f[B]function\f[R] format(template, ...args) {
  \f[B]return\f[R] String.raw(
    { raw: template },
    ...args.map((num) \f[B]=>\f[R]
      (Object.is(num, \-0)
        ? \(dq\-0\(dq
        : (formattedNumbers.get(num) ?? String(num))
      ).padEnd(5),
    ),
  );
}

console.log(\(ga| x     | y     | atan2 | atan  |
|\-\-\-\-\-\-\-|\-\-\-\-\-\-\-|\-\-\-\-\-\-\-|\-\-\-\-\-\-\-|\(ga);

\f[B]for\f[R] (\f[B]const\f[R] x \f[B]of\f[R] [\-\f[B]Infinity\f[R], \-1, \-0, 0, 1, \f[B]Infinity\f[R]]) {
  \f[B]for\f[R] (\f[B]const\f[R] y \f[B]of\f[R] [\-\f[B]Infinity\f[R], \-1, \-0, 0, 1, \f[B]Infinity\f[R]]) {
    \f[B]const\f[R] atan2 = Math.atan2(y, x);
    \f[B]const\f[R] atan = Math.atan(y / x);
    \f[B]if\f[R] (!Object.is(atan2, atan)) {
      console.log(format\(ga| ${x} | ${y} | ${atan2} | ${atan} |\(ga);
    }
  }
}
.EE
.PP
The output is:
.IP
.EX
| x     | y     | atan2 | atan  |
|\-\-\-\-\-\-\-|\-\-\-\-\-\-\-|\-\-\-\-\-\-\-|\-\-\-\-\-\-\-|
| \-∞    | \-∞    | \-3π/4 | NaN   |
| \-∞    | \-1    | \-π    | 0     |
| \-∞    | \-0    | \-π    | 0     |
| \-∞    | 0     | π     | \-0    |
| \-∞    | 1     | π     | \-0    |
| \-∞    | ∞     | 3π/4  | NaN   |
| \-1    | \-∞    | \-π/2  | π/2   |
| \-1    | \-1    | \-3π/4 | π/4   |
| \-1    | \-0    | \-π    | 0     |
| \-1    | 0     | π     | \-0    |
| \-1    | 1     | 3π/4  | \-π/4  |
| \-1    | ∞     | π/2   | \-π/2  |
| \-0    | \-∞    | \-π/2  | π/2   |
| \-0    | \-1    | \-π/2  | π/2   |
| \-0    | \-0    | \-π    | NaN   |
| \-0    | 0     | π     | NaN   |
| \-0    | 1     | π/2   | \-π/2  |
| \-0    | ∞     | π/2   | \-π/2  |
| 0     | \-0    | \-0    | NaN   |
| 0     | 0     | 0     | NaN   |
| ∞     | \-∞    | \-π/4  | NaN   |
| ∞     | ∞     | π/4   | NaN   |
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Math.acos()\f[R]
.IP \(bu 2
\f[CR]Math.asin()\f[R]
.IP \(bu 2
\f[CR]Math.atan()\f[R]
.IP \(bu 2
\f[CR]Math.cos()\f[R]
.IP \(bu 2
\f[CR]Math.sin()\f[R]
.IP \(bu 2
\f[CR]Math.tan()\f[R]
