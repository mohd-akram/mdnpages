.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "SELECTION.GETCOMPOSEDRANGES" "3JS" "May 24, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Selection.getComposedRanges \- Selection: getComposedRanges() method
.SH SYNOPSIS
The \f[B]\f[CB]Selection.getComposedRanges()\f[B]\f[R] method returns an
array of \f[CR]StaticRange\f[R] objects representing the current
selection ranges, and can return ranges that potentially cross shadow
boundaries.
.PP
As the selection range endpoints may be within a shadow tree, or even
different shadow trees, and because these may be closed, the method
cannot by default return nodes from within a shadow tree.
If the method needs to return a selection that includes nodes inside
shadow trees, then the \f[CR]ShadowRoot\f[R] objects for these trees
must be passed as arguments to the method.
If a corresponding roots are not provided and the start or endpoint of
the selection are within a shadow tree, the returned range is re\-scoped
to include the host of the shadow root rather than some node with in the
root.
.PP
The returned ranges represent the range at the time that
\f[CR]getComposedRanges()\f[R] was called.
If the DOM or a shadow DOM is mutated, the selected range is likely to
be incorrect.
Application code might use a \f[CR]MutationObserver\f[R] to monitor for
DOM mutations and then call \f[CR]Selection.setBaseAndExtent()\f[R] to
update the selection.
.RS
.PP
\f[B]Note:\f[R] This method should be used instead of
\f[CR]Selection.getRangeAt()\f[R] when selecting ranges that can
potentially cross shadow root boundaries.
\f[CR]Selection.getRangeAt()\f[R] is not aware of shadow roots.
The returned range is not specified, and varies between browsers.
.RE
.SH SYNTAX
.IP
.EX
getComposedRanges()
getComposedRanges(options)
.EE
.SS Parameters
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object with the following properties, all optional:
.RS
.TP
\f[B]shadowRoots\f[R] \f[I](optional)\f[R]
An array of \f[CR]ShadowRoot\f[R] objects.
If a selection endpoint is within one of the provided shadow roots, the
range will be able to return nodes within its corresponding Shadow DOM
tree.
Otherwise, if the selection crosses a shadow boundary and the
corresponding \f[CR]ShadowRoot\f[R] is not provided, the returned range
will be adjusted to include the entire host element for the shadow root.
.RE
.RS
.PP
\f[B]Note:\f[R] In the original specification, shadow roots were
specified as a set of rest parameters.
Some browsers may still support this legacy syntax.
.RE
.SS Return value
An array of \f[CR]StaticRange\f[R] objects that represent the selected
ranges within the composed (flattened) tree of the document.
At time of writing the specification expects this array to only contain
one object.
.SH EXAMPLES
.SS Selecting across inline shadow roots
This example demonstrates how \f[CR]getComposedRanges()\f[R] behaves,
both when shadow roots are passed and when they are not, and contrasts
with \f[CR]Selection.getRangeAt()\f[R].
.PP
It allows you to select text that is defined in different nodes in the
DOM, and in open and closed shadow roots, copy the range for the
selection using the different approaches, and then reapply the range to
see how well the original selection worked.
.SS HTML
The HTML defines some text nodes with some \f[CR]<span>\f[R] elements to
which we\(cqll attach a shadow root using JavaScript.
We also add some buttons for copying and applying the selection using a
number of different methods.
.IP
.EX
<\f[B]p\f[R]>
  DOM Text One<\f[B]span\f[R] id=\(dqopenHost\(dq></\f[B]span\f[R]>DOM Text Two<\f[B]span\f[R]
    id=\(dqclosedHost\(dq></\f[B]span\f[R]
  >DOM Text Three
</\f[B]p\f[R]>
.EE
.IP
.EX
<\f[B]button\f[R] id=\(dqcopySelection\(dq>Copy range not passing shadow roots</\f[B]button\f[R]>
<\f[B]button\f[R] id=\(dqcopySelectionWithShadowRoots\(dq>
  Copy range passing shadow roots
</\f[B]button\f[R]>
<\f[B]button\f[R] id=\(dqapplySelection\(dq>Apply selection</\f[B]button\f[R]>
<\f[B]hr\f[R] />
<\f[B]button\f[R] id=\(dqcopySelectionRangeAt\(dq>Copy range with getRangeAt()</\f[B]button\f[R]>
<\f[B]button\f[R] id=\(dqapplySelectionGetRangeAt\(dq>Apply selection</\f[B]button\f[R]>
.EE
.SS CSS
The CSS doesn\(cqt do anything interesting.
We\(cqre just laying out the buttons vertically so that they are easier
to read.
.IP
.EX
button {
  \f[B]display\f[R]: block;
}
.EE
.SS JavaScript
Most of the work happens in the JavaScript.
First we log if the \f[CR]getComposedRanges()\f[R] is not supported,
though we don\(cqt actually prevent the rest of the example attempting
to use it.
.IP
.EX
\f[B]if\f[R] (!(\(dqgetComposedRanges\(dq \f[B]in\f[R] Selection.prototype)) {
  log(\(dqgetComposedRanges() method not supported in this browser\(dq);
}
.EE
.PP
Then we create an open and a closed shadow root and attach them to the
two \f[CR]<span>\f[R] elements we created in the HTML.
These contain some simple text in bold so that we can easily identify
the shadow nodes when the HTML is rendered.
.IP
.EX
\f[B]let\f[R] openRoot = openHost.attachShadow({ mode: \(dqopen\(dq });
openRoot.innerHTML = \(ga<b>Open Shadow DOM Text</b>\(ga;

\f[B]let\f[R] closedRoot = closedHost.attachShadow({ mode: \(dqclosed\(dq });
closedRoot.innerHTML = \(ga<b>Closed Shadow DOM Text</b>\(ga;
.EE
.PP
Next we create code to get the selected ranges with
\f[CR]getComposedRanges()\f[R] when the first two buttons are clicked.
The first button calls \f[CR]getComposedRanges()\f[R] without passing
shadow roots, while the second passes both of the shadow roots.
In both cases the composed range is saved to a variable.
.IP
.EX
\f[B]const\f[R] copySelectionButton = document.querySelector(\(dq#copySelection\(dq);
\f[B]let\f[R] composedRangeSelection = \f[B]null\f[R];
copySelectionButton.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
  composedRangeSelection = window.getSelection().getComposedRanges()[0];
  log(\(gaSelection copied (no shadow roots passed)\(ga);
});

\f[B]const\f[R] copySelectionWithShadowRootsButton = document.querySelector(
  \(dq#copySelectionWithShadowRoots\(dq,
);
copySelectionWithShadowRootsButton.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
  composedRangeSelection = window
    .getSelection()
    .getComposedRanges({ shadowRoots: [openRoot, closedRoot] })[0];
  log(\(gaSelection has been copied (shadow roots passed)\(ga);
});
.EE
.PP
The handler for the \(lqApply selection\(rq button is shown below.
This calls \f[CR]setBaseAndExtent()\f[R] to set the current selection,
passing the nodes and offsets from the saved range.
.IP
.EX
\f[B]const\f[R] applySelectionButton = document.querySelector(\(dq#applySelection\(dq);
applySelectionButton.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
  \f[B]if\f[R] (composedRangeSelection) {
    window
      .getSelection()
      .setBaseAndExtent(
        composedRangeSelection.startContainer,
        composedRangeSelection.startOffset,
        composedRangeSelection.endContainer,
        composedRangeSelection.endOffset,
      );
    log(\(gaSelection applied\(ga);
  } \f[B]else\f[R] {
    log(\(gaNo selection to apply\(ga);
  }
});
.EE
.PP
The last part of the code defines buttons to copy the current selection
range using \f[CR]Selection.getRangeAt()\f[R] and then reapply the
selection.
.IP
.EX
\f[B]const\f[R] copySelectionRangeAtButton = document.querySelector(
  \(dq#copySelectionRangeAt\(dq,
);
\f[B]let\f[R] rangeSelection = \f[B]null\f[R];
copySelectionRangeAtButton.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
  \f[B]const\f[R] selection = window.getSelection();
  \f[B]if\f[R] (selection.rangeCount > 0) {
    log(\(gaSelection copied using getRangeAt()\(ga);
    rangeSelection = selection.getRangeAt(0);
  } \f[B]else\f[R] {
    log(\(gaNo range selected\(ga);
  }
});

\f[B]const\f[R] applySelectionGetRangeAtButton = document.querySelector(
  \(dq#applySelectionGetRangeAt\(dq,
);
applySelectionGetRangeAtButton.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
  \f[B]if\f[R] (rangeSelection) {
    window
      .getSelection()
      .setBaseAndExtent(
        rangeSelection.startContainer,
        rangeSelection.startOffset,
        rangeSelection.endContainer,
        rangeSelection.endOffset,
      );
    log(\(gaSelection applied\(ga);
  } \f[B]else\f[R] {
    log(\(gaNo selection to apply\(ga);
  }
});
.EE
.SS Results
The running example is shown below.
Select text in the top line starting from some normal text and ending in
a bold section so that you have selected nodes from the DOM into a
shadow root.
If you select \(lqCopy range passing shadow roots\(rq and then the
\(lqApply selection\(rq button, you will note that the selection
doesn\(cqt change, because the code has given access to all the nodes in
the shadow root, even if it is closed.
If you then select the button \(lqCopy range not passing shadow
roots\(rq and then apply, the selection will extend to the end of the
text in the shadow root.
This is because the selection is re\-scoped to the end of the host node,
since the \f[CR]getComposedRanges()\f[R] method was not given visibility
inside the shadow tree.
.PP
Also test what happens if you use the \(lqCopy range with
getRangeAt()\(rq and \(lqApply selection\(rq buttons.
You should find that the selected range is fairly arbitrary if you cross
into the shadow root, and differs depending on what browser you are
using.
.SH SEE ALSO
.IP \(bu 2
\f[CR]Selection\f[R], the interface it belongs to.
