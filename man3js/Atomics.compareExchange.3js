.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Atomics.compareExchange" "JS" "June 17, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Atomics.compareExchange \- Atomics.compareExchange()
.SH SYNOPSIS
The \f[B]\f[CB]Atomics.compareExchange()\f[B]\f[R] static method
exchanges a given replacement value at a given position in the array, if
a given expected value equals the old value.
It returns the old value at that position whether it was equal to the
expected value or not.
This atomic operation guarantees that no other write happens until the
modified value is written back.
.SH SYNTAX
.IP
.EX
Atomics.compareExchange(typedArray, index, expectedValue, replacementValue)
.EE
.SS Parameters
.TP
\f[B]typedArray\f[R]
An integer typed array.
One of \f[CR]Int8Array\f[R], \f[CR]Uint8Array\f[R],
\f[CR]Int16Array\f[R], \f[CR]Uint16Array\f[R], \f[CR]Int32Array\f[R],
\f[CR]Uint32Array\f[R], \f[CR]BigInt64Array\f[R], or
\f[CR]BigUint64Array\f[R].
.TP
\f[B]index\f[R]
The position in the \f[CR]typedArray\f[R] to exchange a
\f[CR]replacementValue\f[R].
.TP
\f[B]expectedValue\f[R]
The value to check for equality.
.TP
\f[B]replacementValue\f[R]
The number to exchange.
.SS Return value
The old value at the given position (\f[CR]typedArray[index]\f[R]).
If the return value is equal to \f[CR]expectedValue\f[R], the exchange
was successful; otherwise, the exchange failed.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if \f[CR]typedArray\f[R] is not one of the allowed integer types.
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]index\f[R] is out of bounds in the
\f[CR]typedArray\f[R].
.SH EXAMPLES
.SS Using compareExchange()
.IP
.EX
\f[B]const\f[R] sab = \f[B]new\f[R] SharedArrayBuffer(1024);
\f[B]const\f[R] ta = \f[B]new\f[R] Uint8Array(sab);
ta[0] = 7;

Atomics.compareExchange(ta, 0, 7, 12); \f[I]// returns 7, the old value\f[R]
Atomics.load(ta, 0); \f[I]// 12\f[R]
.EE
.SS Checking the return value
\c
.UR https://en.wikipedia.org/wiki/Compare-and-swap
Compare\-and\-swap
.UE \c
\ guarantees that the new value is calculated based on up\-to\-date
information; if the value had been updated by another thread in the
meantime, the write would fail.
Therefore, you should check the return value of
\f[CR]compareExchange()\f[R] to check if it has failed, and retry if
necessary.
.PP
Here is one example of an atomic adder (same functionality as
\f[CR]Atomics.add()\f[R]), adapted from the linked Wikipedia article:
.IP
.EX
\f[B]function\f[R] add(mem, index, value) {
  \f[B]let\f[R] done = \f[B]false\f[R];
  \f[B]while\f[R] (!done) {
    \f[B]const\f[R] value = Atomics.load(mem, index);
    done = Atomics.compareExchange(p, value, value + a) === value;
  }
  \f[B]return\f[R] value + a;
}
.EE
.PP
It first reads the value at the given index, then tries to update it
with the new value.
It keeps retrying until it successfully updates the value.
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Atomics\f[R]
.IP \[bu] 2
\f[CR]Atomics.exchange()\f[R]
