'\" t
.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPUSUPPORTEDLIMITS" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPUSupportedLimits \- GPUSupportedLimits
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]GPUSupportedLimits\f[B]\f[R] interface of the WebGPU API
describes the limits supported by a \f[CR]GPUAdapter\f[R].
.PP
The \f[CR]GPUSupportedLimits\f[R] object for the current adapter is
accessed via the \f[CR]GPUAdapter.limits\f[R] property.
.PP
You should note that, rather than reporting the exact limits of each
GPU, browsers will likely report different tier values of different
limits to reduce the unique information available to drive\-by
fingerprinting.
For example, the tiers of a certain limit might be 2048, 8192, and
32768.
If your GPU\(cqs actual limit is 16384, the browser will still report
8192.
.PP
Given that different browsers will handle this differently and the tier
values may change over time, it is hard to provide an accurate account
of what limit values to expect \(em thorough testing is advised.
.SH INSTANCE PROPERTIES
The following limits are represented by properties in a
\f[CR]GPUSupportedLimits\f[R] object.
See the \c
.UR https://gpuweb.github.io/gpuweb/#limits
Limits
.UE \c
\ section of the specification for detailed descriptions of what the
limits relate to.
.PP
.TS
tab(@);
lw(64.1n) lw(5.9n).
T{
Limit name
T}@T{
Default value
T}
_
T{
\f[CR]maxTextureDimension1D\f[R]
T}@T{
8192
T}
T{
\f[CR]maxTextureDimension2D\f[R]
T}@T{
8192
T}
T{
\f[CR]maxTextureDimension3D\f[R]
T}@T{
2048
T}
T{
\f[CR]maxTextureArrayLayers\f[R]
T}@T{
256
T}
T{
\f[CR]maxBindGroups\f[R]
T}@T{
4
T}
T{
\f[CR]maxBindingsPerBindGroup\f[R]
T}@T{
640
T}
T{
\f[CR]maxDynamicUniformBuffersPerPipelineLayout\f[R]
T}@T{
8
T}
T{
\f[CR]maxDynamicStorageBuffersPerPipelineLayout\f[R]
T}@T{
4
T}
T{
\f[CR]maxSampledTexturesPerShaderStage\f[R]
T}@T{
16
T}
T{
\f[CR]maxSamplersPerShaderStage\f[R]
T}@T{
16
T}
T{
\f[CR]maxStorageBuffersPerShaderStage\f[R]
T}@T{
8
T}
T{
\f[CR]maxStorageTexturesPerShaderStage\f[R]
T}@T{
4
T}
T{
\f[CR]maxUniformBuffersPerShaderStage\f[R]
T}@T{
12
T}
T{
\f[CR]maxUniformBufferBindingSize\f[R]
T}@T{
65536 bytes
T}
T{
\f[CR]maxStorageBufferBindingSize\f[R]
T}@T{
134217728 bytes (128 MB)
T}
T{
\f[CR]minUniformBufferOffsetAlignment\f[R]
T}@T{
256 bytes
T}
T{
\f[CR]minStorageBufferOffsetAlignment\f[R]
T}@T{
256 bytes
T}
T{
\f[CR]maxVertexBuffers\f[R]
T}@T{
8
T}
T{
\f[CR]maxBufferSize\f[R]
T}@T{
268435456 bytes (256 MB)
T}
T{
\f[CR]maxVertexAttributes\f[R]
T}@T{
16
T}
T{
\f[CR]maxVertexBufferArrayStride\f[R]
T}@T{
2048 bytes
T}
T{
\f[CR]maxInterStageShaderComponents\f[R] \f[I](deprecated)\f[R]
\f[I](non\-standard)\f[R] (use \f[CR]maxInterStageShaderVariables\f[R]
instead, see \c
.UR https://developer.chrome.com/blog/new-in-webgpu-133#deprecate_maxinterstageshadercomponents_limit
deprecation notice
.UE \c
\ for more info)
T}@T{
60
T}
T{
\f[CR]maxInterStageShaderVariables\f[R]
T}@T{
16
T}
T{
\f[CR]maxColorAttachments\f[R]
T}@T{
8
T}
T{
\f[CR]maxColorAttachmentBytesPerSample\f[R]
T}@T{
32
T}
T{
\f[CR]maxComputeWorkgroupStorageSize\f[R]
T}@T{
16384 bytes
T}
T{
\f[CR]maxComputeInvocationsPerWorkgroup\f[R]
T}@T{
256
T}
T{
\f[CR]maxComputeWorkgroupSizeX\f[R]
T}@T{
256
T}
T{
\f[CR]maxComputeWorkgroupSizeY\f[R]
T}@T{
256
T}
T{
\f[CR]maxComputeWorkgroupSizeZ\f[R]
T}@T{
64
T}
T{
\f[CR]maxComputeWorkgroupsPerDimension\f[R]
T}@T{
65535
T}
.TE
.SH EXAMPLES
In the following code we query the \f[CR]GPUAdapter.limits\f[R] value of
\f[CR]maxBindGroups\f[R] to see if it is equal to or greater than 6.
Our theoretical example app ideally needs 6 bind groups, so if the
returned value is >= 6, we add a maximum limit of 6 to the
\f[CR]requiredLimits\f[R] object.
We then request a device with that limit requirement using
\f[CR]GPUAdapter.requestDevice()\f[R]:
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] init() {
  \f[B]if\f[R] (!navigator.gpu) {
    \f[B]throw\f[R] Error(\(dqWebGPU not supported.\(dq);
  }

  \f[B]const\f[R] adapter = \f[B]await\f[R] navigator.gpu.requestAdapter();
  \f[B]if\f[R] (!adapter) {
    \f[B]throw\f[R] Error(\(dqCouldn\(aqt request WebGPU adapter.\(dq);
  }

  \f[B]const\f[R] requiredLimits = {};

  \f[I]// App ideally needs 6 bind groups, so we\(aqll try to request what the app needs\f[R]
  \f[B]if\f[R] (adapter.limits.maxBindGroups >= 6) {
    requiredLimits.maxBindGroups = 6;
  }

  \f[B]const\f[R] device = \f[B]await\f[R] adapter.requestDevice({
    requiredLimits,
  });

  \f[I]// \&...\f[R]
}
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
