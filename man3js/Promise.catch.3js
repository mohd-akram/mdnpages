.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Promise.catch" "JS" "December 29, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Promise.catch \- Promise.prototype.catch()
.SH SYNOPSIS
The \f[B]\f[CB]catch()\f[B]\f[R] method of \f[CR]Promise\f[R] instances
schedules a function to be called when the promise is rejected.
It immediately returns an equivalent \f[CR]Promise\f[R] object, allowing
you to chain calls to other promise methods.
It is a shortcut for
\f[CR]Promise.prototype.then(undefined, onRejected)\f[R].
.SH SYNTAX
.IP
.EX
promiseInstance.catch(onRejected)
.EE
.SS Parameters
.TP
\f[B]onRejected\f[R]
A function to asynchronously execute when this promise becomes rejected.
Its return value becomes the fulfillment value of the promise returned
by \f[CR]catch()\f[R].
The function is called with the following arguments:
.RS
.TP
\f[B]reason\f[R]
The value that the promise was rejected with.
.RE
.SS Return value
Returns a new \f[CR]Promise\f[R].
This new promise is always pending when returned, regardless of the
current promise\[cq]s status.
If \f[CR]onRejected\f[R] is called, the returned promise will resolve
based on the return value of this call, or reject with the thrown error
from this call.
If the current promise fulfills, \f[CR]onRejected\f[R] is not called and
the returned promise fulfills to the same value.
.SH DESCRIPTION
The \f[CR]catch\f[R] method is used for error handling in promise
composition.
Since it returns a \f[CR]Promise\f[R], it can be chained in the same way
as its sister method, \f[CR]then()\f[R].
.PP
If a promise becomes rejected, and there are no rejection handlers to
call (a handler can be attached through any of \f[CR]then()\f[R],
\f[CR]catch()\f[R], or \f[CR]finally()\f[R]), then the rejection event
is surfaced by the host.
In the browser, this results in an \f[CR]unhandledrejection\f[R] event.
If a handler is attached to a rejected promise whose rejection has
already caused an unhandled rejection event, then another
\f[CR]rejectionhandled\f[R] event is fired.
.PP
\f[CR]catch()\f[R] internally calls \f[CR]then()\f[R] on the object upon
which it was called, passing \f[CR]undefined\f[R] and
\f[CR]onRejected\f[R] as arguments.
The value of that call is directly returned.
This is observable if you wrap the methods.
.IP
.EX
\f[I]// overriding original Promise.prototype.then/catch just to add some logs\f[R]
((Promise) \f[B]=>\f[R] {
  \f[B]const\f[R] originalThen = Promise.prototype.then;
  \f[B]const\f[R] originalCatch = Promise.prototype.catch;

  Promise.prototype.then = \f[B]function\f[R] (...args) {
    console.log(\[dq]Called .then on %o with arguments: %o\[dq], \f[B]this\f[R], args);
    \f[B]return\f[R] originalThen.apply(\f[B]this\f[R], args);
  };
  Promise.prototype.catch = \f[B]function\f[R] (...args) {
    console.error(\[dq]Called .catch on %o with arguments: %o\[dq], \f[B]this\f[R], args);
    \f[B]return\f[R] originalCatch.apply(\f[B]this\f[R], args);
  };
})(Promise);

\f[I]// calling catch on an already resolved promise\f[R]
Promise.resolve().catch(\f[B]function\f[R] XXX() {});

\f[I]// Logs:\f[R]
\f[I]// Called .catch on Promise{} with arguments: Arguments{1} [0: function XXX()]\f[R]
\f[I]// Called .then on Promise{} with arguments: Arguments{2} [0: undefined, 1: function XXX()]\f[R]
.EE
.PP
This means that passing \f[CR]undefined\f[R] still causes the returned
promise to be rejected, and you have to pass a function to prevent the
final promise from being rejected.
.PP
Because \f[CR]catch()\f[R] just calls \f[CR]then()\f[R], it supports
subclassing.
.RS
.PP
\f[B]Note:\f[R] The examples below are throwing instances of
\f[CR]Error\f[R].
As with synchronous \f[CR]throw\f[R] statements, this is considered a
good practice; otherwise, the part doing the catching would have to
perform checks to see if the argument was a string or an error, and you
might lose valuable information such as stack traces.
.RE
.SH EXAMPLES
.SS Using and chaining the catch() method
.IP
.EX
\f[B]const\f[R] p1 = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  resolve(\[dq]Success\[dq]);
});

p1.then((value) \f[B]=>\f[R] {
  console.log(value); \f[I]// \[dq]Success!\[dq]\f[R]
  \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]oh, no!\[dq]);
})
  .catch((e) \f[B]=>\f[R] {
    console.error(e.message); \f[I]// \[dq]oh, no!\[dq]\f[R]
  })
  .then(
    () \f[B]=>\f[R] console.log(\[dq]after a catch the chain is restored\[dq]), \f[I]// \[dq]after a catch the chain is restored\[dq]\f[R]
    () \f[B]=>\f[R] console.log(\[dq]Not fired due to the catch\[dq]),
  );

\f[I]// The following behaves the same as above\f[R]
p1.then((value) \f[B]=>\f[R] {
  console.log(value); \f[I]// \[dq]Success!\[dq]\f[R]
  \f[B]return\f[R] Promise.reject(\[dq]oh, no!\[dq]);
})
  .catch((e) \f[B]=>\f[R] {
    console.error(e); \f[I]// \[dq]oh, no!\[dq]\f[R]
  })
  .then(
    () \f[B]=>\f[R] console.log(\[dq]after a catch the chain is restored\[dq]), \f[I]// \[dq]after a catch the chain is restored\[dq]\f[R]
    () \f[B]=>\f[R] console.log(\[dq]Not fired due to the catch\[dq]),
  );
.EE
.SS Gotchas when throwing errors
Throwing an error will call the \f[CR]catch()\f[R] method most of the
time:
.IP
.EX
\f[B]const\f[R] p1 = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]Uh\-oh!\[dq]);
});

p1.catch((e) \f[B]=>\f[R] {
  console.error(e); \f[I]// \[dq]Uh\-oh!\[dq]\f[R]
});
.EE
.PP
Errors thrown inside asynchronous functions will act like uncaught
errors:
.IP
.EX
\f[B]const\f[R] p2 = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  setTimeout(() \f[B]=>\f[R] {
    \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]Uncaught Exception!\[dq]);
  }, 1000);
});

p2.catch((e) \f[B]=>\f[R] {
  console.error(e); \f[I]// This is never called\f[R]
});
.EE
.PP
Errors thrown after \f[CR]resolve\f[R] is called will be silenced:
.IP
.EX
\f[B]const\f[R] p3 = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  resolve();
  \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]Silenced Exception!\[dq]);
});

p3.catch((e) \f[B]=>\f[R] {
  console.error(e); \f[I]// This is never called\f[R]
});
.EE
.SS catch() is not called if the promise is fulfilled
.IP
.EX
\f[I]// Create a promise which would not call onReject\f[R]
\f[B]const\f[R] p1 = Promise.resolve(\[dq]calling next\[dq]);

\f[B]const\f[R] p2 = p1.catch((reason) \f[B]=>\f[R] {
  \f[I]// This is never called\f[R]
  console.error(\[dq]catch p1!\[dq]);
  console.error(reason);
});

p2.then(
  (value) \f[B]=>\f[R] {
    console.log(\[dq]next promise\[aq]s onFulfilled\[dq]);
    console.log(value); \f[I]// calling next\f[R]
  },
  (reason) \f[B]=>\f[R] {
    console.log(\[dq]next promise\[aq]s onRejected\[dq]);
    console.log(reason);
  },
);
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Promise\f[R]
.IP \[bu] 2
\f[CR]Promise.prototype.then()\f[R]
.IP \[bu] 2
\f[CR]Promise.prototype.finally()\f[R]
