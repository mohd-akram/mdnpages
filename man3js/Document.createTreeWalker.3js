'\" t
.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "DOCUMENT.CREATETREEWALKER" "3JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Document.createTreeWalker \- Document: createTreeWalker() method
.SH SYNOPSIS
The \f[B]\f[CB]Document.createTreeWalker()\f[B]\f[R] creator method
returns a newly created \f[CR]TreeWalker\f[R] object.
.SH SYNTAX
.IP
.EX
createTreeWalker(root)
createTreeWalker(root, whatToShow)
createTreeWalker(root, whatToShow, filter)
.EE
.SS Parameters
.TP
\f[B]root\f[R]
A \f[CR]Node\f[R] representing the root of the \f[CR]TreeWalker\f[R]
object, which is the initial value of \f[CR]TreeWalker.currentNode\f[R].
.TP
\f[B]whatToShow\f[R] \f[I](optional)\f[R]
An \f[CR]unsigned long\f[R] representing a bitmask created by combining
the constant properties of \c
.UR https://dom.spec.whatwg.org/#interface-nodefilter
\f[CR]NodeFilter\f[R]
.UE \c
\&.
It is a convenient way of filtering for certain types of node.
It defaults to \f[CR]0xFFFFFFFF\f[R], representing the
\f[CR]NodeFilter.SHOW_ALL\f[R] constant.
.RS
.PP
.TS
tab(@);
lw(32.7n) lw(8.8n) lw(28.6n).
T{
Constant
T}@T{
Numerical value
T}@T{
Description
T}
_
T{
\f[CR]NodeFilter.SHOW_ALL\f[R]
T}@T{
\f[CR]0xFFFFFFFF\f[R]
T}@T{
Shows all nodes.
T}
T{
\f[CR]NodeFilter.SHOW_ATTRIBUTE\f[R]
T}@T{
\f[CR]0x2\f[R]
T}@T{
Shows \f[CR]Attr\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_CDATA_SECTION\f[R]
T}@T{
\f[CR]0x8\f[R]
T}@T{
Shows \f[CR]CDATASection\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_COMMENT\f[R]
T}@T{
\f[CR]0x80\f[R]
T}@T{
Shows \f[CR]Comment\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_DOCUMENT\f[R]
T}@T{
\f[CR]0x100\f[R]
T}@T{
Shows \f[CR]Document\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_DOCUMENT_FRAGMENT\f[R]
T}@T{
\f[CR]0x400\f[R]
T}@T{
Shows \f[CR]DocumentFragment\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_DOCUMENT_TYPE\f[R]
T}@T{
\f[CR]0x200\f[R]
T}@T{
Shows \f[CR]DocumentType\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_ELEMENT\f[R]
T}@T{
\f[CR]0x1\f[R]
T}@T{
Shows \f[CR]Element\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_ENTITY\f[R] \f[I](deprecated)\f[R]
T}@T{
\f[CR]0x20\f[R]
T}@T{
Legacy, no longer effective.
T}
T{
\f[CR]NodeFilter.SHOW_ENTITY_REFERENCE\f[R] \f[I](deprecated)\f[R]
T}@T{
\f[CR]0x10\f[R]
T}@T{
Legacy, no longer effective.
T}
T{
\f[CR]NodeFilter.SHOW_NOTATION\f[R] \f[I](deprecated)\f[R]
T}@T{
\f[CR]0x800\f[R]
T}@T{
Legacy, no longer effective.
T}
T{
\f[CR]NodeFilter.SHOW_PROCESSING_INSTRUCTION\f[R]
T}@T{
\f[CR]0x40\f[R]
T}@T{
Shows \f[CR]ProcessingInstruction\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_TEXT\f[R]
T}@T{
\f[CR]0x4\f[R]
T}@T{
Shows \f[CR]Text\f[R] nodes.
T}
.TE
.RS
.PP
\f[B]Note:\f[R] Since the parent of any \f[CR]Attr\f[R] node is always
\f[CR]null\f[R], \f[CR]TreeWalker.nextNode()\f[R] and
\f[CR]TreeWalker.previousNode()\f[R] will never return an
\f[CR]Attr\f[R] node.
To traverse \f[CR]Attr\f[R] nodes, use \f[CR]Element.attributes\f[R]
instead.
.RE
.RE
.TP
\f[B]filter\f[R] \f[I](optional)\f[R]
A callback function or an object with an \f[CR]acceptNode()\f[R] method,
which returns \f[CR]NodeFilter.FILTER_ACCEPT\f[R],
\f[CR]NodeFilter.FILTER_REJECT\f[R], or
\f[CR]NodeFilter.FILTER_SKIP\f[R].
The function or method will be called for each node in the subtree based
at \f[CR]root\f[R] which is accepted as included by the
\f[CR]whatToShow\f[R] flag to determine whether or not to include it in
the list of iterable nodes:
.RS
.IP \(bu 2
If the return value is \f[CR]NodeFilter.FILTER_ACCEPT\f[R], this node is
included.
.IP \(bu 2
If the return value is \f[CR]NodeFilter.FILTER_REJECT\f[R], any node in
the subtree based at this node is not included.
.IP \(bu 2
If the return value is \f[CR]NodeFilter.FILTER_SKIP\f[R], this node is
not included.
.RE
.SS Return value
A new \f[CR]TreeWalker\f[R] object.
.SH EXAMPLES
.SS Using whatToShow
This example uses \f[CR]whatToShow\f[R] to transform text contents into
upper case.
Note that the text nodes of the descendants of the \f[CR]#root\f[R]
element are also traversed despite of the fact that they are not child
nodes of the \f[CR]#root\f[R] element.
.SS HTML
.IP
.EX
<\f[B]div\f[R] id=\(dqroot\(dq>
  This is a text node.
  <\f[B]span\f[R]>And this is a <\f[B]code\f[R]>span</\f[B]code\f[R]> element.</\f[B]span\f[R]>
</\f[B]div\f[R]>
.EE
.SS CSS
.IP
.EX
span {
  \f[B]background\-color\f[R]: aqua;
}
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] treeWalker = document.createTreeWalker(
  document.querySelector(\(dq#root\(dq),
  NodeFilter.SHOW_TEXT,
);

\f[B]while\f[R] (treeWalker.nextNode()) {
  \f[B]const\f[R] node = treeWalker.currentNode;
  node.data = node.data.toUpperCase();
}
.EE
.SS Result
.SS Using filter
This example uses \f[CR]filter\f[R] to escape text contents.
For any text node, its content will be escaped using
\f[CR]encodeURI()\f[R] if it is a descendant of an \f[CR].escape\f[R]
element but not of any \f[CR].no\-escape\f[R] element.
.SS HTML
.IP
.EX
<\f[B]div\f[R]>
  <\f[B]div\f[R]>
    This is not escaped. <\f[B]span\f[R] class=\(dqescape\(dq>But this is escaped.</\f[B]span\f[R]>
  </\f[B]div\f[R]>
  <\f[B]div\f[R] class=\(dqescape\(dq>This is escaped.</\f[B]div\f[R]>
  <\f[B]div\f[R] class=\(dqno\-escape\(dq>This is not escaped.</\f[B]div\f[R]>
</\f[B]div\f[R]>
<\f[B]hr\f[R] />
<\f[B]div\f[R] class=\(dqescape\(dq>
  <\f[B]div\f[R]>
    This is escaped. <\f[B]span\f[R] class=\(dqno\-escape\(dq>But this is not escaped.</\f[B]span\f[R]>
  </\f[B]div\f[R]>
  <\f[B]div\f[R] class=\(dqno\-escape\(dq>This is not escaped.</\f[B]div\f[R]>
</\f[B]div\f[R]>
<\f[B]hr\f[R] />
<\f[B]div\f[R] class=\(dqno\-escape\(dq>
  <\f[B]div\f[R]>This is not escaped.</\f[B]div\f[R]>
  <\f[B]div\f[R] class=\(dqescape\(dq>This is not escaped.</\f[B]div\f[R]>
</\f[B]div\f[R]>
.EE
.SS CSS
.IP
.EX
\&.escape {
  \f[B]border\f[R]: dashed;
}
\&.no\-escape {
  \f[B]border\f[R]: solid;
}
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] treeWalker = document.createTreeWalker(
  document.body,
  NodeFilter.SHOW_ELEMENT,
  (node) \f[B]=>\f[R]
    node.classList.contains(\(dqno\-escape\(dq)
      ? NodeFilter.FILTER_REJECT
      : node.closest(\(dq.escape\(dq)
        ? NodeFilter.FILTER_ACCEPT
        : NodeFilter.FILTER_SKIP,
);

\f[B]while\f[R] (treeWalker.nextNode()) {
  \f[B]for\f[R] (\f[B]const\f[R] node \f[B]of\f[R] treeWalker.currentNode.childNodes) {
    \f[B]if\f[R] (node.nodeType === Node.TEXT_NODE && /\(rsS/.test(node.data)) {
      \f[I]// Exclude whitespace\-only text nodes\f[R]
      node.data = encodeURI(node.data.replace(/\(rss+/g, \(dq \(dq));
    }
  }
}
.EE
.SS Result
.SH SEE ALSO
.IP \(bu 2
\f[CR]TreeWalker\f[R]: Related interface
