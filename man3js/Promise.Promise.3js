.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Promise.Promise" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Promise.Promise \- Promise() constructor
.SH SYNOPSIS
The \f[B]\f[CB]Promise()\f[B]\f[R] constructor creates
\f[CR]Promise\f[R] objects.
It is primarily used to wrap callback\-based APIs that do not already
support promises.
.IP
.EX
\f[B]const\f[R] promise1 = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  setTimeout(() \f[B]=>\f[R] {
    resolve(\[dq]foo\[dq]);
  }, 300);
});

promise1.then((value) \f[B]=>\f[R] {
  console.log(value);
  \f[I]// Expected output: \[dq]foo\[dq]\f[R]
});

console.log(promise1);
\f[I]// Expected output: [object Promise]\f[R]
.EE
.SH SYNTAX
.IP
.EX
new Promise(executor)
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]Promise()\f[R] can only be constructed with
\f[CR]new\f[R].
Attempting to call it without \f[CR]new\f[R] throws a
\f[CR]TypeError\f[R].
.RE
.SS Parameters
.TP
\f[B]executor\f[R]
A \f[CR]function\f[R] to be executed by the constructor.
It receives two functions as parameters: \f[CR]resolveFunc\f[R] and
\f[CR]rejectFunc\f[R].
Any errors thrown in the \f[CR]executor\f[R] will cause the promise to
be rejected, and the return value will be neglected.
The semantics of \f[CR]executor\f[R] are detailed below.
.SS Return value
When called via \f[CR]new\f[R], the \f[CR]Promise\f[R] constructor
returns a promise object.
The promise object will become \f[I]resolved\f[R] when either of the
functions \f[CR]resolveFunc\f[R] or \f[CR]rejectFunc\f[R] are invoked.
Note that if you call \f[CR]resolveFunc\f[R] and pass another promise
object as an argument, the initial promise can be said to be
\[lq]resolved\[rq], but still not \[lq]settled\[rq].
See the Promise description for more explanation.
.SH DESCRIPTION
Traditionally (before promises), asynchronous tasks were designed as
callbacks.
.IP
.EX
readFile(\[dq]./data.txt\[dq], (error, result) \f[B]=>\f[R] {
  \f[I]// This callback will be called when the task is done, with the\f[R]
  \f[I]// final \[ga]error\[ga] or \[ga]result\[ga]. Any operation dependent on the\f[R]
  \f[I]// result must be defined within this callback.\f[R]
});
\f[I]// Code here is immediately executed after the \[ga]readFile\[ga] request\f[R]
\f[I]// is fired. It does not wait for the callback to be called, hence\f[R]
\f[I]// making \[ga]readFile\[ga] \[dq]asynchronous\[dq].\f[R]
.EE
.PP
To take advantage of the readability improvement and language features
offered by promises, the \f[CR]Promise()\f[R] constructor allows one to
transform the callback\-based API to a promise\-based one.
.RS
.PP
\f[B]Note:\f[R] If your task is already promise\-based, you likely do
not need the \f[CR]Promise()\f[R] constructor.
.RE
.PP
The \f[CR]executor\f[R] is custom code that ties an outcome in a
callback to a promise.
You, the programmer, write the \f[CR]executor\f[R].
Its signature is expected to be:
.IP
.EX
\f[B]function\f[R] executor(resolveFunc, rejectFunc) {
  \f[I]// Typically, some asynchronous operation that accepts a callback,\f[R]
  \f[I]// like the \[ga]readFile\[ga] function above\f[R]
}
.EE
.PP
\f[CR]resolveFunc\f[R] and \f[CR]rejectFunc\f[R] are also functions, and
you can give them whatever actual names you want.
Their signatures are simple: they accept a single parameter of any type.
.IP
.EX
resolveFunc(value); \f[I]// call on resolved\f[R]
rejectFunc(reason); \f[I]// call on rejected\f[R]
.EE
.PP
The \f[CR]value\f[R] parameter passed to \f[CR]resolveFunc\f[R] can be
another promise object, in which case the newly constructed
promise\[cq]s state will be \[lq]locked in\[rq] to the promise passed
(as part of the resolution promise).
The \f[CR]rejectFunc\f[R] has semantics close to the \f[CR]throw\f[R]
statement, so \f[CR]reason\f[R] is typically an \f[CR]Error\f[R]
instance.
If either \f[CR]value\f[R] or \f[CR]reason\f[R] is omitted, the promise
is fulfilled/rejected with \f[CR]undefined\f[R].
.PP
The \f[CR]executor\f[R]\[cq]s completion state has limited effect on the
promise\[cq]s state:
.IP \[bu] 2
The \f[CR]executor\f[R] return value is ignored.
\f[CR]return\f[R] statements within the \f[CR]executor\f[R] merely
impact control flow and alter whether a part of the function is
executed, but do not have any impact on the promise\[cq]s fulfillment
value.
If \f[CR]executor\f[R] exits and it\[cq]s impossible for
\f[CR]resolveFunc\f[R] or \f[CR]rejectFunc\f[R] to be called in the
future (for example, there are no async tasks scheduled), then the
promise remains pending forever.
.IP \[bu] 2
If an error is thrown in the \f[CR]executor\f[R], the promise is
rejected, unless \f[CR]resolveFunc\f[R] or \f[CR]rejectFunc\f[R] has
already been called.
.RS
.PP
\f[B]Note:\f[R] The existence of pending promises does not prevent the
program from exiting.
If the event loop is empty, the program exits despite any pending
promises (because those are necessarily forever\-pending).
.RE
.PP
Here\[cq]s a summary of the typical flow:
.IP "1." 3
At the time when the constructor generates the new \f[CR]Promise\f[R]
object, it also generates a corresponding pair of functions for
\f[CR]resolveFunc\f[R] and \f[CR]rejectFunc\f[R]; these are
\[lq]tethered\[rq] to the \f[CR]Promise\f[R] object.
.IP "2." 3
\f[CR]executor\f[R] typically wraps some asynchronous operation which
provides a callback\-based API.
The callback (the one passed to the original callback\-based API) is
defined within the \f[CR]executor\f[R] code, so it has access to the
\f[CR]resolveFunc\f[R] and \f[CR]rejectFunc\f[R].
.IP "3." 3
The \f[CR]executor\f[R] is called synchronously (as soon as the
\f[CR]Promise\f[R] is constructed) with the \f[CR]resolveFunc\f[R] and
\f[CR]rejectFunc\f[R] functions as arguments.
.IP "4." 3
The code within the \f[CR]executor\f[R] has the opportunity to perform
some operation.
The eventual completion of the asynchronous task is communicated with
the promise instance via the side effect caused by
\f[CR]resolveFunc\f[R] or \f[CR]rejectFunc\f[R].
The side effect is that the \f[CR]Promise\f[R] object becomes
\[lq]resolved\[rq].
.RS 4
.IP \[bu] 2
If \f[CR]resolveFunc\f[R] is called first, the value passed will be
resolved.
The promise may stay pending (in case another thenable is passed),
become fulfilled (in most cases where a non\-thenable value is passed),
or become rejected (in case of an invalid resolution value).
.IP \[bu] 2
If \f[CR]rejectFunc\f[R] is called first, the promise instantly becomes
rejected.
.IP \[bu] 2
Once one of the resolving functions (\f[CR]resolveFunc\f[R] or
\f[CR]rejectFunc\f[R]) is called, the promise stays resolved.
Only the first call to \f[CR]resolveFunc\f[R] or \f[CR]rejectFunc\f[R]
affects the promise\[cq]s eventual state, and subsequent calls to either
function can neither change the fulfillment value/rejection reason nor
toggle its eventual state from \[lq]fulfilled\[rq] to \[lq]rejected\[rq]
or opposite.
.IP \[bu] 2
If \f[CR]executor\f[R] exits by throwing an error, then the promise is
rejected.
However, the error is ignored if one of the resolving functions has
already been called (so that the promise is already resolved).
.IP \[bu] 2
Resolving the promise does not necessarily cause the promise to become
fulfilled or rejected (i.e.\ settled).
The promise may still be pending because it\[cq]s resolved with another
thenable, but its eventual state will match that of the resolved
thenable.
.RE
.IP "5." 3
Once the promise settles, it (asynchronously) invokes any further
handlers associated through \f[CR]then()\f[R], \f[CR]catch()\f[R], or
\f[CR]finally()\f[R].
The eventual fulfillment value or rejection reason is passed to the
invocation of fulfillment and rejection handlers as an input parameter
(see Chained Promises).
.PP
For example, the callback\-based \f[CR]readFile\f[R] API above can be
transformed into a promise\-based one.
.IP
.EX
\f[B]const\f[R] readFilePromise = (path) \f[B]=>\f[R]
  \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
    readFile(path, (error, result) \f[B]=>\f[R] {
      \f[B]if\f[R] (error) {
        reject(error);
      } \f[B]else\f[R] {
        resolve(result);
      }
    });
  });

readFilePromise(\[dq]./data.txt\[dq])
  .then((result) \f[B]=>\f[R] console.log(result))
  .catch((error) \f[B]=>\f[R] console.error(\[dq]Failed to read data\[dq]));
.EE
.PP
The \f[CR]resolve\f[R] and \f[CR]reject\f[R] callbacks are only
available within the scope of the executor function, which means you
can\[cq]t access them after the promise is constructed.
If you want to construct the promise before deciding how to resolve it,
you can use the \f[CR]Promise.withResolvers()\f[R] method instead, which
exposes the \f[CR]resolve\f[R] and \f[CR]reject\f[R] functions.
.SS The resolve function
The \f[CR]resolve\f[R] function has the following behaviors:
.IP \[bu] 2
If it\[cq]s called with the same value as the newly created promise (the
promise it\[cq]s \[lq]tethered to\[rq]), the promise is rejected with a
\f[CR]TypeError\f[R].
.IP \[bu] 2
If it\[cq]s called with a non\-thenable value (a primitive, or an object
whose \f[CR]then\f[R] property is not callable, including when the
property is not present), the promise is immediately fulfilled with that
value.
.IP \[bu] 2
If it\[cq]s called with a thenable value (including another
\f[CR]Promise\f[R] instance), then the thenable\[cq]s \f[CR]then\f[R]
method is saved and called in the future (it\[cq]s always called
asynchronously).
The \f[CR]then\f[R] method will be called with two callbacks, which are
two new functions with the exact same behaviors as the
\f[CR]resolveFunc\f[R] and \f[CR]rejectFunc\f[R] passed to the
\f[CR]executor\f[R] function.
If calling the \f[CR]then\f[R] method throws, then the current promise
is rejected with the thrown error.
.PP
In the last case, it means code like:
.IP
.EX
\f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  resolve(thenable);
});
.EE
.PP
Is roughly equivalent to:
.IP
.EX
\f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  \f[B]try\f[R] {
    thenable.then(
      (value) \f[B]=>\f[R] resolve(value),
      (reason) \f[B]=>\f[R] reject(reason),
    );
  } \f[B]catch\f[R] (e) {
    reject(e);
  }
});
.EE
.PP
Except that in the \f[CR]resolve(thenable)\f[R] case:
.IP "1." 3
\f[CR]resolve\f[R] is called synchronously, so that calling
\f[CR]resolve\f[R] or \f[CR]reject\f[R] again has no effect, even when
the handlers attached through \f[CR]anotherPromise.then()\f[R] are not
called yet.
.IP "2." 3
The \f[CR]then\f[R] method is called asynchronously, so that the promise
will never be instantly resolved if a thenable is passed.
.PP
Because \f[CR]resolve\f[R] is called again with whatever
\f[CR]thenable.then()\f[R] passes to it as \f[CR]value\f[R], the
resolver function is able to flatten nested thenables, where a thenable
calls its \f[CR]onFulfilled\f[R] handler with another thenable.
The effect is that the fulfillment handler of a real promise will never
receive a thenable as its fulfillment value.
.SH EXAMPLES
.SS Turning a callback\-based API into a promise\-based one
To provide a function with promise functionality, have it return a
promise by calling the \f[CR]resolve\f[R] and \f[CR]reject\f[R]
functions at the correct times.
.IP
.EX
\f[B]function\f[R] myAsyncFunction(url) {
  \f[B]return\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
    \f[B]const\f[R] xhr = \f[B]new\f[R] XMLHttpRequest();
    xhr.open(\[dq]GET\[dq], url);
    xhr.onload = () \f[B]=>\f[R] resolve(xhr.responseText);
    xhr.onerror = () \f[B]=>\f[R] reject(xhr.statusText);
    xhr.send();
  });
}
.EE
.SS Effect of calling resolveFunc
Calling \f[CR]resolveFunc\f[R] causes the promise to become resolved, so
that calling \f[CR]resolveFunc\f[R] or \f[CR]rejectFunc\f[R] again has
no effect.
However, the promise may be in any of the states: pending, fulfilled, or
rejected.
.PP
This \f[CR]pendingResolved\f[R] promise is resolved the time it\[cq]s
created, because it has already been \[lq]locked in\[rq] to match the
eventual state of the inner promise, and calling \f[CR]resolveOuter\f[R]
or \f[CR]rejectOuter\f[R] or throwing an error later in the executor has
no effect on its eventual state.
However, the inner promise is still pending until 100ms later, so the
outer promise is also pending:
.IP
.EX
\f[B]const\f[R] pendingResolved = \f[B]new\f[R] Promise((resolveOuter, rejectOuter) \f[B]=>\f[R] {
  resolveOuter(
    \f[B]new\f[R] Promise((resolveInner) \f[B]=>\f[R] {
      setTimeout(() \f[B]=>\f[R] {
        resolveInner(\[dq]inner\[dq]);
      }, 100);
    }),
  );
});
.EE
.PP
This \f[CR]fulfilledResolved\f[R] promise becomes fulfilled the moment
it\[cq]s resolved, because it\[cq]s resolved with a non\-thenable value.
However, when it\[cq]s created, it\[cq]s unresolved, because neither
\f[CR]resolve\f[R] nor \f[CR]reject\f[R] has been called yet.
An unresolved promise is necessarily pending:
.IP
.EX
\f[B]const\f[R] fulfilledResolved = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  setTimeout(() \f[B]=>\f[R] {
    resolve(\[dq]outer\[dq]);
  }, 100);
});
.EE
.PP
Calling \f[CR]rejectFunc\f[R] obviously causes the promise to reject.
However, there are also two ways to cause the promise to instantly
become rejected even when the \f[CR]resolveFunc\f[R] callback is called.
.IP
.EX
\f[I]// 1. Resolving with the promise itself\f[R]
\f[B]const\f[R] rejectedResolved1 = \f[B]new\f[R] Promise((resolve) \f[B]=>\f[R] {
  \f[I]// Note: resolve has to be called asynchronously,\f[R]
  \f[I]// so that the rejectedResolved1 variable is initialized\f[R]
  setTimeout(() \f[B]=>\f[R] resolve(rejectedResolved1)); \f[I]// TypeError: Chaining cycle detected for promise #<Promise>\f[R]
});

\f[I]// 2. Resolving with an object which throws when accessing the \[ga]then\[ga] property\f[R]
\f[B]const\f[R] rejectedResolved2 = \f[B]new\f[R] Promise((resolve) \f[B]=>\f[R] {
  resolve({
    \f[B]get\f[R] then() {
      \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]Can\[aq]t get then property\[dq]);
    },
  });
});
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-promise
Polyfill of \f[CR]Promise\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Using promises guide
.IP \[bu] 2
\f[CR]Promise.withResolvers()\f[R]
