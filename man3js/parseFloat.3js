.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "parseFloat" "JS" "September 25, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
parseFloat \- parseFloat()
.SH SYNOPSIS
The \f[B]\f[CB]parseFloat()\f[B]\f[R] function parses a string argument
and returns a floating point number.
.SH SYNTAX
.IP
.EX
parseFloat(string)
.EE
.SS Parameters
.TP
\f[B]string\f[R]
The value to parse, coerced to a string.
Leading whitespace in this argument is ignored.
.SS Return value
A floating point number parsed from the given \f[CR]string\f[R], or
\f[CR]NaN\f[R] when the first non\-whitespace character cannot be
converted to a number.
.RS
.PP
\f[B]Note:\f[R] JavaScript does not have the distinction of
\[lq]floating point numbers\[rq] and \[lq]integers\[rq] on the language
level.
\f[CR]parseInt()\f[R] and \f[CR]parseFloat()\f[R] only differ in their
parsing behavior, but not necessarily their return values.
For example, \f[CR]parseInt(\[dq]42\[dq])\f[R] and
\f[CR]parseFloat(\[dq]42\[dq])\f[R] would return the same value: a
\f[CR]Number\f[R] 42.
.RE
.SH DESCRIPTION
The \f[CR]parseFloat\f[R] function converts its first argument to a
string, parses that string as a decimal number literal, then returns a
number or \f[CR]NaN\f[R].
The number syntax it accepts can be summarized as:
.IP \[bu] 2
The characters accepted by \f[CR]parseFloat()\f[R] are plus sign
(\f[CR]+\f[R]), minus sign (\f[CR]\-\f[R] U+002D HYPHEN\-MINUS), decimal
digits (\f[CR]0\f[R] \[en] \f[CR]9\f[R]), decimal point (\f[CR].\f[R]),
exponent indicator (\f[CR]e\f[R] or \f[CR]E\f[R]), and the
\f[CR]\[dq]Infinity\[dq]\f[R] literal.
.IP \[bu] 2
The \f[CR]+\f[R]/\f[CR]\-\f[R] signs can only appear strictly at the
beginning of the string, or immediately following the
\f[CR]e\f[R]/\f[CR]E\f[R] character.
The decimal point can only appear once, and only before the
\f[CR]e\f[R]/\f[CR]E\f[R] character.
The \f[CR]e\f[R]/\f[CR]E\f[R] character can only appear once, and only
if there is at least one digit before it.
.IP \[bu] 2
Leading spaces in the argument are trimmed and ignored.
.IP \[bu] 2
\f[CR]parseFloat()\f[R] can also parse and return \f[CR]Infinity\f[R] or
\f[CR]\-Infinity\f[R] if the string starts with
\f[CR]\[dq]Infinity\[dq]\f[R] or \f[CR]\[dq]\-Infinity\[dq]\f[R]
preceded by none or more white spaces.
.IP \[bu] 2
\f[CR]parseFloat()\f[R] picks the longest substring starting from the
beginning that generates a valid number literal.
If it encounters an invalid character, it returns the number represented
up to that point, ignoring the invalid character and all characters
following it.
.IP \[bu] 2
If the argument\[cq]s first character can\[cq]t start a legal number
literal per the syntax above, \f[CR]parseFloat\f[R] returns
\f[CR]NaN\f[R].
.PP
Syntax\-wise, \f[CR]parseFloat()\f[R] parses a subset of the syntax that
the \f[CR]Number()\f[R] function accepts.
Namely, \f[CR]parseFloat()\f[R] does not support non\-decimal literals
with \f[CR]0x\f[R], \f[CR]0b\f[R], or \f[CR]0o\f[R] prefixes but
supports everything else.
However, \f[CR]parseFloat()\f[R] is more lenient than
\f[CR]Number()\f[R] because it ignores trailing invalid characters,
which would cause \f[CR]Number()\f[R] to return \f[CR]NaN\f[R].
.PP
Similar to number literals and \f[CR]Number()\f[R], the number returned
from \f[CR]parseFloat()\f[R] may not be exactly equal to the number
represented by the string, due to floating point range and inaccuracy.
For numbers outside the \f[CR]\-1.7976931348623158e+308\f[R] \[en]
\f[CR]1.7976931348623158e+308\f[R] range (see
\f[CR]Number.MAX_VALUE\f[R]), \f[CR]\-Infinity\f[R] or
\f[CR]Infinity\f[R] is returned.
.SH EXAMPLES
.SS Using parseFloat()
The following examples all return \f[CR]3.14\f[R]:
.IP
.EX
parseFloat(3.14);
parseFloat(\[dq]3.14\[dq]);
parseFloat(\[dq]  3.14  \[dq]);
parseFloat(\[dq]314e\-2\[dq]);
parseFloat(\[dq]0.0314E+2\[dq]);
parseFloat(\[dq]3.14some non\-digit characters\[dq]);
parseFloat({
  toString() {
    return \[dq]3.14\[dq];
  },
});
.EE
.SS parseFloat() returning NaN
The following example returns \f[CR]NaN\f[R]:
.IP
.EX
parseFloat(\[dq]FF2\[dq]);
.EE
.PP
Anecdotally, because the string \f[CR]NaN\f[R] itself is invalid syntax
as accepted by \f[CR]parseFloat()\f[R], passing \f[CR]\[dq]NaN\[dq]\f[R]
returns \f[CR]NaN\f[R] as well.
.IP
.EX
parseFloat(\[dq]NaN\[dq]); // NaN
.EE
.SS Returning Infinity
Infinity values are returned when the number is outside the
double\-precision 64\-bit IEEE 754\-2019 format range:
.IP
.EX
parseFloat(\[dq]1.7976931348623159e+308\[dq]); // Infinity
parseFloat(\[dq]\-1.7976931348623159e+308\[dq]); // \-Infinity
.EE
.PP
Infinity is also returned when the string starts with
\f[CR]\[dq]Infinity\[dq]\f[R] or \f[CR]\[dq]\-Infinity\[dq]\f[R]:
.IP
.EX
parseFloat(\[dq]Infinity\[dq]); // Infinity
parseFloat(\[dq]\-Infinity\[dq]); // \-Infinity
.EE
.SS Interaction with BigInt values
\f[CR]parseFloat()\f[R] does not handle \f[CR]BigInt\f[R] values.
It stops at the \f[CR]n\f[R] character, and treats the preceding string
as a normal integer, with possible loss of precision.
If a BigInt value is passed to \f[CR]parseFloat()\f[R], it will be
converted to a string, and the string will be parsed as a
floating\-point number, which may result in loss of precision as well.
.PP
\f[B]Bad\f[R]
.IP
.EX
parseFloat(900719925474099267n); // 900719925474099300
parseFloat(\[dq]900719925474099267n\[dq]); // 900719925474099300
.EE
.PP
You should pass the string to the \f[CR]BigInt()\f[R] function instead,
without the trailing \f[CR]n\f[R] character.
.PP
\f[B]Good\f[R]
.IP
.EX
BigInt(\[dq]900719925474099267\[dq]);
// 900719925474099267n
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]parseInt()\f[R]
.IP \[bu] 2
\f[CR]Number.parseFloat()\f[R]
.IP \[bu] 2
\f[CR]Number.parseInt()\f[R]
.IP \[bu] 2
\f[CR]Number.prototype.toFixed()\f[R]
