.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Array.copyWithin" "JS" "February 8, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.copyWithin \- Array.prototype.copyWithin()
.SH SYNOPSIS
The \f[B]\f[CB]copyWithin()\f[B]\f[R] method of \f[CR]Array\f[R]
instances shallow copies part of this array to another location in the
same array and returns this array without modifying its length.
.SH SYNTAX
.IP
.EX
copyWithin(target, start)
copyWithin(target, start, end)
.EE
.SS Parameters
.TP
\f[B]target\f[R]
Zero\-based index at which to copy the sequence to, converted to an
integer.
This corresponds to where the element at \f[CR]start\f[R] will be copied
to, and all elements between \f[CR]start\f[R] and \f[CR]end\f[R] are
copied to succeeding indices.
.RS
.IP \[bu] 2
Negative index counts back from the end of the array \[em] if
\f[CR]\-array.length <= target < 0\f[R],
\f[CR]target + array.length\f[R] is used.
.IP \[bu] 2
If \f[CR]target < \-array.length\f[R], \f[CR]0\f[R] is used.
.IP \[bu] 2
If \f[CR]target >= array.length\f[R], nothing is copied.
.IP \[bu] 2
If \f[CR]target\f[R] is positioned after \f[CR]start\f[R] after
normalization, copying only happens until the end of
\f[CR]array.length\f[R] (in other words, \f[CR]copyWithin()\f[R] never
extends the array).
.RE
.TP
\f[B]start\f[R]
Zero\-based index at which to start copying elements from, converted to
an integer.
.RS
.IP \[bu] 2
Negative index counts back from the end of the array \[em] if
\f[CR]\-array.length <= start < 0\f[R], \f[CR]start + array.length\f[R]
is used.
.IP \[bu] 2
If \f[CR]start < \-array.length\f[R], \f[CR]0\f[R] is used.
.IP \[bu] 2
If \f[CR]start >= array.length\f[R], nothing is copied.
.RE
.TP
\f[B]end\f[R] \f[I](optional)\f[R]
Zero\-based index at which to end copying elements from, converted to an
integer.
\f[CR]copyWithin()\f[R] copies up to but not including \f[CR]end\f[R].
.RS
.IP \[bu] 2
Negative index counts back from the end of the array \[em] if
\f[CR]\-array.length <= end < 0\f[R], \f[CR]end + array.length\f[R] is
used.
.IP \[bu] 2
If \f[CR]end < \-array.length\f[R], \f[CR]0\f[R] is used.
.IP \[bu] 2
If \f[CR]end >= array.length\f[R] or \f[CR]end\f[R] is omitted,
\f[CR]array.length\f[R] is used, causing all elements until the end to
be copied.
.IP \[bu] 2
If \f[CR]end\f[R] implies a position before or at the position that
\f[CR]start\f[R] implies, nothing is copied.
.RE
.SS Return value
The modified array.
.SH DESCRIPTION
The \f[CR]copyWithin()\f[R] method works like C and C++\[cq]s
\f[CR]memmove\f[R], and is a high\-performance method to shift the data
of an \f[CR]Array\f[R].
This especially applies to the \f[CR]TypedArray\f[R] method of the same
name.
The sequence is copied and pasted as one operation; the pasted sequence
will have the copied values even when the copy and paste region overlap.
.PP
Because \f[CR]undefined\f[R] becomes \f[CR]0\f[R] when converted to an
integer, omitting the \f[CR]start\f[R] parameter has the same effect as
passing \f[CR]0\f[R], which copies the entire array to the target
position, equivalent to a right shift where the right boundary is
clipped off and the left boundary is duplicated.
This behavior may confuse readers of your code, so you should explicitly
pass \f[CR]0\f[R] as \f[CR]start\f[R] instead.
.IP
.EX
console.log([1, 2, 3, 4, 5].copyWithin(2));
\f[I]// [1, 2, 1, 2, 3]; move all elements to the right by 2 positions\f[R]
.EE
.PP
The \f[CR]copyWithin()\f[R] method is a mutating method.
It does not alter the length of \f[CR]this\f[R], but it will change the
content of \f[CR]this\f[R] and create new properties or delete existing
properties, if necessary.
.PP
The \f[CR]copyWithin()\f[R] method preserves empty slots.
If the region to be copied from is sparse, the empty slots\[cq]
corresponding new indices are deleted and also become empty slots.
.PP
The \f[CR]copyWithin()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
Although strings are also array\-like, this method is not suitable to be
applied on them, as strings are immutable.
.SH EXAMPLES
.SS Using copyWithin()
.IP
.EX
console.log([1, 2, 3, 4, 5].copyWithin(0, 3));
\f[I]// [4, 5, 3, 4, 5]\f[R]

console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4));
\f[I]// [4, 2, 3, 4, 5]\f[R]

console.log([1, 2, 3, 4, 5].copyWithin(\-2, \-3, \-1));
\f[I]// [1, 2, 3, 3, 4]\f[R]
.EE
.SS Using copyWithin() on sparse arrays
\f[CR]copyWithin()\f[R] will propagate empty slots.
.IP
.EX
console.log([1, , 3].copyWithin(2, 1, 2)); \f[I]// [1, empty, empty]\f[R]
.EE
.SS Calling copyWithin() on non\-array objects
The \f[CR]copyWithin()\f[R] method reads the \f[CR]length\f[R] property
of \f[CR]this\f[R] and then manipulates the integer indices involved.
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 5,
  3: 1,
};
console.log(Array.prototype.copyWithin.call(arrayLike, 0, 3));
\f[I]// { \[aq]0\[aq]: 1, \[aq]3\[aq]: 1, length: 5 }\f[R]
console.log(Array.prototype.copyWithin.call(arrayLike, 3, 1));
\f[I]// { \[aq]0\[aq]: 1, length: 5 }\f[R]
\f[I]// The \[aq]3\[aq] property is deleted because the copied source is an empty slot\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype.copyWithin\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Indexed collections guide
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]TypedArray.prototype.copyWithin()\f[R]
