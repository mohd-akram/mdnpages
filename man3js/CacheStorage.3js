.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "CacheStorage" "JS" "February 11, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
CacheStorage \- CacheStorage
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]CacheStorage\f[B]\f[R] interface represents the storage
for \f[CR]Cache\f[R] objects.
.PP
The interface:
.IP \[bu] 2
Provides a master directory of all the named caches that can be accessed
by a \f[CR]ServiceWorker\f[R] or other type of worker or
\f[CR]window\f[R] scope (you\[cq]re not limited to only using it with
service workers).
.IP \[bu] 2
Maintains a mapping of string names to corresponding \f[CR]Cache\f[R]
objects.
.PP
Use \f[CR]CacheStorage.open()\f[R] to obtain a \f[CR]Cache\f[R]
instance.
.PP
Use \f[CR]CacheStorage.match()\f[R] to check if a given
\f[CR]Request\f[R] is a key in any of the \f[CR]Cache\f[R] objects that
the \f[CR]CacheStorage\f[R] object tracks.
.PP
You can access \f[CR]CacheStorage\f[R] through the global
\f[CR]caches\f[R] property.
.RS
.PP
\f[B]Note:\f[R] \f[CR]CacheStorage\f[R] always rejects with a
\f[CR]SecurityError\f[R] on untrusted origins (i.e.\ those that
aren\[cq]t using HTTPS, although this definition will likely become more
complex in the future.)
When testing on Firefox, you can get around this by checking the
\f[B]Enable Service Workers over HTTP (when toolbox is open)\f[R] option
in the Firefox Devtools options/gear menu.
Furthermore, because \f[CR]CacheStorage\f[R] requires file\-system
access, it may be unavailable in private mode in Firefox.
.RE
.RS
.PP
\f[B]Note:\f[R] \f[CR]CacheStorage.match()\f[R] is a convenience method.
Equivalent functionality to match a cache entry can be implemented by
returning an array of cache names from \f[CR]CacheStorage.keys()\f[R],
opening each cache with \f[CR]CacheStorage.open()\f[R], and matching the
one you want with \f[CR]Cache.match()\f[R].
.RE
.SH INSTANCE METHODS
.TP
\f[B]CacheStorage.match()\f[R]
Checks if a given \f[CR]Request\f[R] is a key in any of the
\f[CR]Cache\f[R] objects that the \f[CR]CacheStorage\f[R] object tracks,
and returns a \f[CR]Promise\f[R] that resolves to that match.
.TP
\f[B]CacheStorage.has()\f[R]
Returns a \f[CR]Promise\f[R] that resolves to \f[CR]true\f[R] if a
\f[CR]Cache\f[R] object matching the \f[CR]cacheName\f[R] exists.
.TP
\f[B]CacheStorage.open()\f[R]
Returns a \f[CR]Promise\f[R] that resolves to the \f[CR]Cache\f[R]
object matching the \f[CR]cacheName\f[R] (a new cache is created if it
doesn\[cq]t already exist.)
.TP
\f[B]CacheStorage.delete()\f[R]
Finds the \f[CR]Cache\f[R] object matching the \f[CR]cacheName\f[R], and
if found, deletes the \f[CR]Cache\f[R] object and returns a
\f[CR]Promise\f[R] that resolves to \f[CR]true\f[R].
If no \f[CR]Cache\f[R] object is found, it resolves to \f[CR]false\f[R].
.TP
\f[B]CacheStorage.keys()\f[R]
Returns a \f[CR]Promise\f[R] that will resolve with an array containing
strings corresponding to all of the named \f[CR]Cache\f[R] objects
tracked by the \f[CR]CacheStorage\f[R].
Use this method to iterate over a list of all the \f[CR]Cache\f[R]
objects.
.SH EXAMPLES
This code snippet is from the MDN \c
.UR https://github.com/mdn/dom-examples/tree/main/service-worker/simple-service-worker
simple service worker example
.UE \c
\ (see \c
.UR https://bncb2v.csb.app/
simple service worker running live
.UE \c
\&.)
This service worker script waits for an \f[CR]install\f[R] event to
fire, then runs \f[CR]waitUntil\f[R] to handle the install process for
the app.
This consists of calling \f[CR]CacheStorage.open\f[R] to create a new
cache, then using \f[CR]Cache.addAll\f[R] to add a series of assets to
it.
.PP
In the second code block, we wait for a \f[CR]FetchEvent\f[R] to fire.
We construct a custom response like so:
.IP "1." 3
Check whether a match for the request is found in the CacheStorage.
If so, serve that.
.IP "2." 3
If not, fetch the request from the network, then also open the cache
created in the first block and add a clone of the request to it using
\f[CR]Cache.put\f[R]
(\f[CR]cache.put(event.request, response.clone())\f[R].)
.IP "3." 3
If this fails (e.g.\ because the network is down), return a fallback
response.
.PP
Finally, return whatever the custom response ended up being equal to,
using \f[CR]FetchEvent.respondWith\f[R].
.IP
.EX
self.addEventListener(\[dq]install\[dq], (event) \f[B]=>\f[R] {
  event.waitUntil(
    caches
      .open(\[dq]v1\[dq])
      .then((cache) \f[B]=>\f[R]
        cache.addAll([
          \[dq]/\[dq],
          \[dq]/index.html\[dq],
          \[dq]/style.css\[dq],
          \[dq]/app.js\[dq],
          \[dq]/image\-list.js\[dq],
          \[dq]/star\-wars\-logo.jpg\[dq],
          \[dq]/gallery/bountyHunters.jpg\[dq],
          \[dq]/gallery/myLittleVader.jpg\[dq],
          \[dq]/gallery/snowTroopers.jpg\[dq],
        ]),
      ),
  );
});

self.addEventListener(\[dq]fetch\[dq], (event) \f[B]=>\f[R] {
  event.respondWith(
    caches.match(event.request).then((response) \f[B]=>\f[R] {
      \f[I]// caches.match() always resolves\f[R]
      \f[I]// but in case of success response will have value\f[R]
      \f[B]if\f[R] (response !== \f[B]undefined\f[R]) {
        \f[B]return\f[R] response;
      } \f[B]else\f[R] {
        \f[B]return\f[R] fetch(event.request)
          .then((response) \f[B]=>\f[R] {
            \f[I]// response may be used only once\f[R]
            \f[I]// we need to save clone to put one copy in cache\f[R]
            \f[I]// and serve second one\f[R]
            \f[B]let\f[R] responseClone = response.clone();

            caches.open(\[dq]v1\[dq]).then((cache) \f[B]=>\f[R] {
              cache.put(event.request, responseClone);
            });
            \f[B]return\f[R] response;
          })
          .catch(() \f[B]=>\f[R] caches.match(\[dq]/gallery/myLittleVader.jpg\[dq]));
      }
    }),
  );
});
.EE
.PP
This snippet shows how the API can be used outside of a service worker
context, and uses the \f[CR]await\f[R] operator for much more readable
code.
.IP
.EX
\f[I]// Try to get data from the cache, but fall back to fetching it live.\f[R]
\f[B]async\f[R] \f[B]function\f[R] getData() {
  \f[B]const\f[R] cacheVersion = 1;
  \f[B]const\f[R] cacheName = \[ga]myapp\-${cacheVersion}\[ga];
  \f[B]const\f[R] url = \[dq]https://jsonplaceholder.typicode.com/todos/1\[dq];
  \f[B]let\f[R] cachedData = \f[B]await\f[R] getCachedData(cacheName, url);

  \f[B]if\f[R] (cachedData) {
    console.log(\[dq]Retrieved cached data\[dq]);
    \f[B]return\f[R] cachedData;
  }

  console.log(\[dq]Fetching fresh data\[dq]);

  \f[B]const\f[R] cacheStorage = \f[B]await\f[R] caches.open(cacheName);
  \f[B]await\f[R] cacheStorage.add(url);
  cachedData = \f[B]await\f[R] getCachedData(cacheName, url);
  \f[B]await\f[R] deleteOldCaches(cacheName);

  \f[B]return\f[R] cachedData;
}

\f[I]// Get data from the cache.\f[R]
\f[B]async\f[R] \f[B]function\f[R] getCachedData(cacheName, url) {
  \f[B]const\f[R] cacheStorage = \f[B]await\f[R] caches.open(cacheName);
  \f[B]const\f[R] cachedResponse = \f[B]await\f[R] cacheStorage.match(url);

  \f[B]if\f[R] (!cachedResponse || !cachedResponse.ok) {
    \f[B]return\f[R] \f[B]false\f[R];
  }

  \f[B]return\f[R] \f[B]await\f[R] cachedResponse.json();
}

\f[I]// Delete any old caches to respect user\[aq]s disk space.\f[R]
\f[B]async\f[R] \f[B]function\f[R] deleteOldCaches(currentCache) {
  \f[B]const\f[R] keys = \f[B]await\f[R] caches.keys();

  \f[B]for\f[R] (\f[B]const\f[R] key \f[B]of\f[R] keys) {
    \f[B]const\f[R] isOurCache = key.startsWith(\[dq]myapp\-\[dq]);
    \f[B]if\f[R] (currentCache === key || !isOurCache) {
      \f[B]continue\f[R];
    }
    caches.delete(key);
  }
}

\f[B]try\f[R] {
  \f[B]const\f[R] data = \f[B]await\f[R] getData();
  console.log({ data });
} \f[B]catch\f[R] (error) {
  console.error({ error });
}
.EE
.SH SEE ALSO
.IP \[bu] 2
Using Service Workers
.IP \[bu] 2
\f[CR]Cache\f[R]
.IP \[bu] 2
\f[CR]caches\f[R]
.IP \[bu] 2
Private Browsing / Incognito modes
