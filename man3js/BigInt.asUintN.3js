.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "BigInt.asUintN" "JS" "September 12, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
BigInt.asUintN - BigInt.asUintN()
.SH SYNOPSIS
The \f[B]\f[CB]BigInt.asUintN()\f[B]\f[R] static method truncates a
\f[CR]BigInt\f[R] value to the given number of least significant bits
and returns that value as an unsigned integer.
.SH SYNTAX
.IP
.EX
BigInt.asUintN(bits, bigint)
.EE
.SS Parameters
.TP
\f[B]bits\f[R]
The amount of bits available for the returned BigInt.
Should be an integer between 0 and 253 - 1, inclusive.
.TP
\f[B]bigint\f[R]
The BigInt value to truncate to fit into the supplied bits.
.SS Return value
The value of \f[CR]bigint\f[R] modulo 2\[ha]\f[CR]bits\f[R], as an
unsigned integer.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]bits\f[R] is negative or greater than 253 - 1.
.SH DESCRIPTION
The \f[CR]BigInt.asUintN\f[R] method truncates a \f[CR]BigInt\f[R] value
to the given number of bits, and interprets the result as an unsigned
integer.
Unsigned integers have no sign bits and are always non-negative.
For example, for \f[CR]BigInt.asUintN(4, 25n)\f[R], the value
\f[CR]25n\f[R] is truncated to \f[CR]9n\f[R]:
.IP
.EX
25n = 00011001 (base 2)
         \[ha]==== Use only the four remaining bits
===>      1001 (base 2) = 9n
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]BigInt\f[R] values are always encoded as two\[cq]s
complement in binary.
.RE
.PP
Unlike similar language APIs such as
\f[CR]Number.prototype.toExponential()\f[R], \f[CR]asUintN\f[R] is a
static property of \f[CR]BigInt\f[R], so you always use it as
\f[CR]BigInt.asUintN()\f[R], rather than as a method of a BigInt value.
Exposing \f[CR]asUintN()\f[R] as a \[lq]standard library function\[rq]
allows interop with
asm.js (https://github.com/tc39/proposal-bigint/blob/master/ADVANCED.md#dont-break-asmjs).
.SH EXAMPLES
.SS Staying in 64-bit ranges
The \f[CR]BigInt.asUintN()\f[R] method can be useful to stay in the
range of 64-bit arithmetic.
.IP
.EX
const max = 2n ** 64n - 1n;

BigInt.asUintN(64, max); // 18446744073709551615n

BigInt.asUintN(64, max + 1n); // 0n
// zero because of overflow: the lowest 64 bits are all zeros
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]BigInt\f[R]
.IP \[bu] 2
\f[CR]BigInt.asIntN()\f[R]
