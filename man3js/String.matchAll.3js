.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "String.matchAll" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.matchAll \- String.prototype.matchAll()
.SH SYNOPSIS
The \f[B]\f[CB]matchAll()\f[B]\f[R] method of \f[CR]String\f[R] values
returns an iterator of all results matching this string against a
regular expression, including capturing groups.
.IP
.EX
\f[B]const\f[R] regexp = /t(e)(st(\[rs]d?))/g;
\f[B]const\f[R] str = \[dq]test1test2\[dq];

\f[B]const\f[R] array = [...str.matchAll(regexp)];

console.log(array[0]);
\f[I]// Expected output: Array [\[dq]test1\[dq], \[dq]e\[dq], \[dq]st1\[dq], \[dq]1\[dq]]\f[R]

console.log(array[1]);
\f[I]// Expected output: Array [\[dq]test2\[dq], \[dq]e\[dq], \[dq]st2\[dq], \[dq]2\[dq]]\f[R]
.EE
.SH SYNTAX
.IP
.EX
matchAll(regexp)
.EE
.SS Parameters
.TP
\f[B]regexp\f[R]
A regular expression object, or any object that has a
\f[CR]Symbol.matchAll\f[R] method.
.RS
.PP
If \f[CR]regexp\f[R] is not a \f[CR]RegExp\f[R] object and does not have
a \f[CR]Symbol.matchAll\f[R] method, it is implicitly converted to a
\f[CR]RegExp\f[R] by using \f[CR]new RegExp(regexp, \[aq]g\[aq])\f[R].
.PP
If \f[CR]regexp\f[R] is a regex, then it must have the global
(\f[CR]g\f[R]) flag set, or a \f[CR]TypeError\f[R] is thrown.
.RE
.SS Return value
An iterable iterator object (which is not restartable) of matches or an
empty iterator if no matches are found.
Each value yielded by the iterator is an array with the same shape as
the return value of \f[CR]RegExp.prototype.exec()\f[R].
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if the \f[CR]regexp\f[R] is a regex that does not have the global
(\f[CR]g\f[R]) flag set (its \f[CR]flags\f[R] property does not contain
\f[CR]\[dq]g\[dq]\f[R]).
.SH DESCRIPTION
The implementation of \f[CR]String.prototype.matchAll\f[R] doesn\[cq]t
do much other than calling the \f[CR]Symbol.matchAll\f[R] method of the
argument with the string as the first parameter (apart from the extra
input validation that the regex is global).
The actual implementation comes from
\f[CR]RegExp.prototype[Symbol.matchAll]()\f[R].
.SH EXAMPLES
.SS Regexp.prototype.exec() and matchAll()
Without \f[CR]matchAll()\f[R], it\[cq]s possible to use calls to
\f[CR]regexp.exec()\f[R] (and regexes with the \f[CR]g\f[R] flag) in a
loop to obtain all the matches:
.IP
.EX
\f[B]const\f[R] regexp = /foo[a\-z]*/g;
\f[B]const\f[R] str = \[dq]table football, foosball\[dq];
\f[B]let\f[R] match;

\f[B]while\f[R] ((match = regexp.exec(str)) !== \f[B]null\f[R]) {
  console.log(
    \[ga]Found ${match[0]} start=${match.index} end=${regexp.lastIndex}.\[ga],
  );
}
\f[I]// Found football start=6 end=14.\f[R]
\f[I]// Found foosball start=16 end=24.\f[R]
.EE
.PP
With \f[CR]matchAll()\f[R] available, you can avoid the \f[CR]while\f[R]
loop and \f[CR]exec\f[R] with \f[CR]g\f[R].
Instead, you get an iterator to use with the more convenient
\f[CR]for...of\f[R], array spreading, or \f[CR]Array.from()\f[R]
constructs:
.IP
.EX
\f[B]const\f[R] regexp = /foo[a\-z]*/g;
\f[B]const\f[R] str = \[dq]table football, foosball\[dq];
\f[B]const\f[R] matches = str.matchAll(regexp);

\f[B]for\f[R] (\f[B]const\f[R] match \f[B]of\f[R] matches) {
  console.log(
    \[ga]Found ${match[0]} start=${match.index} end=${
      match.index + match[0].length
    }.\[ga],
  );
}
\f[I]// Found football start=6 end=14.\f[R]
\f[I]// Found foosball start=16 end=24.\f[R]

\f[I]// matches iterator is exhausted after the for...of iteration\f[R]
\f[I]// Call matchAll again to create a new iterator\f[R]
Array.from(str.matchAll(regexp), (m) \f[B]=>\f[R] m[0]);
\f[I]// [ \[dq]football\[dq], \[dq]foosball\[dq] ]\f[R]
.EE
.PP
\f[CR]matchAll\f[R] will throw an exception if the \f[CR]g\f[R] flag is
missing.
.IP
.EX
\f[B]const\f[R] regexp = /[a\-c]/;
\f[B]const\f[R] str = \[dq]abc\[dq];
str.matchAll(regexp);
\f[I]// TypeError\f[R]
.EE
.PP
\f[CR]matchAll\f[R] internally makes a clone of the \f[CR]regexp\f[R]
\[em] so, unlike \f[CR]regexp.exec()\f[R], \f[CR]lastIndex\f[R] does not
change as the string is scanned.
.IP
.EX
\f[B]const\f[R] regexp = /[a\-c]/g;
regexp.lastIndex = 1;
\f[B]const\f[R] str = \[dq]abc\[dq];
Array.from(str.matchAll(regexp), (m) \f[B]=>\f[R] \[ga]${regexp.lastIndex} ${m[0]}\[ga]);
\f[I]// [ \[dq]1 b\[dq], \[dq]1 c\[dq] ]\f[R]
.EE
.PP
However, this means that unlike using \f[CR]regexp.exec()\f[R] in a
loop, you can\[cq]t mutate \f[CR]lastIndex\f[R] to make the regex
advance or rewind.
.SS Better access to capturing groups (than String.prototype.match())
Another compelling reason for \f[CR]matchAll\f[R] is the improved access
to capture groups.
.PP
Capture groups are ignored when using \f[CR]match()\f[R] with the global
\f[CR]g\f[R] flag:
.IP
.EX
\f[B]const\f[R] regexp = /t(e)(st(\[rs]d?))/g;
\f[B]const\f[R] str = \[dq]test1test2\[dq];

str.match(regexp); \f[I]// [\[aq]test1\[aq], \[aq]test2\[aq]]\f[R]
.EE
.PP
Using \f[CR]matchAll\f[R], you can access capture groups easily:
.IP
.EX
\f[B]const\f[R] array = [...str.matchAll(regexp)];

array[0];
\f[I]// [\[aq]test1\[aq], \[aq]e\[aq], \[aq]st1\[aq], \[aq]1\[aq], index: 0, input: \[aq]test1test2\[aq], length: 4]\f[R]
array[1];
\f[I]// [\[aq]test2\[aq], \[aq]e\[aq], \[aq]st2\[aq], \[aq]2\[aq], index: 5, input: \[aq]test1test2\[aq], length: 4]\f[R]
.EE
.SS Using matchAll() with a non\-RegExp implementing \f[CR][Symbol.matchAll]()\f[R]
If an object has a \f[CR]Symbol.matchAll\f[R] method, it can be used as
a custom matcher.
The return value of \f[CR]Symbol.matchAll\f[R] becomes the return value
of \f[CR]matchAll()\f[R].
.IP
.EX
\f[B]const\f[R] str = \[dq]Hmm, this is interesting.\[dq];

str.matchAll({
  [Symbol.matchAll](str) {
    \f[B]return\f[R] [[\[dq]Yes, it\[aq]s interesting.\[dq]]];
  },
}); \f[I]// returns [[\[dq]Yes, it\[aq]s interesting.\[dq]]]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-string-and-regexp
Polyfill of \f[CR]String.prototype.matchAll\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Regular expressions guide
.IP \[bu] 2
Groups and backreferences guide
.IP \[bu] 2
\f[CR]String.prototype.match()\f[R]
.IP \[bu] 2
\f[CR]RegExp\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.exec()\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.test()\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype[Symbol.matchAll]()\f[R]
