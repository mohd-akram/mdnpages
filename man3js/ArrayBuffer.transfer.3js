.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ARRAYBUFFER.TRANSFER" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ArrayBuffer.transfer \- ArrayBuffer.prototype.transfer()
.SH SYNOPSIS
The \f[B]\f[CB]transfer()\f[B]\f[R] method of \f[CR]ArrayBuffer\f[R]
instances creates a new \f[CR]ArrayBuffer\f[R] with the same byte
content as this buffer, then detaches this buffer.
.SH SYNTAX
.IP
.EX
transfer()
transfer(newByteLength)
.EE
.SS Parameters
.TP
\f[B]newByteLength\f[R] \f[I](optional)\f[R]
The \f[CR]byteLength\f[R] of the new \f[CR]ArrayBuffer\f[R].
Defaults to the \f[CR]byteLength\f[R] of this \f[CR]ArrayBuffer\f[R].
.RS
.IP \(bu 2
If \f[CR]newByteLength\f[R] is smaller than the \f[CR]byteLength\f[R] of
this \f[CR]ArrayBuffer\f[R], the \(lqoverflowing\(rq bytes are dropped.
.IP \(bu 2
If \f[CR]newByteLength\f[R] is larger than the \f[CR]byteLength\f[R] of
this \f[CR]ArrayBuffer\f[R], the extra bytes are filled with zeros.
.IP \(bu 2
If this \f[CR]ArrayBuffer\f[R] is resizable, \f[CR]newByteLength\f[R]
must not be greater than its \f[CR]maxByteLength\f[R].
.RE
.SS Return value
A new \f[CR]ArrayBuffer\f[R] object.
Its contents are initialized to the contents of this
\f[CR]ArrayBuffer\f[R], and extra bytes, if any, are filled with zeros.
The new \f[CR]ArrayBuffer\f[R] is resizable if and only if this
\f[CR]ArrayBuffer\f[R] is resizable, in which case its
\f[CR]maxByteLength\f[R] is the same as this
\f[CR]ArrayBuffer\f[R]\(cqs.
The original \f[CR]ArrayBuffer\f[R] is detached.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if this \f[CR]ArrayBuffer\f[R] is resizable and
\f[CR]newByteLength\f[R] is greater than the \f[CR]maxByteLength\f[R] of
this \f[CR]ArrayBuffer\f[R].
.TP
\f[B]TypeError\f[R]
Thrown if this \f[CR]ArrayBuffer\f[R] is already detached.
.SH DESCRIPTION
The \f[CR]transfer()\f[R] method performs the same operation as the
structured clone algorithm.
It copies the bytes of this \f[CR]ArrayBuffer\f[R] into a new
\f[CR]ArrayBuffer\f[R] object, then detaches this \f[CR]ArrayBuffer\f[R]
object.
See transferring ArrayBuffers for more information.
.PP
\f[CR]transfer()\f[R] preserves the resizability of this
\f[CR]ArrayBuffer\f[R].
If you want the new \f[CR]ArrayBuffer\f[R] to be non\-resizable, use
\f[CR]transferToFixedLength()\f[R] instead.
There\(cqs no way to transfer a buffer that makes a fixed\-length buffer
become resizable.
.PP
\f[CR]transfer()\f[R] is very efficient because implementations may
implement this method as a zero\-copy move or a \f[CR]realloc\f[R] \(em
there does not need to be an actual copy of the data.
.SH EXAMPLES
.SS Transferring an ArrayBuffer
.IP
.EX
\f[I]// Create an ArrayBuffer and write a few bytes\f[R]
\f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(8);
\f[B]const\f[R] view = \f[B]new\f[R] Uint8Array(buffer);
view[1] = 2;
view[7] = 4;

\f[I]// Copy the buffer to the same size\f[R]
\f[B]const\f[R] buffer2 = buffer.transfer();
console.log(buffer.detached); \f[I]// true\f[R]
console.log(buffer2.byteLength); \f[I]// 8\f[R]
\f[B]const\f[R] view2 = \f[B]new\f[R] Uint8Array(buffer2);
console.log(view2[1]); \f[I]// 2\f[R]
console.log(view2[7]); \f[I]// 4\f[R]

\f[I]// Copy the buffer to a smaller size\f[R]
\f[B]const\f[R] buffer3 = buffer2.transfer(4);
console.log(buffer3.byteLength); \f[I]// 4\f[R]
\f[B]const\f[R] view3 = \f[B]new\f[R] Uint8Array(buffer3);
console.log(view3[1]); \f[I]// 2\f[R]
console.log(view3[7]); \f[I]// undefined\f[R]

\f[I]// Copy the buffer to a larger size\f[R]
\f[B]const\f[R] buffer4 = buffer3.transfer(8);
console.log(buffer4.byteLength); \f[I]// 8\f[R]
\f[B]const\f[R] view4 = \f[B]new\f[R] Uint8Array(buffer4);
console.log(view4[1]); \f[I]// 2\f[R]
console.log(view4[7]); \f[I]// 0\f[R]

\f[I]// Already detached, throws TypeError\f[R]
buffer.transfer(); \f[I]// TypeError: Cannot perform ArrayBuffer.prototype.transfer on a detached ArrayBuffer\f[R]
.EE
.SS Transferring a resizable ArrayBuffer
.IP
.EX
\f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(8, { maxByteLength: 16 });
\f[B]const\f[R] view = \f[B]new\f[R] Uint8Array(buffer);
view[1] = 2;
view[7] = 4;

\f[I]// Copy the buffer to a smaller size\f[R]
\f[B]const\f[R] buffer2 = buffer.transfer(4);
console.log(buffer2.byteLength); \f[I]// 4\f[R]
console.log(buffer2.maxByteLength); \f[I]// 16\f[R]
\f[B]const\f[R] view2 = \f[B]new\f[R] Uint8Array(buffer2);
console.log(view2[1]); \f[I]// 2\f[R]
console.log(view2[7]); \f[I]// undefined\f[R]
buffer2.resize(8);
console.log(view2[7]); \f[I]// 0\f[R]

\f[I]// Copy the buffer to a larger size within maxByteLength\f[R]
\f[B]const\f[R] buffer3 = buffer2.transfer(12);
console.log(buffer3.byteLength); \f[I]// 12\f[R]

\f[I]// Copy the buffer to a larger size than maxByteLength\f[R]
buffer3.transfer(20); \f[I]// RangeError: Invalid array buffer length\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#arraybufferprototypetransfer-and-friends
Polyfill of \f[CR]ArrayBuffer.prototype.transfer\f[R] in
\f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/arraybuffer.prototype.transfer
es\-shims polyfill of \f[CR]ArrayBuffer.prototype.transfer\f[R]
.UE \c
.IP \(bu 2
\f[CR]ArrayBuffer\f[R]
.IP \(bu 2
\f[CR]ArrayBuffer.prototype.detached\f[R]
.IP \(bu 2
\f[CR]ArrayBuffer.prototype.transferToFixedLength()\f[R]
