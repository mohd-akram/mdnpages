.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "REGEXP.SYMBOL.MATCHALL" "3JS" "April 3, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RegExp.Symbol.matchAll \- RegExp.prototypeSymbol.matchAll
.SH SYNOPSIS
The \f[B]\f[CB][Symbol.matchAll]()\f[B]\f[R] method of \f[CR]RegExp\f[R]
instances specifies how \f[CR]String.prototype.matchAll\f[R] should
behave.
.IP
.EX
\f[B]class\f[R] MyRegExp \f[B]extends\f[R] RegExp {
  [Symbol.matchAll](str) {
    \f[B]const\f[R] result = RegExp.prototype[Symbol.matchAll].call(\f[B]this\f[R], str);
    \f[B]if\f[R] (!result) {
      \f[B]return\f[R] \f[B]null\f[R];
    }
    \f[B]return\f[R] Array.from(result);
  }
}

\f[B]const\f[R] re = \f[B]new\f[R] MyRegExp(\(dq\-[0\-9]+\(dq, \(dqg\(dq);
console.log(\(dq2016\-01\-02|2019\-03\-07\(dq.matchAll(re));
\f[I]// Expected output: Array [Array [\(dq\-01\(dq], Array [\(dq\-02\(dq], Array [\(dq\-03\(dq], Array [\(dq\-07\(dq]]\f[R]
.EE
.SH SYNTAX
.IP
.EX
regexp[Symbol.matchAll](str)
.EE
.SS Parameters
.TP
\f[B]str\f[R]
A \f[CR]String\f[R] that is a target of the match.
.SS Return value
An iterable iterator object (which is not restartable) of matches.
Each match is an array with the same shape as the return value of
\f[CR]RegExp.prototype.exec()\f[R].
.SH DESCRIPTION
This method is called internally in
\f[CR]String.prototype.matchAll()\f[R].
For example, the following two examples return the same result.
.IP
.EX
\(dqabc\(dq.matchAll(/a/g);

/a/g[Symbol.matchAll](\(dqabc\(dq);
.EE
.PP
Like \f[CR][Symbol.split]()\f[R], \f[CR][Symbol.matchAll]()\f[R] starts
by using \f[CR][Symbol.species]\f[R] to construct a new regex, thus
avoiding mutating the original regexp in any way.
\f[CR]lastIndex\f[R] starts as the original regex\(cqs value.
.IP
.EX
\f[B]const\f[R] regexp = /[a\-c]/g;
regexp.lastIndex = 1;
\f[B]const\f[R] str = \(dqabc\(dq;
Array.from(str.matchAll(regexp), (m) \f[B]=>\f[R] \(ga${regexp.lastIndex} ${m[0]}\(ga);
\f[I]// [ \(dq1 b\(dq, \(dq1 c\(dq ]\f[R]
.EE
.PP
The validation that the input is a global regex happens in
\f[CR]String.prototype.matchAll()\f[R].
\f[CR][Symbol.matchAll]()\f[R] does not validate the input.
If the regex is not global, the returned iterator yields the
\f[CR]exec()\f[R] result once and then returns \f[CR]undefined\f[R].
If the regexp is global, each time the returned iterator\(cqs
\f[CR]next()\f[R] method is called, the regex\(cqs \f[CR]exec()\f[R] is
called and the result is yielded.
.PP
When the regex is sticky and global, it will still perform sticky
matches \(em i.e., it will not match any occurrences beyond the
\f[CR]lastIndex\f[R].
.IP
.EX
console.log(Array.from(\(dqab\-c\(dq.matchAll(/[abc]/gy)));
\f[I]// [ [ \(dqa\(dq ], [ \(dqb\(dq ] ]\f[R]
.EE
.PP
If the current match is an empty string, the \f[CR]lastIndex\f[R] will
still be advanced.
If the regex has the \f[CR]u\f[R] flag, it advances by one Unicode code
point; otherwise, it advances by one UTF\-16 code point.
.IP
.EX
console.log(Array.from(\(dqðŸ˜„\(dq.matchAll(/(?:)/g)));
\f[I]// [ [ \(dq\(dq ], [ \(dq\(dq ], [ \(dq\(dq ] ]\f[R]

console.log(Array.from(\(dqðŸ˜„\(dq.matchAll(/(?:)/gu)));
\f[I]// [ [ \(dq\(dq ], [ \(dq\(dq ] ]\f[R]
.EE
.PP
This method exists for customizing the behavior of \f[CR]matchAll()\f[R]
in \f[CR]RegExp\f[R] subclasses.
.SH EXAMPLES
.SS Direct call
This method can be used in almost the same way as
\f[CR]String.prototype.matchAll()\f[R], except for the different value
of \f[CR]this\f[R] and the different order of arguments.
.IP
.EX
\f[B]const\f[R] re = /[0\-9]+/g;
\f[B]const\f[R] str = \(dq2016\-01\-02\(dq;
\f[B]const\f[R] result = re[Symbol.matchAll](str);

console.log(Array.from(result, (x) \f[B]=>\f[R] x[0]));
\f[I]// [ \(dq2016\(dq, \(dq01\(dq, \(dq02\(dq ]\f[R]
.EE
.SS Using \f[CR][Symbol.matchAll]()\f[R] in subclasses
Subclasses of \f[CR]RegExp\f[R] can override the
\f[CR][Symbol.matchAll]()\f[R] method to modify the default behavior.
.PP
For example, to return an \f[CR]Array\f[R] instead of an iterator:
.IP
.EX
\f[B]class\f[R] MyRegExp \f[B]extends\f[R] RegExp {
  [Symbol.matchAll](str) {
    \f[B]const\f[R] result = RegExp.prototype[Symbol.matchAll].call(\f[B]this\f[R], str);
    \f[B]return\f[R] result ? Array.from(result) : \f[B]null\f[R];
  }
}

\f[B]const\f[R] re = \f[B]new\f[R] MyRegExp(\(dq([0\-9]+)\-([0\-9]+)\-([0\-9]+)\(dq, \(dqg\(dq);
\f[B]const\f[R] str = \(dq2016\-01\-02|2019\-03\-07\(dq;
\f[B]const\f[R] result = str.matchAll(re);

console.log(result[0]);
\f[I]// [ \(dq2016\-01\-02\(dq, \(dq2016\(dq, \(dq01\(dq, \(dq02\(dq ]\f[R]

console.log(result[1]);
\f[I]// [ \(dq2019\-03\-07\(dq, \(dq2019\(dq, \(dq03\(dq, \(dq07\(dq ]\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-string-and-regexp
Polyfill of \f[CR]RegExp.prototype[Symbol.matchAll]\f[R] in
\f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/string.prototype.matchall
es\-shims polyfill of \f[CR]RegExp.prototype[Symbol.matchAll]\f[R]
.UE \c
.IP \(bu 2
\f[CR]String.prototype.matchAll()\f[R]
.IP \(bu 2
\f[CR]RegExp.prototype[Symbol.match]()\f[R]
.IP \(bu 2
\f[CR]RegExp.prototype[Symbol.replace]()\f[R]
.IP \(bu 2
\f[CR]RegExp.prototype[Symbol.search]()\f[R]
.IP \(bu 2
\f[CR]RegExp.prototype[Symbol.split]()\f[R]
.IP \(bu 2
\f[CR]Symbol.matchAll\f[R]
