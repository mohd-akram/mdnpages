.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Iterator.filter" "JS" "November 25, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator.filter \- Iterator.prototype.filter()
.SH SYNOPSIS
The \f[B]\f[CB]filter()\f[B]\f[R] method of \f[CR]Iterator\f[R]
instances returns a new iterator helper object that yields only those
elements of the iterator for which the provided callback function
returns \f[CR]true\f[R].
.SH SYNTAX
.IP
.EX
filter(callbackFn)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element produced by the iterator.
It should return a truthy value to make the element yielded by the
iterator helper, and a falsy value otherwise.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed.
.TP
\f[B]index\f[R]
The index of the current element being processed.
.RE
.SS Return value
A new iterator helper object.
Each time the iterator helper\[cq]s \f[CR]next()\f[R] method is called,
it returns the next element in the iterator for which the callback
function returns \f[CR]true\f[R].
When the underlying iterator is completed, the iterator helper object is
also completed (the \f[CR]next()\f[R] method produces
\f[CR]{ value: undefined, done: true }\f[R]).
.SH DESCRIPTION
The main advantage of iterator helpers over array methods is that they
are lazy, meaning that they only produce the next value when requested.
This avoids unnecessary computation and also allows them to be used with
infinite iterators.
.SH EXAMPLES
.SS Using filter()
The following example creates an iterator that yields terms in the
Fibonacci sequence, and then reads the first few terms that are even:
.IP
.EX
\f[B]function\f[R]* fibonacci() {
  \f[B]let\f[R] current = 1;
  \f[B]let\f[R] next = 1;
  \f[B]while\f[R] (\f[B]true\f[R]) {
    \f[B]yield\f[R] current;
    [current, next] = [next, current + next];
  }
}

\f[B]const\f[R] seq = fibonacci().filter((x) \f[B]=>\f[R] x % 2 === 0);
console.log(seq.next().value); \f[I]// 2\f[R]
console.log(seq.next().value); \f[I]// 8\f[R]
console.log(seq.next().value); \f[I]// 34\f[R]
.EE
.SS Using filter() with a for\&...of loop
\f[CR]filter()\f[R] is most convenient when you are not hand\-rolling
the iterator.
Because iterators are also iterable, you can iterate the returned helper
with a \f[CR]for...of\f[R] loop:
.IP
.EX
\f[B]for\f[R] (\f[B]const\f[R] n \f[B]of\f[R] fibonacci().filter((x) \f[B]=>\f[R] x % 2 === 0)) {
  console.log(n);
  \f[B]if\f[R] (n > 30) {
    \f[B]break\f[R];
  }
}

\f[I]// Logs:\f[R]
\f[I]// 2\f[R]
\f[I]// 8\f[R]
\f[I]// 34\f[R]
.EE
.PP
This is equivalent to:
.IP
.EX
\f[B]for\f[R] (\f[B]const\f[R] n \f[B]of\f[R] fibonacci()) {
  \f[B]if\f[R] (n % 2 !== 0) {
    \f[B]continue\f[R];
  }
  console.log(n);
  \f[B]if\f[R] (n > 30) {
    \f[B]break\f[R];
  }
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#iterator-helpers
Polyfill of \f[CR]Iterator.prototype.filter\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Iterator\f[R]
.IP \[bu] 2
\f[CR]Iterator.prototype.forEach()\f[R]
.IP \[bu] 2
\f[CR]Iterator.prototype.every()\f[R]
.IP \[bu] 2
\f[CR]Iterator.prototype.map()\f[R]
.IP \[bu] 2
\f[CR]Iterator.prototype.some()\f[R]
.IP \[bu] 2
\f[CR]Iterator.prototype.reduce()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.filter()\f[R]
