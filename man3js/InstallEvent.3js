.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "InstallEvent" "JS" "October 9, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
InstallEvent \- InstallEvent
.SH SYNOPSIS
The parameter passed into an \f[CR]install\f[R] event handler function,
the \f[CR]InstallEvent\f[R] interface represents an install action that
is dispatched on the \f[CR]ServiceWorkerGlobalScope\f[R] of a
\f[CR]ServiceWorker\f[R].
As a child of \f[CR]ExtendableEvent\f[R], it ensures that functional
events such as \f[CR]FetchEvent\f[R] are not dispatched during
installation.
.PP
This interface inherits from the \f[CR]ExtendableEvent\f[R] interface.
.SH CONSTRUCTOR
.TP
\f[B]InstallEvent()\f[R] \f[I](experimental)\f[R]
Creates a new \f[CR]InstallEvent\f[R] object.
.SH INSTANCE PROPERTIES
\f[I]Inherits properties from its parent,
\f[CI]ExtendableEvent\f[I]\f[R].
.SH INSTANCE METHODS
\f[I]Inherits methods from its parent, \f[CI]ExtendableEvent\f[I]\f[R].
.TP
\f[B]addRoutes()\f[R] \f[I](experimental)\f[R]
Specifies one or more static routes, which define rules for fetching
specified resources that will be used even before service worker
startup.
.SH EXAMPLES
This code snippet is from the \c
.UR https://github.com/GoogleChrome/samples/blob/gh-pages/service-worker/prefetch/service-worker.js
service worker prefetch sample
.UE \c
\ (see \c
.UR https://googlechrome.github.io/samples/service-worker/prefetch/
prefetch running live
.UE \c
\&.)
The code calls \f[CR]ExtendableEvent.waitUntil()\f[R] in
\f[CR]ServiceWorkerGlobalScope.oninstall\f[R] and delays treating the
\f[CR]ServiceWorkerRegistration.installing\f[R] worker as installed
until the passed promise resolves successfully.
The promise resolves when all resources have been fetched and cached, or
when any exception occurs.
.PP
The code snippet also shows a best practice for versioning caches used
by the service worker.
Although this example has only one cache, you can use this approach for
multiple caches.
The code maps a shorthand identifier for a cache to a specific,
versioned cache name.
.RS
.PP
\f[B]Note:\f[R] Logging statements are visible in Google Chrome via the
\[lq]Inspect\[rq] interface for the relevant service worker accessed via
chrome://serviceworker\-internals.
.RE
.IP
.EX
\f[B]const\f[R] CACHE_VERSION = 1;
\f[B]const\f[R] CURRENT_CACHES = {
  prefetch: \[ga]prefetch\-cache\-v${CACHE_VERSION}\[ga],
};

self.addEventListener(\[dq]install\[dq], (event) \f[B]=>\f[R] {
  \f[B]const\f[R] urlsToPrefetch = [
    \[dq]./static/pre_fetched.txt\[dq],
    \[dq]./static/pre_fetched.html\[dq],
    \[dq]https://www.chromium.org/_/rsrc/1302286216006/config/customLogo.gif\[dq],
  ];

  console.log(
    \[dq]Handling install event. Resources to pre\-fetch:\[dq],
    urlsToPrefetch,
  );

  event.waitUntil(
    caches
      .open(CURRENT_CACHES[\[dq]prefetch\[dq]])
      .then((cache) \f[B]=>\f[R] {
        \f[B]return\f[R] cache
          .addAll(
            urlsToPrefetch.map((urlToPrefetch) \f[B]=>\f[R] {
              \f[B]return\f[R] \f[B]new\f[R] Request(urlToPrefetch, { mode: \[dq]no\-cors\[dq] });
            }),
          )
          .then(() \f[B]=>\f[R] {
            console.log(\[dq]All resources have been fetched and cached.\[dq]);
          });
      })
      .catch((error) \f[B]=>\f[R] {
        console.error(\[dq]Pre\-fetching failed:\[dq], error);
      }),
  );
});
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]install\f[R] event
.IP \[bu] 2
\f[CR]NotificationEvent\f[R]
.IP \[bu] 2
\f[CR]Promise\f[R]
.IP \[bu] 2
Fetch API
