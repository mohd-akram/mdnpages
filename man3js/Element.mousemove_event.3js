.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Element.mousemove_event" "JS" "March 4, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Element.mousemove_event \- Element: mousemove event
.SH SYNOPSIS
The \f[CR]mousemove\f[R] event is fired at an element when a pointing
device (usually a mouse) is moved while the cursor\[cq]s hotspot is
inside it.
.PP
These events happen whether or not any mouse buttons are pressed.
They can fire at a very high rate, depends on how fast the user moves
the mouse, how fast the machine is, what other tasks and processes are
happening, etc.
.SH SYNTAX
Use the event name in methods like \f[CR]addEventListener()\f[R], or set
an event handler property.
.IP
.EX
addEventListener(\[dq]mousemove\[dq], (event) \f[B]=>\f[R] {});

onmousemove = (event) \f[B]=>\f[R] {};
.EE
.SH EVENT TYPE
A \f[CR]MouseEvent\f[R].
Inherits from \f[CR]UIEvent\f[R] and \f[CR]Event\f[R].
.SH EVENT PROPERTIES
\f[I]This interface also inherits properties of its parents,
\f[CI]UIEvent\f[I] and \f[CI]Event\f[I].\f[R]
.TP
\f[B]MouseEvent.altKey\f[R] \f[I](read\-only)\f[R]
Returns \f[CR]true\f[R] if the alt key was down when the mouse event was
fired.
.TP
\f[B]MouseEvent.button\f[R] \f[I](read\-only)\f[R]
The button number that was pressed (if applicable) when the mouse event
was fired.
.TP
\f[B]MouseEvent.buttons\f[R] \f[I](read\-only)\f[R]
The buttons being pressed (if any) when the mouse event was fired.
.TP
\f[B]MouseEvent.clientX\f[R] \f[I](read\-only)\f[R]
The X coordinate of the mouse pointer in viewport coordinates.
.TP
\f[B]MouseEvent.clientY\f[R] \f[I](read\-only)\f[R]
The Y coordinate of the mouse pointer in viewport coordinates.
.TP
\f[B]MouseEvent.ctrlKey\f[R] \f[I](read\-only)\f[R]
Returns \f[CR]true\f[R] if the control key was down when the mouse event
was fired.
.TP
\f[B]MouseEvent.layerX\f[R] \f[I](non\-standard)\f[R] \f[I](read\-only)\f[R]
Returns the horizontal coordinate of the event relative to the current
layer.
.TP
\f[B]MouseEvent.layerY\f[R] \f[I](non\-standard)\f[R] \f[I](read\-only)\f[R]
Returns the vertical coordinate of the event relative to the current
layer.
.TP
\f[B]MouseEvent.metaKey\f[R] \f[I](read\-only)\f[R]
Returns \f[CR]true\f[R] if the meta key was down when the mouse event
was fired.
.TP
\f[B]MouseEvent.movementX\f[R] \f[I](read\-only)\f[R]
The X coordinate of the mouse pointer relative to the position of the
last \f[CR]mousemove\f[R] event.
.TP
\f[B]MouseEvent.movementY\f[R] \f[I](read\-only)\f[R]
The Y coordinate of the mouse pointer relative to the position of the
last \f[CR]mousemove\f[R] event.
.TP
\f[B]MouseEvent.offsetX\f[R] \f[I](read\-only)\f[R]
The X coordinate of the mouse pointer relative to the position of the
padding edge of the target node.
.TP
\f[B]MouseEvent.offsetY\f[R] \f[I](read\-only)\f[R]
The Y coordinate of the mouse pointer relative to the position of the
padding edge of the target node.
.TP
\f[B]MouseEvent.pageX\f[R] \f[I](read\-only)\f[R]
The X coordinate of the mouse pointer relative to the whole document.
.TP
\f[B]MouseEvent.pageY\f[R] \f[I](read\-only)\f[R]
The Y coordinate of the mouse pointer relative to the whole document.
.TP
\f[B]MouseEvent.relatedTarget\f[R] \f[I](read\-only)\f[R]
The secondary target for the event, if there is one.
.TP
\f[B]MouseEvent.screenX\f[R] \f[I](read\-only)\f[R]
The X coordinate of the mouse pointer in screen coordinates.
.TP
\f[B]MouseEvent.screenY\f[R] \f[I](read\-only)\f[R]
The Y coordinate of the mouse pointer in screen coordinates.
.TP
\f[B]MouseEvent.shiftKey\f[R] \f[I](read\-only)\f[R]
Returns \f[CR]true\f[R] if the shift key was down when the mouse event
was fired.
.TP
\f[B]MouseEvent.mozInputSource\f[R] \f[I](non\-standard)\f[R] \f[I](read\-only)\f[R]
The type of device that generated the event (one of the
\f[CR]MOZ_SOURCE_*\f[R] constants).
This lets you, for example, determine whether a mouse event was
generated by an actual mouse or by a touch event (which might affect the
degree of accuracy with which you interpret the coordinates associated
with the event).
.TP
\f[B]MouseEvent.webkitForce\f[R] \f[I](non\-standard)\f[R] \f[I](read\-only)\f[R]
The amount of pressure applied when clicking.
.TP
\f[B]MouseEvent.x\f[R] \f[I](read\-only)\f[R]
Alias for \f[CR]MouseEvent.clientX\f[R].
.TP
\f[B]MouseEvent.y\f[R] \f[I](read\-only)\f[R]
Alias for \f[CR]MouseEvent.clientY\f[R].
.SH EXAMPLES
The following example uses the \f[CR]mousedown\f[R],
\f[CR]mousemove\f[R], and \f[CR]mouseup\f[R] events to allow the user to
draw on an HTML canvas.
Its functionality is simple: the thickness of the line is set to 1, and
the color is always black.
.PP
When the page loads, constants \f[CR]myPics\f[R] and \f[CR]context\f[R]
are created to store a reference to the canvas and the 2d context we
will use to draw.
.PP
Drawing begins when the \f[CR]mousedown\f[R] event fires.
First we store the x and y coordinates of the mouse pointer in the
variables \f[CR]x\f[R] and \f[CR]y\f[R], and then set
\f[CR]isDrawing\f[R] to true.
.PP
As the mouse moves over the page, the \f[CR]mousemove\f[R] event fires.
If \f[CR]isDrawing\f[R] is true, the event handler calls the
\f[CR]drawLine\f[R] function to draw a line from the stored \f[CR]x\f[R]
and \f[CR]y\f[R] values to the current location.
.PP
When the \f[CR]drawLine()\f[R] function returns, we adjust the
coordinates and then save them in \f[CR]x\f[R] and \f[CR]y\f[R].
.PP
The \f[CR]mouseup\f[R] event draws the final line segment, sets
\f[CR]x\f[R] and \f[CR]y\f[R] to \f[CR]0\f[R], and stops further drawing
by setting \f[CR]isDrawing\f[R] to \f[CR]false\f[R].
.SS HTML
.IP
.EX
<\f[B]h1\f[R]>Drawing with mouse events</\f[B]h1\f[R]>
<\f[B]canvas\f[R] id=\[dq]myPics\[dq] width=\[dq]560\[dq] height=\[dq]360\[dq]></\f[B]canvas\f[R]>
.EE
.SS CSS
.IP
.EX
canvas {
  \f[B]border\f[R]: 1px solid black;
  \f[B]width\f[R]: 560px;
  \f[B]height\f[R]: 360px;
}
.EE
.SS JavaScript
.IP
.EX
\f[I]// When true, moving the mouse draws on the canvas\f[R]
\f[B]let\f[R] isDrawing = \f[B]false\f[R];
\f[B]let\f[R] x = 0;
\f[B]let\f[R] y = 0;

\f[B]const\f[R] myPics = document.getElementById(\[dq]myPics\[dq]);
\f[B]const\f[R] context = myPics.getContext(\[dq]2d\[dq]);

\f[I]// event.offsetX, event.offsetY gives the (x,y) offset from the edge of the canvas.\f[R]

\f[I]// Add the event listeners for mousedown, mousemove, and mouseup\f[R]
myPics.addEventListener(\[dq]mousedown\[dq], (e) \f[B]=>\f[R] {
  x = e.offsetX;
  y = e.offsetY;
  isDrawing = \f[B]true\f[R];
});

myPics.addEventListener(\[dq]mousemove\[dq], (e) \f[B]=>\f[R] {
  \f[B]if\f[R] (isDrawing) {
    drawLine(context, x, y, e.offsetX, e.offsetY);
    x = e.offsetX;
    y = e.offsetY;
  }
});

window.addEventListener(\[dq]mouseup\[dq], (e) \f[B]=>\f[R] {
  \f[B]if\f[R] (isDrawing) {
    drawLine(context, x, y, e.offsetX, e.offsetY);
    x = 0;
    y = 0;
    isDrawing = \f[B]false\f[R];
  }
});

\f[B]function\f[R] drawLine(context, x1, y1, x2, y2) {
  context.beginPath();
  context.strokeStyle = \[dq]black\[dq];
  context.lineWidth = 1;
  context.moveTo(x1, y1);
  context.lineTo(x2, y2);
  context.stroke();
  context.closePath();
}
.EE
.SS Result
.SH SEE ALSO
.IP \[bu] 2
Learn: Introduction to events
.IP \[bu] 2
\f[CR]mousedown\f[R]
.IP \[bu] 2
\f[CR]mouseup\f[R]
.IP \[bu] 2
\f[CR]click\f[R]
.IP \[bu] 2
\f[CR]dblclick\f[R]
.IP \[bu] 2
\f[CR]mouseover\f[R]
.IP \[bu] 2
\f[CR]mouseout\f[R]
.IP \[bu] 2
\f[CR]mouseenter\f[R]
.IP \[bu] 2
\f[CR]mouseleave\f[R]
.IP \[bu] 2
\f[CR]contextmenu\f[R]
.IP \[bu] 2
\f[CR]pointermove\f[R]
