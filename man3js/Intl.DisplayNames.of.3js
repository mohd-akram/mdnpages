.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Intl.DisplayNames.of" "JS" "April 28, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.DisplayNames.of \- Intl.DisplayNames.prototype.of()
.SH SYNOPSIS
The \f[B]\f[CB]of()\f[B]\f[R] method of \f[CR]Intl.DisplayNames\f[R]
instances receives a code and returns a string based on the locale and
options provided when instantiating this \f[CR]Intl.DisplayNames\f[R]
object.
.SH SYNTAX
.IP
.EX
of(code)
.EE
.SS Parameters
.TP
\f[B]code\f[R]
The \f[CR]code\f[R] to provide depends on the \f[CR]type\f[R]:
.RS
.IP \[bu] 2
If the type is \[lq]region\[rq], \f[CR]code\f[R] should be either an \c
.UR https://www.iso.org/iso-3166-country-codes.html
two\-letter ISO 3166 region code
.UE \c
, or a \c
.UR https://unstats.un.org/unsd/methodology/m49/
three\-digit UN M49 geographic region
.UE \c
\&.
It is required to follow the \c
.UR https://unicode.org/reports/tr35/#unicode_region_subtag
\f[CR]unicode_region_subtag\f[R]
.UE \c
\ grammar.
.IP \[bu] 2
If the type is \[lq]script\[rq], \f[CR]code\f[R] should be an \c
.UR https://unicode.org/iso15924/iso15924-codes.html
four\-letter ISO 15924 script code
.UE \c
\&.
It is required to follow the \c
.UR https://unicode.org/reports/tr35/#unicode_script_subtag
\f[CR]unicode_script_subtag\f[R]
.UE \c
\ grammar.
.IP \[bu] 2
If the type is \[lq]language\[rq], \f[CR]code\f[R] should be a
\f[I]languageCode\f[R] [\[lq]\-\[rq] \f[I]scriptCode\f[R]] [\[lq]\-\[rq]
\f[I]regionCode\f[R] ] *(\[lq]\-\[rq] \f[I]variant\f[R] ) subsequence of
the \c
.UR https://unicode.org/reports/tr35/#Unicode_language_identifier
\f[CR]unicode_language_id\f[R]
.UE \c
\ grammar.
\f[I]languageCode\f[R] is either a two\-letter ISO 639\-1 language code
or a three\-letter ISO 639\-2 language code.
.IP \[bu] 2
If the type is \[lq]currency\[rq], \f[CR]code\f[R] should be a \c
.UR https://www.iso.org/iso-4217-currency-codes.html
three\-letter ISO 4217 currency code
.UE \c
\&.
It is required to have exactly three alphabetic characters.
.IP \[bu] 2
If the type is \[lq]dateTimeField\[rq], \f[CR]code\f[R] should be one
of: \f[CR]\[dq]era\[dq]\f[R], \f[CR]\[dq]year\[dq]\f[R],
\f[CR]\[dq]quarter\[dq]\f[R], \f[CR]\[dq]month\[dq]\f[R],
\f[CR]\[dq]weekOfYear\[dq]\f[R], \f[CR]\[dq]weekday\[dq]\f[R],
\f[CR]\[dq]day\[dq]\f[R], \f[CR]\[dq]dayPeriod\[dq]\f[R],
\f[CR]\[dq]hour\[dq]\f[R], \f[CR]\[dq]minute\[dq]\f[R],
\f[CR]\[dq]second\[dq]\f[R], \f[CR]\[dq]timeZoneName\[dq]\f[R].
.IP \[bu] 2
If the type is \[lq]calendar\[rq], \f[CR]code\f[R] should be a calendar
key.
It is required to follow the \f[CR]type\f[R] grammar of a \c
.UR https://unicode.org/reports/tr35/#32-unicode-locale-identifier
Unicode locale identifier
.UE \c
\&.
.RE
.SS Return value
A language\-specific formatted string, or \f[CR]undefined\f[R] if
there\[cq]s no data for the input and \f[CR]fallback\f[R] is
\f[CR]\[dq]none\[dq]\f[R].
.RS
.PP
\f[B]Note:\f[R] \f[CR]fallback\f[R] is only used if \f[CR]code\f[R] is
structurally valid.
See using fallback.
.RE
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]code\f[R] is not structurally valid for the given
\f[CR]type\f[R].
.SH EXAMPLES
.SS Using the of method
.IP
.EX
\f[B]const\f[R] regionNames = \f[B]new\f[R] Intl.DisplayNames(\[dq]en\[dq], { type: \[dq]region\[dq] });
regionNames.of(\[dq]419\[dq]); \f[I]// \[dq]Latin America\[dq]\f[R]

\f[B]const\f[R] languageNames = \f[B]new\f[R] Intl.DisplayNames(\[dq]en\[dq], { type: \[dq]language\[dq] });
languageNames.of(\[dq]fr\[dq]); \f[I]// \[dq]French\[dq]\f[R]

\f[B]const\f[R] currencyNames = \f[B]new\f[R] Intl.DisplayNames(\[dq]en\[dq], { type: \[dq]currency\[dq] });
currencyNames.of(\[dq]EUR\[dq]); \f[I]// \[dq]Euro\[dq]\f[R]
.EE
.SS Using fallback
When the \f[CR]Intl.DisplayNames\f[R] is constructed with
\f[CR]fallback: \[dq]code\[dq]\f[R], the \f[CR]of()\f[R] method will
return the \f[CR]code\f[R] if the input looks structurally valid but
there\[cq]s no data for the input.
If \f[CR]fallback\f[R] is \f[CR]\[dq]none\[dq]\f[R],
\f[CR]undefined\f[R] is returned.
.IP
.EX
console.log(
  \f[B]new\f[R] Intl.DisplayNames(\[dq]en\[dq], { type: \[dq]region\[dq], fallback: \[dq]code\[dq] }).of(\[dq]ZL\[dq]),
); \f[I]// \[dq]ZL\[dq]\f[R]

console.log(
  \f[B]new\f[R] Intl.DisplayNames(\[dq]en\[dq], { type: \[dq]region\[dq], fallback: \[dq]none\[dq] }).of(\[dq]ZL\[dq]),
); \f[I]// undefined\f[R]
.EE
.PP
However, this only applies if the \f[CR]code\f[R] is structurally valid.
For example, if \f[CR]type\f[R] is \f[CR]\[dq]region\[dq]\f[R] but
\f[CR]code\f[R] does not follow the \f[CR]unicode_region_subtag\f[R]
grammar (2 alphabetic characters or 3 numeric characters), a
\f[CR]RangeError\f[R] is directly thrown instead of using the fallback.
.IP
.EX
console.log(
  \f[B]new\f[R] Intl.DisplayNames(\[dq]en\[dq], { type: \[dq]region\[dq], fallback: \[dq]code\[dq] }).of(\[dq]ZLC\[dq]),
); \f[I]// throws RangeError: invalid value \[dq]ZLC\[dq] for option region\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Intl.DisplayNames\f[R]
