.\" Automatically generated by Pandoc 3.4
.\"
.TH "Object.is" "JS" "August 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.is \- Object.is()
.SH SYNOPSIS
The \f[B]\f[CB]Object.is()\f[B]\f[R] static method determines whether
two values are the same value.
.SH SYNTAX
.IP
.EX
Object.is(value1, value2)
.EE
.SS Parameters
.TP
\f[B]value1\f[R]
The first value to compare.
.TP
\f[B]value2\f[R]
The second value to compare.
.SS Return value
A boolean indicating whether or not the two arguments are the same
value.
.SH DESCRIPTION
\f[CR]Object.is()\f[R] determines whether two values are the same value.
Two values are the same if one of the following holds:
.IP \[bu] 2
both \f[CR]undefined\f[R]
.IP \[bu] 2
both \f[CR]null\f[R]
.IP \[bu] 2
both \f[CR]true\f[R] or both \f[CR]false\f[R]
.IP \[bu] 2
both strings of the same length with the same characters in the same
order
.IP \[bu] 2
both the same object (meaning both values reference the same object in
memory)
.IP \[bu] 2
both BigInts with the same numeric value
.IP \[bu] 2
both symbols that reference the same symbol value
.IP \[bu] 2
both numbers and
.RS 2
.IP \[bu] 2
both \f[CR]+0\f[R]
.IP \[bu] 2
both \f[CR]\-0\f[R]
.IP \[bu] 2
both \f[CR]NaN\f[R]
.IP \[bu] 2
or both non\-zero, not \f[CR]NaN\f[R], and have the same value
.RE
.PP
\f[CR]Object.is()\f[R] is not equivalent to the \f[CR]==\f[R] operator.
The \f[CR]==\f[R] operator applies various coercions to both sides (if
they are not the same type) before testing for equality (resulting in
such behavior as \f[CR]\[dq]\[dq] == false\f[R] being \f[CR]true\f[R]),
but \f[CR]Object.is()\f[R] doesn\[cq]t coerce either value.
.PP
\f[CR]Object.is()\f[R] is also \f[I]not\f[R] equivalent to the
\f[CR]===\f[R] operator.
The only difference between \f[CR]Object.is()\f[R] and \f[CR]===\f[R] is
in their treatment of signed zeros and \f[CR]NaN\f[R] values.
The \f[CR]===\f[R] operator (and the \f[CR]==\f[R] operator) treats the
number values \f[CR]\-0\f[R] and \f[CR]+0\f[R] as equal, but treats
\f[CR]NaN\f[R] as not equal to each other.
.SH EXAMPLES
.SS Using Object.is()
.IP
.EX
\f[I]// Case 1: Evaluation result is the same as using ===\f[R]
Object.is(25, 25); \f[I]// true\f[R]
Object.is(\[dq]foo\[dq], \[dq]foo\[dq]); \f[I]// true\f[R]
Object.is(\[dq]foo\[dq], \[dq]bar\[dq]); \f[I]// false\f[R]
Object.is(\f[B]null\f[R], \f[B]null\f[R]); \f[I]// true\f[R]
Object.is(\f[B]undefined\f[R], \f[B]undefined\f[R]); \f[I]// true\f[R]
Object.is(window, window); \f[I]// true\f[R]
Object.is([], []); \f[I]// false\f[R]
\f[B]const\f[R] foo = { a: 1 };
\f[B]const\f[R] bar = { a: 1 };
\f[B]const\f[R] sameFoo = foo;
Object.is(foo, foo); \f[I]// true\f[R]
Object.is(foo, bar); \f[I]// false\f[R]
Object.is(foo, sameFoo); \f[I]// true\f[R]

\f[I]// Case 2: Signed zero\f[R]
Object.is(0, \-0); \f[I]// false\f[R]
Object.is(+0, \-0); \f[I]// false\f[R]
Object.is(\-0, \-0); \f[I]// true\f[R]

\f[I]// Case 3: NaN\f[R]
Object.is(\f[B]NaN\f[R], 0 / 0); \f[I]// true\f[R]
Object.is(\f[B]NaN\f[R], Number.NaN); \f[I]// true\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-object
Polyfill of \f[CR]Object.is\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Equality comparisons and sameness
