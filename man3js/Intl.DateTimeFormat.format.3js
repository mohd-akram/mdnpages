.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Intl.DateTimeFormat.format" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.DateTimeFormat.format \- Intl.DateTimeFormat.prototype.format()
.SH SYNOPSIS
The \f[B]\f[CB]format()\f[B]\f[R] method of
\f[CR]Intl.DateTimeFormat\f[R] instances formats a date according to the
locale and formatting options of this \f[CR]Intl.DateTimeFormat\f[R]
object.
.IP
.EX
\f[B]const\f[R] options1 = {
  weekday: \[dq]long\[dq],
  year: \[dq]numeric\[dq],
  month: \[dq]long\[dq],
  day: \[dq]numeric\[dq],
};
\f[B]const\f[R] date1 = \f[B]new\f[R] Date(2012, 5);

\f[B]const\f[R] dateTimeFormat1 = \f[B]new\f[R] Intl.DateTimeFormat(\[dq]sr\-RS\[dq], options1);
console.log(dateTimeFormat1.format(date1));
\f[I]// Expected output: \[dq]петак, 1. јун 2012.\[dq]\f[R]

\f[B]const\f[R] dateTimeFormat2 = \f[B]new\f[R] Intl.DateTimeFormat(\[dq]en\-GB\[dq], options1);
console.log(dateTimeFormat2.format(date1));
\f[I]// Expected output: \[dq]Friday, 1 June 2012\[dq]\f[R]

\f[B]const\f[R] dateTimeFormat3 = \f[B]new\f[R] Intl.DateTimeFormat(\[dq]en\-US\[dq], options1);
console.log(dateTimeFormat3.format(date1));
\f[I]// Expected output: \[dq]Friday, June 1, 2012\[dq]\f[R]
.EE
.SH SYNTAX
.IP
.EX
format(date)
.EE
.SS Parameters
.TP
\f[B]date\f[R]
The date to format.
Can be a \f[CR]Date\f[R] or \f[CR]Temporal.PlainDateTime\f[R] object.
Additionally can be a \f[CR]Temporal.PlainTime\f[R],
\f[CR]Temporal.PlainDate\f[R], \f[CR]Temporal.PlainYearMonth\f[R], or
\f[CR]Temporal.PlainMonthDay\f[R] object if the
\f[CR]DateTimeFormat\f[R] object was configured to print at least one
relevant part of the date.
.RS
.RS
.PP
\f[B]Note:\f[R] A \f[CR]Temporal.ZonedDateTime\f[R] object will always
throw a \f[CR]TypeError\f[R]; use
\f[CR]Temporal.ZonedDateTime.prototype.toLocaleString()\f[R] or convert
it to a \f[CR]Temporal.PlainDateTime\f[R] object instead.
.RE
.PP
Omitting it results in formatting the current date (as returned by
\f[CR]Date.now()\f[R]), which could be slightly confusing, so it is
advisable to always explicitly pass a date.
.RE
.SS Return value
A string representing the given \f[CR]date\f[R] formatted according to
the locale and formatting options of this \f[CR]Intl.DateTimeFormat\f[R]
object.
.RS
.PP
\f[B]Note:\f[R] Most of the time, the formatting returned by
\f[CR]format()\f[R] is consistent.
However, the output may vary between implementations, even within the
same locale \[em] output variations are by design and allowed by the
specification.
It may also not be what you expect.
For example, the string may use non\-breaking spaces or be surrounded by
bidirectional control characters.
You should not compare the results of \f[CR]format()\f[R] to hardcoded
constants.
.RE
.SH EXAMPLES
.SS Using format
Use the \f[CR]format\f[R] getter function for formatting a single date,
here for Serbia:
.IP
.EX
\f[B]const\f[R] options = {
  weekday: \[dq]long\[dq],
  year: \[dq]numeric\[dq],
  month: \[dq]long\[dq],
  day: \[dq]numeric\[dq],
};
\f[B]const\f[R] dateTimeFormat = \f[B]new\f[R] Intl.DateTimeFormat(\[dq]sr\-RS\[dq], options);
console.log(dateTimeFormat.format(\f[B]new\f[R] Date()));
\f[I]// \[dq]недеља, 7. април 2013.\[dq]\f[R]
.EE
.SS Using format with map
Use the \f[CR]format\f[R] getter function for formatting all dates in an
array.
Note that the function is bound to the \f[CR]Intl.DateTimeFormat\f[R]
from which it was obtained, so it can be passed directly to
\f[CR]Array.prototype.map()\f[R].
.IP
.EX
\f[B]const\f[R] a = [\f[B]new\f[R] Date(2012, 8), \f[B]new\f[R] Date(2012, 11), \f[B]new\f[R] Date(2012, 3)];
\f[B]const\f[R] options = { year: \[dq]numeric\[dq], month: \[dq]long\[dq] };
\f[B]const\f[R] dateTimeFormat = \f[B]new\f[R] Intl.DateTimeFormat(\[dq]pt\-BR\[dq], options);
\f[B]const\f[R] formatted = a.map(dateTimeFormat.format);
console.log(formatted.join(\[dq]; \[dq]));
\f[I]// \[dq]setembro de 2012; dezembro de 2012; abril de 2012\[dq]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Intl.DateTimeFormat\f[R]
