.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Reflect.ownKeys" "JS" "September 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Reflect.ownKeys \- Reflect.ownKeys()
.SH SYNOPSIS
The \f[B]\f[CB]Reflect.ownKeys()\f[B]\f[R] static method returns an
array of the \f[CR]target\f[R] object\[cq]s own property keys.
.SH SYNTAX
.IP
.EX
Reflect.ownKeys(target)
.EE
.SS Parameters
.TP
\f[B]target\f[R]
The target object from which to get the own keys.
.SS Return value
An \f[CR]Array\f[R] of the \f[CR]target\f[R] object\[cq]s own property
keys, including strings and symbols.
For most objects, the array will be in the order of:
.IP "1." 3
Non\-negative integer indexes in increasing numeric order (but as
strings)
.IP "2." 3
Other string keys in the order of property creation
.IP "3." 3
Symbol keys in the order of property creation.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if \f[CR]target\f[R] is not an object.
.SH DESCRIPTION
\f[CR]Reflect.ownKeys()\f[R] provides the reflective semantic of
retrieving all property keys of an object.
It is the only way to get all own properties \[en] enumerable and not
enumerable, strings and symbols \[em] in one call, without extra
filtering logic.
For example, \f[CR]Object.getOwnPropertyNames()\f[R] takes the return
value of \f[CR]Reflect.ownKeys()\f[R] and filters to only string values,
while \f[CR]Object.getOwnPropertySymbols()\f[R] filters to only symbol
values.
Because normal objects implement \f[CR][[OwnPropertyKeys]]\f[R] to
return all string keys before symbol keys,
\f[CR]Reflect.ownKeys(target)\f[R] is usually equivalent to
\f[CR]Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))\f[R].
However, if the object has a custom \f[CR][[OwnPropertyKeys]]\f[R]
method (such as through a proxy\[cq]s \f[CR]ownKeys\f[R] handler), the
order of the keys may be different.
.PP
\f[CR]Reflect.ownKeys()\f[R] invokes the \f[CR][[OwnPropertyKeys]]\f[R]
object internal method of \f[CR]target\f[R].
.SH EXAMPLES
.SS Using Reflect.ownKeys()
.IP
.EX
Reflect.ownKeys({ z: 3, y: 2, x: 1 }); // [ \[dq]z\[dq], \[dq]y\[dq], \[dq]x\[dq] ]
Reflect.ownKeys([]); // [\[dq]length\[dq]]

const sym = Symbol.for(\[dq]comet\[dq]);
const sym2 = Symbol.for(\[dq]meteor\[dq]);
const obj = {
  [sym]: 0,
  str: 0,
  773: 0,
  0: 0,
  [sym2]: 0,
  \[dq]\-1\[dq]: 0,
  8: 0,
  \[dq]second str\[dq]: 0,
};
Reflect.ownKeys(obj);
// [ \[dq]0\[dq], \[dq]8\[dq], \[dq]773\[dq], \[dq]str\[dq], \[dq]\-1\[dq], \[dq]second str\[dq], Symbol(comet), Symbol(meteor) ]
// Indexes in numeric order,
// strings in insertion order,
// symbols in insertion order
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-reflect
Polyfill of \f[CR]Reflect.ownKeys\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Reflect\f[R]
.IP \[bu] 2
\f[CR]Object.getOwnPropertyNames()\f[R]
.IP \[bu] 2
\f[CR]Object.getOwnPropertySymbols()\f[R]
.IP \[bu] 2
\f[CR]handler.ownKeys()\f[R]
