.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "REFLECT.OWNKEYS" "3JS" "March 5, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Reflect.ownKeys \- Reflect.ownKeys()
.SH SYNOPSIS
The \f[B]\f[CB]Reflect.ownKeys()\f[B]\f[R] static method returns an
array of the \f[CR]target\f[R] object\(cqs own property keys.
.IP
.EX
\f[B]const\f[R] object1 = {
  property1: 42,
  property2: 13,
};

\f[B]const\f[R] array1 = [];

console.log(Reflect.ownKeys(object1));
\f[I]// Expected output: Array [\(dqproperty1\(dq, \(dqproperty2\(dq]\f[R]

console.log(Reflect.ownKeys(array1));
\f[I]// Expected output: Array [\(dqlength\(dq]\f[R]
.EE
.SH SYNTAX
.IP
.EX
Reflect.ownKeys(target)
.EE
.SS Parameters
.TP
\f[B]target\f[R]
The target object from which to get the own keys.
.SS Return value
An \f[CR]Array\f[R] of the \f[CR]target\f[R] object\(cqs own property
keys, including strings and symbols.
For most objects, the array will be in the order of:
.IP "1." 3
Non\-negative integer indexes in increasing numeric order (but as
strings)
.IP "2." 3
Other string keys in the order of property creation
.IP "3." 3
Symbol keys in the order of property creation.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if \f[CR]target\f[R] is not an object.
.SH DESCRIPTION
\f[CR]Reflect.ownKeys()\f[R] provides the reflective semantic of
retrieving all property keys of an object.
It is the only way to get all own properties \(en enumerable and not
enumerable, strings and symbols \(em in one call, without extra
filtering logic.
For example, \f[CR]Object.getOwnPropertyNames()\f[R] takes the return
value of \f[CR]Reflect.ownKeys()\f[R] and filters to only string values,
while \f[CR]Object.getOwnPropertySymbols()\f[R] filters to only symbol
values.
Because normal objects implement \f[CR][[OwnPropertyKeys]]\f[R] to
return all string keys before symbol keys,
\f[CR]Reflect.ownKeys(target)\f[R] is usually equivalent to
\f[CR]Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))\f[R].
However, if the object has a custom \f[CR][[OwnPropertyKeys]]\f[R]
method (such as through a proxy\(cqs \f[CR]ownKeys\f[R] handler), the
order of the keys may be different.
.PP
\f[CR]Reflect.ownKeys()\f[R] invokes the \f[CR][[OwnPropertyKeys]]\f[R]
object internal method of \f[CR]target\f[R].
.SH EXAMPLES
.SS Using Reflect.ownKeys()
.IP
.EX
Reflect.ownKeys({ z: 3, y: 2, x: 1 }); \f[I]// [ \(dqz\(dq, \(dqy\(dq, \(dqx\(dq ]\f[R]
Reflect.ownKeys([]); \f[I]// [\(dqlength\(dq]\f[R]

\f[B]const\f[R] sym = Symbol.for(\(dqcomet\(dq);
\f[B]const\f[R] sym2 = Symbol.for(\(dqmeteor\(dq);
\f[B]const\f[R] obj = {
  [sym]: 0,
  str: 0,
  773: 0,
  0: 0,
  [sym2]: 0,
  \(dq\-1\(dq: 0,
  8: 0,
  \(dqsecond str\(dq: 0,
};
Reflect.ownKeys(obj);
\f[I]// [ \(dq0\(dq, \(dq8\(dq, \(dq773\(dq, \(dqstr\(dq, \(dq\-1\(dq, \(dqsecond str\(dq, Symbol(comet), Symbol(meteor) ]\f[R]
\f[I]// Indexes in numeric order,\f[R]
\f[I]// strings in insertion order,\f[R]
\f[I]// symbols in insertion order\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-reflect
Polyfill of \f[CR]Reflect.ownKeys\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/reflect.ownkeys
es\-shims polyfill of \f[CR]Reflect.ownKeys\f[R]
.UE \c
.IP \(bu 2
\f[CR]Reflect\f[R]
.IP \(bu 2
\f[CR]Object.getOwnPropertyNames()\f[R]
.IP \(bu 2
\f[CR]Object.getOwnPropertySymbols()\f[R]
.IP \(bu 2
\f[CR]handler.ownKeys()\f[R]
