.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPURENDERBUNDLEENCODER.SETBINDGROUP" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPURenderBundleEncoder.setBindGroup \- GPURenderBundleEncoder:
setBindGroup() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]setBindGroup()\f[B]\f[R] method of the
\f[CR]GPURenderBundleEncoder\f[R] interface sets the
\f[CR]GPUBindGroup\f[R] to use for subsequent render bundle commands,
for a given index.
.RS
.PP
\f[B]Note:\f[R] This method is functionally identical to its equivalent
on \f[CR]GPURenderPassEncoder\f[R] \(em \f[CR]setBindGroup()\f[R].
.RE
.SH SYNTAX
.IP
.EX
setBindGroup(index, bindGroup)
setBindGroup(index, bindGroup, dynamicOffsets)
setBindGroup(index, bindGroup, dynamicOffsets, dynamicOffsetsStart,
             dynamicOffsetsLength)
.EE
.SS Parameters
.TP
\f[B]index\f[R]
The index to set the bind group at.
This matches the \f[CR]n\f[R] index value of the corresponding \c
.UR https://gpuweb.github.io/gpuweb/wgsl/#attribute-group
\f[CR]\(atgroup(n)\f[R]
.UE \c
\ attribute in the shader code (\f[CR]GPUShaderModule\f[R]) used in the
related pipeline.
.TP
\f[B]bindGroup\f[R]
The \f[CR]GPUBindGroup\f[R] to use for subsequent render bundle
commands, or \f[CR]null\f[R], in which case any previously\-set bind
group in the given slot is unset.
.TP
\f[B]dynamicOffsets\f[R] \f[I](optional)\f[R]
A value specifying the offset, in bytes, for each entry in
\f[CR]bindGroup\f[R] with \f[CR]hasDynamicOffset: true\f[R] set (i.e.,
in the descriptor of the \f[CR]GPUDevice.createBindGroupLayout()\f[R]
call that created the \f[CR]GPUBindGroupLayout\f[R] object that the
\f[CR]bindGroup\f[R] is based on).
This value can be:
.RS
.IP \(bu 2
An array of numbers specifying the different offsets.
.IP \(bu 2
A \f[CR]Uint32Array\f[R] containing numbers specifying the offsets.
.RE
.PP
If a \f[CR]Uint32Array\f[R] value is specified for
\f[CR]dynamicOffsets\f[R], both of the following parameters are also
required:
.TP
\f[B]dynamicOffsetsStart\f[R]
A number specifying the offset, in array elements, into
\f[CR]dynamicOffsetsData\f[R], where the dynamic offset data begins.
.TP
\f[B]dynamicOffsetsLength\f[R]
A number specifying the number of dynamic offset values to be read from
in \f[CR]dynamicOffsetsData\f[R].
.SS Return value
None (\f[CR]Undefined\f[R]).
.SS Exceptions
For \f[CR]setBindGroup()\f[R] calls that use a \f[CR]Uint32Array\f[R]
value for \f[CR]dynamicOffsets\f[R], the call will throw with a
\f[CR]RangeError\f[R] \f[CR]DOMException\f[R] if:
.IP \(bu 2
\f[CR]dynamicOffsetsStart\f[R] is less than 0.
.IP \(bu 2
\f[CR]dynamicOffsetsStart\f[R] + \f[CR]dynamicOffsetsLength\f[R] is
greater than \f[CR]dynamicOffsets.length\f[R].
.SS Validation
The following criteria must be met when calling
\f[B]\f[CB]setBindGroup()\f[B]\f[R], otherwise a
\f[CR]GPUValidationError\f[R] is generated and the
\f[CR]GPURenderBundleEncoder\f[R] becomes invalid:
.IP \(bu 2
\f[CR]index\f[R] is less than or equal to the \f[CR]GPUDevice\f[R]\(cqs
\f[CR]maxBindGroups\f[R] limit.
.IP \(bu 2
\f[CR]dynamicOffsets.length\f[R] is the same as the number of entries in
\f[CR]bindGroup\f[R] with \f[CR]hasDynamicOffset: true\f[R] set.
.IP \(bu 2
For \f[CR]bindGroup\f[R] entries where the bound \f[CR]buffer\f[R]\(cqs
\f[CR]type\f[R] is \f[CR]\(dquniform\(dq\f[R] (see
\f[CR]GPUDevice.createBindGroupLayout()\f[R]), each number in
\f[CR]dynamicOffsets\f[R] is a multiple of the \f[CR]GPUDevice\f[R]\(cqs
\f[CR]minUniformBufferOffsetAlignment\f[R] limit.
.IP \(bu 2
For \f[CR]bindGroup\f[R] entries where the bound \f[CR]buffer\f[R]\(cqs
\f[CR]type\f[R] is \f[CR]\(dqstorage\(dq\f[R] or
\f[CR]\(dqread\-only\-storage\(dq\f[R] (see
\f[CR]GPUDevice.createBindGroupLayout()\f[R]), each number in
\f[CR]dynamicOffsets\f[R] is a multiple of the \f[CR]GPUDevice\f[R]\(cqs
\f[CR]minStorageBufferOffsetAlignment\f[R] limit.
.IP \(bu 2
For each \f[CR]bindGroup\f[R] entry, the bound \f[CR]buffer\f[R]\(cqs
\f[CR]offset\f[R], plus the corresponding layout entry\(cqs
\f[CR]minBindingSize\f[R], plus the corresponding dynamic offset
specified in \f[CR]dynamicOffsets\f[R], is less than or equal to the
bound \f[CR]buffer\f[R]\(cqs \f[CR]size\f[R].
.SH EXAMPLES
.SS Set bind group
.IP
.EX
\f[B]function\f[R] recordRenderPass(passEncoder) {
  \f[B]if\f[R] (settings.dynamicOffsets) {
    passEncoder.setPipeline(dynamicPipeline);
  } \f[B]else\f[R] {
    passEncoder.setPipeline(pipeline);
  }
  passEncoder.setVertexBuffer(0, vertexBuffer);
  passEncoder.setBindGroup(0, timeBindGroup);
  \f[B]const\f[R] dynamicOffsets = [0];
  \f[B]for\f[R] (\f[B]let\f[R] i = 0; i < numTriangles; ++i) {
    \f[B]if\f[R] (settings.dynamicOffsets) {
      dynamicOffsets[0] = i * alignedUniformBytes;
      passEncoder.setBindGroup(1, dynamicBindGroup, dynamicOffsets);
    } \f[B]else\f[R] {
      passEncoder.setBindGroup(1, bindGroups[i]);
    }
    passEncoder.draw(3, 1, 0, 0);
  }
}
.EE
.PP
The above snippet is taken from the WebGPU Samples \c
.UR https://webgpu.github.io/webgpu-samples/samples/animometer/
Animometer example
.UE \c
\&.
.SS Unset bind group
.IP
.EX
\f[I]// Set bind group in slot 0\f[R]
passEncoder.setBindGroup(0, timeBindGroup);

\f[I]// Later, unset bind group in slot 0\f[R]
passEncoder.setBindGroup(0, \f[B]null\f[R]);
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
