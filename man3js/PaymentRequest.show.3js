.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "PAYMENTREQUEST.SHOW" "3JS" "August 3, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
PaymentRequest.show \- PaymentRequest: show() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
The \f[B]\f[CB]PaymentRequest\f[B]\f[R] interface\(cqs
\f[B]\f[CB]show()\f[B]\f[R] method instructs the user agent to begin the
process of showing and handling the user interface for the payment
request to the user.
.PP
Only one payment request can be in the process of being handled at once,
across all documents.
Once one \f[CR]PaymentRequest\f[R]\(cqs \f[CR]show()\f[R] method has
been called, any other call to \f[CR]show()\f[R] will by rejected with
an \f[CR]AbortError\f[R] until the returned promise has been concluded,
either by being fulfilled with a \f[CR]PaymentResponse\f[R] indicating
the results of the payment request, or by being rejected with an error.
.RS
.PP
\f[B]Note:\f[R] In reality, despite the fact that the specification says
this can\(cqt be done, some browsers, including Firefox, support
multiple active payment requests at a time.
.RE
.PP
If your architecture doesn\(cqt necessarily have all of the data ready
to go at the moment it instantiates the payment interface by calling
\f[CR]show()\f[R], specify the \f[CR]detailsPromise\f[R] parameter,
providing a \f[CR]Promise\f[R] that is fulfilled once the data is ready.
If this is provided, \f[CR]show()\f[R] will not allow the user to
interact with the payment interface until the promise is fulfilled, so
that data can be updated prior to the user engaging with the payment
process.
.PP
Processing the result and, if necessary, calling
\f[CR]PaymentResponse.retry()\f[R] to retry a failed payment can all be
done either asynchronously or synchronously, depending on your needs.
For the best user experience, asynchronous solutions are typically the
best way to go.
Most examples on MDN and elsewhere use \f[CR]async\f[R]/\f[CR]await\f[R]
to wait asynchronously while results are validated and so forth.
.SH SYNTAX
.IP
.EX
show()
show(details)
.EE
.SS Parameters
.TP
\f[B]details\f[R] \f[I](optional)\f[R]
Either an object or a \f[CR]Promise\f[R] that resolves to an object.
Provide this if your architecture requires that the payment request\(cqs
details need to be updated between instantiating the payment interface
and the user beginning to interact with it.
The object should contain the updated information:
.RS
.TP
\f[B]displayItems\f[R] \f[I](optional)\f[R]
An array of objects, each describing one line item for the payment
request.
These represent the line items on a receipt or invoice, each with the
following properties:
.RS
.TP
\f[B]amount\f[R]
An object describing the monetary value of the item.
This object includes the following fields:
.RS
.TP
\f[B]currency\f[R]
A string containing a valid 3\-letter \c
.UR https://www.iso.org/iso-4217-currency-codes.html
ISO 4217
.UE \c
\ currency identifier (\c
.UR https://en.wikipedia.org/wiki/ISO_4217
ISO 4217
.UE \c
) indicating the currency used for the payment \f[CR]value\f[R].
.TP
\f[B]value\f[R]
A string containing a valid decimal value representing the mount of
currency constituting the payment amount.
This string must only contain an optional leading \(lq\-\(rq to indicate
a negative value, then one or more digits from 0 to 9, and an optional
decimal point (\(lq.\(rq, regardless of locale) followed by at least one
more digit.
No whitespace is permitted.
.RE
.TP
\f[B]label\f[R]
A string specifying a human\-readable name or description of the item or
service being charged for.
This may be displayed to the user by the user agent, depending on the
design of the interface.
.TP
\f[B]pending\f[R]
A Boolean value which is \f[CR]true\f[R] if the specified
\f[CR]amount\f[R] has not yet been finalized.
This can be used to show items such as shipping or tax amounts that
depend upon the selection of shipping address, shipping option, or so
forth.
The user agent may show this information but is not required to do so.
.RE
.TP
\f[B]error\f[R] \f[I](optional)\f[R] \f[I](deprecated)\f[R] \f[I](non\-standard)\f[R]
A string specifying an error message to present to the user.
When calling \f[CR]updateWith()\f[R], including \f[CR]error\f[R] in the
updated data causes the user agent to display the text as a general
error message.
For address\-field specific errors, use the
\f[CR]shippingAddressErrors\f[R] field.
.TP
\f[B]modifiers\f[R] \f[I](optional)\f[R]
An array of objects, each describing a modifier for particular payment
method identifiers, each with the following properties:
.RS
.TP
\f[B]supportedMethods\f[R]
A string that represents the payment method identifier.
The payment method identifier only applies if the user selects this
payment method.
.TP
\f[B]total\f[R] \f[I](optional)\f[R]
An object that overrides the \f[CR]total\f[R] property of the
\f[CR]detailsPromise\f[R] parameter if this payment method is selected
by the user.
The property takes the same input with the \f[CR]total\f[R] property of
the \f[CR]detailsPromise\f[R] parameter.
.TP
\f[B]additionalDisplayItems\f[R] \f[I](optional)\f[R]
An \f[CR]Array\f[R] of objects provide additional display items that are
appended to the \f[CR]displayItems\f[R] property of the
\f[CR]detailsPromise\f[R] parameter if this payment method is selected
by the user.
This property is commonly used to add a discount or surcharge line item
indicating the reason for the different total amount for the selected
payment method that the user agent may display.
The property takes the same input with the \f[CR]displayItems\f[R]
property of the \f[CR]detailsPromise\f[R] parameter.
.TP
\f[B]data\f[R] \f[I](optional)\f[R]
A serializable object that provides optional information that might be
needed by the supported payment methods.
.PP
For example, you can use one to adjust the total payment amount based on
the selected payment method (\(lq5% cash discount!\(rq).
.RE
.TP
\f[B]shippingAddressErrors\f[R] \f[I](optional)\f[R] \f[I](deprecated)\f[R] \f[I](non\-standard)\f[R]
An object which includes an error message for each property of the
shipping address that could not be validated.
.TP
\f[B]shippingOptions\f[R] \f[I](optional)\f[R] \f[I](deprecated)\f[R] \f[I](non\-standard)\f[R]
An array of objects, each describing one available shipping option from
which the user may choose.
.TP
\f[B]total\f[R] \f[I](optional)\f[R]
An object with the same properties as the objects in
\f[CR]displayItems\f[R] providing an updated total for the payment.
Make sure this equals the sum of all of the items in
\f[CR]displayItems\f[R].
\f[I]This is not calculated automatically\f[R].
You must update this value yourself anytime the total amount due
changes.
This lets you have flexibility for how to handle things like tax,
discounts, and other adjustments to the total price charged.
.RE
.SS Return value
A \f[CR]Promise\f[R] that eventually resolves with a
\f[CR]PaymentResponse\f[R].
The promise is resolved when the user accepts the payment request (such
as by clicking a \(lqPay\(rq button in the browser\(cqs payment sheet).
.SS Exceptions
Exceptions are not thrown but returned when the \f[CR]Promise\f[R]
rejects.
.TP
\f[B]AbortError\f[R] \f[B]DOMException\f[R]
Returned if the user agent is already showing a payment panel.
Only one payment panel may be visible at a time \f[I]across all
documents loaded by the user agent\f[R].
.RS
.PP
The promise is also rejected with \f[CR]AbortError\f[R] if the user
cancels the payment request.
.RE
.TP
\f[B]InvalidStateError\f[R] \f[B]DOMException\f[R]
Returned if the same payment has already been shown for this request
(its state is \f[CR]interactive\f[R] because it is being shown already).
.TP
\f[B]NotSupportedError\f[R] \f[B]DOMException\f[R]
Returned if the user agent does not support the payment methods
specified when the \f[CR]PaymentRequest\f[R] constructor was called.
.TP
\f[B]SecurityError\f[R] \f[B]DOMException\f[R]
Returned if the call to \f[CR]show()\f[R] was not in response to a user
action, such as a \f[CR]click\f[R] or \f[CR]keyup\f[R] event.
Other reasons a \f[CR]SecurityError\f[R] may be thrown are at the
discretion of the user agent, and may include situations such as too
many calls to \f[CR]show()\f[R] being made in a short time or
\f[CR]show()\f[R] being called while payment requests are blocked by
parental controls.
.SH SECURITY
Transient user activation is required.
The user has to interact with the page or a UI element in order for this
feature to work.
.SH USAGE NOTES
The most common patterns for using \f[CR]show()\f[R] involve either the
\f[CR]async\f[R]/\f[CR]await\f[R] syntax or the use of
\f[CR]show().then().catch()\f[R] to handle the response and any possible
rejection.
Those look like this:
.SS async/await syntax
Using \f[CR]await\f[R] to wait for a promise to be resolved makes it
possible to write the code to handle payments particularly cleanly:
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] processPayment() {
  \f[B]try\f[R] {
    \f[B]const\f[R] payRequest = \f[B]new\f[R] PaymentRequest(methodData, details, options);

    payRequest.onshippingaddresschange = (ev) \f[B]=>\f[R]
      ev.updateWith(checkAddress(payRequest));
    payRequest.onshippingoptionchange = (ev) \f[B]=>\f[R]
      ev.updateWith(checkShipping(payRequest));

    \f[B]const\f[R] response = \f[B]await\f[R] payRequest.show();
    \f[B]await\f[R] validateResponse(response);
  } \f[B]catch\f[R] (err) {
    \f[I]/* handle the error; AbortError usually means a user cancellation */\f[R]
  }
}
.EE
.PP
In this code, the methods \f[CR]checkAddress()\f[R] and
\f[CR]checkShipping()\f[R], respectively, check the shipping address and
the shipping option changes and supply in response either an object or a
promise to return one; this object contains the fields in the
\f[CR]PaymentResponse\f[R] which have been or need to be changed.
.PP
The \f[CR]validateResponse()\f[R] method, below, is called once
\f[CR]show()\f[R] returns, in order to look at the returned
\f[CR]response\f[R] and either submit the payment or reject the payment
as failed:
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] validateResponse(response) {
  \f[B]try\f[R] {
    \f[B]if\f[R] (\f[B]await\f[R] checkAllValues(response)) {
      \f[B]await\f[R] response.complete(\(dqsuccess\(dq);
    } \f[B]else\f[R] {
      \f[B]await\f[R] response.complete(\(dqfail\(dq);
    }
  } \f[B]catch\f[R] (err) {
    \f[B]await\f[R] response.complete(\(dqfail\(dq);
  }
}
.EE
.PP
Here, a custom function called \f[CR]checkAllValues()\f[R] looks at each
value in the \f[CR]response\f[R] and ensures that they\(cqre valid,
returning \f[CR]true\f[R] if every field is valid or \f[CR]false\f[R] if
any are not.
If and only if every field is valid, the \f[CR]complete()\f[R] method is
called on the response with the string \f[CR]\(dqsuccess\(dq\f[R], which
indicates that everything is valid and that the payment can complete
accordingly.
.PP
If any fields have unacceptable values, or if an exception is thrown by
the previous code, \f[CR]complete()\f[R] is called with the string
\f[CR]\(dqfail\(dq\f[R], which indicates that the payment process is
complete and failed.
.PP
Instead of immediately failing, you could choose to call
\f[CR]retry()\f[R] on the response object to ask the user agent to try
to process the payment again; this should usually only be done after the
user has made any needed corrections to the order.
.PP
Starting the payment process, in the end, is as simple as calling the
\f[CR]processPayment()\f[R] method.
.SS then/catch syntax
You can also use the older promise\-based approach to work with
payments, using the \f[CR]then()\f[R] and \f[CR]catch()\f[R] functions
on the promise returned by \f[CR]show()\f[R]:
.IP
.EX
\f[B]function\f[R] processPayment() {
  \f[B]const\f[R] payRequest = \f[B]new\f[R] PaymentRequest(methodData, details, options);

  payRequest.onshippingaddresschange = (ev) \f[B]=>\f[R]
    ev.updateWith(checkAddress(payRequest));
  payRequest.onshippingoptionchange = (ev) \f[B]=>\f[R]
    ev.updateWith(checkShipping(payRequest));

  payRequest
    .show()
    .then((response) \f[B]=>\f[R] validateResponse(response))
    .catch((err) \f[B]=>\f[R] handleError(err));
}
.EE
.PP
This is functionally equivalent to the \f[CR]processPayment()\f[R]
method using the \f[CR]await\f[R] syntax.
.IP
.EX
\f[B]function\f[R] validateResponse(response) {
  checkAllValues(response)
    .then((response) \f[B]=>\f[R] response.complete(\(dqsuccess\(dq))
    .catch((response) \f[B]=>\f[R] response.complete(\(dqfail\(dq));
}
.EE
.PP
You could even have \f[CR]checkAllValues()\f[R] be a synchronous
function, although that may have performance implications you don\(cqt
want to deal with:
.IP
.EX
\f[B]function\f[R] validateResponse(response) {
  \f[B]if\f[R] (checkAllValues(response)) {
    response.complete(\(dqsuccess\(dq);
  } \f[B]else\f[R] {
    response.complete(\(dqfail\(dq);
  }
}
.EE
.PP
See the article Using promises for more information if you need more
information about working with promises.
.SH EXAMPLES
In the following example, a \f[CR]PaymentRequest\f[R] object is
instantiated before the \f[CR]show()\f[R] method is called.
This method triggers the user agent\(cqs built\-in process for
retrieving payment information from the user.
The \f[CR]show()\f[R] method returns a \f[CR]Promise\f[R] that resolves
to a \f[CR]PaymentResponse\f[R] object when the user interaction is
complete.
The developer then uses the information in the
\f[CR]PaymentResponse\f[R] object to format and send payment data to the
server.
You should send the payment information to the server asynchronously so
that the final call to \f[CR]paymentResponse.complete()\f[R] can
indicate the success or failure of the payment.
.IP
.EX
button.onclick = \f[B]async\f[R] \f[B]function\f[R] handlePurchase() {
  \f[I]// Initialization of PaymentRequest arguments are excerpted for the sake of\f[R]
  \f[I]// brevity.\f[R]
  \f[B]const\f[R] payment = \f[B]new\f[R] PaymentRequest(methods, details, options);
  \f[B]try\f[R] {
    \f[B]const\f[R] response = \f[B]await\f[R] payment.show();
    \f[I]// Process response here, including sending payment instrument\f[R]
    \f[I]// (e.g., credit card) information to the server.\f[R]
    \f[I]// paymentResponse.methodName contains the selected payment method\f[R]
    \f[I]// paymentResponse.details contains a payment method specific response\f[R]
    \f[B]await\f[R] response.complete(\(dqsuccess\(dq);
  } \f[B]catch\f[R] (err) {
    console.error(\(dqUh oh, something bad happened\(dq, err.message);
  }
};
.EE
.PP
The following example shows how to update the payment sheet as it\(cqs
being presented to the end\-user.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] requestPayment() {
  \f[I]// We start with AU$0 as the total.\f[R]
  \f[B]const\f[R] initialDetails = {
    total: {
      label: \(dqTotal\(dq,
      amount: { value: \(dq0\(dq, currency: \(dqAUD\(dq },
    },
  };
  \f[B]const\f[R] request = \f[B]new\f[R] PaymentRequest(methods, initialDetails, options);
  \f[I]// Check if the user supports the \(gamethods\(ga\f[R]
  \f[B]if\f[R] (!(\f[B]await\f[R] request.canMakePayment())) {
    \f[B]return\f[R]; \f[I]// no, so use a web form instead.\f[R]
  }
  \f[I]// Let\(aqs update the total as the sheet is shown\f[R]
  \f[B]const\f[R] updatedDetails = {
    total: {
      label: \(dqTotal\(dq,
      amount: { value: \(dq20\(dq, currency: \(dqAUD\(dq },
    },
  };
  \f[B]const\f[R] response = \f[B]await\f[R] request.show(updatedDetails);
  \f[I]// Check response, etc.\f[R]
}

document.getElementById(\(dqbuyButton\(dq).onclick = requestPayment;
.EE
.SH SEE ALSO
.IP \(bu 2
Payment Request API
.IP \(bu 2
Using the Payment Request API
.IP \(bu 2
\f[CR]PaymentRequest.abort()\f[R]
.IP \(bu 2
\f[CR]PaymentResponse\f[R]
.IP \(bu 2
\f[CR]PaymentResponse.retry()\f[R]
.IP \(bu 2
\f[CR]PaymentResponse.complete()\f[R]
