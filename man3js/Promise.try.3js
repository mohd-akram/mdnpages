.\" Automatically generated by Pandoc 3.4
.\"
.TH "Promise.try" "JS" "November 7, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Promise.try \- Promise.try()
.SH SYNOPSIS
The \f[B]\f[CB]Promise.try()\f[B]\f[R] static method takes a callback of
any kind (returns or throws, synchronously or asynchronously) and wraps
its result in a \f[CR]Promise\f[R].
.SH SYNTAX
.IP
.EX
Promise.try(func)
Promise.try(func, arg1)
Promise.try(func, arg1, arg2)
Promise.try(func, arg1, arg2, /* \&..., */ argN)
.EE
.SS Parameters
.TP
\f[B]func\f[R]
A function that is called synchronously with the arguments provided
(\f[CR]arg1\f[R], \f[CR]arg2\f[R], \&..., \f[CR]argN\f[R]).
It can do anything\[em]either return a value, throw an error, or return
a promise.
.TP
\f[B]arg1\f[R], \f[B]arg2\f[R], \&..., \f[B]argN\f[R]
Arguments to pass to \f[CR]func\f[R].
.SS Return value
A \f[CR]Promise\f[R] that is:
.IP \[bu] 2
Already fulfilled, if \f[CR]func\f[R] synchronously returns a value.
.IP \[bu] 2
Already rejected, if \f[CR]func\f[R] synchronously throws an error.
.IP \[bu] 2
Asynchronously fulfilled or rejected, if \f[CR]func\f[R] returns a
promise.
.SH DESCRIPTION
You may have an API that takes a callback.
The callback may be synchronous or asynchronous.
You want to handle everything uniformly by wrapping the result in a
promise.
The most straightforward way might be
\f[CR]Promise.resolve(func())\f[R].
The problem is that if \f[CR]func()\f[R] synchronously throws an error,
this error would not be caught and turned into a rejected promise.
.PP
The common approach (lifting a function call result into a promise,
fulfilled or rejected) often looks like this:
.IP
.EX
\f[B]new\f[R] Promise((resolve) \f[B]=>\f[R] resolve(func()));
.EE
.PP
But \f[CR]Promise.try()\f[R] is more helpful here:
.IP
.EX
Promise.try(func);
.EE
.PP
For the built\-in \f[CR]Promise()\f[R] constructor, errors thrown from
the executor are automatically caught and turned into rejections, so
these two approaches are mostly equivalent, except that
\f[CR]Promise.try()\f[R] is more concise and readable.
.PP
Note that \f[CR]Promise.try()\f[R] is \f[I]not\f[R] equivalent to this,
despite being highly similar:
.IP
.EX
Promise.resolve().then(func);
.EE
.PP
The difference is that the callback passed to \f[CR]then()\f[R] is
always called asynchronously, while the executor of the
\f[CR]Promise()\f[R] constructor is called synchronously.
\f[CR]Promise.try\f[R] also calls the function synchronously, and
resolves the promise immediately if possible.
.PP
\f[CR]Promise.try()\f[R], combined with \f[CR]catch()\f[R] and
\f[CR]finally()\f[R], can be used to handle both synchronous and
asynchronous errors in a single chain, and make promise error handling
appear almost like synchronous error handling.
.PP
Like \f[CR]setTimeout()\f[R], \f[CR]Promise.try()\f[R] accepts extra
arguments that are passed to the callback.
This means instead of doing this:
.IP
.EX
Promise.try(() \f[B]=>\f[R] func(arg1, arg2));
.EE
.PP
You can do this:
.IP
.EX
Promise.try(func, arg1, arg2);
.EE
.PP
Which are equivalent, but the latter avoids creating an extra closure
and is more efficient.
.SH EXAMPLES
.SS Using Promise.try()
The following example takes a callback, \[lq]lifts\[rq] it into a
promise, handles the result, and does some error handling:
.IP
.EX
\f[B]function\f[R] doSomething(action) {
  \f[B]return\f[R] Promise.try(action)
    .then((result) \f[B]=>\f[R] console.log(result))
    .catch((error) \f[B]=>\f[R] console.error(error))
    .finally(() \f[B]=>\f[R] console.log(\[dq]Done\[dq]));
}

doSomething(() \f[B]=>\f[R] \[dq]Sync result\[dq]);

doSomething(() \f[B]=>\f[R] {
  \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]Sync error\[dq]);
});

doSomething(\f[B]async\f[R] () \f[B]=>\f[R] \[dq]Async result\[dq]);

doSomething(\f[B]async\f[R] () \f[B]=>\f[R] {
  \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]Async error\[dq]);
});
.EE
.PP
In async/await, the same code would look like this:
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] doSomething(action) {
  \f[B]try\f[R] {
    \f[B]const\f[R] result = \f[B]await\f[R] action();
    console.log(result);
  } \f[B]catch\f[R] (error) {
    console.error(error);
  } \f[B]finally\f[R] {
    console.log(\[dq]Done\[dq]);
  }
}
.EE
.SS Calling try() on a non\-Promise constructor
\f[CR]Promise.try()\f[R] is a generic method.
It can be called on any constructor that implements the same signature
as the \f[CR]Promise()\f[R] constructor.
.PP
The following is a slightly more faithful approximation of the actual
\f[CR]Promise.try()\f[R] (although it should still not be used as a
polyfill):
.IP
.EX
Promise.try = \f[B]function\f[R] (func) {
  \f[B]return\f[R] \f[B]new\f[R] \f[B]this\f[R]((resolve, reject) \f[B]=>\f[R] {
    \f[B]try\f[R] {
      resolve(func());
    } \f[B]catch\f[R] (error) {
      reject(error);
    }
  });
};
.EE
.PP
Because of how \f[CR]Promise.try()\f[R] is implemented (i.e., the
\f[CR]try...catch\f[R]), we can safely invoke \f[CR]Promise.try()\f[R]
with its \f[CR]this\f[R] set to any custom constructor, and it will
never synchronously throw an error.
.IP
.EX
\f[B]class\f[R] NotPromise {
  constructor(executor) {
    \f[I]// The \[dq]resolve\[dq] and \[dq]reject\[dq] functions behave nothing like the native\f[R]
    \f[I]// promise\[aq]s, but Promise.try() just calls resolve\f[R]
    executor(
      (value) \f[B]=>\f[R] console.log(\[dq]Resolved\[dq], value),
      (reason) \f[B]=>\f[R] console.log(\[dq]Rejected\[dq], reason),
    );
  }
}

\f[B]const\f[R] p = Promise.try.call(NotPromise, () \f[B]=>\f[R] \[dq]hello\[dq]);
\f[I]// Logs: Resolved hello\f[R]

\f[B]const\f[R] p2 = Promise.try.call(NotPromise, () \f[B]=>\f[R] {
  \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]oops\[dq]);
});
\f[I]// Logs: Rejected Error: oops\f[R]
.EE
.PP
Unlike \f[CR]Promise()\f[R], this \f[CR]NotPromise()\f[R] constructor
\f[I]does not\f[R] gracefully handle exceptions while running the
executor.
But despite the \f[CR]throw\f[R], \f[CR]Promise.try()\f[R] still catches
the exception, passing it to \f[CR]reject()\f[R] to log out.
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#promisetry
Polyfill of \f[CR]Promise.try\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Using promises guide
.IP \[bu] 2
\f[CR]Promise\f[R]
.IP \[bu] 2
\f[CR]Promise()\f[R] constructor
