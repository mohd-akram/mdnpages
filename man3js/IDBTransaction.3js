'\" t
.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "IDBTRANSACTION" "3JS" "April 3, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
IDBTransaction \- IDBTransaction
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]IDBTransaction\f[B]\f[R] interface of the IndexedDB API
provides a static, asynchronous transaction on a database using event
handler attributes.
All reading and writing of data is done within transactions.
You use \f[CR]IDBDatabase\f[R] to start transactions,
\f[CR]IDBTransaction\f[R] to set the mode of the transaction (e.g., is
it \f[CR]readonly\f[R] or \f[CR]readwrite\f[R]), and you access an
\f[CR]IDBObjectStore\f[R] to make a request.
You can also use an \f[CR]IDBTransaction\f[R] object to abort
transactions.
.PP
Transactions are started when the transaction is created, not when the
first request is placed; for example consider this:
.IP
.EX
\f[B]const\f[R] trans1 = db.transaction(\(dqfoo\(dq, \(dqreadwrite\(dq);
\f[B]const\f[R] trans2 = db.transaction(\(dqfoo\(dq, \(dqreadwrite\(dq);
\f[B]const\f[R] objectStore2 = trans2.objectStore(\(dqfoo\(dq);
\f[B]const\f[R] objectStore1 = trans1.objectStore(\(dqfoo\(dq);
objectStore2.put(\(dq2\(dq, \(dqkey\(dq);
objectStore1.put(\(dq1\(dq, \(dqkey\(dq);
.EE
.PP
After the code is executed the object store should contain the value
\(lq2\(rq, since \f[CR]trans2\f[R] should run after \f[CR]trans1\f[R].
.PP
A transaction alternates between \f[I]active\f[R] and \f[I]inactive\f[R]
states between event loop tasks.
It\(cqs active in the task when it was created, and in each task of the
requests\(cq \f[CR]success\f[R] or \f[CR]error\f[R] event handlers.
It\(cqs inactive in all other tasks, in which case placing requests will
fail.
If no new requests are placed when the transaction is active, and there
are no other outstanding requests, the transaction will automatically
commit.
.SH TRANSACTION FAILURES
Transactions can fail for a fixed number of reasons, all of which
(except the user agent crash) will trigger an abort callback:
.IP \(bu 2
Abort due to bad requests, e.g., trying to \f[CR]add()\f[R] the same key
twice, or \f[CR]put()\f[R] with the same index key with a uniqueness
constraint.
This causes an error on the request, which can bubble up to an error on
the transaction, which aborts the transaction.
This can be prevented by using \f[CR]preventDefault()\f[R] on the error
event on the request.
.IP \(bu 2
An explicit \f[CR]abort()\f[R] call from script.
.IP \(bu 2
An uncaught exception in the request\(cqs
\f[CR]success\f[R]/\f[CR]error\f[R] handler.
.IP \(bu 2
An I/O error (e.g., an actual failure to write to disk, or other
OS/hardware failure).
.IP \(bu 2
Quota exceeded.
.IP \(bu 2
A user agent crash.
.SH FIREFOX DURABILITY GUARANTEES
Note that as of Firefox 40, IndexedDB transactions have relaxed
durability guarantees to increase performance (see \c
.UR https://bugzil.la/1112702
Firefox bug 1112702
.UE \c
\&.)
Previously in a \f[CR]readwrite\f[R] transaction, a \f[CR]complete\f[R]
event was fired only when all data was guaranteed to have been flushed
to disk.
In Firefox 40+ the \f[CR]complete\f[R] event is fired after the OS has
been told to write the data but potentially before that data has
actually been flushed to disk.
The \f[CR]complete\f[R] event may thus be delivered quicker than before,
however, there exists a small chance that the entire transaction will be
lost if the OS crashes or there is a loss of system power before the
data is flushed to disk.
Since such catastrophic events are rare, most consumers should not need
to concern themselves further.
.PP
If you must ensure durability for some reason (e.g., you\(cqre storing
critical data that cannot be recomputed later) you can force a
transaction to flush to disk before delivering the \f[CR]complete\f[R]
event by creating a transaction using the experimental (non\-standard)
\f[CR]readwriteflush\f[R] mode (see \f[CR]IDBDatabase.transaction\f[R].
.SH INSTANCE PROPERTIES
.TP
\f[B]IDBTransaction.db\f[R] \f[I](read\-only)\f[R]
The database connection with which this transaction is associated.
.TP
\f[B]IDBTransaction.durability\f[R] \f[I](read\-only)\f[R]
Returns the durability hint the transaction was created with.
.TP
\f[B]IDBTransaction.error\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]DOMException\f[R] indicating the type of error that
occurred when there is an unsuccessful transaction.
This property is \f[CR]null\f[R] if the transaction is not finished, is
finished and successfully committed, or was aborted with the
\f[CR]IDBTransaction.abort()\f[R] function.
.TP
\f[B]IDBTransaction.mode\f[R] \f[I](read\-only)\f[R]
The mode for isolating access to data in the object stores that are in
the scope of the transaction.
The default value is \f[CR]readonly\f[R].
.TP
\f[B]IDBTransaction.objectStoreNames\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]DOMStringList\f[R] of the names of
\f[CR]IDBObjectStore\f[R] objects associated with the transaction.
.SH INSTANCE METHODS
Inherits from: \f[CR]EventTarget\f[R]
.TP
\f[B]IDBTransaction.abort()\f[R]
Rolls back all the changes to objects in the database associated with
this transaction.
If this transaction has been aborted or completed, this method fires an
error event.
.TP
\f[B]IDBTransaction.objectStore()\f[R]
Returns an \f[CR]IDBObjectStore\f[R] object representing an object store
that is part of the scope of this transaction.
.TP
\f[B]IDBTransaction.commit()\f[R]
For an active transaction, commits the transaction.
Note that this doesn\(cqt normally \f[I]have\f[R] to be called \(em a
transaction will automatically commit when all outstanding requests have
been satisfied and no new requests have been made.
\f[CR]commit()\f[R] can be used to start the commit process without
waiting for events from outstanding requests to be dispatched.
.SH EVENTS
Listen to these events using \f[CR]addEventListener()\f[R] or by
assigning an event listener to the \f[CR]oneventname\f[R] property of
this interface.
.TP
\f[B]abort\f[R]
An event fired when the \f[CR]IndexedDB\f[R] transaction is aborted.
Also available via the \f[CR]onabort\f[R] property; this event bubbles
to \f[CR]IDBDatabase\f[R].
.TP
\f[B]complete\f[R]
An event fired when the transaction successfully completes.
Also available via the \f[CR]oncomplete\f[R] property.
.TP
\f[B]error\f[R]
An event fired when a request returns an error and the event bubbles up
to the connection object (\f[CR]IDBDatabase\f[R]).
Also available via the \f[CR]onerror\f[R] property.
.SH MODE CONSTANTS
\f[B]Deprecated:\f[R] This feature is no longer recommended.
.RS
.PP
\f[B]Warning:\f[R] These constants are no longer available \(em they
were removed in Gecko 25.
You should use the string constants directly instead.
(\c
.UR https://bugzil.la/888598
Firefox bug 888598
.UE \c
)
.RE
.PP
Transactions can have one of three modes:
.PP
.TS
tab(@);
l l l.
T{
Constant
T}@T{
Value
T}@T{
Description
T}
_
T{
\f[CR]READ_ONLY\f[R]
T}@T{
\(dqreadonly\(dq (0 in Chrome)
T}@T{
.PP
Allows data to be read but not changed.
T}
T{
\f[CR]READ_WRITE\f[R]
T}@T{
\(dqreadwrite\(dq (1 in Chrome)
T}@T{
Allows reading and writing of data in existing data stores to be
changed.
T}
T{
\f[CR]VERSION_CHANGE\f[R]
T}@T{
\(dqversionchange\(dq (2 in Chrome)
T}@T{
Allows any operation to be performed, including ones that delete and
create object stores and indexes.
Transactions of this mode cannot run concurrently with other
transactions.
Transactions in this mode are known as \(dqupgrade transactions.\(dq
T}
.TE
.PP
Even if these constants are now deprecated, you can still use them to
provide backward compatibility if required (in Chrome \c
.UR https://peter.sh/2012/05/tab-sizing-string-values-for-indexeddb-and-chrome-21/
the change was made in version 21
.UE \c
).
You should code defensively in case the object is not available anymore:
.IP
.EX
\f[B]const\f[R] myIDBTransaction = window.IDBTransaction ||
  window.webkitIDBTransaction || { READ_WRITE: \(dqreadwrite\(dq };
.EE
.SH EXAMPLES
In the following code snippet, we open a read/write transaction on our
database and add some data to an object store.
Note also the functions attached to transaction event handlers to report
on the outcome of the transaction opening in the event of success or
failure.
For a full working example, see our \c
.UR https://github.com/mdn/dom-examples/tree/main/to-do-notifications
To\-do Notifications
.UE \c
\ app (\c
.UR https://mdn.github.io/dom-examples/to-do-notifications/
view example live
.UE \c
).
.IP
.EX
\f[B]const\f[R] note = document.getElementById(\(dqnotifications\(dq);

\f[I]// an instance of a db object for us to store the IDB data in\f[R]
\f[B]let\f[R] db;

\f[I]// Let us open our database\f[R]
\f[B]const\f[R] DBOpenRequest = window.indexedDB.open(\(dqtoDoList\(dq, 4);

DBOpenRequest.onsuccess = (event) \f[B]=>\f[R] {
  note.appendChild(document.createElement(\(dqli\(dq)).textContent =
    \(dqDatabase initialized.\(dq;

  \f[I]// store the result of opening the database in the db\f[R]
  \f[I]// variable. This is used a lot below\f[R]
  db = DBOpenRequest.result;

  \f[I]// Add the data to the database\f[R]
  addData();
};

\f[B]function\f[R] addData() {
  \f[I]// Create a new object to insert into the IDB\f[R]
  \f[B]const\f[R] newItem = [
    {
      taskTitle: \(dqWalk dog\(dq,
      hours: 19,
      minutes: 30,
      day: 24,
      month: \(dqDecember\(dq,
      year: 2013,
      notified: \(dqno\(dq,
    },
  ];

  \f[I]// open a read/write db transaction, ready to add data\f[R]
  \f[B]const\f[R] transaction = db.transaction([\(dqtoDoList\(dq], \(dqreadwrite\(dq);

  \f[I]// report on the success of opening the transaction\f[R]
  transaction.oncomplete = (event) \f[B]=>\f[R] {
    note.appendChild(document.createElement(\(dqli\(dq)).textContent =
      \(dqTransaction completed: database modification finished.\(dq;
  };

  transaction.onerror = (event) \f[B]=>\f[R] {
    note.appendChild(document.createElement(\(dqli\(dq)).textContent =
      \(dqTransaction not opened due to error. Duplicate items not allowed.\(dq;
  };

  \f[I]// create an object store on the transaction\f[R]
  \f[B]const\f[R] objectStore = transaction.objectStore(\(dqtoDoList\(dq);

  \f[I]// add our newItem object to the object store\f[R]
  \f[B]const\f[R] objectStoreRequest = objectStore.add(newItem[0]);

  objectStoreRequest.onsuccess = (event) \f[B]=>\f[R] {
    \f[I]// report the success of the request (this does not mean the item\f[R]
    \f[I]// has been stored successfully in the DB \- for that you need transaction.oncomplete)\f[R]
    note.appendChild(document.createElement(\(dqli\(dq)).textContent =
      \(dqRequest successful.\(dq;
  };
}
.EE
.SH SEE ALSO
.IP \(bu 2
Using IndexedDB
.IP \(bu 2
Starting transactions: \f[CR]IDBDatabase\f[R]
.IP \(bu 2
Setting a range of keys: \f[CR]IDBKeyRange\f[R]
.IP \(bu 2
Retrieving and making changes to your data: \f[CR]IDBObjectStore\f[R]
.IP \(bu 2
Using cursors: \f[CR]IDBCursor\f[R]
.IP \(bu 2
Reference example: \c
.UR https://github.com/mdn/dom-examples/tree/main/to-do-notifications
To\-do Notifications
.UE \c
\ (\c
.UR https://mdn.github.io/dom-examples/to-do-notifications/
View the example live
.UE \c
).
