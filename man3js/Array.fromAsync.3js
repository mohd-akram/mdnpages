.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ARRAY.FROMASYNC" "3JS" "December 12, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.fromAsync \- Array.fromAsync()
.SH SYNOPSIS
The \f[B]\f[CB]Array.fromAsync()\f[B]\f[R] static method creates a new,
shallow\-copied \f[CR]Array\f[R] instance from an async iterable,
iterable, or array\-like object.
.SH SYNTAX
.IP
.EX
Array.fromAsync(arrayLike)
Array.fromAsync(arrayLike, mapFn)
Array.fromAsync(arrayLike, mapFn, thisArg)
.EE
.SS Parameters
.TP
\f[B]arrayLike\f[R]
An async iterable, iterable, or array\-like object to convert to an
array.
.TP
\f[B]mapFn\f[R] \f[I](optional)\f[R]
A function to call on every element of the array.
If provided, every value to be added to the array is first passed
through this function, and \f[CR]mapFn\f[R]\(cqs return value is added
to the array instead (after being awaited).
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
Because all elements are first awaited, this value will never be a
thenable.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
Value to use as \f[CR]this\f[R] when executing \f[CR]mapFn\f[R].
.SS Return value
A new \f[CR]Promise\f[R] whose fulfillment value is a new
\f[CR]Array\f[R] instance.
.SH DESCRIPTION
\f[CR]Array.fromAsync()\f[R] lets you create arrays from:
.IP \(bu 2
async iterable objects (objects such as \f[CR]ReadableStream\f[R] and
\f[CR]AsyncGenerator\f[R]); or, if the object is not async iterable,
.IP \(bu 2
iterable objects (objects such as \f[CR]Map\f[R] and \f[CR]Set\f[R]);
or, if the object is not iterable,
.IP \(bu 2
array\-like objects (objects with a \f[CR]length\f[R] property and
indexed elements).
.PP
\f[CR]Array.fromAsync()\f[R] iterates the async iterable in a fashion
very similar to \f[CR]for await...of\f[R].
\f[CR]Array.fromAsync()\f[R] is almost equivalent to
\f[CR]Array.from()\f[R] in terms of behavior, except the following:
.IP \(bu 2
\f[CR]Array.fromAsync()\f[R] handles async iterable objects.
.IP \(bu 2
\f[CR]Array.fromAsync()\f[R] returns a \f[CR]Promise\f[R] that fulfills
to the array instance.
.IP \(bu 2
If \f[CR]Array.fromAsync()\f[R] is called with a non\-async iterable
object, each element to be added to the array is first awaited.
.IP \(bu 2
If a \f[CR]mapFn\f[R] is provided, its input and output are internally
awaited.
.PP
\f[CR]Array.fromAsync()\f[R] and \f[CR]Promise.all()\f[R] can both turn
an iterable of promises into a promise of an array.
However, there are two key differences:
.IP \(bu 2
\f[CR]Array.fromAsync()\f[R] awaits each value yielded from the object
sequentially.
\f[CR]Promise.all()\f[R] awaits all values concurrently.
.IP \(bu 2
\f[CR]Array.fromAsync()\f[R] iterates the iterable lazily, and
doesn\(cqt retrieve the next value until the current one is settled.
\f[CR]Promise.all()\f[R] retrieves all values in advance and awaits them
all.
.SH EXAMPLES
.SS Array from an async iterable
.IP
.EX
\f[B]const\f[R] asyncIterable = (\f[B]async\f[R] \f[B]function\f[R]* () {
  \f[B]for\f[R] (\f[B]let\f[R] i = 0; i < 5; i++) {
    \f[B]await\f[R] \f[B]new\f[R] Promise((resolve) \f[B]=>\f[R] setTimeout(resolve, 10 * i));
    \f[B]yield\f[R] i;
  }
})();

Array.fromAsync(asyncIterable).then((array) \f[B]=>\f[R] console.log(array));
\f[I]// [0, 1, 2, 3, 4]\f[R]
.EE
.SS Array from a sync iterable
.IP
.EX
Array.fromAsync(
  \f[B]new\f[R] Map([
    [1, 2],
    [3, 4],
  ]),
).then((array) \f[B]=>\f[R] console.log(array));
\f[I]// [[1, 2], [3, 4]]\f[R]
.EE
.SS Array from a sync iterable that yields promises
.IP
.EX
Array.fromAsync(
  \f[B]new\f[R] Set([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]),
).then((array) \f[B]=>\f[R] console.log(array));
\f[I]// [1, 2, 3]\f[R]
.EE
.SS Array from an array\-like object of promises
.IP
.EX
Array.fromAsync({
  length: 3,
  0: Promise.resolve(1),
  1: Promise.resolve(2),
  2: Promise.resolve(3),
}).then((array) \f[B]=>\f[R] console.log(array));
\f[I]// [1, 2, 3]\f[R]
.EE
.SS Using mapFn
Both the input and output of \f[CR]mapFn\f[R] are awaited internally by
\f[CR]Array.fromAsync()\f[R].
.IP
.EX
\f[B]function\f[R] delayedValue(v) {
  \f[B]return\f[R] \f[B]new\f[R] Promise((resolve) \f[B]=>\f[R] setTimeout(() \f[B]=>\f[R] resolve(v), 100));
}

Array.fromAsync(
  [delayedValue(1), delayedValue(2), delayedValue(3)],
  (element) \f[B]=>\f[R] delayedValue(element * 2),
).then((array) \f[B]=>\f[R] console.log(array));
\f[I]// [2, 4, 6]\f[R]
.EE
.SS Comparison with Promise.all()
\f[CR]Array.fromAsync()\f[R] awaits each value yielded from the object
sequentially.
\f[CR]Promise.all()\f[R] awaits all values concurrently.
.IP
.EX
\f[B]function\f[R]* makeIterableOfPromises() {
  \f[B]for\f[R] (\f[B]let\f[R] i = 0; i < 5; i++) {
    \f[B]yield\f[R] \f[B]new\f[R] Promise((resolve) \f[B]=>\f[R] setTimeout(resolve, 100));
  }
}

(\f[B]async\f[R] () \f[B]=>\f[R] {
  console.time(\(dqArray.fromAsync() time\(dq);
  \f[B]await\f[R] Array.fromAsync(makeIterableOfPromises());
  console.timeEnd(\(dqArray.fromAsync() time\(dq);
  \f[I]// Array.fromAsync() time: 503.610ms\f[R]

  console.time(\(dqPromise.all() time\(dq);
  \f[B]await\f[R] Promise.all(makeIterableOfPromises());
  console.timeEnd(\(dqPromise.all() time\(dq);
  \f[I]// Promise.all() time: 101.728ms\f[R]
})();
.EE
.SS No error handling for sync iterables
Similar to \f[CR]for await...of\f[R], if the object being iterated is a
sync iterable, and an error is thrown while iterating, the
\f[CR]return()\f[R] method of the underlying iterator will not be
called, so the iterator is not closed.
.IP
.EX
\f[B]function\f[R]* generatorWithRejectedPromises() {
  \f[B]try\f[R] {
    \f[B]yield\f[R] 0;
    \f[B]yield\f[R] Promise.reject(3);
  } \f[B]finally\f[R] {
    console.log(\(dqcalled finally\(dq);
  }
}

(\f[B]async\f[R] () \f[B]=>\f[R] {
  \f[B]try\f[R] {
    \f[B]await\f[R] Array.fromAsync(generatorWithRejectedPromises());
  } \f[B]catch\f[R] (e) {
    console.log(\(dqcaught\(dq, e);
  }
})();
\f[I]// caught 3\f[R]
\f[I]// No \(dqcalled finally\(dq message\f[R]
.EE
.PP
If you need to close the iterator, you need to use a \f[CR]for...of\f[R]
loop instead, and \f[CR]await\f[R] each value yourself.
.IP
.EX
(\f[B]async\f[R] () \f[B]=>\f[R] {
  \f[B]const\f[R] arr = [];
  \f[B]try\f[R] {
    \f[B]for\f[R] (\f[B]const\f[R] val \f[B]of\f[R] generatorWithRejectedPromises()) {
      arr.push(\f[B]await\f[R] val);
    }
  } \f[B]catch\f[R] (e) {
    console.log(\(dqcaught\(dq, e);
  }
})();
\f[I]// called finally\f[R]
\f[I]// caught 3\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#arrayfromasync
Polyfill of \f[CR]Array.fromAsync\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
Indexed collections guide
.IP \(bu 2
\f[CR]Array\f[R]
.IP \(bu 2
\f[CR]Array()\f[R]
.IP \(bu 2
\f[CR]Array.of()\f[R]
.IP \(bu 2
\f[CR]Array.from()\f[R]
.IP \(bu 2
\f[CR]for await...of\f[R]
