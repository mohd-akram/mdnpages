.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "FileSystemDirectoryHandle" "JS" "May 13, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
FileSystemDirectoryHandle \- FileSystemDirectoryHandle
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]FileSystemDirectoryHandle\f[B]\f[R] interface of the File
System API provides a handle to a file system directory.
.PP
The interface can be accessed via the
\f[CR]window.showDirectoryPicker()\f[R],
\f[CR]StorageManager.getDirectory()\f[R],
\f[CR]DataTransferItem.getAsFileSystemHandle()\f[R], and
\f[CR]FileSystemDirectoryHandle.getDirectoryHandle()\f[R] methods.
.SH INSTANCE PROPERTIES
\f[I]Inherits properties from its parent,
\f[CI]FileSystemHandle\f[I].\f[R]
.SH INSTANCE METHODS
\f[I]Inherits methods from its parent, \f[CI]FileSystemHandle\f[I].\f[R]
.PP
Regular methods:
.TP
\f[B]FileSystemDirectoryHandle.getDirectoryHandle()\f[R]
Returns a \f[CR]Promise\f[R] fulfilled with a
\f[CR]FileSystemDirectoryHandle\f[R] for a subdirectory with the
specified name within the directory handle on which the method is
called.
.TP
\f[B]FileSystemDirectoryHandle.getFileHandle()\f[R]
Returns a \f[CR]Promise\f[R] fulfilled with a
\f[CR]FileSystemFileHandle\f[R] for a file with the specified name,
within the directory the method is called.
.TP
\f[B]FileSystemDirectoryHandle.removeEntry()\f[R]
Attempts to asynchronously remove an entry if the directory handle
contains a file or directory called the name specified.
.TP
\f[B]FileSystemDirectoryHandle.resolve()\f[R]
Returns a \f[CR]Promise\f[R] fulfilled with an \f[CR]Array\f[R] of
directory names from the parent handle to the specified child entry,
with the name of the child entry as the last array item.
.PP
Asynchronous iterator methods:
.TP
\f[B]FileSystemDirectoryHandle.entries()\f[R]
Returns a new \f[I]async iterator\f[R] of a given object\[cq]s own
enumerable property \f[CR][key, value]\f[R] pairs.
.TP
\f[B]FileSystemDirectoryHandle.keys()\f[R]
Returns a new \f[I]async iterator\f[R] containing the keys for each item
in \f[CR]FileSystemDirectoryHandle\f[R].
.TP
\f[B]FileSystemDirectoryHandle.values()\f[R]
Returns a new \f[I]async iterator\f[R] containing the values for each
index in the \f[CR]FileSystemDirectoryHandle\f[R] object.
.TP
\f[B]FileSystemDirectoryHandle[\[at]\[at]asyncIterator]()\f[R]
Returns a new \f[I]async iterator\f[R] of a given object\[cq]s own
enumerable property \f[CR][key, value]\f[R] pairs.
.SH EXAMPLES
.SS Return directory handle
The following example returns a directory handle with the specified
name; if the directory does not already exist it is created.
.IP
.EX
\f[B]const\f[R] dirName = \[dq]directoryToGetName\[dq];

\f[I]// assuming we have a directory handle: \[aq]currentDirHandle\[aq]\f[R]
\f[B]const\f[R] subDir = currentDirHandle.getDirectoryHandle(dirName, { create: \f[B]true\f[R] });
.EE
.SS Return file path
The following asynchronous function uses \f[CR]resolve()\f[R] to find
the path to a chosen file, relative to a specified directory handle.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] returnPathDirectories(directoryHandle) {
  \f[I]// Get a file handle by showing a file picker:\f[R]
  \f[B]const\f[R] handle = \f[B]await\f[R] self.showOpenFilePicker();
  \f[B]if\f[R] (!handle) {
    \f[I]// User cancelled, or otherwise failed to open a file.\f[R]
    \f[B]return\f[R];
  }

  \f[I]// Check if handle exists inside our directory handle\f[R]
  \f[B]const\f[R] relativePaths = \f[B]await\f[R] directoryHandle.resolve(handle);

  \f[B]if\f[R] (relativePath === \f[B]null\f[R]) {
    \f[I]// Not inside directory handle\f[R]
  } \f[B]else\f[R] {
    \f[I]// relativePath is an array of names, giving the relative path\f[R]

    \f[B]for\f[R] (\f[B]const\f[R] name \f[B]of\f[R] relativePaths) {
      \f[I]// log each entry\f[R]
      console.log(name);
    }
  }
}
.EE
.SS Return handles for all files in a directory
The following example scans recursively through a directory to return
\f[CR]FileSystemFileHandle\f[R] objects for each file in that directory:
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R]* getFilesRecursively(entry) {
  \f[B]if\f[R] (entry.kind === \[dq]file\[dq]) {
    \f[B]const\f[R] file = \f[B]await\f[R] entry.getFile();
    \f[B]if\f[R] (file !== \f[B]null\f[R]) {
      file.relativePath = getRelativePath(entry);
      \f[B]yield\f[R] file;
    }
  } \f[B]else\f[R] \f[B]if\f[R] (entry.kind === \[dq]directory\[dq]) {
    \f[B]for\f[R] \f[B]await\f[R] (\f[B]const\f[R] handle \f[B]of\f[R] entry.values()) {
      \f[B]yield\f[R]* getFilesRecursively(handle);
    }
  }
}
\f[B]for\f[R] \f[B]await\f[R] (\f[B]const\f[R] fileHandle \f[B]of\f[R] getFilesRecursively(directoryHandle)) {
  console.log(fileHandle);
}
.EE
.SH SEE ALSO
.IP \[bu] 2
File System API
.IP \[bu] 2
\c
.UR https://developer.chrome.com/docs/capabilities/web-apis/file-system-access
The File System Access API: simplifying access to local files
.UE \c
