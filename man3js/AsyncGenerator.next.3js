.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ASYNCGENERATOR.NEXT" "3JS" "November 14, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
AsyncGenerator.next \- AsyncGenerator.prototype.next()
.SH SYNOPSIS
The \f[B]\f[CB]next()\f[B]\f[R] method of \f[CR]AsyncGenerator\f[R]
instances returns the next value in the sequence.
.SH SYNTAX
.IP
.EX
next()
next(value)
.EE
.SS Parameters
.TP
\f[B]value\f[R] \f[I](optional)\f[R]
An optional value used to modify the internal state of the generator.
A value passed to the \f[CR]next()\f[R] method will be received by
\f[CR]yield\f[R]
.SS Return value
A \f[CR]Promise\f[R] which when resolved returns an \f[CR]Object\f[R]
with two properties:
.TP
\f[B]done\f[R]
A boolean value:
.RS
.IP \(bu 2
\f[CR]true\f[R] if the generator is past the end of its control flow.
In this case \f[CR]value\f[R] specifies the \f[I]return value\f[R] of
the generator (which may be undefined).
.IP \(bu 2
\f[CR]false\f[R] if the generator is able to produce more values.
.RE
.TP
\f[B]value\f[R]
Any JavaScript value yielded or returned by the generator.
.SH EXAMPLES
.SS Using next()
The following example shows a generator and the object that the
\f[CR]next\f[R] method returns:
.IP
.EX
\f[I]// An async task. Pretend it\(aqs doing something more useful\f[R]
\f[I]// in practice.\f[R]
\f[B]function\f[R] delayedValue(time, value) {
  \f[B]return\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
    setTimeout(() \f[B]=>\f[R] resolve(value), time);
  });
}

\f[B]async\f[R] \f[B]function\f[R]* createAsyncGenerator() {
  \f[B]yield\f[R] delayedValue(500, 1);
  \f[B]yield\f[R] delayedValue(500, 2);
  \f[B]yield\f[R] delayedValue(500, 3);
}

\f[B]const\f[R] asyncGen = createAsyncGenerator();
asyncGen.next().then((res) \f[B]=>\f[R] console.log(res)); \f[I]// { value: 1, done: false }\f[R]
asyncGen.next().then((res) \f[B]=>\f[R] console.log(res)); \f[I]// { value: 2, done: false }\f[R]
asyncGen.next().then((res) \f[B]=>\f[R] console.log(res)); \f[I]// { value: 3, done: false }\f[R]
asyncGen.next().then((res) \f[B]=>\f[R] console.log(res)); \f[I]// { value: undefined, done: true }\f[R]
.EE
.SS Sending values to the generator
In this example, \f[CR]next\f[R] is called with a value.
.RS
.PP
\f[B]Note:\f[R] The first call does not log anything, because the
generator was not yielding anything initially.
.RE
.IP
.EX
\f[I]// An async task. Pretend it\(aqs doing something more useful\f[R]
\f[I]// in practice.\f[R]
\f[B]function\f[R] sleep(time) {
  \f[B]return\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
    setTimeout(resolve, time);
  });
}

\f[B]async\f[R] \f[B]function\f[R]* createAsyncGenerator() {
  \f[B]while\f[R] (\f[B]true\f[R]) {
    \f[B]await\f[R] sleep(500);
    \f[B]const\f[R] value = \f[B]yield\f[R];
    console.log(value);
  }
}

\f[B]async\f[R] \f[B]function\f[R] main() {
  \f[B]const\f[R] asyncGen = createAsyncGenerator();
  \f[I]// No log at this step: the first value sent through \(ganext\(ga is lost\f[R]
  console.log(\f[B]await\f[R] asyncGen.next(1)); \f[I]// { value: undefined, done: false }\f[R]
  \f[I]// Logs 2: the value sent through \(ganext\(ga\f[R]
  console.log(\f[B]await\f[R] asyncGen.next(2)); \f[I]// { value: undefined, done: false }\f[R]
}

main();
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]async function*\f[R]
.IP \(bu 2
Iterators and generators guide
