.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "XRViewport" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
XRViewport \- XRViewport
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
The WebXR Device API\[cq]s \f[B]\f[CB]XRViewport\f[B]\f[R] interface
provides properties used to describe the size and position of the
current viewport within the \f[CR]XRWebGLLayer\f[R] being used to render
the 3D scene.
.SH INSTANCE PROPERTIES
.TP
\f[B]height\f[R] \f[I](read\-only)\f[R]
The height, in pixels, of the viewport.
.TP
\f[B]width\f[R] \f[I](read\-only)\f[R]
The width, in pixels, of the viewport.
.TP
\f[B]x\f[R] \f[I](read\-only)\f[R]
The offset from the origin of the destination graphics surface
(typically a \f[CR]XRWebGLLayer\f[R]) to the left edge of the viewport,
in pixels.
.TP
\f[B]y\f[R] \f[I](read\-only)\f[R]
The offset from the origin of the viewport to the bottom edge of the
viewport; WebGL\[cq]s coordinate system places (0, 0) at the bottom left
corner of the surface.
.SH USAGE NOTES
Currently, the only type of surface available is the
\f[CR]XRWebGLLayer\f[R].
The precise orientation of the coordinate system may vary with other
surface types, but in WebGL, the origin (0, 0) is located at the
bottom\-left corner of the surface.
Thus the values specified in an \f[CR]XRViewport\f[R] define a rectangle
whose bottom\-left corner is at (\f[CR]x\f[R], \f[CR]y\f[R]) and which
extends \f[CR]width\f[R] pixels toward the left and \f[CR]height\f[R]
pixels upward.
.PP
These values may be passed directly into the
\f[CR]WebGLRenderingContext.viewport()\f[R] method:
.IP
.EX
\f[B]const\f[R] xrViewport = xrWebGLLayer.getViewport(xrView);
gl.viewport(xrViewport.x, xrViewport.y, xrViewport.width, xrViewport.height);
.EE
.SH EXAMPLE
This example sets up an animation frame callback using
\f[CR]requestAnimationFrame()\f[R].
After initial setup, it iterates over each of the views within the
viewer\[cq]s pose, configuring the viewport as dictated by the
\f[CR]XRWebGLLayer\f[R].
.IP
.EX
xrSession.requestAnimationFrame((time, xrFrame) \f[B]=>\f[R] {
  \f[B]const\f[R] viewerPose = xrFrame.getViewerPose(xrReferenceSpace);

  gl.bindFramebuffer(xrWebGLLayer.framebuffer);

  \f[B]for\f[R] (\f[B]const\f[R] xrView \f[B]of\f[R] viewerPose.views) {
    \f[B]const\f[R] xrViewport = xrWebGLLayer.getViewport(xrView);
    gl.viewport(
      xrViewport.x,
      xrViewport.y,
      xrViewport.width,
      xrViewport.height,
    );

    \f[I]// Now we can use WebGL to draw into a viewport matching\f[R]
    \f[I]// the viewer\[aq]s needs\f[R]
  }
});
.EE
