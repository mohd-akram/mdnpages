.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Array.concat" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.concat \- Array.prototype.concat()
.SH SYNOPSIS
The \f[B]\f[CB]concat()\f[B]\f[R] method of \f[CR]Array\f[R] instances
is used to merge two or more arrays.
This method does not change the existing arrays, but instead returns a
new array.
.IP
.EX
\f[B]const\f[R] array1 = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq]];
\f[B]const\f[R] array2 = [\[dq]d\[dq], \[dq]e\[dq], \[dq]f\[dq]];
\f[B]const\f[R] array3 = array1.concat(array2);

console.log(array3);
\f[I]// Expected output: Array [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq], \[dq]d\[dq], \[dq]e\[dq], \[dq]f\[dq]]\f[R]
.EE
.SH SYNTAX
.IP
.EX
concat()
concat(value1)
concat(value1, value2)
concat(value1, value2, /* \&..., */ valueN)
.EE
.SS Parameters
.TP
\f[B]value1\f[R], \&..., \f[B]valueN\f[R] \f[I](optional)\f[R]
Arrays and/or values to concatenate into a new array.
If all \f[CR]valueN\f[R] parameters are omitted, \f[CR]concat\f[R]
returns a shallow copy of the existing array on which it is called.
See the description below for more details.
.SS Return value
A new \f[CR]Array\f[R] instance.
.SH DESCRIPTION
The \f[CR]concat\f[R] method creates a new array.
The array will first be populated by the elements in the object on which
it is called.
Then, for each argument, its value will be concatenated into the array
\[em] for normal objects or primitives, the argument itself will become
an element of the final array; for arrays or array\-like objects with
the property \f[CR]Symbol.isConcatSpreadable\f[R] set to a truthy value,
each element of the argument will be independently added to the final
array.
The \f[CR]concat\f[R] method does not recurse into nested array
arguments.
.PP
The \f[CR]concat()\f[R] method is a copying method.
It does not alter \f[CR]this\f[R] or any of the arrays provided as
arguments but instead returns a shallow copy that contains the same
elements as the ones from the original arrays.
.PP
The \f[CR]concat()\f[R] method preserves empty slots if any of the
source arrays is sparse.
.PP
The \f[CR]concat()\f[R] method is generic.
The \f[CR]this\f[R] value is treated in the same way as the other
arguments (except it will be converted to an object first), which means
plain objects will be directly prepended to the resulting array, while
array\-like objects with truthy \f[CR][Symbol.isConcatSpreadable]\f[R]
will be spread into the resulting array.
.SH EXAMPLES
.SS Concatenating two arrays
The following code concatenates two arrays:
.IP
.EX
\f[B]const\f[R] letters = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq]];
\f[B]const\f[R] numbers = [1, 2, 3];

\f[B]const\f[R] alphaNumeric = letters.concat(numbers);
console.log(alphaNumeric);
\f[I]// results in [\[aq]a\[aq], \[aq]b\[aq], \[aq]c\[aq], 1, 2, 3]\f[R]
.EE
.SS Concatenating three arrays
The following code concatenates three arrays:
.IP
.EX
\f[B]const\f[R] num1 = [1, 2, 3];
\f[B]const\f[R] num2 = [4, 5, 6];
\f[B]const\f[R] num3 = [7, 8, 9];

\f[B]const\f[R] numbers = num1.concat(num2, num3);

console.log(numbers);
\f[I]// results in [1, 2, 3, 4, 5, 6, 7, 8, 9]\f[R]
.EE
.SS Concatenating values to an array
The following code concatenates three values to an array:
.IP
.EX
\f[B]const\f[R] letters = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq]];

\f[B]const\f[R] alphaNumeric = letters.concat(1, [2, 3]);

console.log(alphaNumeric);
\f[I]// results in [\[aq]a\[aq], \[aq]b\[aq], \[aq]c\[aq], 1, 2, 3]\f[R]
.EE
.SS Concatenating nested arrays
The following code concatenates nested arrays and demonstrates retention
of references:
.IP
.EX
\f[B]const\f[R] num1 = [[1]];
\f[B]const\f[R] num2 = [2, [3]];

\f[B]const\f[R] numbers = num1.concat(num2);

console.log(numbers);
\f[I]// results in [[1], 2, [3]]\f[R]

\f[I]// modify the first element of num1\f[R]
num1[0].push(4);

console.log(numbers);
\f[I]// results in [[1, 4], 2, [3]]\f[R]
.EE
.SS Concatenating array\-like objects with Symbol.isConcatSpreadable
\f[CR]concat\f[R] does not treat all array\-like objects as arrays by
default \[em] only if \f[CR]Symbol.isConcatSpreadable\f[R] is set to a
truthy value (e.g.\ \f[CR]true\f[R]).
.IP
.EX
\f[B]const\f[R] obj1 = { 0: 1, 1: 2, 2: 3, length: 3 };
\f[B]const\f[R] obj2 = { 0: 1, 1: 2, 2: 3, length: 3, [Symbol.isConcatSpreadable]: \f[B]true\f[R] };
console.log([0].concat(obj1, obj2));
\f[I]// [ 0, { \[aq]0\[aq]: 1, \[aq]1\[aq]: 2, \[aq]2\[aq]: 3, length: 3 }, 1, 2, 3 ]\f[R]
.EE
.SS Using concat() on sparse arrays
If any of the source arrays is sparse, the resulting array will also be
sparse:
.IP
.EX
console.log([1, , 3].concat([4, 5])); \f[I]// [1, empty, 3, 4, 5]\f[R]
console.log([1, 2].concat([3, , 5])); \f[I]// [1, 2, 3, empty, 5]\f[R]
.EE
.SS Calling concat() on non\-array objects
If the \f[CR]this\f[R] value is not an array, it is converted to an
object and then treated in the same way as the arguments for
\f[CR]concat()\f[R].
In this case the return value is always a plain new array.
.IP
.EX
console.log(Array.prototype.concat.call({}, 1, 2, 3)); \f[I]// [{}, 1, 2, 3]\f[R]
console.log(Array.prototype.concat.call(1, 2, 3)); \f[I]// [ [Number: 1], 2, 3 ]\f[R]
\f[B]const\f[R] arrayLike = {
  [Symbol.isConcatSpreadable]: \f[B]true\f[R],
  length: 2,
  0: 1,
  1: 2,
  2: 99, \f[I]// ignored by concat() since length is 2\f[R]
};
console.log(Array.prototype.concat.call(arrayLike, 3, 4)); \f[I]// [1, 2, 3, 4]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype.concat\f[R] in \f[CR]core\-js\f[R]
with fixes and implementation of modern behavior like
\f[CR]Symbol.isConcatSpreadable\f[R] support
.UE \c
.IP \[bu] 2
Indexed collections guide
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.push()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.unshift()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.splice()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.concat()\f[R]
.IP \[bu] 2
\f[CR]Symbol.isConcatSpreadable\f[R]
