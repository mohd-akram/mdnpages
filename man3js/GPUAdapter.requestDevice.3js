.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPUADAPTER.REQUESTDEVICE" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPUAdapter.requestDevice \- GPUAdapter: requestDevice() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]requestDevice()\f[B]\f[R] method of the
\f[CR]GPUAdapter\f[R] interface returns a \f[CR]Promise\f[R] that
fulfills with a \f[CR]GPUDevice\f[R] object, which is the primary
interface for communicating with the GPU.
.SH SYNTAX
.IP
.EX
requestDevice()
requestDevice(descriptor)
.EE
.SS Parameters
.TP
\f[B]descriptor\f[R] \f[I](optional)\f[R]
An object containing the following properties:
.RS
.TP
\f[B]defaultQueue\f[R] \f[I](optional)\f[R]
An object that provides information for the device\(cqs default
\f[CR]GPUQueue\f[R] (as returned by \f[CR]GPUDevice.queue\f[R]).
This object has a single property \(em \f[CR]label\f[R] \(em which
provides the default queue with a \f[CR]label\f[R] value.
If no value is provided, this defaults to an empty object, and the
default queue\(cqs label will be an empty string.
.TP
\f[B]label\f[R] \f[I](optional)\f[R]
A string providing a label that can be used to identify the
\f[CR]GPUDevice\f[R], for example in \f[CR]GPUError\f[R] messages or
console warnings.
.TP
\f[B]requiredFeatures\f[R] \f[I](optional)\f[R]
An array of strings representing additional functionality that you want
supported by the returned \f[CR]GPUDevice\f[R].
The \f[CR]requestDevice()\f[R] call will fail if the
\f[CR]GPUAdapter\f[R] cannot provide these features.
See \f[CR]GPUSupportedFeatures\f[R] for a full list of possible
features.
This defaults to an empty array if no value is provided.
.TP
\f[B]requiredLimits\f[R] \f[I](optional)\f[R]
An object containing properties representing the limits that you want
supported by the returned \f[CR]GPUDevice\f[R].
The \f[CR]requestDevice()\f[R] call will fail if the
\f[CR]GPUAdapter\f[R] cannot provide these limits.
Each key with a non\-\f[CR]undefined\f[R] value must be the name of a
member of \f[CR]GPUSupportedLimits\f[R].
> \f[B]Note:\f[R] > You can request unknown limits when requesting a GPU
device without causing an error.
Such limits will be \f[CR]undefined\f[R].
This is useful because it makes WebGPU code less brittle \(em a codebase
won\(cqt stop working because a limit no longer exists in the adapter.
.RE
.PP
Not all features and limits will be available to WebGPU in all browsers
that support it, even if they are supported by the underlying hardware.
See the \f[CR]features\f[R] and \f[CR]limits\f[R] pages for more
information.
.SS Return value
A \f[CR]Promise\f[R] that fulfills with a \f[CR]GPUDevice\f[R] object
instance.
.PP
If you make a duplicate call, i.e., call \f[CR]requestDevice()\f[R] on a
\f[CR]GPUAdapter\f[R] that \f[CR]requestDevice()\f[R] was already called
on, the promise fulfills with a device that is immediately lost.
You can then get information on how the device was lost via
\f[CR]GPUDevice.lost\f[R].
.SS Exceptions
.TP
\f[B]OperationError\f[R] \f[B]DOMException\f[R]
The promise rejects with an \f[CR]OperationError\f[R] if the limits
included in the \f[CR]requiredLimits\f[R] property are not supported by
the \f[CR]GPUAdapter\f[R], either because they are not valid limits, or
because their values are higher than the adapter\(cqs values for those
limits.
.TP
\f[B]TypeError\f[R] \f[B]DOMException\f[R]
The promise rejects with a \f[CR]TypeError\f[R] if the features included
in the \f[CR]requiredFeatures\f[R] property are not supported by the
\f[CR]GPUAdapter\f[R].
.SH EXAMPLES
.SS Basic example
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] init() {
  \f[B]if\f[R] (!navigator.gpu) {
    \f[B]throw\f[R] Error(\(dqWebGPU not supported.\(dq);
  }

  \f[B]const\f[R] adapter = \f[B]await\f[R] navigator.gpu.requestAdapter();
  \f[B]if\f[R] (!adapter) {
    \f[B]throw\f[R] Error(\(dqCouldn\(aqt request WebGPU adapter.\(dq);
  }

  \f[B]const\f[R] device = \f[B]await\f[R] adapter.requestDevice();

  \f[I]// \&...\f[R]
}
.EE
.SS Requesting specific features and limits
In the following code we:
.IP "1." 3
Check whether a \f[CR]GPUAdapter\f[R] has the
\f[CR]texture\-compression\-astc\f[R] feature available.
If so, we push it into the array of \f[CR]requiredFeatures\f[R].
.IP "2." 3
Query the \f[CR]GPUAdapter.limits\f[R] value of \f[CR]maxBindGroups\f[R]
to see if it is equal to or greater than 6.
Our theoretical example app ideally needs 6 bind groups, so if the
returned value is >= 6, we add a maximum limit of 6 to the
\f[CR]requiredLimits\f[R] object.
.IP "3." 3
Request a device with those feature and limit requirements, plus a
\f[CR]defaultQueue\f[R] label.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] init() {
  \f[B]if\f[R] (!navigator.gpu) {
    \f[B]throw\f[R] Error(\(dqWebGPU not supported.\(dq);
  }

  \f[B]const\f[R] adapter = \f[B]await\f[R] navigator.gpu.requestAdapter();
  \f[B]if\f[R] (!adapter) {
    \f[B]throw\f[R] Error(\(dqCouldn\(aqt request WebGPU adapter.\(dq);
  }

  \f[B]const\f[R] requiredFeatures = [];

  \f[B]if\f[R] (adapter.features.has(\(dqtexture\-compression\-astc\(dq)) {
    requiredFeatures.push(\(dqtexture\-compression\-astc\(dq);
  }

  \f[B]const\f[R] requiredLimits = {};

  \f[I]// App ideally needs 6 bind groups, so we\(aqll try to request what the app needs\f[R]
  \f[B]if\f[R] (adapter.limits.maxBindGroups >= 6) {
    requiredLimits.maxBindGroups = 6;
  }

  \f[B]const\f[R] device = \f[B]await\f[R] adapter.requestDevice({
    defaultQueue: {
      label: \(dqmy_queue\(dq,
    },
    requiredFeatures,
    requiredLimits,
  });

  \f[I]// \&...\f[R]
}
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
