.\" Automatically generated by Pandoc 3.4
.\"
.TH "Object.valueOf" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.valueOf \- Object.prototype.valueOf()
.SH SYNOPSIS
The \f[B]\f[CB]valueOf()\f[B]\f[R] method of \f[CR]Object\f[R] instances
converts the \f[CR]this\f[R] value to an object.
This method is meant to be overridden by derived objects for custom type
conversion logic.
.SH SYNTAX
.IP
.EX
valueOf()
.EE
.SS Parameters
None.
.SS Return value
The \f[CR]this\f[R] value, converted to an object.
.RS
.PP
\f[B]Note:\f[R] In order for \f[CR]valueOf\f[R] to be useful during type
conversion, it must return a primitive.
Because all primitive types have their own \f[CR]valueOf()\f[R] methods,
calling \f[CR]aPrimitiveValue.valueOf()\f[R] generally does not invoke
\f[CR]Object.prototype.valueOf()\f[R].
.RE
.SH DESCRIPTION
JavaScript calls the \f[CR]valueOf\f[R] method to convert an object to a
primitive value.
You rarely need to invoke the \f[CR]valueOf\f[R] method yourself;
JavaScript automatically invokes it when encountering an object where a
primitive value is expected.
.PP
This method is called in priority by numeric conversion and primitive
conversion, but string conversion calls \f[CR]toString()\f[R] in
priority, and \f[CR]toString()\f[R] is very likely to return a string
value (even for the \f[CR]Object.prototype.toString()\f[R] base
implementation), so \f[CR]valueOf()\f[R] is usually not called in this
case.
.PP
All objects that inherit from \f[CR]Object.prototype\f[R] (that is, all
except \f[CR]null\f[R]\-prototype objects) inherit the
\f[CR]toString()\f[R] method.
The \f[CR]Object.prototype.valueOf()\f[R] base implementation is
deliberately useless: by returning an object, its return value will
never be used by any primitive conversion algorithm.
Many built\-in objects override this method to return an appropriate
primitive value.
When you create a custom object, you can override \f[CR]valueOf()\f[R]
to call a custom method, so that your custom object can be converted to
a primitive value.
Generally, \f[CR]valueOf()\f[R] is used to return a value that is most
meaningful for the object \[em] unlike \f[CR]toString()\f[R], it does
not need to be a string.
Alternatively, you can add a \f[CR][Symbol.toPrimitive]()\f[R] method,
which allows even more control over the conversion process, and will
always be preferred over \f[CR]valueOf\f[R] or \f[CR]toString\f[R] for
any type conversion.
.SH EXAMPLES
.SS Using valueOf()
The base \f[CR]valueOf()\f[R] method returns the \f[CR]this\f[R] value
itself, converted to an object if it isn\[cq]t already.
Therefore its return value will never be used by any primitive
conversion algorithm.
.IP
.EX
\f[B]const\f[R] obj = { foo: 1 };
console.log(obj.valueOf() === obj); \f[I]// true\f[R]

console.log(Object.prototype.valueOf.call(\[dq]primitive\[dq]));
\f[I]// [String: \[aq]primitive\[aq]] (a wrapper object)\f[R]
.EE
.SS Overriding valueOf for custom objects
You can create a function to be called in place of the default
\f[CR]valueOf\f[R] method.
Your function should take no arguments, since it won\[cq]t be passed any
when called during type conversion.
.PP
For example, you can add a \f[CR]valueOf\f[R] method to your custom
class \f[CR]Box\f[R].
.IP
.EX
\f[B]class\f[R] Box {
  #value;
  constructor(value) {
    \f[B]this\f[R].#value = value;
  }
  valueOf() {
    \f[B]return\f[R] \f[B]this\f[R].#value;
  }
}
.EE
.PP
With the preceding code in place, any time an object of type
\f[CR]Box\f[R] is used in a context where it is to be represented as a
primitive value (but not specifically a string), JavaScript
automatically calls the function defined in the preceding code.
.IP
.EX
\f[B]const\f[R] box = \f[B]new\f[R] Box(123);
console.log(box + 456); \f[I]// 579\f[R]
console.log(box == 123); \f[I]// true\f[R]
.EE
.PP
An object\[cq]s \f[CR]valueOf\f[R] method is usually invoked by
JavaScript, but you can invoke it yourself as follows:
.IP
.EX
box.valueOf();
.EE
.SS Using unary plus on objects
Unary plus performs number coercion on its operand, which, for most
objects without \f[CR][Symbol.toPrimitive]()\f[R], means calling its
\f[CR]valueOf()\f[R].
However, if the object doesn\[cq]t have a custom \f[CR]valueOf()\f[R]
method, the base implementation will cause \f[CR]valueOf()\f[R] to be
ignored and the return value of \f[CR]toString()\f[R] to be used
instead.
.IP
.EX
+\f[B]new\f[R] Date(); \f[I]// the current timestamp; same as new Date().getTime()\f[R]
+{}; \f[I]// NaN (toString() returns \[dq][object Object]\[dq])\f[R]
+[]; \f[I]// 0 (toString() returns an empty string list)\f[R]
+[1]; \f[I]// 1 (toString() returns \[dq]1\[dq])\f[R]
+[1, 2]; \f[I]// NaN (toString() returns \[dq]1,2\[dq])\f[R]
+\f[B]new\f[R] Set([1]); \f[I]// NaN (toString() returns \[dq][object Set]\[dq])\f[R]
+{ valueOf: () \f[B]=>\f[R] 42 }; \f[I]// 42\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Object.prototype.toString()\f[R]
.IP \[bu] 2
\f[CR]parseInt()\f[R]
.IP \[bu] 2
\f[CR]Symbol.toPrimitive\f[R]
