.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "BOOLEAN" "3JS" "March 6, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Boolean \- Boolean
.SH SYNOPSIS
\f[B]\f[CB]Boolean\f[B]\f[R] values can be one of two values:
\f[CR]true\f[R] or \f[CR]false\f[R], representing the truth value of a
logical proposition.
.SH DESCRIPTION
Boolean values are typically produced by relational operators, equality
operators, and logical NOT (\f[CR]!\f[R]).
They can also be produced by functions that represent conditions, such
as \f[CR]Array.isArray()\f[R].
Note that binary logical operators such as \f[CR]&&\f[R] and
\f[CR]||\f[R] return the values of the operands, which may or may not be
boolean values.
.PP
Boolean values are typically used in conditional testing, such as the
condition for \f[CR]if...else\f[R] and \f[CR]while\f[R] statements, the
conditional operator (\f[CR]? :\f[R]), or the predicate return value of
\f[CR]Array.prototype.filter()\f[R].
.PP
You would rarely need to explicitly convert something to a boolean
value, as JavaScript does this automatically in boolean contexts, so you
can use any value as if it\(cqs a boolean, based on its truthiness.
You are also encouraged to use \f[CR]if (condition)\f[R] and
\f[CR]if (!condition)\f[R] instead of \f[CR]if (condition === true)\f[R]
or \f[CR]if (condition === false)\f[R] in your own code so you can take
advantage of this convention.
However, making sure that values representing conditions are always
booleans can help clarify the intent of your code.
.IP
.EX
\f[I]// Do this:\f[R]
\f[I]// This always returns a boolean value\f[R]
\f[B]const\f[R] isObject = (obj) \f[B]=>\f[R] !!obj && \f[B]typeof\f[R] obj === \(dqobject\(dq;

\f[I]// Or this:\f[R]
\f[B]const\f[R] isObject = (obj) \f[B]=>\f[R] Boolean(obj) && \f[B]typeof\f[R] obj === \(dqobject\(dq;

\f[I]// Or this:\f[R]
\f[B]const\f[R] isObject = (obj) \f[B]=>\f[R] obj !== \f[B]null\f[R] && \f[B]typeof\f[R] obj === \(dqobject\(dq;

\f[I]// Instead of this:\f[R]
\f[I]// This may return falsy values that are not equal to false\f[R]
\f[B]const\f[R] isObject = (obj) \f[B]=>\f[R] obj && \f[B]typeof\f[R] obj === \(dqobject\(dq;
.EE
.SS Boolean primitives and Boolean objects
For converting non\-boolean values to boolean, use \f[CR]Boolean\f[R] as
a function or use the double NOT operator.
Do not use the \f[CR]Boolean()\f[R] constructor with \f[CR]new\f[R].
.PP
\f[B]Good\f[R]
.IP
.EX
\f[B]const\f[R] good = Boolean(expression);
\f[B]const\f[R] good2 = !!expression;
.EE
.PP
\f[B]Bad\f[R]
.IP
.EX
\f[B]const\f[R] bad = \f[B]new\f[R] Boolean(expression); \f[I]// don\(aqt use this!\f[R]
.EE
.PP
This is because \f[I]all\f[R] objects, including a \f[CR]Boolean\f[R]
object whose wrapped value is \f[CR]false\f[R], are truthy and evaluate
to \f[CR]true\f[R] in places such as conditional statements.
(See also the boolean coercion section below.)
.IP
.EX
\f[B]if\f[R] (\f[B]new\f[R] Boolean(\f[B]true\f[R])) {
  console.log(\(dqThis log is printed.\(dq);
}

\f[B]if\f[R] (\f[B]new\f[R] Boolean(\f[B]false\f[R])) {
  console.log(\(dqThis log is ALSO printed.\(dq);
}

\f[B]const\f[R] myFalse = \f[B]new\f[R] Boolean(\f[B]false\f[R]); \f[I]// myFalse is a Boolean object (not the primitive value false)\f[R]
\f[B]const\f[R] g = Boolean(myFalse); \f[I]// g is true\f[R]
\f[B]const\f[R] myString = \f[B]new\f[R] String(\(dqHello\(dq); \f[I]// myString is a String object\f[R]
\f[B]const\f[R] s = Boolean(myString); \f[I]// s is true\f[R]
.EE
.RS
.PP
\f[B]Warning:\f[R] You should rarely find yourself using
\f[CR]Boolean\f[R] as a constructor.
.RE
.SS Boolean coercion
Many built\-in operations that expect booleans first coerce their
arguments to booleans.
\c
.UR https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toboolean
The operation
.UE \c
\ can be summarized as follows:
.IP \(bu 2
Booleans are returned as\-is.
.IP \(bu 2
\f[CR]undefined\f[R] turns into \f[CR]false\f[R].
.IP \(bu 2
\f[CR]null\f[R] turns into \f[CR]false\f[R].
.IP \(bu 2
\f[CR]0\f[R], \f[CR]\-0\f[R], and \f[CR]NaN\f[R] turn into
\f[CR]false\f[R]; other numbers turn into \f[CR]true\f[R].
.IP \(bu 2
\f[CR]0n\f[R] turns into \f[CR]false\f[R]; other BigInts turn into
\f[CR]true\f[R].
.IP \(bu 2
The empty string \f[CR]\(dq\(dq\f[R] turns into \f[CR]false\f[R]; other
strings turn into \f[CR]true\f[R].
.IP \(bu 2
Symbols turn into \f[CR]true\f[R].
.IP \(bu 2
All objects become \f[CR]true\f[R].
.RS
.PP
\f[B]Note:\f[R] A legacy behavior makes \f[CR]document.all\f[R] return
\f[CR]false\f[R] when used as a boolean, despite it being an object.
This property is legacy and non\-standard and should not be used.
.RE
.RS
.PP
\f[B]Note:\f[R] Unlike other type conversions like string coercion or
number coercion, boolean coercion does not attempt to convert objects to
primitives by calling user methods.
.RE
.PP
In other words, there are only a handful of values that get coerced to
\f[CR]false\f[R] \(em these are called falsy values.
All other values are called truthy values.
A value\(cqs truthiness is important when used with logical operators,
conditional statements, or any boolean context.
.PP
There are two ways to achieve the same effect in JavaScript.
.IP \(bu 2
Double NOT: \f[CR]!!x\f[R] negates \f[CR]x\f[R] twice, which converts
\f[CR]x\f[R] to a boolean using the same algorithm as above.
.IP \(bu 2
The \f[CR]Boolean()\f[R] function: \f[CR]Boolean(x)\f[R] uses the same
algorithm as above to convert \f[CR]x\f[R].
.PP
Note that truthiness is not the same as being loosely equal to
\f[CR]true\f[R] or \f[CR]false\f[R].
.IP
.EX
\f[B]if\f[R] ([]) {
  console.log(\(dq[] is truthy\(dq);
}
\f[B]if\f[R] ([] == \f[B]false\f[R]) {
  console.log(\(dq[] == false\(dq);
}
\f[I]// [] is truthy\f[R]
\f[I]// [] == false\f[R]
.EE
.PP
\f[CR][]\f[R] is truthy, but it\(cqs also loosely equal to
\f[CR]false\f[R].
It\(cqs truthy, because all objects are truthy.
However, when comparing with \f[CR]false\f[R], which is a primitive,
\f[CR][]\f[R] is also converted to a primitive, which is
\f[CR]\(dq\(dq\f[R] via \f[CR]Array.prototype.toString()\f[R].
Comparing strings and booleans results in both being converted to
numbers, and they both become \f[CR]0\f[R], so \f[CR][] == false\f[R] is
\f[CR]true\f[R].
In general, falsiness and \f[CR]== false\f[R] differ in the following
cases:
.IP \(bu 2
\f[CR]NaN\f[R], \f[CR]undefined\f[R], and \f[CR]null\f[R] are falsy but
not loosely equal to \f[CR]false\f[R].
.IP \(bu 2
\f[CR]\(dq0\(dq\f[R] (and other string literals that are not
\f[CR]\(dq\(dq\f[R] but get coerced to 0) is truthy but loosely equal to
\f[CR]false\f[R].
.IP \(bu 2
Objects are always truthy, but their primitive representation may be
loosely equal to \f[CR]false\f[R].
.PP
Truthy values are even more unlikely to be loosely equal to
\f[CR]true\f[R].
All values are either truthy or falsy, but most values are loosely equal
to neither \f[CR]true\f[R] nor \f[CR]false\f[R].
.SH CONSTRUCTOR
.TP
\f[B]Boolean()\f[R]
Creates \f[CR]Boolean\f[R] objects.
When called as a function, it returns primitive values of type Boolean.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]Boolean.prototype\f[R] and shared
by all \f[CR]Boolean\f[R] instances.
.TP
\f[B]Boolean.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]Boolean\f[R] instances, the initial value is the
\f[CR]Boolean\f[R] constructor.
.SH INSTANCE METHODS
.TP
\f[B]Boolean.prototype.toString()\f[R]
Returns a string of either \f[CR]true\f[R] or \f[CR]false\f[R] depending
upon the value of the object.
Overrides the \f[CR]Object.prototype.toString()\f[R] method.
.TP
\f[B]Boolean.prototype.valueOf()\f[R]
Returns the primitive value of the \f[CR]Boolean\f[R] object.
Overrides the \f[CR]Object.prototype.valueOf()\f[R] method.
.SH EXAMPLES
.SS Creating false values
.IP
.EX
\f[B]const\f[R] bNoParam = Boolean();
\f[B]const\f[R] bZero = Boolean(0);
\f[B]const\f[R] bNull = Boolean(\f[B]null\f[R]);
\f[B]const\f[R] bEmptyString = Boolean(\(dq\(dq);
\f[B]const\f[R] bfalse = Boolean(\f[B]false\f[R]);
.EE
.SS Creating true values
.IP
.EX
\f[B]const\f[R] btrue = Boolean(\f[B]true\f[R]);
\f[B]const\f[R] btrueString = Boolean(\(dqtrue\(dq);
\f[B]const\f[R] bfalseString = Boolean(\(dqfalse\(dq);
\f[B]const\f[R] bSuLin = Boolean(\(dqSu Lin\(dq);
\f[B]const\f[R] bArrayProto = Boolean([]);
\f[B]const\f[R] bObjProto = Boolean({});
.EE
.SH SEE ALSO
.IP \(bu 2
Boolean
.IP \(bu 2
Boolean primitives
.IP \(bu 2
\c
.UR https://en.wikipedia.org/wiki/Boolean_data_type
Boolean data type
.UE \c
\ on Wikipedia
