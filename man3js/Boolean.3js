.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Boolean" "JS" "February 12, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Boolean \- Boolean
.SH SYNOPSIS
The \f[B]\f[CB]Boolean\f[B]\f[R] object represents a truth value:
\f[CR]true\f[R] or \f[CR]false\f[R].
.SH DESCRIPTION
.SS Boolean primitives and Boolean objects
For converting non\-boolean values to boolean, use \f[CR]Boolean\f[R] as
a function or use the double NOT operator.
Do not use the \f[CR]Boolean()\f[R] constructor with \f[CR]new\f[R].
.PP
\f[B]Good\f[R]
.IP
.EX
\f[B]const\f[R] good = Boolean(expression);
\f[B]const\f[R] good2 = !!expression;
.EE
.PP
\f[B]Bad\f[R]
.IP
.EX
\f[B]const\f[R] bad = \f[B]new\f[R] Boolean(expression); \f[I]// don\[aq]t use this!\f[R]
.EE
.PP
This is because \f[I]all\f[R] objects, including a \f[CR]Boolean\f[R]
object whose wrapped value is \f[CR]false\f[R], are truthy and evaluate
to \f[CR]true\f[R] in places such as conditional statements.
(See also the boolean coercion section below.)
.IP
.EX
\f[B]if\f[R] (\f[B]new\f[R] Boolean(\f[B]true\f[R])) {
  console.log(\[dq]This log is printed.\[dq]);
}

\f[B]if\f[R] (\f[B]new\f[R] Boolean(\f[B]false\f[R])) {
  console.log(\[dq]This log is ALSO printed.\[dq]);
}

\f[B]const\f[R] myFalse = \f[B]new\f[R] Boolean(\f[B]false\f[R]); \f[I]// myFalse is a Boolean object (not the primitive value false)\f[R]
\f[B]const\f[R] g = Boolean(myFalse); \f[I]// g is true\f[R]
\f[B]const\f[R] myString = \f[B]new\f[R] String(\[dq]Hello\[dq]); \f[I]// myString is a String object\f[R]
\f[B]const\f[R] s = Boolean(myString); \f[I]// s is true\f[R]
.EE
.RS
.PP
\f[B]Warning:\f[R] You should rarely find yourself using
\f[CR]Boolean\f[R] as a constructor.
.RE
.SS Boolean coercion
Many built\-in operations that expect booleans first coerce their
arguments to booleans.
\c
.UR https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toboolean
The operation
.UE \c
\ can be summarized as follows:
.IP \[bu] 2
Booleans are returned as\-is.
.IP \[bu] 2
\f[CR]undefined\f[R] turns into \f[CR]false\f[R].
.IP \[bu] 2
\f[CR]null\f[R] turns into \f[CR]false\f[R].
.IP \[bu] 2
\f[CR]0\f[R], \f[CR]\-0\f[R], and \f[CR]NaN\f[R] turn into
\f[CR]false\f[R]; other numbers turn into \f[CR]true\f[R].
.IP \[bu] 2
\f[CR]0n\f[R] turns into \f[CR]false\f[R]; other BigInts turn into
\f[CR]true\f[R].
.IP \[bu] 2
The empty string \f[CR]\[dq]\[dq]\f[R] turns into \f[CR]false\f[R];
other strings turn into \f[CR]true\f[R].
.IP \[bu] 2
Symbols turn into \f[CR]true\f[R].
.IP \[bu] 2
All objects become \f[CR]true\f[R].
.RS
.PP
\f[B]Note:\f[R] A legacy behavior makes \f[CR]document.all\f[R] return
\f[CR]false\f[R] when used as a boolean, despite it being an object.
This property is legacy and non\-standard and should not be used.
.RE
.RS
.PP
\f[B]Note:\f[R] Unlike other type conversions like string coercion or
number coercion, boolean coercion does not attempt to convert objects to
primitives.
.RE
.PP
In other words, there are only a handful of values that get coerced to
\f[CR]false\f[R] \[em] these are called falsy values.
All other values are called truthy values.
A value\[cq]s truthiness is important when used with logical operators,
conditional statements, or any boolean context.
.PP
There are two ways to achieve the same effect in JavaScript.
.IP \[bu] 2
Double NOT: \f[CR]!!x\f[R] negates \f[CR]x\f[R] twice, which converts
\f[CR]x\f[R] to a boolean using the same algorithm as above.
.IP \[bu] 2
The \f[CR]Boolean()\f[R] function: \f[CR]Boolean(x)\f[R] uses the same
algorithm as above to convert \f[CR]x\f[R].
.PP
Note that truthiness is not the same as being loosely equal to
\f[CR]true\f[R] or \f[CR]false\f[R].
.IP
.EX
\f[B]if\f[R] ([]) {
  console.log(\[dq][] is truthy\[dq]);
}
\f[B]if\f[R] ([] == \f[B]false\f[R]) {
  console.log(\[dq][] == false\[dq]);
}
\f[I]// [] is truthy\f[R]
\f[I]// [] == false\f[R]
.EE
.PP
\f[CR][]\f[R] is truthy, but it\[cq]s also loosely equal to
\f[CR]false\f[R].
It\[cq]s truthy, because all objects are truthy.
However, when comparing with \f[CR]false\f[R], which is a primitive,
\f[CR][]\f[R] is also converted to a primitive, which is
\f[CR]\[dq]\[dq]\f[R] via \f[CR]Array.prototype.toString()\f[R].
Comparing strings and booleans results in both being converted to
numbers, and they both become \f[CR]0\f[R], so \f[CR][] == false\f[R] is
\f[CR]true\f[R].
In general, falsiness and \f[CR]== false\f[R] differ in the following
cases:
.IP \[bu] 2
\f[CR]NaN\f[R], \f[CR]undefined\f[R], and \f[CR]null\f[R] are falsy but
not loosely equal to \f[CR]false\f[R].
.IP \[bu] 2
\f[CR]\[dq]0\[dq]\f[R] (and other string literals that are not
\f[CR]\[dq]\[dq]\f[R] but get coerced to 0) is truthy but loosely equal
to \f[CR]false\f[R].
.IP \[bu] 2
Objects are always truthy, but their primitive representation may be
loosely equal to \f[CR]false\f[R].
.PP
Truthy values are even more unlikely to be loosely equal to
\f[CR]true\f[R].
All values are either truthy or falsy, but most values are loosely equal
to neither \f[CR]true\f[R] nor \f[CR]false\f[R].
.SH CONSTRUCTOR
.TP
\f[B]Boolean()\f[R]
Creates a new \f[CR]Boolean\f[R] object.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]Boolean.prototype\f[R] and shared
by all \f[CR]Boolean\f[R] instances.
.TP
\f[B]Boolean.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]Boolean\f[R] instances, the initial value is the
\f[CR]Boolean\f[R] constructor.
.SH INSTANCE METHODS
.TP
\f[B]Boolean.prototype.toString()\f[R]
Returns a string of either \f[CR]true\f[R] or \f[CR]false\f[R] depending
upon the value of the object.
Overrides the \f[CR]Object.prototype.toString()\f[R] method.
.TP
\f[B]Boolean.prototype.valueOf()\f[R]
Returns the primitive value of the \f[CR]Boolean\f[R] object.
Overrides the \f[CR]Object.prototype.valueOf()\f[R] method.
.SH EXAMPLES
.SS Creating Boolean objects with an initial value of false
.IP
.EX
\f[B]const\f[R] bNoParam = \f[B]new\f[R] Boolean();
\f[B]const\f[R] bZero = \f[B]new\f[R] Boolean(0);
\f[B]const\f[R] bNull = \f[B]new\f[R] Boolean(\f[B]null\f[R]);
\f[B]const\f[R] bEmptyString = \f[B]new\f[R] Boolean(\[dq]\[dq]);
\f[B]const\f[R] bfalse = \f[B]new\f[R] Boolean(\f[B]false\f[R]);
.EE
.SS Creating Boolean objects with an initial value of true
.IP
.EX
\f[B]const\f[R] btrue = \f[B]new\f[R] Boolean(\f[B]true\f[R]);
\f[B]const\f[R] btrueString = \f[B]new\f[R] Boolean(\[dq]true\[dq]);
\f[B]const\f[R] bfalseString = \f[B]new\f[R] Boolean(\[dq]false\[dq]);
\f[B]const\f[R] bSuLin = \f[B]new\f[R] Boolean(\[dq]Su Lin\[dq]);
\f[B]const\f[R] bArrayProto = \f[B]new\f[R] Boolean([]);
\f[B]const\f[R] bObjProto = \f[B]new\f[R] Boolean({});
.EE
.SH SEE ALSO
.IP \[bu] 2
Boolean
.IP \[bu] 2
Boolean primitives
.IP \[bu] 2
\c
.UR https://en.wikipedia.org/wiki/Boolean_data_type
Boolean data type
.UE \c
\ on Wikipedia
