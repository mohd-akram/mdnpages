.\" Automatically generated by Pandoc 3.4
.\"
.TH "CanvasRenderingContext2D.roundRect" "JS" "April 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
CanvasRenderingContext2D.roundRect \- CanvasRenderingContext2D:
roundRect() method
.SH SYNOPSIS
The \f[B]\f[CB]CanvasRenderingContext2D.roundRect()\f[B]\f[R] method of
the Canvas 2D API adds a rounded rectangle to the current path.
.PP
The radii of the corners can be specified in much the same way as the
CSS \f[CR]border\-radius\f[R] property.
.PP
Like other methods that modify the current path, this method does not
directly render anything.
To draw the rounded rectangle onto a canvas, you can use the
\f[CR]fill()\f[R] or \f[CR]stroke()\f[R] methods.
.SH SYNTAX
.IP
.EX
roundRect(x, y, width, height, radii)
.EE
.SS Parameters
.TP
\f[B]x\f[R]
The x\-axis coordinate of the rectangle\[cq]s starting point, in pixels.
.TP
\f[B]y\f[R]
The y\-axis coordinate of the rectangle\[cq]s starting point, in pixels.
.TP
\f[B]width\f[R]
The rectangle\[cq]s width.
Positive values are to the right, and negative to the left.
.TP
\f[B]height\f[R]
The rectangle\[cq]s height.
Positive values are down, and negative are up.
.TP
\f[B]radii\f[R]
A number or list specifying the radii of the circular arc to be used for
the corners of the rectangle.
The number and order of the radii function in the same way as the
\f[CR]border\-radius\f[R] CSS property when \f[CR]width\f[R] and
\f[CR]height\f[R] are \f[I]positive\f[R]:
.RS
.IP \[bu] 2
\f[CR]all\-corners\f[R]
.IP \[bu] 2
\f[CR][all\-corners]\f[R]
.IP \[bu] 2
\f[CR][top\-left\-and\-bottom\-right, top\-right\-and\-bottom\-left]\f[R]
.IP \[bu] 2
\f[CR][top\-left, top\-right\-and\-bottom\-left, bottom\-right]\f[R]
.IP \[bu] 2
\f[CR][top\-left, top\-right, bottom\-right, bottom\-left]\f[R]
.PP
If \f[CR]width\f[R] is \f[I]negative\f[R] the rounded rectangle is
flipped horizontally, so the radius values that normally apply to the
left corners are used on the right and vice versa.
Similarly, when \f[CR]height\f[R] is negative, the rounded rect is
flipped vertically.
The specified radii may be scaled (reduced) if any of the edges are
shorter than the combined radius of the vertices on either end.
.PP
The \f[CR]radii\f[R] parameter can also be a \f[CR]DOMPoint\f[R] or
\f[CR]DOMPointReadOnly\f[R] instance, or an object containing the same
properties (\f[CR]{x: 0, y: 0}\f[R]), or a list of such objects, or a
list mixing numbers and such objects.
.RE
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.TP
\f[B]RangeError\f[R]
If \f[CR]radii\f[R] is a list that has zero or more than four elements,
or if one of its values is a negative number.
.SH EXAMPLES
.SS Drawing rectangles
This example creates a number of rounded rectangular paths using the
\f[CR]roundRect()\f[R] method.
The paths are then rendered using the \f[CR]stroke()\f[R] method.
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]canvas\[dq] width=\[dq]700\[dq] height=\[dq]300\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
First we create a context for drawing our rounded rectangles.
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);
.EE
.PP
The code below draws two rectangles, both starting from the point (10,
20) and with a width of 150 and a height of 100.
The first rectangle is drawn in red and specifies a zero radius for all
the corners using a number as an argument.
The second is drawn in blue, and specifies a 40px radius as a single
element in a list.
.IP
.EX
\f[I]// Rounded rectangle with zero radius (specified as a number)\f[R]
ctx.strokeStyle = \[dq]red\[dq];
ctx.beginPath();
ctx.roundRect(10, 20, 150, 100, 0);
ctx.stroke();

\f[I]// Rounded rectangle with 40px radius (single element list)\f[R]
ctx.strokeStyle = \[dq]blue\[dq];
ctx.beginPath();
ctx.roundRect(10, 20, 150, 100, [40]);
ctx.stroke();
.EE
.PP
Below the previous rectangle we draw another in orange that specifies
the values of the radii of opposite corners.
.IP
.EX
\f[I]// Rounded rectangle with 2 different radii\f[R]
ctx.strokeStyle = \[dq]orange\[dq];
ctx.beginPath();
ctx.roundRect(10, 150, 150, 100, [10, 40]);
ctx.stroke();
.EE
.PP
Finally, we draw two rounded rectangles that have four values for the
radii and the same starting point.
The difference here is that the second is drawn with a negative width.
.IP
.EX
\f[I]// Rounded rectangle with four different radii\f[R]
ctx.strokeStyle = \[dq]green\[dq];
ctx.beginPath();
ctx.roundRect(400, 20, 200, 100, [0, 30, 50, 60]);
ctx.stroke();

\f[I]// Same rectangle drawn backwards\f[R]
ctx.strokeStyle = \[dq]magenta\[dq];
ctx.beginPath();
ctx.roundRect(400, 150, \-200, 100, [0, 30, 50, 60]);
ctx.stroke();
.EE
.SS Result
The result is shown below.
For the two rectangles on the right, note how the bottom rectangle is
drawn with a negative width, and how this flips the rectangle
horizontally.
.SH SEE ALSO
.IP \[bu] 2
The interface defining this method: \f[CR]CanvasRenderingContext2D\f[R]
.IP \[bu] 2
\f[CR]CanvasRenderingContext2D.rect()\f[R]
.IP \[bu] 2
\f[CR]CanvasRenderingContext2D.fillRect\f[R]
.IP \[bu] 2
\f[CR]CanvasRenderingContext2D.strokeRect()\f[R]
.IP \[bu] 2
\f[CR]CanvasRenderingContext2D.fill()\f[R]
.IP \[bu] 2
\f[CR]CanvasRenderingContext2D.stroke()\f[R]
