.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "INTL.SEGMENTER.SEGMENT.SEGMENTS.SYMBOL.ITERATOR" "3JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.Segmenter.segment.Segments.Symbol.iterator \-
Segments.prototypeSymbol.iterator
.SH SYNOPSIS
The \f[B]\f[CB][Symbol.iterator]()\f[B]\f[R] method of
\f[CR]Segments\f[R] instances implements the iterable protocol and
allows \f[CR]Segments\f[R] objects to be consumed by most syntaxes
expecting iterables, such as the spread syntax and \f[CR]for...of\f[R]
loops.
It returns a segments iterator object that yields data about each
segment.
.IP
.EX
\f[B]const\f[R] segmenterFr = \f[B]new\f[R] Intl.Segmenter(\(dqfr\(dq, { granularity: \(dqword\(dq });
\f[B]const\f[R] string1 = \(dqQue ma joie demeure\(dq;

\f[B]const\f[R] iterator1 = segmenterFr.segment(string1)[Symbol.iterator]();

\f[B]for\f[R] (\f[B]const\f[R] segment \f[B]of\f[R] iterator1) {
  \f[B]if\f[R] (segment.segment.length > 4) {
    console.log(segment.segment);
  }
}

\f[I]// Expected output: \(dqdemeure\(dq\f[R]
.EE
.SH SYNTAX
.IP
.EX
segments[Symbol.iterator]()
.EE
.SS Parameters
None.
.SS Return value
A new iterable iterator object that yields data about each segment.
Each yielded object has the same properties as the object returned by
the \f[CR]containing()\f[R] method.
.SH EXAMPLES
.SS Iteration using for\&...of loop
Note that you seldom need to call this method directly.
The existence of the \f[CR][Symbol.iterator]()\f[R] method makes
\f[CR]Segments\f[R] objects iterable, and iterating syntaxes like the
\f[CR]for...of\f[R] loop automatically call this method to obtain the
iterator to loop over.
.IP
.EX
\f[B]const\f[R] segmenter = \f[B]new\f[R] Intl.Segmenter(\(dqzh\-CN\(dq, { granularity: \(dqword\(dq });
\f[B]const\f[R] input = \(dq你好，世界！我爱编程。\(dq;

\f[B]for\f[R] (\f[B]const\f[R] value \f[B]of\f[R] segmenter.segment(input)) {
  console.log(value);
}

\f[I]/*\f[R]
\f[I]{segment: \(aq你好\(aq, index: 0, input: \(aq你好，世界！我爱编程。\(aq, isWordLike: true}\f[R]
\f[I]{segment: \(aq，\(aq, index: 2, input: \(aq你好，世界！我爱编程。\(aq, isWordLike: false}\f[R]
\f[I]{segment: \(aq世界\(aq, index: 3, input: \(aq你好，世界！我爱编程。\(aq, isWordLike: true}\f[R]
\f[I]{segment: \(aq！\(aq, index: 5, input: \(aq你好，世界！我爱编程。\(aq, isWordLike: false}\f[R]
\f[I]{segment: \(aq我\(aq, index: 6, input: \(aq你好，世界！我爱编程。\(aq, isWordLike: true}\f[R]
\f[I]{segment: \(aq爱\(aq, index: 7, input: \(aq你好，世界！我爱编程。\(aq, isWordLike: true}\f[R]
\f[I]{segment: \(aq编\(aq, index: 8, input: \(aq你好，世界！我爱编程。\(aq, isWordLike: true}\f[R]
\f[I]{segment: \(aq程\(aq, index: 9, input: \(aq你好，世界！我爱编程。\(aq, isWordLike: true}\f[R]
\f[I]{segment: \(aq。\(aq, index: 10, input: \(aq你好，世界！我爱编程。\(aq, isWordLike: false}\f[R]
\f[I]*/\f[R]
.EE
.SS Manually hand\-rolling the iterator
You may still manually call the \f[CR]next()\f[R] method of the returned
iterator object to achieve maximum control over the iteration process.
.IP
.EX
\f[B]const\f[R] segmenter = \f[B]new\f[R] Intl.Segmenter(\(dqfr\(dq, { granularity: \(dqword\(dq });
\f[B]const\f[R] input = \(dqMoi ? N\(aqest\-ce pas ?\(dq;
\f[B]const\f[R] segments = segmenter.segment(input);
\f[B]const\f[R] iterator = segments[Symbol.iterator]();

\f[B]let\f[R] result = iterator.next();

\f[B]while\f[R] (!result.done) {
  console.log(result.value);
  result = iterator.next();
}

\f[I]/*\f[R]
\f[I]{segment: \(aqMoi\(aq, index: 0, input: \(dqMoi ? N\(aqest\-ce pas ?\(dq, isWordLike: true}\f[R]
\f[I]{segment: \(aq \(aq, index: 3, input: \(dqMoi ? N\(aqest\-ce pas ?\(dq, isWordLike: false}\f[R]
\f[I]{segment: \(aq?\(aq, index: 4, input: \(dqMoi ? N\(aqest\-ce pas ?\(dq, isWordLike: false}\f[R]
\f[I]{segment: \(aq \(aq, index: 5, input: \(dqMoi ? N\(aqest\-ce pas ?\(dq, isWordLike: false}\f[R]
\f[I]{segment: \(dqN\(aqest\(dq, index: 6, input: \(dqMoi ? N\(aqest\-ce pas ?\(dq, isWordLike: true}\f[R]
\f[I]{segment: \(aq\-\(aq, index: 11, input: \(dqMoi ? N\(aqest\-ce pas ?\(dq, isWordLike: false}\f[R]
\f[I]{segment: \(aqce\(aq, index: 12, input: \(dqMoi ? N\(aqest\-ce pas ?\(dq, isWordLike: true}\f[R]
\f[I]{segment: \(aq \(aq, index: 14, input: \(dqMoi ? N\(aqest\-ce pas ?\(dq, isWordLike: false}\f[R]
\f[I]{segment: \(aqpas\(aq, index: 15, input: \(dqMoi ? N\(aqest\-ce pas ?\(dq, isWordLike: true}\f[R]
\f[I]{segment: \(aq \(aq, index: 18, input: \(dqMoi ? N\(aqest\-ce pas ?\(dq, isWordLike: false}\f[R]
\f[I]{segment: \(aq?\(aq, index: 19, input: \(dqMoi ? N\(aqest\-ce pas ?\(dq, isWordLike: false}\f[R]
\f[I]*/\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Intl.Segmenter\f[R]
.IP \(bu 2
\f[CR]Intl.Segmenter.prototype.segment()\f[R]
.IP \(bu 2
\f[CR]Symbol.iterator\f[R]
.IP \(bu 2
Iteration protocols
