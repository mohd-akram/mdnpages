.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "NUMBER.ISINTEGER" "3JS" "March 5, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Number.isInteger \- Number.isInteger()
.SH SYNOPSIS
The \f[B]\f[CB]Number.isInteger()\f[B]\f[R] static method determines
whether the passed value is an integer.
.IP
.EX
\f[B]function\f[R] fits(x, y) {
  \f[B]if\f[R] (Number.isInteger(y / x)) {
    \f[B]return\f[R] \(dqFits!\(dq;
  }
  \f[B]return\f[R] \(dqDoes NOT fit!\(dq;
}

console.log(fits(5, 10));
\f[I]// Expected output: \(dqFits!\(dq\f[R]

console.log(fits(5, 11));
\f[I]// Expected output: \(dqDoes NOT fit!\(dq\f[R]
.EE
.SH SYNTAX
.IP
.EX
Number.isInteger(value)
.EE
.SS Parameters
.TP
\f[B]value\f[R]
The value to be tested for being an integer.
.SS Return value
The boolean value \f[CR]true\f[R] if the given value is an integer.
Otherwise \f[CR]false\f[R].
.SH DESCRIPTION
If the target value is an integer, return \f[CR]true\f[R], otherwise
return \f[CR]false\f[R].
If the value is \f[CR]NaN\f[R] or \f[CR]Infinity\f[R], return
\f[CR]false\f[R].
The method will also return \f[CR]true\f[R] for floating point numbers
that can be represented as integer.
It will always return \f[CR]false\f[R] if the value is not a number.
.PP
Note that some number literals, while looking like non\-integers,
actually represent integers \(em due to the precision limit of
ECMAScript floating\-point number encoding (IEEE\-754).
For example, \f[CR]5.0000000000000001\f[R] only differs from
\f[CR]5\f[R] by \f[CR]1e\-16\f[R], which is too small to be represented.
(For reference, \f[CR]Number.EPSILON\f[R] stores the distance between 1
and the next representable floating\-point number greater than 1, and
that is about \f[CR]2.22e\-16\f[R].)
Therefore, \f[CR]5.0000000000000001\f[R] will be represented with the
same encoding as \f[CR]5\f[R], thus making
\f[CR]Number.isInteger(5.0000000000000001)\f[R] return \f[CR]true\f[R].
.PP
In a similar sense, numbers around the magnitude of
\f[CR]Number.MAX_SAFE_INTEGER\f[R] will suffer from loss of precision
and make \f[CR]Number.isInteger\f[R] return \f[CR]true\f[R] even when
it\(cqs not an integer.
(The actual threshold varies based on how many bits are needed to
represent the decimal \(em for example,
\f[CR]Number.isInteger(4500000000000000.1)\f[R] is \f[CR]true\f[R], but
\f[CR]Number.isInteger(4500000000000000.5)\f[R] is \f[CR]false\f[R].)
.SH EXAMPLES
.SS Using isInteger
.IP
.EX
Number.isInteger(0); \f[I]// true\f[R]
Number.isInteger(1); \f[I]// true\f[R]
Number.isInteger(\-100000); \f[I]// true\f[R]
Number.isInteger(99999999999999999999999); \f[I]// true\f[R]

Number.isInteger(0.1); \f[I]// false\f[R]
Number.isInteger(Math.PI); \f[I]// false\f[R]

Number.isInteger(\f[B]NaN\f[R]); \f[I]// false\f[R]
Number.isInteger(\f[B]Infinity\f[R]); \f[I]// false\f[R]
Number.isInteger(\-\f[B]Infinity\f[R]); \f[I]// false\f[R]
Number.isInteger(\(dq10\(dq); \f[I]// false\f[R]
Number.isInteger(\f[B]true\f[R]); \f[I]// false\f[R]
Number.isInteger(\f[B]false\f[R]); \f[I]// false\f[R]
Number.isInteger([1]); \f[I]// false\f[R]

Number.isInteger(5.0); \f[I]// true\f[R]
Number.isInteger(5.000000000000001); \f[I]// false\f[R]
Number.isInteger(5.0000000000000001); \f[I]// true, because of loss of precision\f[R]
Number.isInteger(4500000000000000.1); \f[I]// true, because of loss of precision\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-number
Polyfill of \f[CR]Number.isInteger\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/number.isinteger
es\-shims polyfill of \f[CR]Number.isInteger\f[R]
.UE \c
.IP \(bu 2
\f[CR]Number\f[R]
