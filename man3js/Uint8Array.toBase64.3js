.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Uint8Array.toBase64" "JS" "November 5, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Uint8Array.toBase64 \- Uint8Array.prototype.toBase64()
.SH SYNOPSIS
The \f[B]\f[CB]toBase64()\f[B]\f[R] method of \f[CR]Uint8Array\f[R]
instances returns a base64\-encoded string based on the data in this
\f[CR]Uint8Array\f[R] object.
.PP
This method should be preferred over \f[CR]Window.btoa()\f[R],
especially if you already have a \f[CR]Uint8Array\f[R] holding the
object, because you don\[cq]t need to convert it to a string first.
.SH SYNTAX
.IP
.EX
toBase64()
toBase64(options)
.EE
.SS Parameters
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object customizing the base64 string format.
It can contain the following properties:
.RS
.TP
\f[B]alphabet\f[R] \f[I](optional)\f[R]
A string specifying the base64 alphabet to use.
It can be one of the following:
.RS
.TP
\f[B]\[dq]base64\[dq]\f[R] (default)
Encode input with the standard base64 alphabet, which uses \f[CR]+\f[R]
and \f[CR]/\f[R].
.TP
\f[B]\[dq]base64url\[dq]\f[R]
Encode input with the URL\-safe base64 alphabet, which uses
\f[CR]\-\f[R] and \f[CR]_\f[R].
.RE
.TP
\f[B]omitPadding\f[R] \f[I](optional)\f[R]
A boolean specifying whether to omit padding characters (\f[CR]=\f[R])
at the end of the base64 string.
The default is \f[CR]false\f[R].
.RE
.SS Return value
A base64\-encoded string representing the data in the
\f[CR]Uint8Array\f[R].
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown in one of the following cases:
.RS
.IP \[bu] 2
The \f[CR]options\f[R] object is not an object or \f[CR]undefined\f[R].
.IP \[bu] 2
The \f[CR]options.alphabet\f[R] is not of the expected values or
\f[CR]undefined\f[R].
.RE
.SH EXAMPLES
.SS Encoding binary data
This example uses the default \f[CR]alphabet\f[R] and
\f[CR]omitPadding\f[R] options to encode data from a
\f[CR]Uint8Array\f[R] into a base64 string.
.IP
.EX
\f[B]const\f[R] uint8Array = \f[B]new\f[R] Uint8Array([29, 233, 101, 161]);
console.log(uint8Array.toBase64()); \f[I]// \[dq]HelloQ==\[dq]\f[R]
.EE
.SS Encoding data without padding
.IP
.EX
\f[B]const\f[R] uint8Array = \f[B]new\f[R] Uint8Array([29, 233, 101, 161]);
console.log(uint8Array.toBase64({ omitPadding: \f[B]true\f[R] })); \f[I]// \[dq]HelloQ\[dq]\f[R]
.EE
.SS Encoding data with URL\-safe alphabet
This example populates a \f[CR]URLSearchParams\f[R] object with a
base64\-encoded string using the URL\-safe alphabet.
.IP
.EX
\f[B]const\f[R] uint8Array = \f[B]new\f[R] Uint8Array([46, 139, 222, 255, 42, 46]);
\f[B]const\f[R] base64 = uint8Array.toBase64({ alphabet: \[dq]base64url\[dq] });
\f[B]const\f[R] params = \f[B]new\f[R] URLSearchParams();
params.set(\[dq]data\[dq], base64);
console.log(params.toString()); \f[I]// \[dq]data=Love_you\[dq]\f[R]
.EE
.SS Stream encoding
This example is adapted from the \c
.UR https://github.com/tc39/proposal-arraybuffer-base64/blob/main/stream.mjs
original proposal
.UE \c
, showcasing how to implement streaming in userland.
It mimics the \f[CR]TextEncoder\f[R] API with the \f[CR]stream\f[R]
option.
.IP
.EX
\f[B]class\f[R] Base64Encoder {
  #extra;
  #extraLength;
  constructor() {
    \f[B]this\f[R].#extra = \f[B]new\f[R] Uint8Array(3);
    \f[B]this\f[R].#extraLength = 0;
  }

  \f[I]// Partly derived from https://github.com/lucacasonato/base64_streams/blob/main/src/iterator/encoder.ts\f[R]
  encode(chunk = Uint8Array.of(), options = {}) {
    \f[B]const\f[R] stream = options.stream ?? \f[B]false\f[R];

    \f[B]if\f[R] (\f[B]this\f[R].#extraLength > 0) {
      \f[B]const\f[R] bytesNeeded = 3 \- \f[B]this\f[R].#extraLength;
      \f[B]const\f[R] bytesAvailable = Math.min(bytesNeeded, chunk.length);
      \f[B]this\f[R].#extra.set(chunk.subarray(0, bytesAvailable), \f[B]this\f[R].#extraLength);
      chunk = chunk.subarray(bytesAvailable);
      \f[B]this\f[R].#extraLength += bytesAvailable;
    }

    \f[B]if\f[R] (!stream) {
      \f[I]// assert: this.#extraLength.length === 0 || this.#extraLength === 3 || chunk.length === 0\f[R]
      \f[B]const\f[R] prefix = \f[B]this\f[R].#extra.subarray(0, \f[B]this\f[R].#extraLength).toBase64();
      \f[B]this\f[R].#extraLength = 0;
      \f[B]return\f[R] prefix + chunk.toBase64();
    }

    \f[B]let\f[R] extraReturn = \[dq]\[dq];

    \f[B]if\f[R] (\f[B]this\f[R].#extraLength === 3) {
      extraReturn = \f[B]this\f[R].#extra.toBase64();
      \f[B]this\f[R].#extraLength = 0;
    }

    \f[B]const\f[R] remainder = chunk.length % 3;
    \f[B]if\f[R] (remainder > 0) {
      \f[B]this\f[R].#extra.set(chunk.subarray(chunk.length \- remainder));
      \f[B]this\f[R].#extraLength = remainder;
      chunk = chunk.subarray(0, chunk.length \- remainder);
    }

    \f[B]return\f[R] extraReturn + chunk.toBase64();
  }
}

\f[B]const\f[R] encoder = \f[B]new\f[R] Base64Encoder();

console.log(
  encoder.encode(Uint8Array.of(72, 101, 108, 108, 111), { stream: \f[B]true\f[R] }),
);
\f[I]// \[dq]SGVs\[dq]\f[R]
console.log(
  encoder.encode(Uint8Array.of(32, 87, 111, 114, 108, 100), { stream: \f[B]true\f[R] }),
);
\f[I]// \[dq]bG8gV29y\[dq]\f[R]
console.log(encoder.encode());
\f[I]// \[dq]bGQ=\[dq]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#uint8array-to--from-base64-and-hex
Polyfill of \f[CR]Uint8Array.toBase64\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Uint8Array\f[R]
.IP \[bu] 2
\f[CR]Uint8Array.fromBase64()\f[R]
.IP \[bu] 2
\f[CR]Uint8Array.prototype.setFromBase64()\f[R]
.IP \[bu] 2
\f[CR]Window.btoa()\f[R]
