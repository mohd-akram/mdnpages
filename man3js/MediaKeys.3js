.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "MediaKeys" "JS" "September 23, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
MediaKeys \- MediaKeys
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
The \f[B]\f[CB]MediaKeys\f[B]\f[R] interface of Encrypted Media
Extensions API represents a set of keys that an associated
\f[CR]HTMLMediaElement\f[R] can use for decryption of media data during
playback.
.SH INSTANCE PROPERTIES
None.
.SH INSTANCE METHODS
.TP
\f[B]MediaKeys.createSession()\f[R]
Returns a new \f[CR]MediaKeySession\f[R] object, which represents a
context for message exchange with a content decryption module (CDM).
.TP
\f[B]MediaKeys.getStatusForPolicy()\f[R]
Returns a \f[CR]Promise\f[R] that resolves to a status string indicating
whether the CDM would allow the presentation of encrypted media data
using the keys, based on specified policy requirements.
.TP
\f[B]MediaKeys.setServerCertificate()\f[R]
Returns a \f[CR]Promise\f[R] to a server certificate to be used to
encrypt messages to the license server.
.SH EXAMPLES
.SS Check if keys are usable with HDCP restriction
This example shows how \f[CR]getStatusForPolicy()\f[R] can be used to
check if keys can decrypt a particular video format in a setup that has
a minimum HDCP version of \f[CR]2.2\f[R].
For more information, see the MediaKeys: getStatusForPolicy() method
documentation.
.SS HTML
.IP
.EX
<\f[B]pre\f[R] id=\[dq]log\[dq]></\f[B]pre\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] config = [
  {
    videoCapabilities: [
      {
        contentType: \[aq]video/mp4; codecs=\[dq]avc1.640028\[dq]\[aq],
        encryptionScheme: \[dq]cenc\[dq],
        robustness: \[dq]SW_SECURE_DECODE\[dq], \f[I]// Widevine L3\f[R]
      },
    ],
  },
];

getMediaStatus(config);

\f[B]async\f[R] \f[B]function\f[R] getMediaStatus(config) {
  \f[B]try\f[R] {
    \f[B]const\f[R] mediaKeySystemAccess = \f[B]await\f[R] navigator.requestMediaKeySystemAccess(
      \[dq]com.widevine.alpha\[dq],
      config,
    );
    \f[B]const\f[R] mediaKeys = \f[B]await\f[R] mediaKeySystemAccess.createMediaKeys();
    \f[B]const\f[R] mediaStatus = \f[B]await\f[R] mediaKeys.getStatusForPolicy({
      minHdcpVersion: \[dq]2.2\[dq],
    });
    log(mediaStatus);

    \f[I]// Get the content or fallback to an alternative if the\f[R]
    \f[I]// keys are not usable\f[R]
    \f[B]if\f[R] (mediaStatus === \[dq]usable\[dq]) {
      console.log(\[dq]HDCP 2.2 can be enforced.\[dq]);
      \f[I]// Fetch the high resolution protected content\f[R]
    } \f[B]else\f[R] {
      log(\[dq]HDCP 2.2 cannot be enforced\[dq]);
      \f[I]// Fallback other content, get license, etc.\f[R]
    }
  } \f[B]catch\f[R] (error) {
    log(error);
  }
}
.EE
.SS Results
