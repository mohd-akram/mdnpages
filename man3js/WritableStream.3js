.\" Automatically generated by Pandoc 3.4
.\"
.TH "WritableStream" "JS" "June 28, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
WritableStream \- WritableStream
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]WritableStream\f[B]\f[R] interface of the Streams API
provides a standard abstraction for writing streaming data to a
destination, known as a sink.
This object comes with built\-in backpressure and queuing.
.PP
\f[CR]WritableStream\f[R] is a transferable object.
.SH CONSTRUCTOR
.TP
\f[B]WritableStream()\f[R]
Creates a new \f[CR]WritableStream\f[R] object.
.SH INSTANCE PROPERTIES
.TP
\f[B]WritableStream.locked\f[R] \f[I](read\-only)\f[R]
A boolean indicating whether the \f[CR]WritableStream\f[R] is locked to
a writer.
.SH INSTANCE METHODS
.TP
\f[B]WritableStream.abort()\f[R]
Aborts the stream, signaling that the producer can no longer
successfully write to the stream and it is to be immediately moved to an
error state, with any queued writes discarded.
.TP
\f[B]WritableStream.close()\f[R]
Closes the stream.
.TP
\f[B]WritableStream.getWriter()\f[R]
Returns a new instance of \f[CR]WritableStreamDefaultWriter\f[R] and
locks the stream to that instance.
While the stream is locked, no other writer can be acquired until this
one is released.
.SH EXAMPLES
The following example illustrates several features of this interface.
It shows the creation of the \f[CR]WritableStream\f[R] with a custom
sink and an API\-supplied queueing strategy.
It then calls a function called \f[CR]sendMessage()\f[R], passing the
newly created stream and a string.
Inside this function it calls the stream\[cq]s \f[CR]getWriter()\f[R]
method, which returns an instance of
\f[CR]WritableStreamDefaultWriter\f[R].
A \f[CR]forEach()\f[R] call is used to write each chunk of the string to
the stream.
Finally, \f[CR]write()\f[R] and \f[CR]close()\f[R] return promises that
are processed to deal with success or failure of chunks and streams.
.IP
.EX
\f[B]const\f[R] list = document.querySelector(\[dq]ul\[dq]);

\f[B]function\f[R] sendMessage(message, writableStream) {
  \f[I]// defaultWriter is of type WritableStreamDefaultWriter\f[R]
  \f[B]const\f[R] defaultWriter = writableStream.getWriter();
  \f[B]const\f[R] encoder = \f[B]new\f[R] TextEncoder();
  \f[B]const\f[R] encoded = encoder.encode(message);
  encoded.forEach((chunk) \f[B]=>\f[R] {
    defaultWriter.ready
      .then(() \f[B]=>\f[R] defaultWriter.write(chunk))
      .then(() \f[B]=>\f[R] {
        console.log(\[dq]Chunk written to sink.\[dq]);
      })
      .catch((err) \f[B]=>\f[R] {
        console.log(\[dq]Chunk error:\[dq], err);
      });
  });
  \f[I]// Call ready again to ensure that all chunks are written\f[R]
  \f[I]//   before closing the writer.\f[R]
  defaultWriter.ready
    .then(() \f[B]=>\f[R] {
      defaultWriter.close();
    })
    .then(() \f[B]=>\f[R] {
      console.log(\[dq]All chunks written\[dq]);
    })
    .catch((err) \f[B]=>\f[R] {
      console.log(\[dq]Stream error:\[dq], err);
    });
}

\f[B]const\f[R] decoder = \f[B]new\f[R] TextDecoder(\[dq]utf\-8\[dq]);
\f[B]const\f[R] queuingStrategy = \f[B]new\f[R] CountQueuingStrategy({ highWaterMark: 1 });
\f[B]let\f[R] result = \[dq]\[dq];
\f[B]const\f[R] writableStream = \f[B]new\f[R] WritableStream(
  {
    \f[I]// Implement the sink\f[R]
    write(chunk) {
      \f[B]return\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
        \f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(1);
        \f[B]const\f[R] view = \f[B]new\f[R] Uint8Array(buffer);
        view[0] = chunk;
        \f[B]const\f[R] decoded = decoder.decode(view, { stream: \f[B]true\f[R] });
        \f[B]const\f[R] listItem = document.createElement(\[dq]li\[dq]);
        listItem.textContent = \[ga]Chunk decoded: ${decoded}\[ga];
        list.appendChild(listItem);
        result += decoded;
        resolve();
      });
    },
    close() {
      \f[B]const\f[R] listItem = document.createElement(\[dq]li\[dq]);
      listItem.textContent = \[ga][MESSAGE RECEIVED] ${result}\[ga];
      list.appendChild(listItem);
    },
    abort(err) {
      console.log(\[dq]Sink error:\[dq], err);
    },
  },
  queuingStrategy,
);

sendMessage(\[dq]Hello, world.\[dq], writableStream);
.EE
.PP
You can find the full code in our \c
.UR https://mdn.github.io/dom-examples/streams/simple-writer/
Simple writer example
.UE \c
\&.
.SS Backpressure
Because of how backpressure is supported in the API, its implementation
in code may be less than obvious.
To see how backpressure is implemented look for three things:
.IP \[bu] 2
The \f[CR]highWaterMark\f[R] property, which is set when creating the
counting strategy using \f[CR]new CountQueuingStrategy\f[R], sets the
maximum amount of data that the \f[CR]WritableStream\f[R] instance will
handle in a single \f[CR]write()\f[R] operation.
In this example, it\[cq]s the maximum amount of data that can be sent to
\f[CR]defaultWriter.write()\f[R], in the \f[CR]sendMessage\f[R]
function.
.IP \[bu] 2
The \f[CR]defaultWriter.ready\f[R] property returns a promise that
resolves when the sink (the first property of the
\f[CR]WritableStream\f[R] constructor) is done writing data.
The data source can either write more data using
\f[CR]defaultWriter.write()\f[R] or call
\f[CR]defaultWriter.close()\f[R], as demonstrated in the example above.
Calling \f[CR]close()\f[R] too early can prevent data from being
written.
This is why the example calls \f[CR]defaultWriter.ready\f[R] twice.
.IP \[bu] 2
The \f[CR]Promise\f[R] returned by the sink\[cq]s \f[CR]write()\f[R]
method tells the \f[CR]WritableStream\f[R] and its writer when to
resolve \f[CR]defaultWriter.ready\f[R].
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://whatwg-stream-visualizer.glitch.me/
WHATWG Stream Visualizer
.UE \c
, for a basic visualization of readable, writable, and transform
streams.
