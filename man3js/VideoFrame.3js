.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "VideoFrame" "JS" "July 25, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
VideoFrame \- VideoFrame
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Dedicated Web Workers.
.PP
The \f[B]\f[CB]VideoFrame\f[B]\f[R] interface of the Web Codecs API
represents a frame of a video.
.PP
\f[CR]VideoFrame\f[R] is a transferable object.
.SH DESCRIPTION
A \f[CR]VideoFrame\f[R] object can be created or accessed in a number of
ways.
The \f[CR]MediaStreamTrackProcessor\f[R] breaks a media track into
individual \f[CR]VideoFrame\f[R] objects.
.PP
A \f[CR]VideoFrame\f[R] is an image source and has a constructor that
accepts any other canvas source ( an \f[CR]SVGImageElement\f[R], an
\f[CR]HTMLVideoElement\f[R], an \f[CR]HTMLCanvasElement\f[R], an
\f[CR]ImageBitmap\f[R], an \f[CR]OffscreenCanvas\f[R], or another
\f[CR]VideoFrame\f[R]).
This means that a frame can be created from an image or video element.
.PP
A second constructor enables the creation of a \f[CR]VideoFrame\f[R]
from its binary pixel representation in an \f[CR]ArrayBuffer\f[R], a
\f[CR]TypedArray\f[R], or a \f[CR]DataView\f[R].
.PP
Created frames may then turned into a media track, for example with the
\f[CR]MediaStreamTrackGenerator\f[R] interface that creates a media
track from a stream of frames.
.SH CONSTRUCTOR
.TP
\f[B]VideoFrame()\f[R]
Creates a new \f[CR]VideoFrame\f[R] object.
.SH INSTANCE PROPERTIES
.TP
\f[B]VideoFrame.format\f[R] \f[I](read\-only)\f[R]
Returns the pixel format of the \f[CR]VideoFrame\f[R].
.TP
\f[B]VideoFrame.codedWidth\f[R] \f[I](read\-only)\f[R]
Returns the width of the \f[CR]VideoFrame\f[R] in pixels, potentially
including non\-visible padding, and prior to considering potential ratio
adjustments.
.TP
\f[B]VideoFrame.codedHeight\f[R] \f[I](read\-only)\f[R]
Returns the height of the \f[CR]VideoFrame\f[R] in pixels, potentially
including non\-visible padding, and prior to considering potential ratio
adjustments.
.TP
\f[B]VideoFrame.codedRect\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]DOMRectReadOnly\f[R] with the width and height matching
\f[CR]codedWidth\f[R] and \f[CR]codedHeight\f[R].
.TP
\f[B]VideoFrame.visibleRect\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]DOMRectReadOnly\f[R] describing the visible rectangle of
pixels for this \f[CR]VideoFrame\f[R].
.TP
\f[B]VideoFrame.displayWidth\f[R] \f[I](read\-only)\f[R]
Returns the width of the \f[CR]VideoFrame\f[R] when displayed after
applying aspect ratio adjustments.
.TP
\f[B]VideoFrame.displayHeight\f[R] \f[I](read\-only)\f[R]
Returns the height of the \f[CR]VideoFrame\f[R] when displayed after
applying aspect ratio adjustments.
.TP
\f[B]VideoFrame.duration\f[R] \f[I](read\-only)\f[R]
Returns an integer indicating the duration of the video in microseconds.
.TP
\f[B]VideoFrame.timestamp\f[R] \f[I](read\-only)\f[R]
Returns an integer indicating the timestamp of the video in
microseconds.
.TP
\f[B]VideoFrame.colorSpace\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]VideoColorSpace\f[R] object.
.SH INSTANCE METHODS
.TP
\f[B]VideoFrame.allocationSize()\f[R]
Returns the number of bytes required to hold the \f[CR]VideoFrame\f[R]
as filtered by options passed into the method.
.TP
\f[B]VideoFrame.copyTo()\f[R]
Copies the contents of the \f[CR]VideoFrame\f[R] to an
\f[CR]ArrayBuffer\f[R].
.TP
\f[B]VideoFrame.clone()\f[R]
Creates a new \f[CR]VideoFrame\f[R] object with reference to the same
media resource as the original.
.TP
\f[B]VideoFrame.close()\f[R]
Clears all states and releases the reference to the media resource.
.SH EXAMPLES
In the following example frames are returned from a
\f[CR]MediaStreamTrackProcessor\f[R], then encoded.
See the full example and read more about it in the article \c
.UR https://developer.chrome.com/docs/web-platform/best-practices/webcodecs
Video processing with WebCodecs
.UE \c
\&.
.IP
.EX
\f[B]let\f[R] frame_counter = 0;

\f[B]const\f[R] track = stream.getVideoTracks()[0];
\f[B]const\f[R] media_processor = \f[B]new\f[R] MediaStreamTrackProcessor(track);

\f[B]const\f[R] reader = media_processor.readable.getReader();
\f[B]while\f[R] (\f[B]true\f[R]) {
  \f[B]const\f[R] result = \f[B]await\f[R] reader.read();
  \f[B]if\f[R] (result.done) \f[B]break\f[R];

  \f[B]let\f[R] frame = result.value;
  \f[B]if\f[R] (encoder.encodeQueueSize > 2) {
    \f[I]// Too many frames in flight, encoder is overwhelmed\f[R]
    \f[I]// let\[aq]s drop this frame.\f[R]
    frame.close();
  } \f[B]else\f[R] {
    frame_counter++;
    \f[B]const\f[R] insert_keyframe = frame_counter % 150 === 0;
    encoder.encode(frame, { keyFrame: insert_keyframe });
    frame.close();
  }
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://developer.chrome.com/docs/web-platform/best-practices/webcodecs
Video processing with WebCodecs
.UE \c
.IP \[bu] 2
\c
.UR https://w3c.github.io/webcodecs/samples/
WebCodecs examples
.UE \c
