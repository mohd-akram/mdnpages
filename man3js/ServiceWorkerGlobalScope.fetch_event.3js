.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "ServiceWorkerGlobalScope.fetch_event" "JS" "July 24, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ServiceWorkerGlobalScope.fetch_event \- ServiceWorkerGlobalScope: fetch
event
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is only available in Service Workers.
.PP
The \f[B]\f[CB]fetch\f[B]\f[R] event of the
\f[CR]ServiceWorkerGlobalScope\f[R] interface is fired in the service
worker\[cq]s global scope when the main app thread makes a network
request.
It enables the service worker to intercept network requests and send
customized responses (for example, from a local cache).
.PP
This event is not cancelable and does not bubble.
.SH SYNTAX
Use the event name in methods like \f[CR]addEventListener()\f[R], or set
an event handler property.
.IP
.EX
addEventListener(\[dq]fetch\[dq], (event) \f[B]=>\f[R] {});

onfetch = (event) \f[B]=>\f[R] {};
.EE
.SH DESCRIPTION
The \f[CR]fetch\f[R] event is fired in the service worker\[cq]s global
scope when the main app thread makes a network request.
This includes not only explicit \f[CR]fetch()\f[R] calls from the main
thread, but also implicit network requests to load pages and
subresources (such as JavaScript, CSS, and images) made by the browser
following page navigation.
.PP
The event handler is passed a \f[CR]FetchEvent\f[R] object, which
provides access to the request as a \f[CR]Request\f[R] instance.
.PP
The \f[CR]FetchEvent\f[R] also provides a \f[CR]respondWith()\f[R]
method, that takes a \f[CR]Response\f[R] (or a \f[CR]Promise\f[R] that
resolves to a \f[CR]Response\f[R]) as a parameter.
This enables the service worker event handler to provide the response
that is returned to the request in the main thread.
.PP
For example, the service worker can return:
.IP \[bu] 2
A locally cached response retrieved from the \f[CR]Cache\f[R] interface.
.IP \[bu] 2
A response that the service worker synthesizes, using methods like
\f[CR]Response.json()\f[R] or the \f[CR]Response()\f[R] constructor.
.IP \[bu] 2
A network error, using the \f[CR]Response.error()\f[R] method.
This will cause the \f[CR]fetch()\f[R] call to reject.
.PP
The \f[CR]respondWith()\f[R] method can only be called once for a given
request.
If multiple \f[CR]fetch\f[R] event listeners are added, they will be
called in the order they were registered until one of them calls
\f[CR]respondWith()\f[R].
.PP
The \f[CR]respondWith()\f[R] method must be called synchronously: that
is, you can\[cq]t call it in a \f[CR]then\f[R] handler.
.PP
Typically, a \f[CR]fetch\f[R] event handler will execute different
strategies depending on features of the request such as its URL:
.IP
.EX
\f[B]function\f[R] strategy1() {
  \f[B]return\f[R] fetch(\[dq]picnic.jpg\[dq]);
}

\f[B]function\f[R] strategy2() {
  \f[B]return\f[R] Response.error();
}

\f[B]const\f[R] pattern1 = /\[ha]\[rs]/salamander/;
\f[B]const\f[R] pattern2 = /\[ha]\[rs]/lizard/;

self.addEventListener(\[dq]fetch\[dq], (event) \f[B]=>\f[R] {
  \f[B]const\f[R] url = \f[B]new\f[R] URL(event.request.url);
  \f[B]if\f[R] (pattern1.test(url.pathname)) {
    event.respondWith(strategy1());
  } \f[B]else\f[R] \f[B]if\f[R] (pattern2.test(url.pathname)) {
    event.respondWith(strategy2());
  }
});
.EE
.PP
If \f[CR]respondWith()\f[R] is not called in the handler, then the user
agent automatically makes the original network request.
For example, in the code above, all requests that do not match
\f[CR]pattern1\f[R] or \f[CR]pattern2\f[R] are made as if the service
worker did not exist.
.SH EVENT TYPE
A \f[CR]FetchEvent\f[R].
.SH EXAMPLES
.SS Cache falling back to network
This \f[CR]fetch\f[R] event handler first tries to find the response in
the cache.
If a response is found, it returns the cached response.
Otherwise, it tries to fetch the resource from the network.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] cacheThenNetwork(request) {
  \f[B]const\f[R] cachedResponse = \f[B]await\f[R] caches.match(request);
  \f[B]if\f[R] (cachedResponse) {
    console.log(\[dq]Found response in cache:\[dq], cachedResponse);
    \f[B]return\f[R] cachedResponse;
  }
  console.log(\[dq]Falling back to network\[dq]);
  \f[B]return\f[R] fetch(request);
}

self.addEventListener(\[dq]fetch\[dq], (event) \f[B]=>\f[R] {
  console.log(\[ga]Handling fetch event for ${event.request.url}\[ga]);
  event.respondWith(cacheThenNetwork(event.request));
});
.EE
.SS Cache only
This \f[CR]fetch\f[R] event handler implements a \[lq]cache only\[rq]
policy for scripts and stylesheets.
If the request\[cq]s \f[CR]destination\f[R] property is
\f[CR]\[dq]script\[dq]\f[R] or \f[CR]\[dq]style\[dq]\f[R], the handler
only looks in the cache, returning an error if the response was not
found.
All other requests go through to the network.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] cacheOnly(request) {
  \f[B]const\f[R] cachedResponse = \f[B]await\f[R] caches.match(request);
  \f[B]if\f[R] (cachedResponse) {
    console.log(\[dq]Found response in cache:\[dq], cachedResponse);
    \f[B]return\f[R] cachedResponse;
  }
  \f[B]return\f[R] Response.error();
}

self.addEventListener(\[dq]fetch\[dq], (event) \f[B]=>\f[R] {
  \f[B]if\f[R] (
    event.request.destination === \[dq]script\[dq] ||
    event.request.destination === \[dq]style\[dq]
  ) {
    event.respondWith(cacheOnly(event.request));
  }
});
.EE
.SH SEE ALSO
.IP \[bu] 2
Using Service Workers
.IP \[bu] 2
\c
.UR https://github.com/mdn/dom-examples/tree/main/service-worker/simple-service-worker
Service workers basic code example
.UE \c
.IP \[bu] 2
\f[CR]fetch()\f[R] method
.IP \[bu] 2
\f[CR]Request\f[R] interface
.IP \[bu] 2
\f[CR]Response\f[R] interface
