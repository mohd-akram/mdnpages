.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "SourceBuffer.abort" "JS" "April 8, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SourceBuffer.abort \- SourceBuffer: abort() method
.SH SYNOPSIS
The \f[B]\f[CB]abort()\f[B]\f[R] method of the \f[CR]SourceBuffer\f[R]
interface aborts the current segment and resets the segment parser.
.SH SYNTAX
.IP
.EX
abort()
.EE
.SS Parameters
None.
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.TP
\f[B]InvalidStateError\f[R] \f[B]DOMException\f[R]
Thrown if the \f[CR]MediaSource.readyState\f[R] property of the parent
media source is not equal to \f[CR]open\f[R], or this
\f[CR]SourceBuffer\f[R] has been removed from the
\f[CR]MediaSource\f[R].
.SH EXAMPLES
The spec description of \f[CR]abort()\f[R] is somewhat confusing \[em]
consider for example step 1 of \c
.UR https://w3c.github.io/media-source/index.html#sourcebuffer-reset-parser-state
reset parser state
.UE \c
\&.
The MSE API is fully asynchronous, but this step seems to suggest a
synchronous (blocking) operation, which doesn\[cq]t make sense.
.PP
Saying that, current implementations can be useful in certain
situations, when you want to stop the current append (or whatever)
operation occurring on a sourcebuffer, and then immediately start
performing operations on it again.
For example, consider this code:
.IP
.EX
sourceBuffer.addEventListener(\[dq]updateend\[dq], (ev) \f[B]=>\f[R] {
  \f[I]// ...\f[R]
});

sourceBuffer.appendBuffer(buf);
.EE
.PP
Let\[cq]s say that after the call to \f[CR]appendBuffer\f[R] BUT before
the \f[CR]updateend\f[R] event fires (i.e.\ a buffer is being appended
but the operation has not yet completed) a user \[lq]scrubs\[rq] the
video seeking to a new point in time.
In this case you would want to manually call \f[CR]abort()\f[R] on the
source buffer to stop the decoding of the current buffer, then fetch and
append the newly requested segment that relates to the current new
position of the video.
.PP
You can see something similar in action in Nick Desaulnier\[cq]s \c
.UR https://github.com/nickdesaulniers/netfix/blob/gh-pages/demo/bufferWhenNeeded.html
bufferWhenNeeded demo
.UE \c
\ \[em] in \c
.UR https://github.com/nickdesaulniers/netfix/blob/gh-pages/demo/bufferWhenNeeded.html#L48
line 48, an event listener is added to the playing video
.UE \c
\ so a function called \f[CR]seek()\f[R] is run when the
\f[CR]seeking\f[R] event fires.
In \c
.UR https://github.com/nickdesaulniers/netfix/blob/gh-pages/demo/bufferWhenNeeded.html#L92-L101
lines 92\-101, the seek() function is defined
.UE \c
\ \[em] note that \f[CR]abort()\f[R] is called if
\f[CR]MediaSource.readyState\f[R] is set to \f[CR]open\f[R], which means
that it is ready to receive new source buffers \[em] at this point it is
worth aborting the current segment and just getting the one for the new
seek position (see \c
.UR https://github.com/nickdesaulniers/netfix/blob/gh-pages/demo/bufferWhenNeeded.html#L78-L90
\f[CR]checkBuffer()\f[R]
.UE \c
\ and \c
.UR https://github.com/nickdesaulniers/netfix/blob/gh-pages/demo/bufferWhenNeeded.html#L103-L105
\f[CR]getCurrentSegment()\f[R]
.UE \c
\&.)
.SH SEE ALSO
.IP \[bu] 2
\f[CR]MediaSource\f[R]
.IP \[bu] 2
\f[CR]SourceBufferList\f[R]
