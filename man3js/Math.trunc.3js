.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "MATH.TRUNC" "3JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Math.trunc \- Math.trunc()
.SH SYNOPSIS
The \f[B]\f[CB]Math.trunc()\f[B]\f[R] static method returns the integer
part of a number by removing any fractional digits.
.IP
.EX
console.log(Math.trunc(13.37));
\f[I]// Expected output: 13\f[R]

console.log(Math.trunc(42.84));
\f[I]// Expected output: 42\f[R]

console.log(Math.trunc(0.123));
\f[I]// Expected output: 0\f[R]

console.log(Math.trunc(\-0.123));
\f[I]// Expected output: \-0\f[R]
.EE
.SH SYNTAX
.IP
.EX
Math.trunc(x)
.EE
.SS Parameters
.TP
\f[B]x\f[R]
A number.
.SS Return value
The integer part of \f[CR]x\f[R].
.SH DESCRIPTION
The way \f[CR]Math.trunc()\f[R] works is more straightforward than the
other three \f[CR]Math\f[R] methods: \f[CR]Math.floor()\f[R],
\f[CR]Math.ceil()\f[R] and \f[CR]Math.round()\f[R]; it
\f[I]truncates\f[R] (cuts off) the dot and the digits to the right of
it, no matter whether the argument is a positive or negative number.
.PP
Because \f[CR]trunc()\f[R] is a static method of \f[CR]Math\f[R], you
always use it as \f[CR]Math.trunc()\f[R], rather than as a method of a
\f[CR]Math\f[R] object you created (\f[CR]Math\f[R] is not a
constructor).
.SH EXAMPLES
.SS Using Math.trunc()
.IP
.EX
Math.trunc(\-\f[B]Infinity\f[R]); \f[I]// \-Infinity\f[R]
Math.trunc(\(dq\-1.123\(dq); \f[I]// \-1\f[R]
Math.trunc(\-0.123); \f[I]// \-0\f[R]
Math.trunc(\-0); \f[I]// \-0\f[R]
Math.trunc(0); \f[I]// 0\f[R]
Math.trunc(0.123); \f[I]// 0\f[R]
Math.trunc(13.37); \f[I]// 13\f[R]
Math.trunc(42.84); \f[I]// 42\f[R]
Math.trunc(\f[B]Infinity\f[R]); \f[I]// Infinity\f[R]
.EE
.SS Using bitwise no\-ops to truncate numbers
.RS
.PP
\f[B]Warning:\f[R] This is not a polyfill for \f[CR]Math.trunc()\f[R]
because of non\-negligible edge cases.
.RE
.PP
Bitwise operations convert their operands to 32\-bit integers, which
people have historically taken advantage of to truncate float\-point
numbers.
Common techniques include:
.IP
.EX
\f[B]const\f[R] original = 3.14;
\f[B]const\f[R] truncated1 = \(ti\(tioriginal; \f[I]// Double negation\f[R]
\f[B]const\f[R] truncated2 = original & \-1; \f[I]// Bitwise AND with \-1\f[R]
\f[B]const\f[R] truncated3 = original | 0; \f[I]// Bitwise OR with 0\f[R]
\f[B]const\f[R] truncated4 = original \(ha 0; \f[I]// Bitwise XOR with 0\f[R]
\f[B]const\f[R] truncated5 = original >> 0; \f[I]// Bitwise shifting by 0\f[R]
.EE
.PP
Beware that this is essentially \f[CR]toInt32\f[R], which is not the
same as \f[CR]Math.trunc\f[R].
When the value does not satisfy \-2\(ha31 \- 1 < \f[CR]value\f[R] <
2\(ha31 (\-2147483649 < \f[CR]value\f[R] < 2147483648), the conversion
would overflow.
.IP
.EX
\f[B]const\f[R] a = \(ti\(ti2147483648; \f[I]// \-2147483648\f[R]
\f[B]const\f[R] b = \(ti\(ti\-2147483649; \f[I]// 2147483647\f[R]
\f[B]const\f[R] c = \(ti\(ti4294967296; \f[I]// 0\f[R]
.EE
.PP
Only use \f[CR]\(ti\(ti\f[R] as a substitution for
\f[CR]Math.trunc()\f[R] when you are confident that the range of input
falls within the range of 32\-bit integers.
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-math
Polyfill of \f[CR]Math.trunc\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\f[CR]Math.abs()\f[R]
.IP \(bu 2
\f[CR]Math.ceil()\f[R]
.IP \(bu 2
\f[CR]Math.floor()\f[R]
.IP \(bu 2
\f[CR]Math.round()\f[R]
.IP \(bu 2
\f[CR]Math.sign()\f[R]
