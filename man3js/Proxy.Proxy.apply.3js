.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "PROXY.PROXY.APPLY" "3JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Proxy.Proxy.apply \- handler.apply()
.SH SYNOPSIS
The \f[B]\f[CB]handler.apply()\f[B]\f[R] method is a trap for the
\f[CR][[Call]]\f[R] object internal method, which is used by operations
such as function calls.
.IP
.EX
\f[B]function\f[R] sum(a, b) {
  \f[B]return\f[R] a + b;
}

\f[B]const\f[R] handler = {
  apply: \f[B]function\f[R] (target, thisArg, argumentsList) {
    console.log(\(gaCalculate sum: ${argumentsList}\(ga);
    \f[I]// Expected output: \(dqCalculate sum: 1,2\(dq\f[R]

    \f[B]return\f[R] target(argumentsList[0], argumentsList[1]) * 10;
  },
};

\f[B]const\f[R] proxy1 = \f[B]new\f[R] Proxy(sum, handler);

console.log(sum(1, 2));
\f[I]// Expected output: 3\f[R]
console.log(proxy1(1, 2));
\f[I]// Expected output: 30\f[R]
.EE
.SH SYNTAX
.IP
.EX
new Proxy(target, {
  apply(target, thisArg, argumentsList) {
  }
})
.EE
.SS Parameters
The following parameters are passed to the \f[CR]apply()\f[R] method.
\f[CR]this\f[R] is bound to the handler.
.TP
\f[B]target\f[R]
The target callable object.
.TP
\f[B]thisArg\f[R]
The \f[CR]this\f[R] argument for the call.
.TP
\f[B]argumentsList\f[R]
An \f[CR]Array\f[R] containing the arguments passed to the function.
.SS Return value
The \f[CR]apply()\f[R] method can return any value, representing the
return value of the function call.
.SH DESCRIPTION
.SS Interceptions
This trap can intercept these operations:
.IP \(bu 2
Function call: \f[CR]proxy(...args)\f[R]
.IP \(bu 2
\f[CR]Function.prototype.apply()\f[R] and
\f[CR]Function.prototype.call()\f[R]
.IP \(bu 2
\f[CR]Reflect.apply()\f[R]
.PP
Or any other operation that invokes the \f[CR][[Call]]\f[R] internal
method.
.SS Invariants
The proxy\(cqs \f[CR][[Call]]\f[R] internal method throws a
\f[CR]TypeError\f[R] if the handler definition violates one of the
following invariants:
.IP \(bu 2
The \f[CR]target\f[R] must be a callable itself.
That is, it must be a function object.
.SH EXAMPLES
.SS Trapping a function call
The following code traps a function call.
.IP
.EX
\f[B]const\f[R] p = \f[B]new\f[R] Proxy(\f[B]function\f[R] () {}, {
  apply(target, thisArg, argumentsList) {
    console.log(\(gacalled: ${argumentsList}\(ga);
    \f[B]return\f[R] argumentsList[0] + argumentsList[1] + argumentsList[2];
  },
});

console.log(p(1, 2, 3)); \f[I]// \(dqcalled: 1,2,3\(dq\f[R]
\f[I]// 6\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Proxy\f[R]
.IP \(bu 2
\f[CR]Proxy()\f[R] constructor
.IP \(bu 2
\f[CR]Function.prototype.apply()\f[R]
.IP \(bu 2
\f[CR]Function.prototype.call()\f[R]
.IP \(bu 2
\f[CR]Reflect.apply()\f[R]
