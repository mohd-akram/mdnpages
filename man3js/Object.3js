.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Object" "JS" "October 1, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object - Object
.SH SYNOPSIS
The \f[B]\f[CB]Object\f[B]\f[R] type represents one of JavaScript\[cq]s
data types.
It is used to store various keyed collections and more complex entities.
Objects can be created using the \f[CR]Object()\f[R] constructor or the
object initializer / literal syntax.
.SH DESCRIPTION
Nearly all objects in JavaScript are instances of \f[CR]Object\f[R]; a
typical object inherits properties (including methods) from
\f[CR]Object.prototype\f[R], although these properties may be shadowed
(a.k.a.
overridden).
The only objects that don\[cq]t inherit from \f[CR]Object.prototype\f[R]
are those with \f[CR]null\f[R] prototype, or descended from other
\f[CR]null\f[R] prototype objects.
.PP
Changes to the \f[CR]Object.prototype\f[R] object are seen by
\f[B]all\f[R] objects through prototype chaining, unless the properties
and methods subject to those changes are overridden further along the
prototype chain.
This provides a very powerful although potentially dangerous mechanism
to override or extend object behavior.
To make it more secure, \f[CR]Object.prototype\f[R] is the only object
in the core JavaScript language that has immutable prototype \[em] the
prototype of \f[CR]Object.prototype\f[R] is always \f[CR]null\f[R] and
not changeable.
.SS Object prototype properties
You should avoid calling any \f[CR]Object.prototype\f[R] method directly
from the instance, especially those that are not intended to be
polymorphic (i.e.\ only its initial behavior makes sense and no
descending object could override it in a meaningful way).
All objects descending from \f[CR]Object.prototype\f[R] may define a
custom own property that has the same name, but with entirely different
semantics from what you expect.
Furthermore, these properties are not inherited by
\f[CR]null\f[R]-prototype objects.
All modern JavaScript utilities for working with objects are static.
More specifically:
.IP \[bu] 2
\f[CR]valueOf()\f[R], \f[CR]toString()\f[R], and
\f[CR]toLocaleString()\f[R] exist to be polymorphic and you should
expect the object to define its own implementation with sensible
behaviors, so you can call them as instance methods.
However, \f[CR]valueOf()\f[R] and \f[CR]toString()\f[R] are usually
implicitly called through type conversion and you don\[cq]t need to call
them yourself in your code.
.IP \[bu] 2
\f[CR]__defineGetter__()\f[R], \f[CR]__defineSetter__()\f[R],
\f[CR]__lookupGetter__()\f[R], and \f[CR]__lookupSetter__()\f[R] are
deprecated and should not be used.
Use the static alternatives \f[CR]Object.defineProperty()\f[R] and
\f[CR]Object.getOwnPropertyDescriptor()\f[R] instead.
.IP \[bu] 2
The \f[CR]__proto__\f[R] property is deprecated and should not be used.
The \f[CR]Object.getPrototypeOf()\f[R] and
\f[CR]Object.setPrototypeOf()\f[R] alternatives are static methods.
.IP \[bu] 2
The \f[CR]propertyIsEnumerable()\f[R] and \f[CR]hasOwnProperty()\f[R]
methods can be replaced with the
\f[CR]Object.getOwnPropertyDescriptor()\f[R] and
\f[CR]Object.hasOwn()\f[R] static methods, respectively.
.IP \[bu] 2
The \f[CR]isPrototypeOf()\f[R] method can usually be replaced with
\f[CR]instanceof\f[R], if you are checking the \f[CR]prototype\f[R]
property of a constructor.
.PP
In case where a semantically equivalent static method doesn\[cq]t exist,
or if you really want to use the \f[CR]Object.prototype\f[R] method, you
should directly \f[CR]call()\f[R] the \f[CR]Object.prototype\f[R] method
on your target object instead, to prevent the object from having an
overriding property that produces unexpected results.
.IP
.EX
const obj = {
  foo: 1,
  // You should not define such a method on your own object,
  // but you may not be able to prevent it from happening if
  // you are receiving the object from external input
  propertyIsEnumerable() {
    return false;
  },
};

obj.propertyIsEnumerable(\[dq]foo\[dq]); // false; unexpected result
Object.prototype.propertyIsEnumerable.call(obj, \[dq]foo\[dq]); // true; expected result
.EE
.SS Deleting a property from an object
There isn\[cq]t any method in an Object itself to delete its own
properties (such as \f[CR]Map.prototype.delete()\f[R]).
To do so, one must use the \f[CR]delete\f[R] operator.
.SS null-prototype objects
Almost all objects in JavaScript ultimately inherit from
\f[CR]Object.prototype\f[R] (see inheritance and the prototype chain).
However, you may create \f[CR]null\f[R]-prototype objects using
\f[CR]Object.create(null)\f[R] or the object initializer syntax with
\f[CR]__proto__: null\f[R] (note: the \f[CR]__proto__\f[R] key in object
literals is different from the deprecated
\f[CR]Object.prototype.__proto__\f[R] property).
You can also change the prototype of an existing object to
\f[CR]null\f[R] by calling \f[CR]Object.setPrototypeOf(obj, null)\f[R].
.IP
.EX
const obj = Object.create(null);
const obj2 = { __proto__: null };
.EE
.PP
An object with a \f[CR]null\f[R] prototype can behave in unexpected
ways, because it doesn\[cq]t inherit any object methods from
\f[CR]Object.prototype\f[R].
This is especially true when debugging, since common object-property
converting/detecting utility functions may generate errors, or lose
information (especially if using silent error-traps that ignore errors).
.PP
For example, the lack of \f[CR]Object.prototype.toString()\f[R] often
makes debugging intractable:
.IP
.EX
const normalObj = {}; // create a normal object
const nullProtoObj = Object.create(null); // create an object with \[dq]null\[dq] prototype

console.log(\[ga]normalObj is: ${normalObj}\[ga]); // shows \[dq]normalObj is: [object Object]\[dq]
console.log(\[ga]nullProtoObj is: ${nullProtoObj}\[ga]); // throws error: Cannot convert object to primitive value

alert(normalObj); // shows [object Object]
alert(nullProtoObj); // throws error: Cannot convert object to primitive value
.EE
.PP
Other methods will fail as well.
.IP
.EX
normalObj.valueOf(); // shows {}
nullProtoObj.valueOf(); // throws error: nullProtoObj.valueOf is not a function

normalObj.hasOwnProperty(\[dq]p\[dq]); // shows \[dq]true\[dq]
nullProtoObj.hasOwnProperty(\[dq]p\[dq]); // throws error: nullProtoObj.hasOwnProperty is not a function

normalObj.constructor; // shows \[dq]Object() { [native code] }\[dq]
nullProtoObj.constructor; // shows \[dq]undefined\[dq]
.EE
.PP
We can add the \f[CR]toString\f[R] method back to the null-prototype
object by assigning it one:
.IP
.EX
nullProtoObj.toString = Object.prototype.toString; // since new object lacks toString, add the original generic one back

console.log(nullProtoObj.toString()); // shows \[dq][object Object]\[dq]
console.log(\[ga]nullProtoObj is: ${nullProtoObj}\[ga]); // shows \[dq]nullProtoObj is: [object Object]\[dq]
.EE
.PP
Unlike normal objects, in which \f[CR]toString()\f[R] is on the
object\[cq]s prototype, the \f[CR]toString()\f[R] method here is an own
property of \f[CR]nullProtoObj\f[R].
This is because \f[CR]nullProtoObj\f[R] has no (\f[CR]null\f[R])
prototype.
.PP
You can also revert a null-prototype object back to an ordinary object
using \f[CR]Object.setPrototypeOf(nullProtoObj, Object.prototype)\f[R].
.PP
In practice, objects with \f[CR]null\f[R] prototype are usually used as
a cheap substitute for maps.
The presence of \f[CR]Object.prototype\f[R] properties will cause some
bugs:
.IP
.EX
const ages = { alice: 18, bob: 27 };

function hasPerson(name) {
  return name in ages;
}

function getAge(name) {
  return ages[name];
}

hasPerson(\[dq]hasOwnProperty\[dq]); // true
getAge(\[dq]toString\[dq]); // [Function: toString]
.EE
.PP
Using a null-prototype object removes this hazard without introducing
too much complexity to the \f[CR]hasPerson\f[R] and \f[CR]getAge\f[R]
functions:
.IP
.EX
const ages = Object.create(null, {
  alice: { value: 18, enumerable: true },
  bob: { value: 27, enumerable: true },
});

hasPerson(\[dq]hasOwnProperty\[dq]); // false
getAge(\[dq]toString\[dq]); // undefined
.EE
.PP
In such case, the addition of any method should be done cautiously, as
they can be confused with the other key-value pairs stored as data.
.PP
Making your object not inherit from \f[CR]Object.prototype\f[R] also
prevents prototype pollution attacks.
If a malicious script adds a property to \f[CR]Object.prototype\f[R], it
will be accessible on every object in your program, except objects that
have null prototype.
.IP
.EX
const user = {};

// A malicious script:
Object.prototype.authenticated = true;

// Unexpectedly allowing unauthenticated user to pass through
if (user.authenticated) {
  // access confidential data
}
.EE
.PP
JavaScript also has built-in APIs that produce \f[CR]null\f[R]-prototype
objects, especially those that use objects as ad hoc key-value
collections.
For example:
.IP \[bu] 2
The return value of \f[CR]Object.groupBy()\f[R]
.IP \[bu] 2
The \f[CR]groups\f[R] and \f[CR]indices.groups\f[R] properties of the
result of \f[CR]RegExp.prototype.exec()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype[\[at]\[at]unscopables]\f[R] (all
\f[CR]\[at]\[at]unscopables\f[R] objects should have
\f[CR]null\f[R]-prototype)
.IP \[bu] 2
\f[CR]import.meta\f[R]
.IP \[bu] 2
Module namespace objects, obtained through
\f[CR]import * as ns from \[dq]module\[dq];\f[R] or \f[CR]import()\f[R]
.PP
The term \[lq]\f[CR]null\f[R]-prototype object\[rq] often also includes
any object without \f[CR]Object.prototype\f[R] in its prototype chain.
Such objects can be created with \f[CR]extends null\f[R] when using
classes.
.SS Object coercion
Many built-in operations that expect objects first coerce their
arguments to objects.
The
operation (https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toobject)
can be summarized as follows:
.IP \[bu] 2
Objects are returned as-is.
.IP \[bu] 2
\f[CR]undefined\f[R] and \f[CR]null\f[R] throw a \f[CR]TypeError\f[R].
.IP \[bu] 2
\f[CR]Number\f[R], \f[CR]String\f[R], \f[CR]Boolean\f[R],
\f[CR]Symbol\f[R], \f[CR]BigInt\f[R] primitives are wrapped into their
corresponding object wrappers.
.PP
There are two ways to achieve nearly the same effect in JavaScript.
.IP \[bu] 2
\f[CR]Object.prototype.valueOf()\f[R]:
\f[CR]Object.prototype.valueOf.call(x)\f[R] does exactly the object
coercion steps explained above to convert \f[CR]x\f[R].
.IP \[bu] 2
The \f[CR]Object()\f[R] function: \f[CR]Object(x)\f[R] uses the same
algorithm to convert \f[CR]x\f[R], except that \f[CR]undefined\f[R] and
\f[CR]null\f[R] don\[cq]t throw a \f[CR]TypeError\f[R], but return a
plain object.
.PP
Places that use object coercion include:
.IP \[bu] 2
The \f[CR]object\f[R] parameter of \f[CR]for...in\f[R] loops.
.IP \[bu] 2
The \f[CR]this\f[R] value of \f[CR]Array\f[R] methods.
.IP \[bu] 2
Parameters of \f[CR]Object\f[R] methods such as
\f[CR]Object.keys()\f[R].
.IP \[bu] 2
Auto-boxing when a property is accessed on a primitive value, since
primitives do not have properties.
.IP \[bu] 2
The \f[CR]this\f[R] value when calling a non-strict function.
Primitives are boxed while \f[CR]null\f[R] and \f[CR]undefined\f[R] are
replaced with the global object.
.PP
Unlike conversion to primitives, the object coercion process itself is
not observable in any way, since it doesn\[cq]t invoke custom code like
\f[CR]toString\f[R] or \f[CR]valueOf\f[R] methods.
.SH CONSTRUCTOR
.TP
\f[B]Object()\f[R]
Turns the input into an object.
.SH STATIC METHODS
.TP
\f[B]Object.assign()\f[R]
Copies the values of all enumerable own properties from one or more
source objects to a target object.
.TP
\f[B]Object.create()\f[R]
Creates a new object with the specified prototype object and properties.
.TP
\f[B]Object.defineProperties()\f[R]
Adds the named properties described by the given descriptors to an
object.
.TP
\f[B]Object.defineProperty()\f[R]
Adds the named property described by a given descriptor to an object.
.TP
\f[B]Object.entries()\f[R]
Returns an array containing all of the \f[CR][key, value]\f[R] pairs of
a given object\[cq]s \f[B]own\f[R] enumerable string properties.
.TP
\f[B]Object.freeze()\f[R]
Freezes an object.
Other code cannot delete or change its properties.
.TP
\f[B]Object.fromEntries()\f[R]
Returns a new object from an iterable of \f[CR][key, value]\f[R] pairs.
(This is the reverse of \f[CR]Object.entries\f[R]).
.TP
\f[B]Object.getOwnPropertyDescriptor()\f[R]
Returns a property descriptor for a named property on an object.
.TP
\f[B]Object.getOwnPropertyDescriptors()\f[R]
Returns an object containing all own property descriptors for an object.
.TP
\f[B]Object.getOwnPropertyNames()\f[R]
Returns an array containing the names of all of the given object\[cq]s
\f[B]own\f[R] enumerable and non-enumerable properties.
.TP
\f[B]Object.getOwnPropertySymbols()\f[R]
Returns an array of all symbol properties found directly upon a given
object.
.TP
\f[B]Object.getPrototypeOf()\f[R]
Returns the prototype (internal \f[CR][[Prototype]]\f[R] property) of
the specified object.
.TP
\f[B]Object.groupBy()\f[R]
Groups the elements of a given iterable according to the string values
returned by a provided callback function.
The returned object has separate properties for each group, containing
arrays with the elements in the group.
.TP
\f[B]Object.hasOwn()\f[R]
Returns \f[CR]true\f[R] if the specified object has the indicated
property as its \f[I]own\f[R] property, or \f[CR]false\f[R] if the
property is inherited or does not exist.
.TP
\f[B]Object.is()\f[R]
Compares if two values are the same value.
Equates all \f[CR]NaN\f[R] values (which differs from both
\f[CR]IsLooselyEqual\f[R] used by \f[CR]==\f[R] and
\f[CR]IsStrictlyEqual\f[R] used by \f[CR]===\f[R]).
.TP
\f[B]Object.isExtensible()\f[R]
Determines if extending of an object is allowed.
.TP
\f[B]Object.isFrozen()\f[R]
Determines if an object was frozen.
.TP
\f[B]Object.isSealed()\f[R]
Determines if an object is sealed.
.TP
\f[B]Object.keys()\f[R]
Returns an array containing the names of all of the given object\[cq]s
\f[B]own\f[R] enumerable string properties.
.TP
\f[B]Object.preventExtensions()\f[R]
Prevents any extensions of an object.
.TP
\f[B]Object.seal()\f[R]
Prevents other code from deleting properties of an object.
.TP
\f[B]Object.setPrototypeOf()\f[R]
Sets the object\[cq]s prototype (its internal \f[CR][[Prototype]]\f[R]
property).
.TP
\f[B]Object.values()\f[R]
Returns an array containing the values that correspond to all of a given
object\[cq]s \f[B]own\f[R] enumerable string properties.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]Object.prototype\f[R] and shared
by all \f[CR]Object\f[R] instances.
.TP
\f[B]Object.prototype.__proto__\f[R] \f[I](deprecated)\f[R]
Points to the object which was used as prototype when the object was
instantiated.
.TP
\f[B]Object.prototype.constructor\f[R]
The constructor function that created the instance object.
For plain \f[CR]Object\f[R] instances, the initial value is the
\f[CR]Object\f[R] constructor.
Instances of other constructors each inherit the \f[CR]constructor\f[R]
property from their respective \f[CR]Constructor.prototype\f[R] object.
.SH INSTANCE METHODS
.TP
\f[B]Object.prototype.__defineGetter__()\f[R] \f[I](deprecated)\f[R]
Associates a function with a property that, when accessed, executes that
function and returns its return value.
.TP
\f[B]Object.prototype.__defineSetter__()\f[R] \f[I](deprecated)\f[R]
Associates a function with a property that, when set, executes that
function which modifies the property.
.TP
\f[B]Object.prototype.__lookupGetter__()\f[R] \f[I](deprecated)\f[R]
Returns the function bound as a getter to the specified property.
.TP
\f[B]Object.prototype.__lookupSetter__()\f[R] \f[I](deprecated)\f[R]
Returns the function bound as a setter to the specified property.
.TP
\f[B]Object.prototype.hasOwnProperty()\f[R]
Returns a boolean indicating whether an object contains the specified
property as a direct property of that object and not inherited through
the prototype chain.
.TP
\f[B]Object.prototype.isPrototypeOf()\f[R]
Returns a boolean indicating whether the object this method is called
upon is in the prototype chain of the specified object.
.TP
\f[B]Object.prototype.propertyIsEnumerable()\f[R]
Returns a boolean indicating whether the specified property is the
object\[cq]s enumerable own property.
.TP
\f[B]Object.prototype.toLocaleString()\f[R]
Calls \f[CR]toString()\f[R].
.TP
\f[B]Object.prototype.toString()\f[R]
Returns a string representation of the object.
.TP
\f[B]Object.prototype.valueOf()\f[R]
Returns the primitive value of the specified object.
.SH EXAMPLES
.SS Constructing empty objects
The following example creates empty objects using the \f[CR]new\f[R]
keyword with different arguments:
.IP
.EX
const o1 = new Object();
const o2 = new Object(undefined);
const o3 = new Object(null);
.EE
.SS Using Object() constructor to turn primitives into an Object of their respective type
You can use the \f[CR]Object()\f[R] constructor to create an object
wrapper of a primitive value.
.PP
The following examples create variables \f[CR]o1\f[R] and \f[CR]o2\f[R]
which are objects storing \f[CR]Boolean\f[R] and \f[CR]BigInt\f[R]
values:
.IP
.EX
// Equivalent to const o1 = new Boolean(true)
const o1 = new Object(true);

// No equivalent because BigInt() can\[aq]t be called as a constructor,
// and calling it as a regular function won\[aq]t create an object
const o2 = new Object(1n);
.EE
.SS Object prototypes
When altering the behavior of existing \f[CR]Object.prototype\f[R]
methods, consider injecting code by wrapping your extension before or
after the existing logic.
For example, this (untested) code will pre-conditionally execute custom
logic before the built-in logic or someone else\[cq]s extension is
executed.
.PP
When modifying prototypes with hooks, pass \f[CR]this\f[R] and the
arguments (the call state) to the current behavior by calling
\f[CR]apply()\f[R] on the function.
This pattern can be used for any prototype, such as
\f[CR]Node.prototype\f[R], \f[CR]Function.prototype\f[R], etc.
.IP
.EX
const current = Object.prototype.valueOf;

// Since my property \[dq]-prop-value\[dq] is cross-cutting and isn\[aq]t always
// on the same prototype chain, I want to modify Object.prototype:
Object.prototype.valueOf = function (...args) {
  if (Object.hasOwn(this, \[dq]-prop-value\[dq])) {
    return this[\[dq]-prop-value\[dq]];
  } else {
    // It doesn\[aq]t look like one of my objects, so let\[aq]s fall back on
    // the default behavior by reproducing the current behavior as best we can.
    // The apply behaves like \[dq]super\[dq] in some other languages.
    // Even though valueOf() doesn\[aq]t take arguments, some other hook may.
    return current.apply(this, args);
  }
};
.EE
.RS
.PP
\f[B]Warning:\f[R] Modifying the \f[CR]prototype\f[R] property of any
built-in constructor is considered a bad practice and risks forward
compatibility.
.RE
.PP
You can read more about prototypes in Inheritance and the prototype
chain.
.SH SEE ALSO
.IP \[bu] 2
Object initializer
