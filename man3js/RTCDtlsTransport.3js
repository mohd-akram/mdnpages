.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "RTCDtlsTransport" "JS" "December 12, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCDtlsTransport \- RTCDtlsTransport
.SH SYNOPSIS
The \f[B]\f[CB]RTCDtlsTransport\f[B]\f[R] interface provides access to
information about the Datagram Transport Layer Security (\f[B]DTLS\f[R])
transport over which a \f[CR]RTCPeerConnection\f[R]\[cq]s RTP and RTCP
packets are sent and received by its \f[CR]RTCRtpSender\f[R] and
\f[CR]RTCRtpReceiver\f[R] objects.
.PP
A \f[CR]RTCDtlsTransport\f[R] object is also used to provide information
about SCTP packets transmitted and received by a connection\[cq]s data
channels.
.PP
Features of the DTLS transport include the addition of security to the
underlying transport; the \f[CR]RTCDtlsTransport\f[R] interface can be
used to obtain information about the underlying transport and the
security added to it by the DTLS layer.
.SH INSTANCE PROPERTIES
\f[I]Also inherits properties from \f[CI]EventTarget\f[I].\f[R]
.TP
\f[B]iceTransport\f[R] \f[I](read\-only)\f[R]
Returns a reference to the underlying \f[CR]RTCIceTransport\f[R] object.
.TP
\f[B]state\f[R] \f[I](read\-only)\f[R]
Returns a string which describes the underlying Datagram Transport Layer
Security (\f[B]DTLS\f[R]) transport state.
It can be one of the following values: \f[CR]new\f[R],
\f[CR]connecting\f[R], \f[CR]connected\f[R], \f[CR]closed\f[R], or
\f[CR]failed\f[R].
.SH INSTANCE METHODS
\f[I]Also inherits methods from \f[CI]EventTarget\f[I].\f[R]
.TP
\f[B]getRemoteCertificates()\f[R]
Returns an array of \f[CR]ArrayBuffer\f[R] containing the certificates
of the remote peer of the connection.
.SH EVENTS
.TP
\f[B]error\f[R]
Sent when a transport\-level error occurs on the
\f[CR]RTCPeerConnection\f[R].
.TP
\f[B]statechange\f[R]
Sent when the \f[CR]state\f[R] of the DTLS transport changes.
.SH DESCRIPTION
.SS Allocation of DTLS transports
\f[CR]RTCDtlsTransport\f[R] objects are created when an app calls either
\f[CR]setLocalDescription()\f[R] or \f[CR]setRemoteDescription()\f[R].
The number of DTLS transports created and how they\[cq]re used depends
on the bundling mode used when creating the
\f[CR]RTCPeerConnection\f[R].
.PP
Whether bundling is used depends on what the other endpoint is able to
negotiate.
All browsers support bundling, so when both endpoints are browsers, you
can rest assured that bundling will be used.
.PP
Some non\-browser legacy endpoints, however, may not support bundle.
To be able to negotiate with such endpoints (or to exclude them
entirely), the \f[CR]bundlePolicy\f[R] property may be provided when
creating the connection.
The \f[CR]bundlePolicy\f[R] lets you control how to negotiate with these
legacy endpoints.
The default policy is \f[CR]\[dq]balanced\[dq]\f[R], which provides a
balance between performance and compatibility.
.PP
For example, to create the connection using the highest level of
bundling:
.IP
.EX
\f[B]const\f[R] rtcConfig = {
  bundlePolicy: \[dq]max\-bundle\[dq],
};

\f[B]const\f[R] pc = \f[B]new\f[R] RTCPeerConnection(rtcConfig);
.EE
.PP
\c
.UR https://webrtcstandards.info/sdp-bundle/
Bundling
.UE \c
\ lets you use one \f[CR]RTCDtlsTransport\f[R] to carry the data for
multiple higher\-level transports, such as multiple
\f[CR]RTCRtpTransceiver\f[R]s.
.SS When not using BUNDLE
When the connection is created without using BUNDLE, each RTP or RTCP
component of each \f[CR]RTCRtpTransceiver\f[R] has its own
\f[CR]RTCDtlsTransport\f[R]; that is, every \f[CR]RTCRtpSender\f[R] and
\f[CR]RTCRtpReceiver\f[R], has its own transport, and all
\f[CR]RTCDataChannel\f[R] objects share a transport dedicated to SCTP.
.SS When using BUNDLE
When the connection is using BUNDLE, each \f[CR]RTCDtlsTransport\f[R]
object represents a group of \f[CR]RTCRtpTransceiver\f[R] objects.
If the connection was created using \f[CR]max\-compat\f[R] mode, each
transport is responsible for handling all communication for a given type
of media (audio, video, or data channel).
Thus, a connection with any number of audio and video channels will
always have exactly one DTLS transport for audio and one for video
communications.
.PP
Because transports are established early in the negotiation process,
it\[cq]s likely that it won\[cq]t be known until after they\[cq]re
created whether or not the remote peer supports bundling.
For this reason, you\[cq]ll sometimes see separate transports created at
first, one for each track, then see them get bundled up once it\[cq]s
known that bundling is possible.
If your code accesses \f[CR]RTCRtpSender\f[R]s and/or
\f[CR]RTCRtpReceiver\f[R]s directly, you may encounter situations where
they\[cq]re initially separate, then half or more of them get closed and
the senders and receivers updated to refer to the appropriate remaining
\f[CR]RTCDtlsTransport\f[R] objects.
.SS Data channels
\f[CR]RTCDataChannel\f[R]s use SCTP to communicate.
All of a peer connection\[cq]s data channels share a single
\f[CR]RTCSctpTransport\f[R], found in the connection\[cq]s
\f[CR]sctp\f[R] property.
.PP
You can, in turn, identify the \f[CR]RTCDtlsTransport\f[R] used to
securely encapsulate the data channels\[cq] SCTP communications by
looking at the \f[CR]RTCSctpTransport\f[R] object\[cq]s
\f[CR]transport\f[R] property.
.SH EXAMPLES
This example presents a function, \f[CR]tallySenders()\f[R], which
iterates over an \f[CR]RTCPeerConnection\f[R]\[cq]s
\f[CR]RTCRtpSender\f[R]s, tallying up how many of them are in various
states.
The function returns an object containing properties whose values
indicate how many senders are in each state.
.IP
.EX
\f[B]let\f[R] pc = \f[B]new\f[R] RTCPeerConnection({ bundlePolicy: \[dq]max\-bundle\[dq] });

\f[I]// \&...\f[R]

\f[B]function\f[R] tallySenders(pc) {
  \f[B]let\f[R] results = {
    transportMissing: 0,
    connectionPending: 0,
    connected: 0,
    closed: 0,
    failed: 0,
    unknown: 0,
  };

  \f[B]let\f[R] senderList = pc.getSenders();
  senderList.forEach((sender) \f[B]=>\f[R] {
    \f[B]let\f[R] transport = sender.transport;

    \f[B]if\f[R] (!transport) {
      results.transportMissing++;
    } \f[B]else\f[R] {
      \f[B]switch\f[R] (transport.state) {
        \f[B]case\f[R] \[dq]new\[dq]:
        \f[B]case\f[R] \[dq]connecting\[dq]:
          results.connectionPending++;
          \f[B]break\f[R];
        \f[B]case\f[R] \[dq]connected\[dq]:
          results.connected++;
          \f[B]break\f[R];
        \f[B]case\f[R] \[dq]closed\[dq]:
          results.closed++;
          \f[B]break\f[R];
        \f[B]case\f[R] \[dq]failed\[dq]:
          results.failed++;
          \f[B]break\f[R];
        \f[B]default\f[R]:
          results.unknown++;
          \f[B]break\f[R];
      }
    }
  });
  \f[B]return\f[R] results;
}
.EE
.PP
Note that in this code, the \f[CR]new\f[R] and \f[CR]connecting\f[R]
states are being treated as a single \f[CR]connectionPending\f[R] status
in the returned object.
.SH SEE ALSO
.IP \[bu] 2
\f[CR]RTCRtpSender.transport\f[R] and
\f[CR]RTCRtpReceiver.transport\f[R]
.IP \[bu] 2
\f[CR]RTCSctpTransport.transport\f[R]
