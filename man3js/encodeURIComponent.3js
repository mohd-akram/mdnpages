.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "encodeURIComponent" "JS" "June 28, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
encodeURIComponent \- encodeURIComponent()
.SH SYNOPSIS
The \f[B]\f[CB]encodeURIComponent()\f[B]\f[R] function encodes a URI by
replacing each instance of certain characters by one, two, three, or
four escape sequences representing the UTF\-8 encoding of the character
(will only be four escape sequences for characters composed of two
surrogate characters).
Compared to \f[CR]encodeURI()\f[R], this function encodes more
characters, including those that are part of the URI syntax.
.SH SYNTAX
.IP
.EX
encodeURIComponent(uriComponent)
.EE
.SS Parameters
.TP
\f[B]uriComponent\f[R]
A string to be encoded as a URI component (a path, query string,
fragment, etc.).
Other values are converted to strings.
.SS Return value
A new string representing the provided \f[CR]uriComponent\f[R] encoded
as a URI component.
.SS Exceptions
.TP
\f[B]URIError\f[R]
Thrown if \f[CR]uriComponent\f[R] contains a lone surrogate.
.SH DESCRIPTION
\f[CR]encodeURIComponent()\f[R] is a function property of the global
object.
.PP
\f[CR]encodeURIComponent()\f[R] uses the same encoding algorithm as
described in \f[CR]encodeURI()\f[R].
It escapes all characters \f[B]except\f[R]:
.IP
.EX
A\[en]Z a\[en]z 0\[en]9 \- _ . ! \[ti] * \[aq] ( )
.EE
.PP
Compared to \f[CR]encodeURI()\f[R], \f[CR]encodeURIComponent()\f[R]
escapes a larger set of characters.
Use \f[CR]encodeURIComponent()\f[R] on user\-entered fields from forms
\f[CR]POST\f[R]\[cq]d to the server \[em] this will encode \f[CR]&\f[R]
symbols that may inadvertently be generated during data entry for
character references or other characters that require encoding/decoding.
For example, if a user writes \f[CR]Jack & Jill\f[R], without
\f[CR]encodeURIComponent()\f[R], the ampersand could be interpreted on
the server as the start of a new field and jeopardize the integrity of
the data.
.PP
For \c
.UR https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#application/x-www-form-urlencoded-encoding-algorithm
\f[CR]application/x\-www\-form\-urlencoded\f[R]
.UE \c
, spaces are to be replaced by \f[CR]+\f[R], so one may wish to follow a
\f[CR]encodeURIComponent()\f[R] replacement with an additional
replacement of \f[CR]%20\f[R] with \f[CR]+\f[R].
.SH EXAMPLES
.SS Encoding for Content\-Disposition and Link headers
The following example provides the special encoding required within
UTF\-8 \f[CR]Content\-Disposition\f[R] and \f[CR]Link\f[R] server
response header parameters (e.g., UTF\-8 filenames):
.IP
.EX
\f[B]const\f[R] fileName = \[dq]my file(2).txt\[dq];
\f[B]const\f[R] header = \[ga]Content\-Disposition: attachment; filename*=UTF\-8\[aq]\[aq]${encodeRFC5987ValueChars(
  fileName,
)}\[ga];

console.log(header);
\f[I]// \[dq]Content\-Disposition: attachment; filename*=UTF\-8\[aq]\[aq]my%20file%282%29.txt\[dq]\f[R]

\f[B]function\f[R] encodeRFC5987ValueChars(str) {
  \f[B]return\f[R] (
    encodeURIComponent(str)
      \f[I]// The following creates the sequences %27 %28 %29 %2A (Note that\f[R]
      \f[I]// the valid encoding of \[dq]*\[dq] is %2A, which necessitates calling\f[R]
      \f[I]// toUpperCase() to properly encode). Although RFC3986 reserves \[dq]!\[dq],\f[R]
      \f[I]// RFC5987 does not, so we do not need to escape it.\f[R]
      .replace(
        /[\[aq]()*]/g,
        (c) \f[B]=>\f[R] \[ga]%${c.charCodeAt(0).toString(16).toUpperCase()}\[ga],
      )
      \f[I]// The following are not required for percent\-encoding per RFC5987,\f[R]
      \f[I]// so we can allow for a little better readability over the wire: |\[ga]\[ha]\f[R]
      .replace(/%(7C|60|5E)/g, (str, hex) \f[B]=>\f[R]
        String.fromCharCode(parseInt(hex, 16)),
      )
  );
}
.EE
.SS Encoding for RFC3986
The more recent \c
.UR https://datatracker.ietf.org/doc/html/rfc3986
RFC3986
.UE \c
\ reserves \f[CR]!\f[R], \f[CR]\[aq]\f[R], \f[CR](\f[R], \f[CR])\f[R],
and \f[CR]*\f[R], even though these characters have no formalized URI
delimiting uses.
The following function encodes a string for RFC3986\-compliant URL
component format.
It also encodes \f[CR][\f[R] and \f[CR]]\f[R], which are part of the
IPv6 URI syntax.
An RFC3986\-compliant \f[CR]encodeURI\f[R] implementation should not
escape them, which is demonstrated in the \f[CR]encodeURI()\f[R]
example.
.IP
.EX
\f[B]function\f[R] encodeRFC3986URIComponent(str) {
  \f[B]return\f[R] encodeURIComponent(str).replace(
    /[!\[aq]()*]/g,
    (c) \f[B]=>\f[R] \[ga]%${c.charCodeAt(0).toString(16).toUpperCase()}\[ga],
  );
}
.EE
.SS Encoding a lone surrogate throws
A \f[CR]URIError\f[R] will be thrown if one attempts to encode a
surrogate which is not part of a high\-low pair.
For example:
.IP
.EX
\f[I]// High\-low pair OK\f[R]
encodeURIComponent(\[dq]\[rs]uD800\[rs]uDFFF\[dq]); \f[I]// \[dq]%F0%90%8F%BF\[dq]\f[R]

\f[I]// Lone high\-surrogate code unit throws \[dq]URIError: malformed URI sequence\[dq]\f[R]
encodeURIComponent(\[dq]\[rs]uD800\[dq]);

\f[I]// Lone high\-surrogate code unit throws \[dq]URIError: malformed URI sequence\[dq]\f[R]
encodeURIComponent(\[dq]\[rs]uDFFF\[dq]);
.EE
.PP
You can use \f[CR]String.prototype.toWellFormed()\f[R], which replaces
lone surrogates with the Unicode replacement character (U+FFFD), to
avoid this error.
You can also use \f[CR]String.prototype.isWellFormed()\f[R] to check if
a string contains lone surrogates before passing it to
\f[CR]encodeURIComponent()\f[R].
.SH SEE ALSO
.IP \[bu] 2
\f[CR]decodeURI()\f[R]
.IP \[bu] 2
\f[CR]encodeURI()\f[R]
.IP \[bu] 2
\f[CR]decodeURIComponent()\f[R]
