.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPURENDERBUNDLEENCODER" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPURenderBundleEncoder \- GPURenderBundleEncoder
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]GPURenderBundleEncoder\f[B]\f[R] interface of the WebGPU
API is used to pre\-record bundles of commands.
.PP
The command bundles are encoded by calling the methods of
\f[CR]GPURenderBundleEncoder\f[R]; once the desired commands have been
encoded, they are recorded into a \f[CR]GPURenderBundle\f[R] object
instance using the \f[CR]GPURenderBundleEncoder.finish()\f[R] method.
These render bundles can then be reused across multiple render passes by
passing the \f[CR]GPURenderBundle\f[R] objects into
\f[CR]GPURenderPassEncoder.executeBundles()\f[R] calls.
.PP
In effect, this is like a partial render pass \(em
\f[CR]GPURenderBundleEncoder\f[R]s have all the same functionality
available as \f[CR]GPURenderPassEncoder\f[R]s, except that they can\(cqt
begin and end occlusion queries, and can\(cqt set the scissor rect,
viewport, blend constant, and stencil reference.
The \f[CR]GPURenderBundle\f[R] will inherit all these values from the
\f[CR]GPURenderPassEncoder\f[R] that executes it.
.RS
.PP
\f[B]Note:\f[R] Currently set vertex buffers, index buffers, bind
groups, and pipeline are all cleared prior to executing a render bundle,
and once the render bundle has finished executing.
.RE
.PP
Reusing pre\-recoded commands can significantly improve app performance
in situations where JavaScript draw call overhead is a bottleneck.
Render bundles are most effective in situations where a batch of objects
will be drawn the same way across multiple views or frames, with the
only differences being the buffer content being used (such as updated
matrix uniforms).
A good example is VR rendering.
Recording the rendering as a render bundle and then tweaking the view
matrix and replaying it for each eye is a more efficient way to issue
draw calls for both renderings of the scene.
.PP
A \f[CR]GPURenderBundleEncoder\f[R] object instance is created via the
\f[CR]GPUDevice.createRenderBundleEncoder()\f[R] property.
.RS
.PP
\f[B]Note:\f[R] The methods of \f[CR]GPURenderBundleEncoder\f[R] are
functionally identical to their equivalents available on
\f[CR]GPURenderPassEncoder\f[R], except for
\f[CR]GPURenderBundleEncoder.finish()\f[R], which is similar in purpose
to \f[CR]GPUCommandEncoder.finish()\f[R].
.RE
.SH INSTANCE PROPERTIES
.TP
\f[B]label\f[R]
A string providing a label that can be used to identify the object, for
example in \f[CR]GPUError\f[R] messages or console warnings.
.SH INSTANCE METHODS
.TP
\f[B]draw()\f[R]
Draw primitives based on the vertex buffers provided by
\f[CR]setVertexBuffer()\f[R].
.TP
\f[B]drawIndexed()\f[R]
Draw indexed primitives based on the vertex and index buffers provided
by \f[CR]setVertexBuffer()\f[R] and \f[CR]setIndexBuffer()\f[R]
.TP
\f[B]drawIndirect()\f[R]
Draw primitives using parameters read from a \f[CR]GPUBuffer\f[R].
.TP
\f[B]drawIndexedIndirect()\f[R]
Draw indexed primitives using parameters read from a
\f[CR]GPUBuffer\f[R].
.TP
\f[B]finish()\f[R]
Completes recording of the current render pass command sequence.
.TP
\f[B]insertDebugMarker()\f[R]
Marks a specific point in a series of encoded commands with a label.
.TP
\f[B]popDebugGroup()\f[R]
Ends a debug group, which is begun with a \f[CR]pushDebugGroup()\f[R]
call.
.TP
\f[B]pushDebugGroup()\f[R]
Begins a debug group, which is marked with a specified label, and will
contain all subsequent encoded commands up until a
\f[CR]popDebugGroup()\f[R] method is invoked.
.TP
\f[B]setBindGroup()\f[R]
Sets the \f[CR]GPUBindGroup\f[R] to use for subsequent render bundle
commands, for a given index.
.TP
\f[B]setIndexBuffer()\f[R]
Sets the current \f[CR]GPUBuffer\f[R] that will provide index data for
subsequent drawing commands.
.TP
\f[B]setPipeline()\f[R]
Sets the \f[CR]GPURenderPipeline\f[R] to use for this render bundle.
.TP
\f[B]setVertexBuffer()\f[R]
Sets or unsets the current \f[CR]GPUBuffer\f[R] that will provide vertex
data for subsequent drawing commands.
.SH EXAMPLES
In the WebGPU Samples \c
.UR https://webgpu.github.io/webgpu-samples/samples/animometer/
Animometer example
.UE \c
, a lot of like operations are done on many different objects
simultaneously.
A bundle of commands is encoded using the following function:
.IP
.EX
\f[B]function\f[R] recordRenderPass(
  passEncoder: GPURenderBundleEncoder | GPURenderPassEncoder
) {
  \f[B]if\f[R] (settings.dynamicOffsets) {
    passEncoder.setPipeline(dynamicPipeline);
  } \f[B]else\f[R] {
    passEncoder.setPipeline(pipeline);
  }
  passEncoder.setVertexBuffer(0, vertexBuffer);
  passEncoder.setBindGroup(0, timeBindGroup);
  \f[B]const\f[R] dynamicOffsets = [0];
  \f[B]for\f[R] (\f[B]let\f[R] i = 0; i < numTriangles; ++i) {
    \f[B]if\f[R] (settings.dynamicOffsets) {
      dynamicOffsets[0] = i * alignedUniformBytes;
      passEncoder.setBindGroup(1, dynamicBindGroup, dynamicOffsets);
    } \f[B]else\f[R] {
      passEncoder.setBindGroup(1, bindGroups[i]);
    }
    passEncoder.draw(3, 1, 0, 0);
  }
}
.EE
.PP
Later on, a \f[CR]GPURenderBundleEncoder\f[R] is created, the function
is invoked, and the command bundle is recorded into a
\f[CR]GPURenderBundle\f[R] using
\f[CR]GPURenderBundleEncoder.finish()\f[R]:
.IP
.EX
\f[B]const\f[R] renderBundleEncoder = device.createRenderBundleEncoder({
  colorFormats: [presentationFormat],
});
recordRenderPass(renderBundleEncoder);
\f[B]const\f[R] renderBundle = renderBundleEncoder.finish();
.EE
.PP
\f[CR]GPURenderPassEncoder.executeBundles()\f[R] is then used to reuse
the work across multiple render passes to improve performance.
Study the example code listing for the full context.
.IP
.EX
\f[I]// \&...\f[R]

\f[B]return\f[R] \f[B]function\f[R] doDraw(timestamp) {
  \f[B]if\f[R] (startTime === \f[B]undefined\f[R]) {
    startTime = timestamp;
  }
  uniformTime[0] = (timestamp \- startTime) / 1000;
  device.queue.writeBuffer(uniformBuffer, timeOffset, uniformTime.buffer);

  renderPassDescriptor.colorAttachments[0].view = context
    .getCurrentTexture()
    .createView();

  \f[B]const\f[R] commandEncoder = device.createCommandEncoder();
  \f[B]const\f[R] passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);

  \f[B]if\f[R] (settings.renderBundles) {
    passEncoder.executeBundles([renderBundle]);
  } \f[B]else\f[R] {
    recordRenderPass(passEncoder);
  }

  passEncoder.end();
  device.queue.submit([commandEncoder.finish()]);
};

\f[I]// \&...\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
