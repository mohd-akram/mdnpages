.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ATOMICS.WAITASYNC" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Atomics.waitAsync \- Atomics.waitAsync()
.SH SYNOPSIS
The \f[B]\f[CB]Atomics.waitAsync()\f[B]\f[R] static method verifies that
a shared memory location contains a given value, immediately returning
an object with the \f[CR]value\f[R] property containing the string
\f[CR]\(dqnot\-equal\(dq\f[R] if the memory location does not match the
given value, or \f[CR]\(dqtimed\-out\(dq\f[R] if the timeout was set to
zero.
Otherwise the method returns an object where the \f[CR]value\f[R]
property is a \f[CR]Promise\f[R] that fulfills with either
\f[CR]\(dqok\(dq\f[R] when \f[CR]Atomics.notify()\f[R] is called, or
\f[CR]\(dqtimed\-out\(dq\f[R] if the timeout expires.
.PP
\f[CR]Atomics.waitAsync()\f[R] and \f[CR]Atomics.notify()\f[R] are used
together to enable thread synchronization based on a value in shared
memory.
A thread can proceed immediately if the synchronization value has
changed, or it can wait for notification from another thread when it
reaches the synchronization point.
.PP
This method only works with an \f[CR]Int32Array\f[R] or
\f[CR]BigInt64Array\f[R] that views a \f[CR]SharedArrayBuffer\f[R].
It is non\-blocking and, unlike \f[CR]Atomics.wait()\f[R], can be used
on the main thread.
Because it does not block the whole thread, you still need to be careful
not to access the shared memory before the promise settles.
.SH SYNTAX
.IP
.EX
Atomics.waitAsync(typedArray, index, value)
Atomics.waitAsync(typedArray, index, value, timeout)
.EE
.SS Parameters
.TP
\f[B]typedArray\f[R]
An \f[CR]Int32Array\f[R] or \f[CR]BigInt64Array\f[R] that views a
\f[CR]SharedArrayBuffer\f[R].
.TP
\f[B]index\f[R]
The position in the \f[CR]typedArray\f[R] to wait on.
.TP
\f[B]value\f[R]
The expected value to test.
.TP
\f[B]timeout\f[R] \f[I](optional)\f[R]
Time to wait in milliseconds.
\f[CR]NaN\f[R] (and values that get converted to \f[CR]NaN\f[R], such as
\f[CR]undefined\f[R]) becomes \f[CR]Infinity\f[R].
Negative values become \f[CR]0\f[R].
.SS Return value
An \f[CR]Object\f[R] with the following properties:
.TP
\f[B]async\f[R]
A boolean indicating whether the \f[CR]value\f[R] property is a
\f[CR]Promise\f[R] or not.
.TP
\f[B]value\f[R]
If \f[CR]async\f[R] is \f[CR]false\f[R], it will be a string which is
either \f[CR]\(dqnot\-equal\(dq\f[R] or \f[CR]\(dqtimed\-out\(dq\f[R]
(only when the \f[CR]timeout\f[R] parameter is \f[CR]0\f[R]).
If \f[CR]async\f[R] is \f[CR]true\f[R], it will be a \f[CR]Promise\f[R]
which is fulfilled with a string value, either \f[CR]\(dqok\(dq\f[R] or
\f[CR]\(dqtimed\-out\(dq\f[R].
The promise is never rejected.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if \f[CR]typedArray\f[R] is not an \f[CR]Int32Array\f[R] or
\f[CR]BigInt64Array\f[R] that views a \f[CR]SharedArrayBuffer\f[R].
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]index\f[R] is out of bounds in the
\f[CR]typedArray\f[R].
.SH EXAMPLES
.SS Using waitAsync()
Given a shared \f[CR]Int32Array\f[R].
.IP
.EX
\f[B]const\f[R] sab = \f[B]new\f[R] SharedArrayBuffer(1024);
\f[B]const\f[R] int32 = \f[B]new\f[R] Int32Array(sab);
.EE
.PP
A reading thread is sleeping and waiting on location 0 which is expected
to be 0.
The \f[CR]result.value\f[R] will be a promise.
.IP
.EX
\f[B]const\f[R] result = Atomics.waitAsync(int32, 0, 0, 1000);
\f[I]// { async: true, value: Promise {<pending>} }\f[R]
.EE
.PP
In the reading thread or in another thread, the memory location 0 is
called and the promise can be resolved with \f[CR]\(dqok\(dq\f[R].
.IP
.EX
Atomics.notify(int32, 0);
\f[I]// { async: true, value: Promise {<fulfilled>: \(aqok\(aq} }\f[R]
.EE
.PP
If it isn\(cqt resolving to \f[CR]\(dqok\(dq\f[R], the value in the
shared memory location wasn\(cqt the expected (the \f[CR]value\f[R]
would be \f[CR]\(dqnot\-equal\(dq\f[R] instead of a promise) or the
timeout was reached (the promise will resolve to
\f[CR]\(dqtime\-out\(dq\f[R]).
.SH SEE ALSO
.IP \(bu 2
\f[CR]Atomics\f[R]
.IP \(bu 2
\f[CR]Atomics.wait()\f[R]
.IP \(bu 2
\f[CR]Atomics.notify()\f[R]
