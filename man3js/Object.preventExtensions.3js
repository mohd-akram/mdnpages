.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Object.preventExtensions" "JS" "February 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.preventExtensions \- Object.preventExtensions()
.SH SYNOPSIS
The \f[B]\f[CB]Object.preventExtensions()\f[B]\f[R] static method
prevents new properties from ever being added to an object
(i.e.\ prevents future extensions to the object).
It also prevents the object\[cq]s prototype from being re\-assigned.
.SH SYNTAX
.IP
.EX
Object.preventExtensions(obj)
.EE
.SS Parameters
.TP
\f[B]obj\f[R]
The object which should be made non\-extensible.
.SS Return value
The object being made non\-extensible.
.SH DESCRIPTION
An object is extensible if new properties can be added to it.
\f[CR]Object.preventExtensions()\f[R] marks an object as no longer
extensible, so that it will never have properties beyond the ones it had
at the time it was marked as non\-extensible.
Note that the properties of a non\-extensible object, in general, may
still be \f[I]deleted\f[R].
Attempting to add new properties to a non\-extensible object will fail,
either silently or, in strict mode, throwing a \f[CR]TypeError\f[R].
.PP
Unlike \f[CR]Object.seal()\f[R] and \f[CR]Object.freeze()\f[R],
\f[CR]Object.preventExtensions()\f[R] invokes an intrinsic JavaScript
behavior and cannot be replaced with a composition of several other
operations.
It also has its \f[CR]Reflect\f[R] counterpart (which only exists for
intrinsic operations), \f[CR]Reflect.preventExtensions()\f[R].
.PP
\f[CR]Object.preventExtensions()\f[R] only prevents addition of own
properties.
Properties can still be added to the object prototype.
.PP
This method makes the \f[CR][[Prototype]]\f[R] of the target immutable;
any \f[CR][[Prototype]]\f[R] re\-assignment will throw a
\f[CR]TypeError\f[R].
This behavior is specific to the internal \f[CR][[Prototype]]\f[R]
property; other properties of the target object will remain mutable.
.PP
There is no way to make an object extensible again once it has been made
non\-extensible.
.SH EXAMPLES
.SS Using Object.preventExtensions
.IP
.EX
\f[I]// Object.preventExtensions returns the object\f[R]
\f[I]// being made non\-extensible.\f[R]
\f[B]const\f[R] obj = {};
\f[B]const\f[R] obj2 = Object.preventExtensions(obj);
obj === obj2; \f[I]// true\f[R]

\f[I]// Objects are extensible by default.\f[R]
\f[B]const\f[R] empty = {};
Object.isExtensible(empty); \f[I]// true\f[R]

\f[I]// They can be made un\-extensible\f[R]
Object.preventExtensions(empty);
Object.isExtensible(empty); \f[I]// false\f[R]

\f[I]// Object.defineProperty throws when adding\f[R]
\f[I]// a new property to a non\-extensible object.\f[R]
\f[B]const\f[R] nonExtensible = { removable: \f[B]true\f[R] };
Object.preventExtensions(nonExtensible);
Object.defineProperty(nonExtensible, \[dq]new\[dq], {
  value: 8675309,
}); \f[I]// throws a TypeError\f[R]

\f[I]// In strict mode, attempting to add new properties\f[R]
\f[I]// to a non\-extensible object throws a TypeError.\f[R]
\f[B]function\f[R] fail() {
  \[dq]use strict\[dq];
  \f[I]// throws a TypeError\f[R]
  nonExtensible.newProperty = \[dq]FAIL\[dq];
}
fail();
.EE
.PP
A non\-extensible object\[cq]s prototype is immutable:
.IP
.EX
\f[B]const\f[R] fixed = Object.preventExtensions({});
\f[I]// throws a \[aq]TypeError\[aq].\f[R]
fixed.__proto__ = { oh: \[dq]hai\[dq] };
.EE
.SS Non\-object argument
In ES5, if the argument to this method is not an object (a primitive),
then it will cause a \f[CR]TypeError\f[R].
In ES2015, a non\-object argument will be returned as\-is without any
errors, since primitives are already, by definition, immutable.
.IP
.EX
Object.preventExtensions(1);
\f[I]// TypeError: 1 is not an object (ES5 code)\f[R]

Object.preventExtensions(1);
\f[I]// 1                             (ES2015 code)\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Object.isExtensible()\f[R]
.IP \[bu] 2
\f[CR]Object.seal()\f[R]
.IP \[bu] 2
\f[CR]Object.isSealed()\f[R]
.IP \[bu] 2
\f[CR]Object.freeze()\f[R]
.IP \[bu] 2
\f[CR]Object.isFrozen()\f[R]
.IP \[bu] 2
\f[CR]Reflect.preventExtensions()\f[R]
