.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "RTCDATACHANNEL.PROTOCOL" "3JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCDataChannel.protocol \- RTCDataChannel: protocol property
.SH SYNOPSIS
The read\-only \f[CR]RTCDataChannel\f[R] property
\f[B]\f[CB]protocol\f[B]\f[R] returns a string containing the name of
the subprotocol in use.
If no protocol was specified when the data channel was created, then
this property\(cqs value is the empty string (\f[CR]\(dq\(dq\f[R]).
.RS
.PP
\f[B]Note:\f[R] The permitted values of this property are defined by the
website or app using the data channel.
.RE
.PP
The ability for each channel to have a defined subprotocol lets your
app, for example, use JSON objects as messages on one channel while
another channel is plaintext and another is raw binary or even some
other format.
.SH VALUE
A string identifying the app\-defined subprotocol being used for
exchanging data on the channel.
If none has been established, this is an empty string (\(lq\(lq).
.SH EXAMPLE
.IP
.EX
\f[B]const\f[R] pc = \f[B]new\f[R] RTCPeerConnection();
\f[B]const\f[R] dc = pc.createDataChannel(\(dqmy channel\(dq, {
  protocol: \(dqjson\(dq,
});

\f[B]function\f[R] handleChannelMessage(dataChannel, msg) {
  \f[B]switch\f[R] (dataChannel.protocol) {
    \f[B]case\f[R] \(dqjson\(dq:
      \f[I]/* process JSON data */\f[R]
      \f[B]break\f[R];
    \f[B]case\f[R] \(dqraw\(dq:
      \f[I]/* process raw binary data */\f[R]
      \f[B]break\f[R];
  }
}
.EE
.SH SEE ALSO
.IP \(bu 2
WebRTC
.IP \(bu 2
\f[CR]RTCDataChannel\f[R]
.IP \(bu 2
\f[CR]RTCPeerConnection.createDataChannel()\f[R]
