.\" Automatically generated by Pandoc 3.4
.\"
.TH "DedicatedWorkerGlobalScope.cancelAnimationFrame" "JS" "April 22, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
DedicatedWorkerGlobalScope.cancelAnimationFrame \-
DedicatedWorkerGlobalScope: cancelAnimationFrame() method
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is only available in Dedicated Web Workers.
.PP
The \f[B]\f[CB]cancelAnimationFrame()\f[B]\f[R] method of the
\f[CR]DedicatedWorkerGlobalScope\f[R] interface cancels an animation
frame request previously scheduled through a call to
\f[CR]requestAnimationFrame()\f[R].
.PP
Calling the \f[CR]cancelAnimationFrame()\f[R] method requires the
current worker to have an associated owner \f[CR]window\f[R].
That means that the current worker must be created by \f[CR]window\f[R]
or by a dedicated worker that also has an associated owner
\f[CR]window\f[R].
.SH SYNTAX
.IP
.EX
cancelAnimationFrame(handle)
.EE
.SS Parameters
.TP
\f[B]handle\f[R]
The ID value returned by a call to \f[CR]requestAnimationFrame()\f[R];
the call must have been made in the same worker.
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.TP
\f[B]NotSupportedError\f[R] \f[B]DOMException\f[R]
Thrown if the method is not supported by the current worker.
.SH EXAMPLES
On the main thread, we start by transferring the control of a
\f[CR]<canvas>\f[R] element to an \f[CR]OffscreenCanvas\f[R], using
\f[CR]HTMLCanvasElement.transferControlToOffscreen()\f[R] and send to a
message to \f[CR]\[dq]start\[dq]\f[R] its work to the worker, with the
offscreen canvas:
.IP
.EX
\f[B]const\f[R] offscreenCanvas = document
  .querySelector(\[dq]canvas\[dq])
  .transferControlToOffscreen();

worker.postMessage(
  {
    type: \[dq]start\[dq],
    canvas: offscreenCanvas,
  },
  [offscreenCanvas],
);
.EE
.PP
When receiving the \f[CR]\[dq]start\[dq]\f[R] message, the worker starts
the animation, moving the rectangle from left to right.
Upon reception of a \f[CR]\[dq]stop\[dq]\f[R] message, it will stop the
animation.
.IP
.EX
\f[B]let\f[R] ctx;
\f[B]let\f[R] pos = 0;

\f[B]function\f[R] draw(dt) {
  ctx.clearRect(0, 0, 100, 100);
  ctx.fillRect(pos, 0, 10, 10);
  pos += 10 * dt;
  self.requestAnimationFrame(draw);
}

self.addEventListener(\[dq]message\[dq], (e) \f[B]=>\f[R] {
  \f[B]if\f[R] (e.data.type === \[dq]start\[dq]) {
    \f[B]const\f[R] transferredCanvas = e.data.canvas;
    ctx = transferredCanvas.getContext(\[dq]2d\[dq]);
    self.requestAnimationFrame(draw);
  }
  \f[B]if\f[R] (e.data.type === \[dq]stop\[dq]) {
    self.cancelAnimationFrame(handle);
  }
});
.EE
.PP
Finally, if needed, the main thread can send a \f[CR]\[dq]stop\[dq]\f[R]
message to the worker to stop the animation:
.IP
.EX
worker.postMessage({
  type: \[dq]stop\[dq],
});
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]DedicatedWorkerGlobalScope.requestAnimationFrame()\f[R]
.IP \[bu] 2
\f[CR]Window.cancelAnimationFrame()\f[R]
