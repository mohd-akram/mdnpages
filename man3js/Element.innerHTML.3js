.\" Automatically generated by Pandoc 3.4
.\"
.TH "Element.innerHTML" "JS" "October 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Element.innerHTML \- Element: innerHTML property
.SH SYNOPSIS
The \f[CR]Element\f[R] property \f[B]\f[CB]innerHTML\f[B]\f[R] gets or
sets the HTML or XML markup contained within the element.
.PP
More precisely, \f[CR]innerHTML\f[R] gets a serialization of the nested
child DOM elements within the element, or sets HTML or XML that should
be parsed to replace the DOM tree within the element.
.PP
To insert the HTML into the document rather than replace the contents of
an element, use the method \f[CR]insertAdjacentHTML()\f[R].
.PP
The serialization of the DOM tree read from the property does not
include shadow roots \[em] if you want to get a HTML string that
includes shadow roots, you must instead use the
\f[CR]Element.getHTML()\f[R] or \f[CR]ShadowRoot.getHTML()\f[R] methods.
Similarly, when setting element content using \f[CR]innerHTML\f[R], the
HTML string is parsed into DOM elements that do not contain shadow
roots.
.PP
So for example \f[CR]<template>\f[R] is parsed into as
\f[CR]HTMLTemplateElement\f[R], whether or not the
\f[CR]shadowrootmode\f[R] attribute is specified In order to set an
element\[cq]s contents from an HTML string that includes declarative
shadow roots, you must use either \f[CR]Element.setHTMLUnsafe()\f[R] or
\f[CR]ShadowRoot.setHTMLUnsafe()\f[R].
.SH VALUE
A string containing the HTML serialization of the element\[cq]s
descendants.
Setting the value of \f[CR]innerHTML\f[R] removes all of the
element\[cq]s descendants and replaces them with nodes constructed by
parsing the HTML given in the string \f[I]htmlString\f[R].
.PP
When set to the \f[CR]null\f[R] value, that \f[CR]null\f[R] value is
converted to the empty string (\f[CR]\[dq]\[dq]\f[R]), so
\f[CR]elt.innerHTML = null\f[R] is equivalent to
\f[CR]elt.innerHTML = \[dq]\[dq]\f[R].
.SS Exceptions
.TP
\f[B]SyntaxError\f[R] \f[B]DOMException\f[R]
Thrown if an attempt was made to set the value of \f[CR]innerHTML\f[R]
using a string which is not properly\-formed HTML.
.TP
\f[B]NoModificationAllowedError\f[R] \f[B]DOMException\f[R]
Thrown if an attempt was made to insert the HTML into a node whose
parent is a \f[CR]Document\f[R].
.SH USAGE NOTES
.SS Reading the HTML contents of an element
Reading \f[CR]innerHTML\f[R] causes the user agent to serialize the HTML
or XML fragment comprised of the element\[cq]s descendants.
The resulting string is returned.
.IP
.EX
\f[B]let\f[R] contents = myElement.innerHTML;
.EE
.PP
This lets you look at the HTML markup of the element\[cq]s content
nodes.
.RS
.PP
\f[B]Note:\f[R] The returned HTML or XML fragment is generated based on
the current contents of the element, so the markup and formatting of the
returned fragment is likely not to match the original page markup.
.RE
.SS Replacing the contents of an element
Setting the value of \f[CR]innerHTML\f[R] lets you easily replace the
existing contents of an element with new content.
.RS
.PP
\f[B]Warning:\f[R] This is a security risk if the string to be inserted
might contain potentially malicious content.
When inserting user\-supplied data you should always consider using a
sanitizer library, in order to sanitize the content before it is
inserted.
.RE
.PP
For example, you can erase the entire contents of a document by clearing
the contents of the document\[cq]s \f[CR]body\f[R] attribute:
.IP
.EX
document.body.textContent = \[dq]\[dq];
.EE
.PP
This example fetches the document\[cq]s current HTML markup and replaces
the \f[CR]\[dq]<\[dq]\f[R] characters with the character reference
\f[CR]\[dq]&lt;\[dq]\f[R], thereby essentially converting the HTML into
raw text.
This is then wrapped in a \f[CR]<pre>\f[R] element.
Then the value of \f[CR]innerHTML\f[R] is changed to this new string.
As a result, the document contents are replaced with a display of the
page\[cq]s entire source code.
.IP
.EX
document.documentElement.innerHTML = \[ga]<pre>${document.documentElement.innerHTML.replace(
  /</g,
  \[dq]&lt;\[dq],
)}</pre>\[ga];
.EE
.SS Operational details
What exactly happens when you set value of \f[CR]innerHTML\f[R]?
Doing so causes the user agent to follow these steps:
.IP "1." 3
The specified value is parsed as HTML or XML (based on the document
type), resulting in a \f[CR]DocumentFragment\f[R] object representing
the new set of DOM nodes for the new elements.
.IP "2." 3
If the element whose contents are being replaced is a
\f[CR]<template>\f[R] element, then the \f[CR]<template>\f[R]
element\[cq]s \f[CR]content\f[R] attribute is replaced with the new
\f[CR]DocumentFragment\f[R] created in step 1.
.IP "3." 3
For all other elements, the element\[cq]s contents are replaced with the
nodes in the new \f[CR]DocumentFragment\f[R].
.SS Appending HTML to an element
Setting the value of \f[CR]innerHTML\f[R] lets you append new contents
to the existing one of an element.
.PP
For example, we can append a new list item (\f[CR]<li>\f[R]) to the
existing list (\f[CR]<ul>\f[R]):
.SS HTML
.IP
.EX
<\f[B]ul\f[R] id=\[dq]list\[dq]>
  <\f[B]li\f[R]><\f[B]a\f[R] href=\[dq]#\[dq]>Item 1</\f[B]a\f[R]></\f[B]li\f[R]>
  <\f[B]li\f[R]><\f[B]a\f[R] href=\[dq]#\[dq]>Item 2</\f[B]a\f[R]></\f[B]li\f[R]>
  <\f[B]li\f[R]><\f[B]a\f[R] href=\[dq]#\[dq]>Item 3</\f[B]a\f[R]></\f[B]li\f[R]>
</\f[B]ul\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] list = document.getElementById(\[dq]list\[dq]);

list.innerHTML += \[ga]<li><a href=\[dq]#\[dq]>Item ${list.children.length + 1}</a></li>\[ga];
.EE
.PP
Please note that using \f[CR]innerHTML\f[R] to append HTML elements
(e.g.\ \f[CR]el.innerHTML += \[dq]<a href=\[aq]\&...\[aq]>link</a>\[dq]\f[R])
will result in the removal of any previously set event listeners.
That is, after you append any HTML element that way you won\[cq]t be
able to listen to the previously set event listeners.
.SS Security considerations
It is not uncommon to see \f[CR]innerHTML\f[R] used to insert text into
a web page.
There is potential for this to become an attack vector on a site,
creating a potential security risk.
.IP
.EX
\f[B]let\f[R] name = \[dq]John\[dq];
\f[I]// assuming \[aq]el\[aq] is an HTML DOM element\f[R]
el.innerHTML = name; \f[I]// harmless in this case\f[R]

\f[I]// \&...\f[R]

name = \[dq]<script>alert(\[aq]I am John in an annoying alert!\[aq])</script>\[dq];
el.innerHTML = name; \f[I]// harmless in this case\f[R]
.EE
.PP
Although this may look like a \c
.UR https://en.wikipedia.org/wiki/Cross-site_scripting
cross\-site scripting
.UE \c
\ attack, the result is harmless.
HTML specifies that a \f[CR]<script>\f[R] tag inserted with
\f[CR]innerHTML\f[R] \c
.UR https://www.w3.org/TR/2008/WD-html5-20080610/dom.html#innerhtml0
should not execute
.UE \c
\&.
.PP
However, there are ways to execute JavaScript without using
\f[CR]<script>\f[R] elements, so there is still a security risk whenever
you use \f[CR]innerHTML\f[R] to set strings over which you have no
control.
For example:
.IP
.EX
\f[B]const\f[R] name = \[dq]<img src=\[aq]x\[aq] onerror=\[aq]alert(1)\[aq]>\[dq];
el.innerHTML = name; \f[I]// shows the alert\f[R]
.EE
.PP
For that reason, it is recommended that instead of \f[CR]innerHTML\f[R]
you use:
.IP \[bu] 2
\f[CR]Node.textContent\f[R] when inserting plain text, as this inserts
it as raw text rather than parsing it as HTML.
.RS
.PP
\f[B]Warning:\f[R] If your project is one that will undergo any form of
security review, using \f[CR]innerHTML\f[R] most likely will result in
your code being rejected.
For example, \c
.UR https://wiki.mozilla.org/Add-ons/Reviewers/Guide/Reviewing#Step_2:_Automatic_validation
if you use \f[CR]innerHTML\f[R]
.UE \c
\ in a browser extension and submit the extension to \c
.UR https://addons.mozilla.org/
addons.mozilla.org
.UE \c
, it may be rejected in the review process.
Please see Safely inserting external content into a page for alternative
methods.
.RE
.SH EXAMPLES
This example uses \f[CR]innerHTML\f[R] to create a mechanism for logging
messages into a box on a web page.
.SS JavaScript
.IP
.EX
\f[B]function\f[R] log(msg) {
  \f[B]const\f[R] logElem = document.querySelector(\[dq].log\[dq]);

  \f[B]const\f[R] time = \f[B]new\f[R] Date();
  \f[B]const\f[R] timeStr = time.toLocaleTimeString();
  logElem.innerHTML += \[ga]${timeStr}: ${msg}<br/>\[ga];
}

log(\[dq]Logging mouse events inside this container\&...\[dq]);
.EE
.PP
The \f[CR]log()\f[R] function creates the log output by getting the
current time from a \f[CR]Date\f[R] object using
\f[CR]toLocaleTimeString()\f[R], and building a string with the
timestamp and the message text.
Then the message is appended to the box with the class
\f[CR]\[dq]log\[dq]\f[R].
.PP
We add a second method that logs information about \f[CR]MouseEvent\f[R]
based events (such as \f[CR]mousedown\f[R], \f[CR]click\f[R], and
\f[CR]mouseenter\f[R]):
.IP
.EX
\f[B]function\f[R] logEvent(event) {
  \f[B]const\f[R] msg = \[ga]Event <strong>${event.type}</strong> at <em>${event.clientX}, ${event.clientY}</em>\[ga];
  log(msg);
}
.EE
.PP
Then we use this as the event handler for a number of mouse events on
the box that contains our log:
.IP
.EX
\f[B]const\f[R] boxElem = document.querySelector(\[dq].box\[dq]);

boxElem.addEventListener(\[dq]mousedown\[dq], logEvent);
boxElem.addEventListener(\[dq]mouseup\[dq], logEvent);
boxElem.addEventListener(\[dq]click\[dq], logEvent);
boxElem.addEventListener(\[dq]mouseenter\[dq], logEvent);
boxElem.addEventListener(\[dq]mouseleave\[dq], logEvent);
.EE
.SS HTML
The HTML is quite simple for our example.
.IP
.EX
<\f[B]div\f[R] class=\[dq]box\[dq]>
  <\f[B]div\f[R]><\f[B]strong\f[R]>Log:</\f[B]strong\f[R]></\f[B]div\f[R]>
  <\f[B]div\f[R] class=\[dq]log\[dq]></\f[B]div\f[R]>
</\f[B]div\f[R]>
.EE
.PP
The \f[CR]<div>\f[R] with the class \f[CR]\[dq]box\[dq]\f[R] is just a
container for layout purposes, presenting the contents with a box around
it.
The \f[CR]<div>\f[R] whose class is \f[CR]\[dq]log\[dq]\f[R] is the
container for the log text itself.
.SS CSS
The following CSS styles our example content.
.IP
.EX
\&.box {
  \f[B]width\f[R]: 600px;
  \f[B]height\f[R]: 300px;
  \f[B]border\f[R]: 1px solid black;
  \f[B]padding\f[R]: 2px 4px;
  \f[B]overflow\-y\f[R]: scroll;
  \f[B]overflow\-x\f[R]: auto;
}

\&.log {
  \f[B]margin\-top\f[R]: 8px;
  \f[B]font\-family\f[R]: monospace;
}
.EE
.SS Result
The resulting content looks like this.
You can see output into the log by moving the mouse in and out of the
box, clicking in it, and so forth.
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Node.textContent\f[R] and \f[CR]HTMLElement.innerText\f[R]
.IP \[bu] 2
\f[CR]Element.insertAdjacentHTML()\f[R]
.IP \[bu] 2
\f[CR]Element.outerHTML\f[R]
.IP \[bu] 2
Parsing HTML or XML into a DOM tree: \f[CR]DOMParser\f[R]
.IP \[bu] 2
Serializing a DOM tree into an XML string: \f[CR]XMLSerializer\f[R]
.IP \[bu] 2
\f[CR]Element.getHTML()\f[R]
.IP \[bu] 2
\f[CR]ShadowRoot.getHTML()\f[R]
.IP \[bu] 2
\f[CR]Element.setHTMLUnsafe()\f[R]
.IP \[bu] 2
\f[CR]ShadowRoot.setHTMLUnsafe()\f[R]
