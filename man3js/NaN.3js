'\" t
.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "NaN" "JS" "December 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
NaN \- NaN
.SH SYNOPSIS
The \f[B]\f[CB]NaN\f[B]\f[R] global property is a value representing
Not\-A\-Number.
.SH VALUE
The same number value as \f[CR]Number.NaN\f[R].
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
no
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
no
T}
.TE
.SH DESCRIPTION
\f[CR]NaN\f[R] is a property of the \f[I]global object\f[R].
In other words, it is a variable in global scope.
.PP
In modern browsers, \f[CR]NaN\f[R] is a non\-configurable, non\-writable
property.
Even when this is not the case, avoid overriding it.
.PP
There are five different types of operations that return \f[CR]NaN\f[R]:
.IP \[bu] 2
Failed number conversion (e.g.\ explicit ones like
\f[CR]parseInt(\[dq]blabla\[dq])\f[R], \f[CR]Number(undefined)\f[R], or
implicit ones like \f[CR]Math.abs(undefined)\f[R])
.IP \[bu] 2
Math operation where the result is not a real number
(e.g.\ \f[CR]Math.sqrt(\-1)\f[R])
.IP \[bu] 2
Indeterminate form (e.g.\ \f[CR]0 * Infinity\f[R],
\f[CR]1 ** Infinity\f[R], \f[CR]Infinity / Infinity\f[R],
\f[CR]Infinity \- Infinity\f[R])
.IP \[bu] 2
A method or expression whose operand is or gets coerced to
\f[CR]NaN\f[R] (e.g.\ \f[CR]7 ** NaN\f[R],
\f[CR]7 * \[dq]blabla\[dq]\f[R]) \[em] this means \f[CR]NaN\f[R] is
contagious
.IP \[bu] 2
Other cases where an invalid value is to be represented as a number
(e.g.\ an invalid Date \f[CR]new Date(\[dq]blabla\[dq]).getTime()\f[R],
\f[CR]\[dq]\[dq].charCodeAt(1)\f[R])
.PP
\f[CR]NaN\f[R] and its behaviors are not invented by JavaScript.
Its semantics in floating point arithmetic (including that
\f[CR]NaN !== NaN\f[R]) are specified by \c
.UR https://en.wikipedia.org/wiki/Double_precision_floating-point_format
IEEE 754
.UE \c
\&.
\f[CR]NaN\f[R]\[cq]s behaviors include:
.IP \[bu] 2
If \f[CR]NaN\f[R] is involved in a mathematical operation (but not
bitwise operations), the result is usually also \f[CR]NaN\f[R].
(See counter\-example below.)
.IP \[bu] 2
When \f[CR]NaN\f[R] is one of the operands of any relational comparison
(\f[CR]>\f[R], \f[CR]<\f[R], \f[CR]>=\f[R], \f[CR]<=\f[R]), the result
is always \f[CR]false\f[R].
.IP \[bu] 2
\f[CR]NaN\f[R] compares unequal (via \f[CR]==\f[R], \f[CR]!=\f[R],
\f[CR]===\f[R], and \f[CR]!==\f[R]) to any other value \[em] including
to another \f[CR]NaN\f[R] value.
.PP
\f[CR]NaN\f[R] is also one of the falsy values in JavaScript.
.SH EXAMPLES
.SS Testing against NaN
To tell if a value is \f[CR]NaN\f[R], use \f[CR]Number.isNaN()\f[R] or
\f[CR]isNaN()\f[R] to most clearly determine whether a value is
\f[CR]NaN\f[R] \[em] or, since \f[CR]NaN\f[R] is the only value that
compares unequal to itself, you can perform a self\-comparison like
\f[CR]x !== x\f[R].
.IP
.EX
\f[B]NaN\f[R] === \f[B]NaN\f[R]; \f[I]// false\f[R]
Number.NaN === \f[B]NaN\f[R]; \f[I]// false\f[R]
isNaN(\f[B]NaN\f[R]); \f[I]// true\f[R]
isNaN(Number.NaN); \f[I]// true\f[R]
Number.isNaN(\f[B]NaN\f[R]); \f[I]// true\f[R]

\f[B]function\f[R] valueIsNaN(v) {
  \f[B]return\f[R] v !== v;
}
valueIsNaN(1); \f[I]// false\f[R]
valueIsNaN(\f[B]NaN\f[R]); \f[I]// true\f[R]
valueIsNaN(Number.NaN); \f[I]// true\f[R]
.EE
.PP
However, do note the difference between \f[CR]isNaN()\f[R] and
\f[CR]Number.isNaN()\f[R]: the former will return \f[CR]true\f[R] if the
value is currently \f[CR]NaN\f[R], or if it is going to be
\f[CR]NaN\f[R] after it is coerced to a number, while the latter will
return \f[CR]true\f[R] only if the value is currently \f[CR]NaN\f[R]:
.IP
.EX
isNaN(\[dq]hello world\[dq]); \f[I]// true\f[R]
Number.isNaN(\[dq]hello world\[dq]); \f[I]// false\f[R]
.EE
.PP
For the same reason, using a BigInt value will throw an error with
\f[CR]isNaN()\f[R] and not with \f[CR]Number.isNaN()\f[R]:
.IP
.EX
isNaN(1n); \f[I]// TypeError: Conversion from \[aq]BigInt\[aq] to \[aq]number\[aq] is not allowed.\f[R]
Number.isNaN(1n); \f[I]// false\f[R]
.EE
.PP
Additionally, some array methods cannot find \f[CR]NaN\f[R], while
others can.
Namely, the index\-finding ones (\f[CR]indexOf()\f[R],
\f[CR]lastIndexOf()\f[R]) cannot find \f[CR]NaN\f[R], while the
value\-finding ones (\f[CR]includes()\f[R]) can:
.IP
.EX
\f[B]const\f[R] arr = [2, 4, \f[B]NaN\f[R], 12];
arr.indexOf(\f[B]NaN\f[R]); \f[I]// \-1\f[R]
arr.includes(\f[B]NaN\f[R]); \f[I]// true\f[R]

\f[I]// Methods accepting a properly defined predicate can always find NaN\f[R]
arr.findIndex((n) \f[B]=>\f[R] Number.isNaN(n)); \f[I]// 2\f[R]
.EE
.PP
For more information about \f[CR]NaN\f[R] and its comparison, see
Equality comparison and sameness.
.SS Observably distinct NaN values
There\[cq]s a motivation for \f[CR]NaN\f[R] being unequal to itself.
It\[cq]s possible to produce two floating point numbers with different
binary representations but are both \f[CR]NaN\f[R], because in \c
.UR https://en.wikipedia.org/wiki/NaN#Floating_point
IEEE 754 encoding
.UE \c
, any floating point number with exponent \f[CR]0x7ff\f[R] and a
non\-zero mantissa is \f[CR]NaN\f[R].
In JavaScript, you can do bit\-level manipulation using typed arrays.
.IP
.EX
\f[B]const\f[R] f2b = (x) \f[B]=>\f[R] \f[B]new\f[R] Uint8Array(\f[B]new\f[R] Float64Array([x]).buffer);
\f[B]const\f[R] b2f = (x) \f[B]=>\f[R] \f[B]new\f[R] Float64Array(x.buffer)[0];
\f[I]// Get a byte representation of NaN\f[R]
\f[B]const\f[R] n = f2b(\f[B]NaN\f[R]);
\f[B]const\f[R] m = f2b(\f[B]NaN\f[R]);
\f[I]// Change the sign bit, which doesn\[aq]t matter for NaN\f[R]
n[7] += 2 ** 7;
\f[I]// n[0] += 2**7; for big endian processors\f[R]
\f[B]const\f[R] nan2 = b2f(n);
console.log(nan2); \f[I]// NaN\f[R]
console.log(Object.is(nan2, \f[B]NaN\f[R])); \f[I]// true\f[R]
console.log(f2b(\f[B]NaN\f[R])); \f[I]// Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]\f[R]
console.log(f2b(nan2)); \f[I]// Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 255]\f[R]
\f[I]// Change the first bit, which is the least significant bit of the mantissa and doesn\[aq]t matter for NaN\f[R]
m[0] = 1;
\f[I]// m[7] = 1; for big endian processors\f[R]
\f[B]const\f[R] nan3 = b2f(m);
console.log(nan3); \f[I]// NaN\f[R]
console.log(Object.is(nan3, \f[B]NaN\f[R])); \f[I]// true\f[R]
console.log(f2b(\f[B]NaN\f[R])); \f[I]// Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]\f[R]
console.log(f2b(nan3)); \f[I]// Uint8Array(8) [1, 0, 0, 0, 0, 0, 248, 127]\f[R]
.EE
.SS Silently escaping NaN
\f[CR]NaN\f[R] propagates through mathematical operations, so it\[cq]s
usually sufficient to test for \f[CR]NaN\f[R] once at the end of
calculation to detect error conditions.
The only case where \f[CR]NaN\f[R] gets silently escaped is when using
exponentiation with an exponent of \f[CR]0\f[R], which immediately
returns \f[CR]1\f[R] without testing the base\[cq]s value.
.IP
.EX
\f[B]NaN\f[R] ** 0 === 1; \f[I]// true\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Number.NaN\f[R]
.IP \[bu] 2
\f[CR]Number.isNaN()\f[R]
.IP \[bu] 2
\f[CR]isNaN()\f[R]
