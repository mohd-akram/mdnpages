.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "WRITABLESTREAM.WRITABLESTREAM" "3JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
WritableStream.WritableStream \- WritableStream: WritableStream()
constructor
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]WritableStream()\f[B]\f[R] constructor creates a new
\f[CR]WritableStream\f[R] object instance.
.SH SYNTAX
.IP
.EX
new WritableStream(underlyingSink)
new WritableStream(underlyingSink, queuingStrategy)
.EE
.SS Parameters
.TP
\f[B]underlyingSink\f[R] \f[I](optional)\f[R]
An object containing methods and properties that define how the
constructed stream instance will behave.
The \f[CR]controller\f[R] parameter passed to this object\(cqs methods
is a \f[CR]WritableStreamDefaultController\f[R] that provides abort and
error signaling.
\f[CR]underlyingSink\f[R] can contain the following:
.RS
.TP
\f[B]start(controller)\f[R] \f[I](optional)\f[R]
This is a method, called immediately when the object is constructed.
The contents of this method are defined by the developer, and should aim
to get access to the underlying sink.
If this process is to be done asynchronously, it can return a promise to
signal success or failure.
.TP
\f[B]write(chunk, controller)\f[R] \f[I](optional)\f[R]
This method, also defined by the developer, will be called when a new
chunk of data (specified in the \f[CR]chunk\f[R] parameter) is ready to
be written to the underlying sink.
It can return a promise to signal success or failure of the write
operation.
This method will be called only after previous writes have succeeded,
and never after the stream is closed or aborted (see below).
.TP
\f[B]close(controller)\f[R] \f[I](optional)\f[R]
This method, also defined by the developer, will be called if the app
signals that it has finished writing chunks to the stream.
The contents should do whatever is necessary to finalize writes to the
underlying sink, and release access to it.
If this process is asynchronous, it can return a promise to signal
success or failure.
This method will be called only after all queued\-up writes have
succeeded.
.TP
\f[B]abort(reason)\f[R] \f[I](optional)\f[R]
This method, also defined by the developer, will be called if the app
signals that it wishes to abruptly close the stream and put it in an
errored state.
It can clean up any held resources, much like \f[CR]close()\f[R], but
\f[CR]abort()\f[R] will be called even if writes are queued up \(em
those chunks will be thrown away.
If this process is asynchronous, it can return a promise to signal
success or failure.
The \f[CR]reason\f[R] parameter contains a string describing why the
stream was aborted.
.RE
.TP
\f[B]queuingStrategy\f[R] \f[I](optional)\f[R]
An object that optionally defines a queuing strategy for the stream.
This takes two parameters:
.RS
.TP
\f[B]highWaterMark\f[R]
A non\-negative integer \(em this defines the total number of chunks
that can be contained in the internal queue before backpressure is
applied.
.TP
\f[B]size(chunk)\f[R]
A method containing a parameter \f[CR]chunk\f[R] \(em this indicates the
size to use for each chunk, in bytes.
.RS
.PP
\f[B]Note:\f[R] You could define your own custom
\f[CR]queuingStrategy\f[R], or use an instance of
\f[CR]ByteLengthQueuingStrategy\f[R] or \f[CR]CountQueuingStrategy\f[R]
for this object value.
If no \f[CR]queuingStrategy\f[R] is supplied, the default used is the
same as a \f[CR]CountQueuingStrategy\f[R] with a high water mark of 1.
.RE
.RE
.SS Return value
An instance of the \f[CR]WritableStream\f[R] object.
.SH EXAMPLES
The following example illustrates several features of this interface.
It shows the creation of the \f[CR]WritableStream\f[R] with a custom
sink and an API\-supplied queuing strategy.
It then calls a function called \f[CR]sendMessage()\f[R], passing the
newly created stream and a string.
Inside this function it calls the stream\(cqs \f[CR]getWriter()\f[R]
method, which returns an instance of
\f[CR]WritableStreamDefaultWriter\f[R].
A \f[CR]forEach()\f[R] call is used to write each chunk of the string to
the stream.
Finally, \f[CR]write()\f[R] and \f[CR]close()\f[R] return promises that
are processed to deal with success or failure of chunks and streams.
.IP
.EX
\f[B]const\f[R] list = document.querySelector(\(dqul\(dq);

\f[B]function\f[R] sendMessage(message, writableStream) {
  \f[I]// defaultWriter is of type WritableStreamDefaultWriter\f[R]
  \f[B]const\f[R] defaultWriter = writableStream.getWriter();
  \f[B]const\f[R] encoder = \f[B]new\f[R] TextEncoder();
  \f[B]const\f[R] encoded = encoder.encode(message);
  encoded.forEach((chunk) \f[B]=>\f[R] {
    defaultWriter.ready
      .then(() \f[B]=>\f[R] defaultWriter.write(chunk))
      .then(() \f[B]=>\f[R] {
        console.log(\(dqChunk written to sink.\(dq);
      })
      .catch((err) \f[B]=>\f[R] {
        console.log(\(dqChunk error:\(dq, err);
      });
  });
  \f[I]// Call ready again to ensure that all chunks are written\f[R]
  \f[I]//   before closing the writer.\f[R]
  defaultWriter.ready
    .then(() \f[B]=>\f[R] {
      defaultWriter.close();
    })
    .then(() \f[B]=>\f[R] {
      console.log(\(dqAll chunks written\(dq);
    })
    .catch((err) \f[B]=>\f[R] {
      console.log(\(dqStream error:\(dq, err);
    });
}

\f[B]const\f[R] decoder = \f[B]new\f[R] TextDecoder(\(dqutf\-8\(dq);
\f[B]const\f[R] queuingStrategy = \f[B]new\f[R] CountQueuingStrategy({ highWaterMark: 1 });
\f[B]let\f[R] result = \(dq\(dq;
\f[B]const\f[R] writableStream = \f[B]new\f[R] WritableStream(
  {
    \f[I]// Implement the sink\f[R]
    write(chunk) {
      \f[B]return\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
        \f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(1);
        \f[B]const\f[R] view = \f[B]new\f[R] Uint8Array(buffer);
        view[0] = chunk;
        \f[B]const\f[R] decoded = decoder.decode(view, { stream: \f[B]true\f[R] });
        \f[B]const\f[R] listItem = document.createElement(\(dqli\(dq);
        listItem.textContent = \(gaChunk decoded: ${decoded}\(ga;
        list.appendChild(listItem);
        result += decoded;
        resolve();
      });
    },
    close() {
      \f[B]const\f[R] listItem = document.createElement(\(dqli\(dq);
      listItem.textContent = \(ga[MESSAGE RECEIVED] ${result}\(ga;
      list.appendChild(listItem);
    },
    abort(err) {
      console.log(\(dqSink error:\(dq, err);
    },
  },
  queuingStrategy,
);

sendMessage(\(dqHello, world.\(dq, writableStream);
.EE
.PP
You can find the full code in our \c
.UR https://mdn.github.io/dom-examples/streams/simple-writer/
Simple writer example
.UE \c
\&.
.SS Backpressure
Because of how backpressure is supported in the API, its implementation
in code may be less than obvious.
To see how backpressure is implemented look for three things.
.IP \(bu 2
The \f[CR]highWaterMark\f[R] property, which is set when creating the
counting strategy using \f[CR]new CountQueuingStrategy\f[R], sets the
maximum amount of data that the \f[CR]WritableStream\f[R] instance will
handle in a single \f[CR]write()\f[R] operation.
In this example, it\(cqs the maximum amount of data that can be sent to
\f[CR]defaultWriter.write()\f[R], in the \f[CR]sendMessage\f[R]
function.
.IP \(bu 2
The \f[CR]defaultWriter.ready\f[R] property returns a promise that
resolves when the sink (the first property of the
\f[CR]WritableStream\f[R] constructor) is done writing data.
The data source can either write more data using
\f[CR]defaultWriter.write()\f[R] or call
\f[CR]defaultWriter.close()\f[R], as demonstrated in the example above.
Calling \f[CR]close()\f[R] too early can prevent data from being
written.
This is why the example calls \f[CR]defaultWriter.ready\f[R] twice.
.IP \(bu 2
The \f[CR]Promise\f[R] returned by the sink\(cqs \f[CR]write()\f[R]
method tells the \f[CR]WritableStream\f[R] and its writer when to
resolve \f[CR]defaultWriter.ready\f[R].
