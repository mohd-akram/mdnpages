.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Event.composedPath" "JS" "May 7, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Event.composedPath \- Event: composedPath() method
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]composedPath()\f[B]\f[R] method of the \f[CR]Event\f[R]
interface returns the event\[cq]s path which is an array of the objects
on which listeners will be invoked.
This does not include nodes in shadow trees if the shadow root was
created with its \f[CR]ShadowRoot.mode\f[R] closed.
.SH SYNTAX
.IP
.EX
const composed = Event.composedPath()
.EE
.SS Parameters
None.
.SS Return value
An array of \f[CR]EventTarget\f[R] objects representing the objects on
which an event listener will be invoked.
.SH EXAMPLES
In the following example, which you can try out at \c
.UR https://mdn.github.io/web-components-examples/composed-composed-path/
.UE \c
, we define two trivial custom elements, \f[CR]<open\-shadow>\f[R] and
\f[CR]<closed\-shadow>\f[R], both of which take the contents of their
text attribute and insert them into the element\[cq]s shadow DOM as the
text content of a \f[CR]<p>\f[R] element.
The only difference between the two is that their shadow roots are
attached with their modes set to \f[CR]open\f[R] and \f[CR]closed\f[R]
respectively.
.IP
.EX
customElements.define(
  \[dq]open\-shadow\[dq],
  \f[B]class\f[R] \f[B]extends\f[R] HTMLElement {
    constructor() {
      \f[B]super\f[R]();

      \f[B]const\f[R] pElem = document.createElement(\[dq]p\[dq]);
      pElem.textContent = \f[B]this\f[R].getAttribute(\[dq]text\[dq]);

      \f[B]const\f[R] shadowRoot = \f[B]this\f[R].attachShadow({ mode: \[dq]open\[dq] });
      shadowRoot.appendChild(pElem);
    }
  },
);

customElements.define(
  \[dq]closed\-shadow\[dq],
  \f[B]class\f[R] \f[B]extends\f[R] HTMLElement {
    constructor() {
      \f[B]super\f[R]();

      \f[B]const\f[R] pElem = document.createElement(\[dq]p\[dq]);
      pElem.textContent = \f[B]this\f[R].getAttribute(\[dq]text\[dq]);

      \f[B]const\f[R] shadowRoot = \f[B]this\f[R].attachShadow({ mode: \[dq]closed\[dq] });
      shadowRoot.appendChild(pElem);
    }
  },
);
.EE
.PP
We then insert one of each element into our page:
.IP
.EX
<\f[B]open\-shadow\f[R] text=\[dq]I have an open shadow root\[dq]></\f[B]open\-shadow\f[R]>
<\f[B]closed\-shadow\f[R] text=\[dq]I have a closed shadow root\[dq]></\f[B]closed\-shadow\f[R]>
.EE
.PP
Then include a click event listener on the \f[CR]<html>\f[R] element:
.IP
.EX
document.querySelector(\[dq]html\[dq]).addEventListener(\[dq]click\[dq], (e) \f[B]=>\f[R] {
  console.log(e.composed);
  console.log(e.composedPath());
});
.EE
.PP
When you click on the \f[CR]<open\-shadow>\f[R] element and then the
\f[CR]<closed\-shadow>\f[R] element, you\[cq]ll notice two things.
First, the \f[CR]composed\f[R] property returns \f[CR]true\f[R] because
the \f[CR]click\f[R] event is always able to propagate across shadow
boundaries.
Second, you\[cq]ll notice a difference in the value of
\f[CR]composedPath\f[R] for the two elements.
The \f[CR]<open\-shadow>\f[R] element\[cq]s composed path is this:
.IP
.EX
Array [ p, ShadowRoot, open\-shadow, body, html, HTMLDocument https://mdn.github.io/web\-components\-examples/composed\-composed\-path/, Window ]
.EE
.PP
Whereas the \f[CR]<closed\-shadow>\f[R] element\[cq]s composed path is a
follows:
.IP
.EX
Array [ closed\-shadow, body, html, HTMLDocument https://mdn.github.io/web\-components\-examples/composed\-composed\-path/, Window ]
.EE
.PP
In the second case, the event listeners only propagate as far as the
\f[CR]<closed\-shadow>\f[R] element itself, but not to the nodes inside
the shadow boundary.
