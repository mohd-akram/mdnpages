.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "INTL.DATETIMEFORMAT.FORMATTOPARTS" "3JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.DateTimeFormat.formatToParts \-
Intl.DateTimeFormat.prototype.formatToParts()
.SH SYNOPSIS
The \f[B]\f[CB]formatToParts()\f[B]\f[R] method of
\f[CR]Intl.DateTimeFormat\f[R] instances returns an array of objects
representing each part of the formatted string that would be returned by
\f[CR]format()\f[R].
It is useful for building custom strings from the locale\-specific
tokens.
.IP
.EX
\f[B]const\f[R] date = \f[B]new\f[R] Date(2012, 5);
\f[B]const\f[R] options = {
  weekday: \(dqlong\(dq,
  year: \(dqnumeric\(dq,
  month: \(dqlong\(dq,
  day: \(dqnumeric\(dq,
};
\f[B]const\f[R] dateTimeFormat = \f[B]new\f[R] Intl.DateTimeFormat(\(dqen\-US\(dq, options);

\f[B]const\f[R] parts = dateTimeFormat.formatToParts(date);
\f[B]const\f[R] partValues = parts.map((p) \f[B]=>\f[R] p.value);

console.log(partValues);
\f[I]// Expected output: \(dq[\(dqFriday\(dq, \(dq, \(dq, \(dqJune\(dq, \(dq \(dq, \(dq1\(dq, \(dq, \(dq, \(dq2012\(dq]\(dq\f[R]
.EE
.SH SYNTAX
.IP
.EX
formatToParts(date)
.EE
.SS Parameters
.TP
\f[B]date\f[R] \f[I](optional)\f[R]
The date to format.
Can be a \f[CR]Date\f[R] or \f[CR]Temporal.PlainDateTime\f[R] object.
Additionally can be a \f[CR]Temporal.PlainTime\f[R],
\f[CR]Temporal.PlainDate\f[R], \f[CR]Temporal.PlainYearMonth\f[R], or
\f[CR]Temporal.PlainMonthDay\f[R] object if the
\f[CR]DateTimeFormat\f[R] object was configured to print at least one
relevant part of the date.
.RS
.RS
.PP
\f[B]Note:\f[R] A \f[CR]Temporal.ZonedDateTime\f[R] object will always
throw a \f[CR]TypeError\f[R]; use
\f[CR]Temporal.ZonedDateTime.prototype.toLocaleString()\f[R] or convert
it to a \f[CR]Temporal.PlainDateTime\f[R] object instead.
.RE
.PP
Omitting it results in formatting the current date (as returned by
\f[CR]Date.now()\f[R]), which could be slightly confusing, so it is
advisable to always explicitly pass a date.
.RE
.SS Return value
An \f[CR]Array\f[R] of objects containing the formatted date in parts.
Each object has two properties, \f[CR]type\f[R] and \f[CR]value\f[R],
each containing a string.
The string concatenation of \f[CR]value\f[R], in the order provided,
will result in the same string as \f[CR]format()\f[R].
The \f[CR]type\f[R] may be one of the date\-time components:
.TP
\f[B]weekday\f[R]
For example \f[CR]\(dqM\(dq\f[R], \f[CR]\(dqMonday\(dq\f[R], or
\f[CR]\(dqMontag\(dq\f[R].
.TP
\f[B]era\f[R]
For example \f[CR]\(dqBC\(dq\f[R] or \f[CR]\(dqAD\(dq\f[R].
.TP
\f[B]year\f[R]
For example \f[CR]\(dq2012\(dq\f[R] or \f[CR]\(dq96\(dq\f[R].
.TP
\f[B]month\f[R]
For example \f[CR]\(dq12\(dq\f[R] or \f[CR]\(dqJanuary\(dq\f[R].
.TP
\f[B]day\f[R]
For example \f[CR]\(dq17\(dq\f[R].
.TP
\f[B]dayPeriod\f[R]
For example \f[CR]\(dqAM\(dq\f[R], \f[CR]\(dqPM\(dq\f[R],
\f[CR]\(dqin the morning\(dq\f[R], or \f[CR]\(dqnoon\(dq\f[R].
.TP
\f[B]hour\f[R]
For example \f[CR]\(dq3\(dq\f[R] or \f[CR]\(dq03\(dq\f[R].
.TP
\f[B]minute\f[R]
For example \f[CR]\(dq00\(dq\f[R].
.TP
\f[B]second\f[R]
For example \f[CR]\(dq07\(dq\f[R] or \f[CR]\(dq42\(dq\f[R].
.TP
\f[B]fractionalSecond\f[R]
For example \f[CR]\(dq0\(dq\f[R], \f[CR]\(dq00\(dq\f[R], or
\f[CR]\(dq000\(dq\f[R].
.TP
\f[B]timeZoneName\f[R]
For example \f[CR]\(dqUTC\(dq\f[R], \f[CR]\(dqCET\(dq\f[R], or
\f[CR]\(dqCentral European Time\(dq\f[R].
.PP
The \f[CR]type\f[R] may also be one of the following:
.TP
\f[B]literal\f[R]
Any string that\(cqs a part of the format pattern and not influenced by
the \f[CR]date\f[R]; for example \f[CR]\(dq/\(dq\f[R],
\f[CR]\(dq, \(dq\f[R], \f[CR]\(dqo\(aqclock\(dq\f[R],
\f[CR]\(dqde\(dq\f[R], \f[CR]\(dq \(dq\f[R], etc.
.TP
\f[B]relatedYear\f[R]
A 4\-digit Gregorian year, in the event that the calendar\(cqs
representation would be a \f[CR]yearName\f[R] instead of a year; for
example \f[CR]\(dq2019\(dq\f[R].
See named years for more details.
.TP
\f[B]yearName\f[R]
The name given to the year, usually in calendars without the concept of
continuous years; for example \f[CR]\(dqgeng\-zi\(dq\f[R].
.TP
\f[B]unknown\f[R]
Reserved for any token that\(cqs not recognized as any of the above;
should be rarely encountered.
.SH EXAMPLES
.SS Using formatToParts()
The \f[CR]format()\f[R] method outputs localized, opaque strings that
cannot be manipulated directly:
.IP
.EX
\f[B]const\f[R] date = Date.UTC(2012, 11, 17, 3, 0, 42);

\f[B]const\f[R] formatter = \f[B]new\f[R] Intl.DateTimeFormat(\(dqen\-us\(dq, {
  weekday: \(dqlong\(dq,
  year: \(dqnumeric\(dq,
  month: \(dqnumeric\(dq,
  day: \(dqnumeric\(dq,
  hour: \(dqnumeric\(dq,
  minute: \(dqnumeric\(dq,
  second: \(dqnumeric\(dq,
  fractionalSecondDigits: 3,
  hour12: \f[B]true\f[R],
  timeZone: \(dqUTC\(dq,
});

formatter.format(date);
\f[I]// \(dqMonday, 12/17/2012, 3:00:42.000 AM\(dq\f[R]
.EE
.PP
However, in many user interfaces you may want to customize the
formatting of this string, or interleave it with other texts.
The \f[CR]formatToParts()\f[R] method produces the same information in
parts:
.IP
.EX
formatter.formatToParts(date);

\f[I]// return value:\f[R]
[
  { type: \(dqweekday\(dq, value: \(dqMonday\(dq },
  { type: \(dqliteral\(dq, value: \(dq, \(dq },
  { type: \(dqmonth\(dq, value: \(dq12\(dq },
  { type: \(dqliteral\(dq, value: \(dq/\(dq },
  { type: \(dqday\(dq, value: \(dq17\(dq },
  { type: \(dqliteral\(dq, value: \(dq/\(dq },
  { type: \(dqyear\(dq, value: \(dq2012\(dq },
  { type: \(dqliteral\(dq, value: \(dq, \(dq },
  { type: \(dqhour\(dq, value: \(dq3\(dq },
  { type: \(dqliteral\(dq, value: \(dq:\(dq },
  { type: \(dqminute\(dq, value: \(dq00\(dq },
  { type: \(dqliteral\(dq, value: \(dq:\(dq },
  { type: \(dqsecond\(dq, value: \(dq42\(dq },
  { type: \(dqfractionalSecond\(dq, value: \(dq000\(dq },
  { type: \(dqliteral\(dq, value: \(dq \(dq },
  { type: \(dqdayPeriod\(dq, value: \(dqAM\(dq },
];
.EE
.PP
Now the information is available separately and it can be formatted and
concatenated again in a customized way.
For example by using \f[CR]Array.prototype.map()\f[R], arrow functions,
a switch statement, template literals, and
\f[CR]Array.prototype.join()\f[R], to insert additional markup for
certain components.
.IP
.EX
\f[B]const\f[R] dateString = formatter
  .formatToParts(date)
  .map(({ type, value }) \f[B]=>\f[R] {
    \f[B]switch\f[R] (type) {
      \f[B]case\f[R] \(dqdayPeriod\(dq:
        \f[B]return\f[R] \(ga<em>${value}</em>\(ga;
      \f[B]default\f[R]:
        \f[B]return\f[R] value;
    }
  })
  .join(\(dq\(dq);

console.log(dateString);
\f[I]// \(dqMonday, 12/17/2012, 3:00:42.000 <em>AM</em>\(dq\f[R]
.EE
.SS Named years
Some calendars use named years; for example, the Chinese and Tibetan
calendars use a 60\-year \c
.UR https://en.wikipedia.org/wiki/Sexagenary_cycle
sexagenary cycle
.UE \c
\ of named years.
These calendars do not have a universal way to unambiguously number each
year, so years are disambiguated by relationship to corresponding years
on the Gregorian calendar.
In this case, when the \f[CR]DateTimeFormat\f[R] is configured to output
the year component, a token for \f[CR]relatedYear\f[R] is output instead
of \f[CR]year\f[R].
.IP
.EX
\f[B]const\f[R] df = \f[B]new\f[R] Intl.DateTimeFormat(\(dqzh\-u\-ca\-chinese\(dq);
df.formatToParts(Date.UTC(2012, 11, 17, 3, 0, 42));

\f[I]// return value:\f[R]
[
  { type: \(dqrelatedYear\(dq, value: \(dq2012\(dq },
  { type: \(dqliteral\(dq, value: \(dq年\(dq },
  { type: \(dqmonth\(dq, value: \(dq十一月\(dq },
  { type: \(dqday\(dq, value: \(dq4\(dq },
];
.EE
.PP
Sometimes, the combination of date\-time component options maps to a
format that also includes a \f[CR]yearName\f[R].
There isn\(cqt a separate option that controls whether
\f[CR]yearName\f[R] is displayed or not.
For example, the options below sets \f[CR]month\f[R] to
\f[CR]\(dqlong\(dq\f[R] and results in a \f[CR]yearName\f[R] token,
despite \f[CR]year\f[R] still being \f[CR]\(dqnumeric\(dq\f[R]:
.IP
.EX
\f[B]const\f[R] opts = { year: \(dqnumeric\(dq, month: \(dqlong\(dq, day: \(dqnumeric\(dq };
\f[B]const\f[R] df = \f[B]new\f[R] Intl.DateTimeFormat(\(dqzh\-u\-ca\-chinese\(dq, opts);
df.formatToParts(Date.UTC(2012, 11, 17, 3, 0, 42));

\f[I]// return value:\f[R]
[
  { type: \(dqrelatedYear\(dq, value: \(dq2012\(dq },
  { type: \(dqyearName\(dq, value: \(dq壬辰\(dq },
  { type: \(dqliteral\(dq, value: \(dq年\(dq },
  { type: \(dqmonth\(dq, value: \(dq十一月\(dq },
  { type: \(dqday\(dq, value: \(dq4\(dq },
];
.EE
.PP
Because \f[CR]format()\f[R] just concatenates all the \f[CR]value\f[R]
strings together, you will see the Gregorian year and the year name
together in the output in this case.
.SH SEE ALSO
.IP \(bu 2
\f[CR]Intl.DateTimeFormat\f[R]
.IP \(bu 2
\f[CR]Intl.DateTimeFormat.prototype.format()\f[R]
