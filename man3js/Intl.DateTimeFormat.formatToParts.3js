.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Intl.DateTimeFormat.formatToParts" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.DateTimeFormat.formatToParts \-
Intl.DateTimeFormat.prototype.formatToParts()
.SH SYNOPSIS
The \f[B]\f[CB]formatToParts()\f[B]\f[R] method of
\f[CR]Intl.DateTimeFormat\f[R] instances returns an array of objects
representing each part of the formatted string that would be returned by
\f[CR]format()\f[R].
It is useful for building custom strings from the locale\-specific
tokens.
.IP
.EX
\f[B]const\f[R] date = \f[B]new\f[R] Date(2012, 5);
\f[B]const\f[R] options = {
  weekday: \[dq]long\[dq],
  year: \[dq]numeric\[dq],
  month: \[dq]long\[dq],
  day: \[dq]numeric\[dq],
};
\f[B]const\f[R] dateTimeFormat = \f[B]new\f[R] Intl.DateTimeFormat(\[dq]en\-US\[dq], options);

\f[B]const\f[R] parts = dateTimeFormat.formatToParts(date);
\f[B]const\f[R] partValues = parts.map((p) \f[B]=>\f[R] p.value);

console.log(partValues);
\f[I]// Expected output: \[dq][\[dq]Friday\[dq], \[dq], \[dq], \[dq]June\[dq], \[dq] \[dq], \[dq]1\[dq], \[dq], \[dq], \[dq]2012\[dq]]\[dq]\f[R]
.EE
.SH SYNTAX
.IP
.EX
formatToParts(date)
.EE
.SS Parameters
.TP
\f[B]date\f[R] \f[I](optional)\f[R]
The date to format.
Can be a \f[CR]Date\f[R] or \f[CR]Temporal.PlainDateTime\f[R] object.
Additionally can be a \f[CR]Temporal.PlainTime\f[R],
\f[CR]Temporal.PlainDate\f[R], \f[CR]Temporal.PlainYearMonth\f[R], or
\f[CR]Temporal.PlainMonthDay\f[R] object if the
\f[CR]DateTimeFormat\f[R] object was configured to print at least one
relevant part of the date.
.RS
.RS
.PP
\f[B]Note:\f[R] A \f[CR]Temporal.ZonedDateTime\f[R] object will always
throw a \f[CR]TypeError\f[R]; use
\f[CR]Temporal.ZonedDateTime.prototype.toLocaleString()\f[R] or convert
it to a \f[CR]Temporal.PlainDateTime\f[R] object instead.
.RE
.PP
Omitting it results in formatting the current date (as returned by
\f[CR]Date.now()\f[R]), which could be slightly confusing, so it is
advisable to always explicitly pass a date.
.RE
.SS Return value
An \f[CR]Array\f[R] of objects containing the formatted date in parts.
Each object has two properties, \f[CR]type\f[R] and \f[CR]value\f[R],
each containing a string.
The string concatenation of \f[CR]value\f[R], in the order provided,
will result in the same string as \f[CR]format()\f[R].
The \f[CR]type\f[R] may be one of the date\-time components:
.TP
\f[B]weekday\f[R]
For example \f[CR]\[dq]M\[dq]\f[R], \f[CR]\[dq]Monday\[dq]\f[R], or
\f[CR]\[dq]Montag\[dq]\f[R].
.TP
\f[B]era\f[R]
For example \f[CR]\[dq]BC\[dq]\f[R] or \f[CR]\[dq]AD\[dq]\f[R].
.TP
\f[B]year\f[R]
For example \f[CR]\[dq]2012\[dq]\f[R] or \f[CR]\[dq]96\[dq]\f[R].
.TP
\f[B]month\f[R]
For example \f[CR]\[dq]12\[dq]\f[R] or \f[CR]\[dq]January\[dq]\f[R].
.TP
\f[B]day\f[R]
For example \f[CR]\[dq]17\[dq]\f[R].
.TP
\f[B]dayPeriod\f[R]
For example \f[CR]\[dq]AM\[dq]\f[R], \f[CR]\[dq]PM\[dq]\f[R],
\f[CR]\[dq]in the morning\[dq]\f[R], or \f[CR]\[dq]noon\[dq]\f[R].
.TP
\f[B]hour\f[R]
For example \f[CR]\[dq]3\[dq]\f[R] or \f[CR]\[dq]03\[dq]\f[R].
.TP
\f[B]minute\f[R]
For example \f[CR]\[dq]00\[dq]\f[R].
.TP
\f[B]second\f[R]
For example \f[CR]\[dq]07\[dq]\f[R] or \f[CR]\[dq]42\[dq]\f[R].
.TP
\f[B]fractionalSecond\f[R]
For example \f[CR]\[dq]0\[dq]\f[R], \f[CR]\[dq]00\[dq]\f[R], or
\f[CR]\[dq]000\[dq]\f[R].
.TP
\f[B]timeZoneName\f[R]
For example \f[CR]\[dq]UTC\[dq]\f[R], \f[CR]\[dq]CET\[dq]\f[R], or
\f[CR]\[dq]Central European Time\[dq]\f[R].
.PP
The \f[CR]type\f[R] may also be one of the following:
.TP
\f[B]literal\f[R]
Any string that\[cq]s a part of the format pattern and not influenced by
the \f[CR]date\f[R]; for example \f[CR]\[dq]/\[dq]\f[R],
\f[CR]\[dq], \[dq]\f[R], \f[CR]\[dq]o\[aq]clock\[dq]\f[R],
\f[CR]\[dq]de\[dq]\f[R], \f[CR]\[dq] \[dq]\f[R], etc.
.TP
\f[B]relatedYear\f[R]
A 4\-digit Gregorian year, in the event that the calendar\[cq]s
representation would be a \f[CR]yearName\f[R] instead of a year; for
example \f[CR]\[dq]2019\[dq]\f[R].
See named years for more details.
.TP
\f[B]yearName\f[R]
The name given to the year, usually in calendars without the concept of
continuous years; for example \f[CR]\[dq]geng\-zi\[dq]\f[R].
.TP
\f[B]unknown\f[R]
Reserved for any token that\[cq]s not recognized as any of the above;
should be rarely encountered.
.SH EXAMPLES
.SS Using formatToParts()
The \f[CR]format()\f[R] method outputs localized, opaque strings that
cannot be manipulated directly:
.IP
.EX
\f[B]const\f[R] date = Date.UTC(2012, 11, 17, 3, 0, 42);

\f[B]const\f[R] formatter = \f[B]new\f[R] Intl.DateTimeFormat(\[dq]en\-us\[dq], {
  weekday: \[dq]long\[dq],
  year: \[dq]numeric\[dq],
  month: \[dq]numeric\[dq],
  day: \[dq]numeric\[dq],
  hour: \[dq]numeric\[dq],
  minute: \[dq]numeric\[dq],
  second: \[dq]numeric\[dq],
  fractionalSecondDigits: 3,
  hour12: \f[B]true\f[R],
  timeZone: \[dq]UTC\[dq],
});

formatter.format(date);
\f[I]// \[dq]Monday, 12/17/2012, 3:00:42.000 AM\[dq]\f[R]
.EE
.PP
However, in many user interfaces you may want to customize the
formatting of this string, or interleave it with other texts.
The \f[CR]formatToParts()\f[R] method produces the same information in
parts:
.IP
.EX
formatter.formatToParts(date);

\f[I]// return value:\f[R]
[
  { type: \[dq]weekday\[dq], value: \[dq]Monday\[dq] },
  { type: \[dq]literal\[dq], value: \[dq], \[dq] },
  { type: \[dq]month\[dq], value: \[dq]12\[dq] },
  { type: \[dq]literal\[dq], value: \[dq]/\[dq] },
  { type: \[dq]day\[dq], value: \[dq]17\[dq] },
  { type: \[dq]literal\[dq], value: \[dq]/\[dq] },
  { type: \[dq]year\[dq], value: \[dq]2012\[dq] },
  { type: \[dq]literal\[dq], value: \[dq], \[dq] },
  { type: \[dq]hour\[dq], value: \[dq]3\[dq] },
  { type: \[dq]literal\[dq], value: \[dq]:\[dq] },
  { type: \[dq]minute\[dq], value: \[dq]00\[dq] },
  { type: \[dq]literal\[dq], value: \[dq]:\[dq] },
  { type: \[dq]second\[dq], value: \[dq]42\[dq] },
  { type: \[dq]fractionalSecond\[dq], value: \[dq]000\[dq] },
  { type: \[dq]literal\[dq], value: \[dq] \[dq] },
  { type: \[dq]dayPeriod\[dq], value: \[dq]AM\[dq] },
];
.EE
.PP
Now the information is available separately and it can be formatted and
concatenated again in a customized way.
For example by using \f[CR]Array.prototype.map()\f[R], arrow functions,
a switch statement, template literals, and
\f[CR]Array.prototype.join()\f[R], to insert additional markup for
certain components.
.IP
.EX
\f[B]const\f[R] dateString = formatter
  .formatToParts(date)
  .map(({ type, value }) \f[B]=>\f[R] {
    \f[B]switch\f[R] (type) {
      \f[B]case\f[R] \[dq]dayPeriod\[dq]:
        \f[B]return\f[R] \[ga]<em>${value}</em>\[ga];
      \f[B]default\f[R]:
        \f[B]return\f[R] value;
    }
  })
  .join(\[dq]\[dq]);

console.log(dateString);
\f[I]// \[dq]Monday, 12/17/2012, 3:00:42.000 <em>AM</em>\[dq]\f[R]
.EE
.SS Named years
Some calendars use named years; for example, the Chinese and Tibetan
calendars use a 60\-year \c
.UR https://en.wikipedia.org/wiki/Sexagenary_cycle
sexagenary cycle
.UE \c
\ of named years.
These calendars do not have a universal way to unambiguously number each
year, so years are disambiguated by relationship to corresponding years
on the Gregorian calendar.
In this case, when the \f[CR]DateTimeFormat\f[R] is configured to output
the year component, a token for \f[CR]relatedYear\f[R] is output instead
of \f[CR]year\f[R].
.IP
.EX
\f[B]const\f[R] df = \f[B]new\f[R] Intl.DateTimeFormat(\[dq]zh\-u\-ca\-chinese\[dq]);
df.formatToParts(Date.UTC(2012, 11, 17, 3, 0, 42));

\f[I]// return value:\f[R]
[
  { type: \[dq]relatedYear\[dq], value: \[dq]2012\[dq] },
  { type: \[dq]literal\[dq], value: \[dq]年\[dq] },
  { type: \[dq]month\[dq], value: \[dq]十一月\[dq] },
  { type: \[dq]day\[dq], value: \[dq]4\[dq] },
];
.EE
.PP
Sometimes, the combination of date\-time component options maps to a
format that also includes a \f[CR]yearName\f[R].
There isn\[cq]t a separate option that controls whether
\f[CR]yearName\f[R] is displayed or not.
For example, the options below sets \f[CR]month\f[R] to
\f[CR]\[dq]long\[dq]\f[R] and results in a \f[CR]yearName\f[R] token,
despite \f[CR]year\f[R] still being \f[CR]\[dq]numeric\[dq]\f[R]:
.IP
.EX
\f[B]const\f[R] opts = { year: \[dq]numeric\[dq], month: \[dq]long\[dq], day: \[dq]numeric\[dq] };
\f[B]const\f[R] df = \f[B]new\f[R] Intl.DateTimeFormat(\[dq]zh\-u\-ca\-chinese\[dq], opts);
df.formatToParts(Date.UTC(2012, 11, 17, 3, 0, 42));

\f[I]// return value:\f[R]
[
  { type: \[dq]relatedYear\[dq], value: \[dq]2012\[dq] },
  { type: \[dq]yearName\[dq], value: \[dq]壬辰\[dq] },
  { type: \[dq]literal\[dq], value: \[dq]年\[dq] },
  { type: \[dq]month\[dq], value: \[dq]十一月\[dq] },
  { type: \[dq]day\[dq], value: \[dq]4\[dq] },
];
.EE
.PP
Because \f[CR]format()\f[R] just concatenates all the \f[CR]value\f[R]
strings together, you will see the Gregorian year and the year name
together in the output in this case.
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Intl.DateTimeFormat\f[R]
.IP \[bu] 2
\f[CR]Intl.DateTimeFormat.prototype.format()\f[R]
