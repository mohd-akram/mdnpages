.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPUDEVICE.CREATERENDERBUNDLEENCODER" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPUDevice.createRenderBundleEncoder \- GPUDevice:
createRenderBundleEncoder() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]createRenderBundleEncoder()\f[B]\f[R] method of the
\f[CR]GPUDevice\f[R] interface creates a
\f[CR]GPURenderBundleEncoder\f[R] that can be used to pre\-record
bundles of commands.
These can be reused in \f[CR]GPURenderPassEncoder\f[R]s via the
\f[CR]executeBundles()\f[R] method, as many times as required.
.SH SYNTAX
.IP
.EX
createRenderBundleEncoder(descriptor)
.EE
.SS Parameters
.TP
\f[B]descriptor\f[R]
An object containing the following properties:
.RS
.TP
\f[B]colorFormats\f[R]
An array of enumerated values specifying the expected color formats for
render targets.
For possible values, see the \c
.UR https://gpuweb.github.io/gpuweb/#depth-or-stencil-format
\f[CR]GPUTextureFormat\f[R] definition
.UE \c
\ in the spec.
.TP
\f[B]depthReadOnly\f[R] \f[I](optional)\f[R]
A boolean.
If \f[CR]true\f[R], specifies that executing any
\f[CR]GPURenderBundle\f[R] created by the
\f[CR]GPURenderBundleEncoder\f[R] will not modify the depth component of
the \f[CR]depthStencilFormat\f[R] when executed.
If omitted, \f[CR]depthReadOnly\f[R] will default to \f[CR]false\f[R].
.TP
\f[B]depthStencilFormat\f[R] \f[I](optional)\f[R]
An enumerated value that specifies the expected depth\-or\-stencil
format for render targets.
For possible values, see the \c
.UR https://gpuweb.github.io/gpuweb/#depth-or-stencil-format
Depth\-stencil formats
.UE \c
\ section of the spec.
.TP
\f[B]label\f[R] \f[I](optional)\f[R]
A string providing a label that can be used to identify the object, for
example in \f[CR]GPUError\f[R] messages or console warnings.
.TP
\f[B]sampleCount\f[R] \f[I](optional)\f[R]
A number representing the expected sample count for render targets.
.TP
\f[B]stencilReadOnly\f[R] \f[I](optional)\f[R]
A boolean.
If \f[CR]true\f[R], specifies that executing any
\f[CR]GPURenderBundle\f[R] created by the
\f[CR]GPURenderBundleEncoder\f[R] will not modify the stencil component
of the \f[CR]depthStencilFormat\f[R] when executed.
If omitted, \f[CR]stencilReadOnly\f[R] will default to \f[CR]false\f[R].
.RE
.SS Return value
A \f[CR]GPURenderBundleEncoder\f[R] object instance.
.SH EXAMPLES
In the WebGPU Samples \c
.UR https://webgpu.github.io/webgpu-samples/samples/animometer/
Animometer example
.UE \c
, numerous similar operations are done on many different objects
simultaneously.
A bundle of commands is encoded using the following function:
.IP
.EX
\f[B]function\f[R] recordRenderPass(
  passEncoder: GPURenderBundleEncoder | GPURenderPassEncoder
) {
  \f[B]if\f[R] (settings.dynamicOffsets) {
    passEncoder.setPipeline(dynamicPipeline);
  } \f[B]else\f[R] {
    passEncoder.setPipeline(pipeline);
  }
  passEncoder.setVertexBuffer(0, vertexBuffer);
  passEncoder.setBindGroup(0, timeBindGroup);
  \f[B]const\f[R] dynamicOffsets = [0];
  \f[B]for\f[R] (\f[B]let\f[R] i = 0; i < numTriangles; ++i) {
    \f[B]if\f[R] (settings.dynamicOffsets) {
      dynamicOffsets[0] = i * alignedUniformBytes;
      passEncoder.setBindGroup(1, dynamicBindGroup, dynamicOffsets);
    } \f[B]else\f[R] {
      passEncoder.setBindGroup(1, bindGroups[i]);
    }
    passEncoder.draw(3, 1, 0, 0);
  }
}
.EE
.PP
Later on, a \f[CR]GPURenderBundleEncoder\f[R] is created using
\f[CR]createRenderBundleEncoder()\f[R], the function is invoked, and the
command bundle is recorded into a \f[CR]GPURenderBundle\f[R] using
\f[CR]GPURenderBundleEncoder.finish()\f[R]:
.IP
.EX
\f[B]const\f[R] renderBundleEncoder = device.createRenderBundleEncoder({
  colorFormats: [presentationFormat],
});
recordRenderPass(renderBundleEncoder);
\f[B]const\f[R] renderBundle = renderBundleEncoder.finish();
.EE
.PP
\f[CR]GPURenderPassEncoder.executeBundles()\f[R] is then used to reuse
the work across multiple render passes to improve performance.
Study the example code listing for the full context.
.IP
.EX
\f[I]// \&...\f[R]

\f[B]return\f[R] \f[B]function\f[R] doDraw(timestamp) {
  \f[B]if\f[R] (startTime === \f[B]undefined\f[R]) {
    startTime = timestamp;
  }
  uniformTime[0] = (timestamp \- startTime) / 1000;
  device.queue.writeBuffer(uniformBuffer, timeOffset, uniformTime.buffer);

  renderPassDescriptor.colorAttachments[0].view = context
    .getCurrentTexture()
    .createView();

  \f[B]const\f[R] commandEncoder = device.createCommandEncoder();
  \f[B]const\f[R] passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);

  \f[B]if\f[R] (settings.renderBundles) {
    passEncoder.executeBundles([renderBundle]);
  } \f[B]else\f[R] {
    recordRenderPass(passEncoder);
  }

  passEncoder.end();
  device.queue.submit([commandEncoder.finish()]);
};

\f[I]// \&...\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
