.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Error" "JS" "February 24, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Error \- Error
.SH SYNOPSIS
\f[B]\f[CB]Error\f[B]\f[R] objects are thrown when runtime errors occur.
The \f[CR]Error\f[R] object can also be used as a base object for
user\-defined exceptions.
See below for standard built\-in error types.
.SH DESCRIPTION
Runtime errors result in new \f[CR]Error\f[R] objects being created and
thrown.
.PP
\f[CR]Error\f[R] is a serializable object, so it can be cloned with
\f[CR]structuredClone()\f[R] or copied between Workers using
\f[CR]postMessage()\f[R].
.SS Error types
Besides the generic \f[CR]Error\f[R] constructor, there are other core
error constructors in JavaScript.
For client\-side exceptions, see Exception handling statements.
.TP
\f[B]EvalError\f[R]
Creates an instance representing an error that occurs regarding the
global function \f[CR]eval()\f[R].
.TP
\f[B]RangeError\f[R]
Creates an instance representing an error that occurs when a numeric
variable or parameter is outside its valid range.
.TP
\f[B]ReferenceError\f[R]
Creates an instance representing an error that occurs when
de\-referencing an invalid reference.
.TP
\f[B]SyntaxError\f[R]
Creates an instance representing a syntax error.
.TP
\f[B]TypeError\f[R]
Creates an instance representing an error that occurs when a variable or
parameter is not of a valid type.
.TP
\f[B]URIError\f[R]
Creates an instance representing an error that occurs when
\f[CR]encodeURI()\f[R] or \f[CR]decodeURI()\f[R] are passed invalid
parameters.
.TP
\f[B]AggregateError\f[R]
Creates an instance representing several errors wrapped in a single
error when multiple errors need to be reported by an operation, for
example by \f[CR]Promise.any()\f[R].
.TP
\f[B]InternalError\f[R] \f[I](non\-standard)\f[R]
Creates an instance representing an error that occurs when an internal
error in the JavaScript engine is thrown.
E.g.
\[lq]too much recursion\[rq].
.SH CONSTRUCTOR
.TP
\f[B]Error()\f[R]
Creates a new \f[CR]Error\f[R] object.
.SH STATIC PROPERTIES
.TP
\f[B]Error.stackTraceLimit\f[R] \f[I](non\-standard)\f[R]
A non\-standard numerical property that limits how many stack frames to
include in an error stack trace.
.SH STATIC METHODS
.TP
\f[B]Error.captureStackTrace()\f[R] \f[I](non\-standard)\f[R]
A non\-standard function that creates the \f[CR]stack\f[R] property on
the provided object.
.TP
\f[B]Error.isError()\f[R]
Returns \f[CR]true\f[R] if the argument is an error, or \f[CR]false\f[R]
otherwise.
.TP
\f[B]Error.prepareStackTrace()\f[R] \f[I](non\-standard)\f[R] \f[I](optional)\f[R]
A non\-standard function that, if provided by user code, is called by
the JavaScript engine for thrown exceptions, allowing the user to
provide custom formatting for stack traces.
See the \c
.UR https://v8.dev/docs/stack-trace-api#customizing-stack-traces
V8 Stack Trace API
.UE \c
\ docs.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]Error.prototype\f[R] and shared by
all \f[CR]Error\f[R] instances.
.TP
\f[B]Error.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]Error\f[R] instances, the initial value is the
\f[CR]Error\f[R] constructor.
.TP
\f[B]Error.prototype.name\f[R]
Represents the name for the type of error.
For \f[CR]Error.prototype.name\f[R], the initial value is
\f[CR]\[dq]Error\[dq]\f[R].
Subclasses like \f[CR]TypeError\f[R] and \f[CR]SyntaxError\f[R] provide
their own \f[CR]name\f[R] properties.
.TP
\f[B]Error.prototype.stack\f[R] \f[I](non\-standard)\f[R]
A non\-standard property for a stack trace.
.PP
These properties are own properties of each \f[CR]Error\f[R] instance.
.TP
\f[B]cause\f[R]
Error cause indicating the reason why the current error is thrown \[em]
usually another caught error.
For user\-created \f[CR]Error\f[R] objects, this is the value provided
as the \f[CR]cause\f[R] property of the constructor\[cq]s second
argument.
.TP
\f[B]columnNumber\f[R] \f[I](non\-standard)\f[R]
A non\-standard Mozilla property for the column number in the line that
raised this error.
.TP
\f[B]fileName\f[R] \f[I](non\-standard)\f[R]
A non\-standard Mozilla property for the path to the file that raised
this error.
.TP
\f[B]lineNumber\f[R] \f[I](non\-standard)\f[R]
A non\-standard Mozilla property for the line number in the file that
raised this error.
.TP
\f[B]message\f[R]
Error message.
For user\-created \f[CR]Error\f[R] objects, this is the string provided
as the constructor\[cq]s first argument.
.SH INSTANCE METHODS
.TP
\f[B]Error.prototype.toString()\f[R]
Returns a string representing the specified object.
Overrides the \f[CR]Object.prototype.toString()\f[R] method.
.SH EXAMPLES
.SS Throwing a generic error
Usually you create an \f[CR]Error\f[R] object with the intention of
raising it using the \f[CR]throw\f[R] keyword.
You can handle the error using the \f[CR]try...catch\f[R] construct:
.IP
.EX
\f[B]try\f[R] {
  \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]Whoops!\[dq]);
} \f[B]catch\f[R] (e) {
  console.error(\[ga]${e.name}: ${e.message}\[ga]);
}
.EE
.SS Handling a specific error type
You can choose to handle only specific error types by testing the error
type with the \f[CR]instanceof\f[R] keyword:
.IP
.EX
\f[B]try\f[R] {
  foo.bar();
} \f[B]catch\f[R] (e) {
  \f[B]if\f[R] (e \f[B]instanceof\f[R] EvalError) {
    console.error(\[ga]${e.name}: ${e.message}\[ga]);
  } \f[B]else\f[R] \f[B]if\f[R] (e \f[B]instanceof\f[R] RangeError) {
    console.error(\[ga]${e.name}: ${e.message}\[ga]);
  }
  \f[I]// etc.\f[R]
  \f[B]else\f[R] {
    \f[I]// If none of our cases matched leave the Error unhandled\f[R]
    \f[B]throw\f[R] e;
  }
}
.EE
.SS Differentiate between similar errors
Sometimes a block of code can fail for reasons that require different
handling, but which throw very similar errors (i.e.\ with the same type
and message).
.PP
If you don\[cq]t have control over the original errors that are thrown,
one option is to catch them and throw new \f[CR]Error\f[R] objects that
have more specific messages.
The original error should be passed to the new \f[CR]Error\f[R] in the
constructor\[cq]s \f[CR]options\f[R] parameter as its \f[CR]cause\f[R]
property.
This ensures that the original error and stack trace are available to
higher\-level try/catch blocks.
.PP
The example below shows this for two methods that would otherwise fail
with similar errors (\f[CR]doFailSomeWay()\f[R] and
\f[CR]doFailAnotherWay()\f[R]):
.IP
.EX
\f[B]function\f[R] doWork() {
  \f[B]try\f[R] {
    doFailSomeWay();
  } \f[B]catch\f[R] (err) {
    \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]Failed in some way\[dq], { cause: err });
  }
  \f[B]try\f[R] {
    doFailAnotherWay();
  } \f[B]catch\f[R] (err) {
    \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]Failed in another way\[dq], { cause: err });
  }
}

\f[B]try\f[R] {
  doWork();
} \f[B]catch\f[R] (err) {
  \f[B]switch\f[R] (err.message) {
    \f[B]case\f[R] \[dq]Failed in some way\[dq]:
      handleFailSomeWay(err.cause);
      \f[B]break\f[R];
    \f[B]case\f[R] \[dq]Failed in another way\[dq]:
      handleFailAnotherWay(err.cause);
      \f[B]break\f[R];
  }
}
.EE
.RS
.PP
\f[B]Note:\f[R] If you are making a library, you should prefer to use
error cause to discriminate between different errors emitted \[em]
rather than asking your consumers to parse the error message.
See the error cause page for an example.
.RE
.PP
Custom error types can also use the \f[CR]cause\f[R] property, provided
the subclasses\[cq] constructor passes the \f[CR]options\f[R] parameter
when calling \f[CR]super()\f[R].
The \f[CR]Error()\f[R] base class constructor will read
\f[CR]options.cause\f[R] and define the \f[CR]cause\f[R] property on the
new error instance.
.IP
.EX
\f[B]class\f[R] MyError \f[B]extends\f[R] Error {
  constructor(message, options) {
    \f[I]// Need to pass \[ga]options\[ga] as the second parameter to install the \[dq]cause\[dq] property.\f[R]
    \f[B]super\f[R](message, options);
  }
}

console.log(\f[B]new\f[R] MyError(\[dq]test\[dq], { cause: \f[B]new\f[R] Error(\[dq]cause\[dq]) }).cause);
\f[I]// Error: cause\f[R]
.EE
.SS Custom error types
You might want to define your own error types deriving from
\f[CR]Error\f[R] to be able to \f[CR]throw new MyError()\f[R] and use
\f[CR]instanceof MyError\f[R] to check the kind of error in the
exception handler.
This results in cleaner and more consistent error handling code.
.PP
See \c
.UR https://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript
\[lq]What\[cq]s a good way to extend Error in JavaScript?\[rq]
.UE \c
\ on Stack Overflow for an in\-depth discussion.
.RS
.PP
\f[B]Warning:\f[R] Builtin subclassing cannot be reliably transpiled to
pre\-ES6 code, because there\[cq]s no way to construct the base class
with a particular \f[CR]new.target\f[R] without
\f[CR]Reflect.construct()\f[R].
You need \c
.UR https://github.com/loganfsmyth/babel-plugin-transform-builtin-extend
additional configuration
.UE \c
\ or manually call
\f[CR]Object.setPrototypeOf(this, CustomError.prototype)\f[R] at the end
of the constructor; otherwise, the constructed instance will not be a
\f[CR]CustomError\f[R] instance.
See \c
.UR https://github.com/microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work
the TypeScript FAQ
.UE \c
\ for more information.
.RE
.RS
.PP
\f[B]Note:\f[R] Some browsers include the \f[CR]CustomError\f[R]
constructor in the stack trace when using ES2015 classes.
.RE
.IP
.EX
\f[B]class\f[R] CustomError \f[B]extends\f[R] Error {
  constructor(foo = \[dq]bar\[dq], ...params) {
    \f[I]// Pass remaining arguments (including vendor specific ones) to parent constructor\f[R]
    \f[B]super\f[R](...params);

    \f[I]// Maintains proper stack trace for where our error was thrown (non\-standard)\f[R]
    \f[B]if\f[R] (Error.captureStackTrace) {
      Error.captureStackTrace(\f[B]this\f[R], CustomError);
    }

    \f[B]this\f[R].name = \[dq]CustomError\[dq];
    \f[I]// Custom debugging information\f[R]
    \f[B]this\f[R].foo = foo;
    \f[B]this\f[R].date = \f[B]new\f[R] Date();
  }
}

\f[B]try\f[R] {
  \f[B]throw\f[R] \f[B]new\f[R] CustomError(\[dq]baz\[dq], \[dq]bazMessage\[dq]);
} \f[B]catch\f[R] (e) {
  console.error(e.name); \f[I]// CustomError\f[R]
  console.error(e.foo); \f[I]// baz\f[R]
  console.error(e.message); \f[I]// bazMessage\f[R]
  console.error(e.stack); \f[I]// stack trace\f[R]
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-error
Polyfill of \f[CR]Error\f[R] with \f[CR]cause\f[R] support in
\f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]throw\f[R]
.IP \[bu] 2
\f[CR]try...catch\f[R]
.IP \[bu] 2
\c
.UR https://v8.dev/docs/stack-trace-api
Stack trace API
.UE \c
\ in the V8 docs
