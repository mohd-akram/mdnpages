.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ARRAY.FLATMAP" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.flatMap \- Array.prototype.flatMap()
.SH SYNOPSIS
The \f[B]\f[CB]flatMap()\f[B]\f[R] method of \f[CR]Array\f[R] instances
returns a new array formed by applying a given callback function to each
element of the array, and then flattening the result by one level.
It is identical to a \f[CR]map()\f[R] followed by a \f[CR]flat()\f[R] of
depth 1 (\f[CR]arr.map(...args).flat()\f[R]), but slightly more
efficient than calling those two methods separately.
.IP
.EX
\f[B]const\f[R] arr1 = [1, 2, 1];

\f[B]const\f[R] result = arr1.flatMap((num) \f[B]=>\f[R] (num === 2 ? [2, 2] : 1));

console.log(result);
\f[I]// Expected output: Array [1, 2, 2, 1]\f[R]
.EE
.SH SYNTAX
.IP
.EX
flatMap(callbackFn)
flatMap(callbackFn, thisArg)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element in the array.
It should return an array containing new elements of the new array, or a
single non\-array value to be added to the new array.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.TP
\f[B]array\f[R]
The array \f[CR]flatMap()\f[R] was called upon.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
A value to use as \f[CR]this\f[R] when executing \f[CR]callbackFn\f[R].
See iterative methods.
.SS Return value
A new array with each element being the result of the callback function
and flattened by a depth of 1.
.SH DESCRIPTION
The \f[CR]flatMap()\f[R] method is an iterative method.
See \f[CR]Array.prototype.map()\f[R] for a detailed description of the
callback function.
The \f[CR]flatMap()\f[R] method is identical to
\f[CR]map(callbackFn, thisArg)\f[R] followed by \f[CR]flat(1)\f[R] \(em
for each element, it produces an array of new elements, and concatenates
the resulting arrays together to form a new array.
Read the iterative methods section for more information about how these
methods work in general.
.PP
The \f[CR]flatMap()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
However, the value returned from \f[CR]callbackFn\f[R] must be an array
if it is to be flattened.
.SS Alternative
.SS Pre\-allocate and explicitly iterate
.IP
.EX
\f[B]const\f[R] arr = [1, 2, 3, 4];

arr.flatMap((x) \f[B]=>\f[R] [x, x * 2]);
\f[I]// is equivalent to\f[R]
\f[B]const\f[R] n = arr.length;
\f[B]const\f[R] acc = \f[B]new\f[R] Array(n * 2);
\f[B]for\f[R] (\f[B]let\f[R] i = 0; i < n; i++) {
  \f[B]const\f[R] x = arr[i];
  acc[i * 2] = x;
  acc[i * 2 + 1] = x * 2;
}
\f[I]// [1, 2, 2, 4, 3, 6, 4, 8]\f[R]
.EE
.PP
Note that in this particular case the \f[CR]flatMap\f[R] approach is
slower than the for\-loop approach \(em due to the creation of temporary
arrays that must be garbage collected, as well as the return array not
needing to be frequently resized.
However, \f[CR]flatMap\f[R] may still be the correct solution in cases
where its flexibility and readability are desired.
.SH EXAMPLES
.SS map() and flatMap()
.IP
.EX
\f[B]const\f[R] arr1 = [1, 2, 3, 4];

arr1.map((x) \f[B]=>\f[R] [x * 2]);
\f[I]// [[2], [4], [6], [8]]\f[R]

arr1.flatMap((x) \f[B]=>\f[R] [x * 2]);
\f[I]// [2, 4, 6, 8]\f[R]

\f[I]// only one level is flattened\f[R]
arr1.flatMap((x) \f[B]=>\f[R] [[x * 2]]);
\f[I]// [[2], [4], [6], [8]]\f[R]
.EE
.PP
While the above could have been achieved by using map itself, here is an
example that better showcases the use of \f[CR]flatMap()\f[R].
.PP
Let\(cqs generate a list of words from a list of sentences.
.IP
.EX
\f[B]const\f[R] arr1 = [\(dqit\(aqs Sunny in\(dq, \(dq\(dq, \(dqCalifornia\(dq];

arr1.map((x) \f[B]=>\f[R] x.split(\(dq \(dq));
\f[I]// [[\(dqit\(aqs\(dq,\(dqSunny\(dq,\(dqin\(dq],[\(dq\(dq],[\(dqCalifornia\(dq]]\f[R]

arr1.flatMap((x) \f[B]=>\f[R] x.split(\(dq \(dq));
\f[I]// [\(dqit\(aqs\(dq,\(dqSunny\(dq,\(dqin\(dq, \(dq\(dq, \(dqCalifornia\(dq]\f[R]
.EE
.PP
Notice, the output list length can be different from the input list
length.
.SS For adding and removing items during a map()
\f[CR]flatMap\f[R] can be used as a way to add and remove items (modify
the number of items) during a \f[CR]map\f[R].
In other words, it allows you to map \f[I]many items to many items\f[R]
(by handling each input item separately), rather than always
\f[I]one\-to\-one\f[R].
In this sense, it works like the opposite of filter.
Return a 1\-element array to keep the item, a multiple\-element array to
add items, or a 0\-element array to remove the item.
.IP
.EX
\f[I]// Let\(aqs say we want to remove all the negative numbers\f[R]
\f[I]// and split the odd numbers into an even number and a 1\f[R]
\f[B]const\f[R] a = [5, 4, \-3, 20, 17, \-33, \-4, 18];
\f[I]//         |\(rs  \(rs  x   |  | \(rs   x   x   |\f[R]
\f[I]//        [4,1, 4,   20, 16, 1,       18]\f[R]

\f[B]const\f[R] result = a.flatMap((n) \f[B]=>\f[R] {
  \f[B]if\f[R] (n < 0) {
    \f[B]return\f[R] [];
  }
  \f[B]return\f[R] n % 2 === 0 ? [n] : [n \- 1, 1];
});
console.log(result); \f[I]// [4, 1, 4, 20, 16, 1, 18]\f[R]
.EE
.SS Using the third argument of callbackFn
The \f[CR]array\f[R] argument is useful if you want to access another
element in the array, especially when you don\(cqt have an existing
variable that refers to the array.
The following example first uses \f[CR]filter()\f[R] to extract
operational stations and then uses \f[CR]flatMap()\f[R] to create a new
array where each element contains a station and its next station.
On the last station, it returns an empty array to exclude it from the
final array.
.IP
.EX
\f[B]const\f[R] stations = [\(dqNew Haven\(dq, \(dqWest Haven\(dq, \(dqMilford (closed)\(dq, \(dqStratford\(dq];
\f[B]const\f[R] line = stations
  .filter((name) \f[B]=>\f[R] !name.endsWith(\(dq(closed)\(dq))
  .flatMap((name, idx, arr) \f[B]=>\f[R] {
    \f[I]// Without the arr argument, there\(aqs no way to easily access the\f[R]
    \f[I]// intermediate array without saving it to a variable.\f[R]
    \f[B]if\f[R] (idx === arr.length \- 1) \f[B]return\f[R] []; \f[I]// last station has no next station\f[R]
    \f[B]return\f[R] [\(ga${name} \- ${arr[idx + 1]}\(ga];
  });
console.log(line); \f[I]// [\(aqNew Haven \- West Haven\(aq, \(aqWest Haven \- Stratford\(aq]\f[R]
.EE
.PP
The \f[CR]array\f[R] argument is \f[I]not\f[R] the array that is being
built \(em there is no way to access the array being built from the
callback function.
.SS Using flatMap() on sparse arrays
The \f[CR]callbackFn\f[R] won\(cqt be called for empty slots in the
source array because \f[CR]map()\f[R] doesn\(cqt, while
\f[CR]flat()\f[R] ignores empty slots in the returned arrays.
.IP
.EX
console.log([1, 2, , 4, 5].flatMap((x) \f[B]=>\f[R] [x, x * 2])); \f[I]// [1, 2, 2, 4, 4, 8, 5, 10]\f[R]
console.log([1, 2, 3, 4].flatMap((x) \f[B]=>\f[R] [, x * 2])); \f[I]// [2, 4, 6, 8]\f[R]
.EE
.SS Calling flatMap() on non\-array objects
The \f[CR]flatMap()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R] and then accesses each property whose key is a
nonnegative integer less than \f[CR]length\f[R].
If the return value of the callback function is not an array, it is
always directly appended to the result array.
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  0: 1,
  1: 2,
  2: 3,
  3: 4, \f[I]// ignored by flatMap() since length is 3\f[R]
};
console.log(Array.prototype.flatMap.call(arrayLike, (x) \f[B]=>\f[R] [x, x * 2]));
\f[I]// [1, 2, 2, 4, 3, 6]\f[R]

\f[I]// Array\-like objects returned from the callback won\(aqt be flattened\f[R]
console.log(
  Array.prototype.flatMap.call(arrayLike, (x) \f[B]=>\f[R] ({
    length: 1,
    0: x,
  })),
);
\f[I]// [ { \(aq0\(aq: 1, length: 1 }, { \(aq0\(aq: 2, length: 1 }, { \(aq0\(aq: 3, length: 1 } ]\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype.flatMap\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/array.prototype.flatmap
es\-shims polyfill of \f[CR]Array.prototype.flatMap\f[R]
.UE \c
.IP \(bu 2
Indexed collections guide
.IP \(bu 2
\f[CR]Array\f[R]
.IP \(bu 2
\f[CR]Array.prototype.concat()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.flat()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.map()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.reduce()\f[R]
