.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ITERATOR.DROP" "3JS" "March 5, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator.drop \- Iterator.prototype.drop()
.SH SYNOPSIS
The \f[B]\f[CB]drop()\f[B]\f[R] method of \f[CR]Iterator\f[R] instances
returns a new iterator helper object that skips the given number of
elements at the start of this iterator.
.SH SYNTAX
.IP
.EX
drop(limit)
.EE
.SS Parameters
.TP
\f[B]limit\f[R]
The number of elements to drop from the start of the iteration.
.SS Return value
A new iterator helper object.
The first time the returned iterator helper\(cqs \f[CR]next()\f[R]
method is called, the current iterator is immediately advanced by
\f[CR]limit\f[R] elements, and then the next element (the
\f[CR]limit+1\f[R]\-th element) is yielded.
The iterator helper then yields the remaining elements one\-by\-one.
If the current iterator has fewer than \f[CR]limit\f[R] elements, the
new iterator helper will be immediately completed the first time
\f[CR]next()\f[R] is called.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]limit\f[R] becomes \f[CR]NaN\f[R] or negative when
converted to an integer.
.SH EXAMPLES
.SS Using drop()
The following example creates an iterator that yields terms in the
Fibonacci sequence, starting from the 3rd term by dropping the first two
terms:
.IP
.EX
\f[B]function\f[R]* fibonacci() {
  \f[B]let\f[R] current = 1;
  \f[B]let\f[R] next = 1;
  \f[B]while\f[R] (\f[B]true\f[R]) {
    \f[B]yield\f[R] current;
    [current, next] = [next, current + next];
  }
}

\f[B]const\f[R] seq = fibonacci().drop(2);
console.log(seq.next().value); \f[I]// 2\f[R]
console.log(seq.next().value); \f[I]// 3\f[R]
.EE
.PP
This is equivalent to:
.IP
.EX
\f[B]const\f[R] seq = fibonacci();
seq.next();
seq.next();
.EE
.SS Using drop() with a for\&...of loop
\f[CR]drop()\f[R] is most convenient when you are not hand\-rolling the
iterator.
Because iterators are also iterable, you can iterate the returned helper
with a \f[CR]for...of\f[R] loop:
.IP
.EX
\f[B]for\f[R] (\f[B]const\f[R] n \f[B]of\f[R] fibonacci().drop(2)) {
  console.log(n);
  \f[B]if\f[R] (n > 30) {
    \f[B]break\f[R];
  }
}

\f[I]// Logs:\f[R]
\f[I]// 2\f[R]
\f[I]// 3\f[R]
\f[I]// 5\f[R]
\f[I]// 8\f[R]
\f[I]// 13\f[R]
\f[I]// 21\f[R]
\f[I]// 34\f[R]
.EE
.SS Combining drop() with take()
You can combine \f[CR]drop()\f[R] with
\f[CR]Iterator.prototype.take()\f[R] to get a slice of an iterator:
.IP
.EX
\f[B]for\f[R] (\f[B]const\f[R] n \f[B]of\f[R] fibonacci().drop(2).take(5)) {
  \f[I]// Drops the first two elements, then takes the next five\f[R]
  console.log(n);
}
\f[I]// Logs:\f[R]
\f[I]// 2\f[R]
\f[I]// 3\f[R]
\f[I]// 5\f[R]
\f[I]// 8\f[R]
\f[I]// 13\f[R]

\f[B]for\f[R] (\f[B]const\f[R] n \f[B]of\f[R] fibonacci().take(5).drop(2)) {
  \f[I]// Takes the first five elements, then drops the first two\f[R]
  console.log(n);
}
\f[I]// Logs:\f[R]
\f[I]// 2\f[R]
\f[I]// 3\f[R]
\f[I]// 5\f[R]
.EE
.SS Lower and upper bounds of drop count
When the \f[CR]limit\f[R] is negative or \f[CR]NaN\f[R], a
\f[CR]RangeError\f[R] is thrown:
.IP
.EX
fibonacci().drop(\-1); \f[I]// RangeError: \-1 must be positive\f[R]
fibonacci().drop(\f[B]undefined\f[R]); \f[I]// RangeError: undefined must be positive\f[R]
.EE
.PP
When the \f[CR]limit\f[R] is larger than the total number of elements
the iterator can produce (such as \f[CR]Infinity\f[R]), the returned
iterator helper will instantly drop all elements and then be completed
the first time \f[CR]next()\f[R] is called.
If the current iterator is infinite, the returned iterator helper will
never complete.
.IP
.EX
fibonacci().drop(\f[B]Infinity\f[R]).next(); \f[I]// Never ends\f[R]
\f[B]new\f[R] Set([1, 2, 3]).values().drop(\f[B]Infinity\f[R]).next(); \f[I]// { value: undefined, done: true }\f[R]
\f[B]new\f[R] Set([1, 2, 3]).values().drop(4).next(); \f[I]// { value: undefined, done: true }\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#iterator-helpers
Polyfill of \f[CR]Iterator.prototype.drop\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/es-iterator-helpers
es\-shims polyfill of \f[CR]Iterator.prototype.drop\f[R]
.UE \c
.IP \(bu 2
\f[CR]Iterator\f[R]
.IP \(bu 2
\f[CR]Iterator.prototype.take()\f[R]
