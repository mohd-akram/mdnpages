.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "PointerEvent.getCoalescedEvents" "JS" "December 14, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
PointerEvent.getCoalescedEvents \- PointerEvent: getCoalescedEvents()
method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
The \f[B]\f[CB]getCoalescedEvents()\f[B]\f[R] method of the
\f[CR]PointerEvent\f[R] interface returns a sequence of
\f[CR]PointerEvent\f[R] instances that were coalesced (merged) into a
single \f[CR]pointermove\f[R] or \f[CR]pointerrawupdate\f[R] event.
Instead of a stream of many \f[CR]pointermove\f[R] events, user agents
coalesce multiple updates into a single event.
This helps with performance as the user agent has less event handling to
perform, but there is a reduction in the granularity and accuracy when
tracking, especially with fast and large movements.
.PP
The \f[B]\f[CB]getCoalescedEvents()\f[B]\f[R] method lets applications
access all un\-coalesced position changes for precise handling of
pointer movement data where necessary.
Un\-coalesced position changes are desirable in drawing applications,
for instance, where having access to all events helps to build smoother
curves that better match the movement of a pointer.
.PP
For an illustration of coalesced events, see \c
.UR https://w3c.github.io/pointerevents/#figure_coalesced
Figure 7 in the specification
.UE \c
\&.
.SH SYNTAX
.IP
.EX
getCoalescedEvents()
.EE
.SS Parameters
None.
.SS Return value
A sequence of \f[CR]PointerEvent\f[R] instances.
.SH EXAMPLE
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]target\[dq] width=\[dq]600\[dq] height=\[dq]300\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]target\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);

\f[B]const\f[R] pointerEvents = [];

\f[B]function\f[R] drawCircle(x, y, color) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  \f[I]// draw the last 20 events\f[R]
  \f[B]if\f[R] (pointerEvents.length > 20) {
    pointerEvents.shift();
  }
  pointerEvents.push({ x, y, color });

  \f[B]for\f[R] (\f[B]const\f[R] pointerEvent \f[B]of\f[R] pointerEvents) {
    ctx.beginPath();
    ctx.arc(pointerEvent.x, pointerEvent.y, 10, 0, 2 * Math.PI);
    ctx.strokeStyle = pointerEvent.color;
    ctx.stroke();
  }
}

canvas.addEventListener(\[dq]pointermove\[dq], (e) \f[B]=>\f[R] {
  \f[I]// draw a circle for the current event\f[R]
  drawCircle(e.clientX, e.clientY, \[dq]black\[dq]);

  \f[B]const\f[R] coalescedEvents = e.getCoalescedEvents();
  \f[B]for\f[R] (\f[B]let\f[R] coalescedEvent \f[B]of\f[R] coalescedEvents) {
    \f[I]// give it an offset so we can see the difference and color it red\f[R]
    drawCircle(coalescedEvent.clientX + 20, coalescedEvent.clientY + 20, \[dq]red\[dq]);
  }
});
.EE
.SS Result
