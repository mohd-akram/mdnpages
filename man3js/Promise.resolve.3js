.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Promise.resolve" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Promise.resolve \- Promise.resolve()
.SH SYNOPSIS
The \f[B]\f[CB]Promise.resolve()\f[B]\f[R] static method
\[lq]resolves\[rq] a given value to a \f[CR]Promise\f[R].
If the value is a promise, that promise is returned; if the value is a
thenable, \f[CR]Promise.resolve()\f[R] will call the \f[CR]then()\f[R]
method with two callbacks it prepared; otherwise the returned promise
will be fulfilled with the value.
.PP
This function flattens nested layers of promise\-like objects (e.g.\ a
promise that fulfills to a promise that fulfills to something) into a
single layer \[em] a promise that fulfills to a non\-thenable value.
.IP
.EX
\f[B]const\f[R] promise1 = Promise.resolve(123);

promise1.then((value) \f[B]=>\f[R] {
  console.log(value);
  \f[I]// Expected output: 123\f[R]
});
.EE
.SH SYNTAX
.IP
.EX
Promise.resolve(value)
.EE
.SS Parameters
.TP
\f[B]value\f[R]
Argument to be resolved by this \f[CR]Promise\f[R].
Can also be a \f[CR]Promise\f[R] or a thenable to resolve.
.SS Return value
A \f[CR]Promise\f[R] that is resolved with the given value, or the
promise passed as value, if the value was a promise object.
A resolved promise can be in any of the states \[em] fulfilled,
rejected, or pending.
For example, resolving a rejected promise will still result in a
rejected promise.
.SH DESCRIPTION
\f[CR]Promise.resolve()\f[R] \f[I]resolves\f[R] a promise, which is not
the same as fulfilling or rejecting the promise.
See Promise description for definitions of the terminology.
In brief, \f[CR]Promise.resolve()\f[R] returns a promise whose eventual
state depends on another promise, thenable object, or other value.
.RS
.PP
\f[B]Note:\f[R] If evaluating the \f[CR]value\f[R] expression may
synchronously throw an error, this error won\[cq]t be caught and wrapped
in a rejected promise by \f[CR]Promise.resolve()\f[R].
Consider using \f[CR]Promise.try(() => value)\f[R] in this case.
.RE
.PP
\f[CR]Promise.resolve()\f[R] is generic and supports subclassing, which
means it can be called on subclasses of \f[CR]Promise\f[R], and the
result will be a promise of the subclass type.
To do so, the subclass\[cq]s constructor must implement the same
signature as the \f[CR]Promise()\f[R] constructor \[em] accepting a
single \f[CR]executor\f[R] function that can be called with the
\f[CR]resolve\f[R] and \f[CR]reject\f[R] callbacks as parameters.
.PP
\f[CR]Promise.resolve()\f[R] special\-cases native \f[CR]Promise\f[R]
instances.
If \f[CR]value\f[R] belongs to \f[CR]Promise\f[R] or a subclass, and
\f[CR]value.constructor === Promise\f[R], then \f[CR]value\f[R] is
directly returned by \f[CR]Promise.resolve()\f[R], without creating a
new \f[CR]Promise\f[R] instance.
Otherwise, \f[CR]Promise.resolve()\f[R] is essentially a shorthand for
\f[CR]new Promise((resolve) => resolve(value))\f[R].
.PP
The bulk of the resolving logic is actually implemented by the
\f[CR]resolve\f[R] function passed by the \f[CR]Promise()\f[R]
constructor.
In summary:
.IP \[bu] 2
If a non\-thenable value is passed, the returned promise is already
fulfilled with that value.
.IP \[bu] 2
If a thenable is passed, the returned promise will adopt the state of
that thenable by calling the \f[CR]then\f[R] method and passing a pair
of resolving functions as arguments.
(But because native promises directly pass through
\f[CR]Promise.resolve()\f[R] without creating a wrapper, the
\f[CR]then\f[R] method is not called on native promises.)
If the \f[CR]resolve\f[R] function receives another thenable object, it
will be resolved again, so that the eventual fulfillment value of the
promise will never be thenable.
.SH EXAMPLES
.SS Using the static Promise.resolve method
.IP
.EX
Promise.resolve(\[dq]Success\[dq]).then(
  (value) \f[B]=>\f[R] {
    console.log(value); \f[I]// \[dq]Success\[dq]\f[R]
  },
  (reason) \f[B]=>\f[R] {
    \f[I]// not called\f[R]
  },
);
.EE
.SS Resolving an array
.IP
.EX
\f[B]const\f[R] p = Promise.resolve([1, 2, 3]);
p.then((v) \f[B]=>\f[R] {
  console.log(v[0]); \f[I]// 1\f[R]
});
.EE
.SS Resolving another Promise
\f[CR]Promise.resolve()\f[R] reuses existing \f[CR]Promise\f[R]
instances.
If it\[cq]s resolving a native promise, it returns the same promise
instance without creating a wrapper.
.IP
.EX
\f[B]const\f[R] original = Promise.resolve(33);
\f[B]const\f[R] cast = Promise.resolve(original);
cast.then((value) \f[B]=>\f[R] {
  console.log(\[ga]value: ${value}\[ga]);
});
console.log(\[ga]original === cast ? ${original === cast}\[ga]);

\f[I]// Logs, in order:\f[R]
\f[I]// original === cast ? true\f[R]
\f[I]// value: 33\f[R]
.EE
.PP
The inverted order of the logs is due to the fact that the
\f[CR]then\f[R] handlers are called asynchronously.
See the \f[CR]then()\f[R] reference for more information.
.SS Resolving thenables and throwing Errors
.IP
.EX
\f[I]// Resolving a thenable object\f[R]
\f[B]const\f[R] p1 = Promise.resolve({
  then(onFulfill, onReject) {
    onFulfill(\[dq]fulfilled!\[dq]);
  },
});
console.log(p1 \f[B]instanceof\f[R] Promise); \f[I]// true, object casted to a Promise\f[R]

p1.then(
  (v) \f[B]=>\f[R] {
    console.log(v); \f[I]// \[dq]fulfilled!\[dq]\f[R]
  },
  (e) \f[B]=>\f[R] {
    \f[I]// not called\f[R]
  },
);

\f[I]// Thenable throws\f[R]
\f[I]// Promise rejects\f[R]
\f[B]const\f[R] p2 = Promise.resolve({
  then() {
    \f[B]throw\f[R] \f[B]new\f[R] TypeError(\[dq]Throwing\[dq]);
  },
});
p2.then(
  (v) \f[B]=>\f[R] {
    \f[I]// not called\f[R]
  },
  (e) \f[B]=>\f[R] {
    console.error(e); \f[I]// TypeError: Throwing\f[R]
  },
);

\f[I]// Thenable throws after callback\f[R]
\f[I]// Promise resolves\f[R]
\f[B]const\f[R] p3 = Promise.resolve({
  then(onFulfilled) {
    onFulfilled(\[dq]Resolving\[dq]);
    \f[B]throw\f[R] \f[B]new\f[R] TypeError(\[dq]Throwing\[dq]);
  },
});
p3.then(
  (v) \f[B]=>\f[R] {
    console.log(v); \f[I]// \[dq]Resolving\[dq]\f[R]
  },
  (e) \f[B]=>\f[R] {
    \f[I]// not called\f[R]
  },
);
.EE
.PP
Nested thenables will be \[lq]deeply flattened\[rq] to a single promise.
.IP
.EX
\f[B]const\f[R] thenable = {
  then(onFulfilled, onRejected) {
    onFulfilled({
      \f[I]// The thenable is fulfilled with another thenable\f[R]
      then(onFulfilled, onRejected) {
        onFulfilled(42);
      },
    });
  },
};

Promise.resolve(thenable).then((v) \f[B]=>\f[R] {
  console.log(v); \f[I]// 42\f[R]
});
.EE
.RS
.PP
\f[B]Warning:\f[R] Do not call \f[CR]Promise.resolve()\f[R] on a
thenable that resolves to itself.
That leads to infinite recursion, because it attempts to flatten an
infinitely\-nested promise.
.RE
.PP
\f[B]Bad\f[R]
.IP
.EX
\f[B]const\f[R] thenable = {
  then(onFulfilled, onRejected) {
    onFulfilled(thenable);
  },
};

Promise.resolve(thenable); \f[I]// Will lead to infinite recursion.\f[R]
.EE
.SS Calling resolve() on a non\-Promise constructor
\f[CR]Promise.resolve()\f[R] is a generic method.
It can be called on any constructor that implements the same signature
as the \f[CR]Promise()\f[R] constructor.
For example, we can call it on a constructor that passes it
\f[CR]console.log\f[R] as \f[CR]resolve\f[R]:
.IP
.EX
\f[B]class\f[R] NotPromise {
  constructor(executor) {
    \f[I]// The \[dq]resolve\[dq] and \[dq]reject\[dq] functions behave nothing like the\f[R]
    \f[I]// native promise\[aq]s, but Promise.resolve() calls them in the same way.\f[R]
    executor(
      (value) \f[B]=>\f[R] console.log(\[dq]Resolved\[dq], value),
      (reason) \f[B]=>\f[R] console.log(\[dq]Rejected\[dq], reason),
    );
  }
}

Promise.resolve.call(NotPromise, \[dq]foo\[dq]); \f[I]// Logs \[dq]Resolved foo\[dq]\f[R]
.EE
.PP
The ability to flatten nested thenables is implemented by the
\f[CR]resolve\f[R] function of the \f[CR]Promise()\f[R] constructor, so
if you call it on another constructor, nested thenables may not be
flattened, depending on how that constructor implements its
\f[CR]resolve\f[R] function.
.IP
.EX
\f[B]const\f[R] thenable = {
  then(onFulfilled, onRejected) {
    onFulfilled({
      \f[I]// The thenable is fulfilled with another thenable\f[R]
      then(onFulfilled, onRejected) {
        onFulfilled(42);
      },
    });
  },
};

Promise.resolve.call(NotPromise, thenable); \f[I]// Logs \[dq]Resolved { then: [Function: then] }\[dq]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Promise\f[R]
