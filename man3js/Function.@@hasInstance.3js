.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Function.\[at]\[at]hasInstance" "JS" "April 26, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Function.\[at]\[at]hasInstance \-
Function.prototype\[at]\[at]hasInstance
.SH SYNOPSIS
The \f[B]\f[CB][\[at]\[at]hasInstance]()\f[B]\f[R] method of
\f[CR]Function\f[R] instances specifies the default procedure for
determining if a constructor function recognizes an object as one of the
constructor\[cq]s instances.
It is called by the \f[CR]instanceof\f[R] operator.
.SH SYNTAX
.IP
.EX
func[Symbol.hasInstance](value)
.EE
.SS Parameters
.TP
\f[B]value\f[R]
The object to test.
Primitive values always return \f[CR]false\f[R].
.SS Return value
\f[CR]true\f[R] if \f[CR]func.prototype\f[R] is in the prototype chain
of \f[CR]value\f[R]; otherwise, \f[CR]false\f[R].
Always returns \f[CR]false\f[R] if \f[CR]value\f[R] is not an object or
\f[CR]this\f[R] is not a function.
If \f[CR]this\f[R] is a bound function, returns the result of a
\f[CR]instanceof\f[R] test on \f[CR]value\f[R] and the underlying target
function.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if \f[CR]this\f[R] is not a bound function and
\f[CR]this.prototype\f[R] is not an object.
.SH DESCRIPTION
The \f[CR]instanceof\f[R] operator calls the
\f[CR][\[at]\[at]hasInstance]()\f[R] method of the right\-hand side
whenever such a method exists.
Because all functions inherit from \f[CR]Function.prototype\f[R] by
default, they would all have the \f[CR][\[at]\[at]hasInstance]()\f[R]
method, so most of the time, the
\f[CR]Function.prototype[\[at]\[at]hasInstance]\f[R] method specifies
the behavior of \f[CR]instanceof\f[R] when the right\-hand side is a
function.
This method implements the default behavior of the \f[CR]instanceof\f[R]
operator (the same algorithm when \f[CR]constructor\f[R] has no
\f[CR]\[at]\[at]hasInstance\f[R] method).
.PP
Unlike most methods, the
\f[CR]Function.prototype[\[at]\[at]hasInstance]()\f[R] property is
non\-configurable and non\-writable.
This is a security feature to prevent the underlying target function of
a bound function from being obtainable.
See \c
.UR https://stackoverflow.com/questions/38215027/trying-to-understand-the-official-es6-spec-regarding-symbol-hasinstance/38215392#38215392
this StackOverflow answer
.UE \c
\ for an example.
.SH EXAMPLES
.SS Reverting to default instanceof behavior
You would rarely need to call this method directly.
Instead, this method is called by the \f[CR]instanceof\f[R] operator.
You should expect the two results to usually be equivalent.
.IP
.EX
\f[B]class\f[R] Foo {}
\f[B]const\f[R] foo = \f[B]new\f[R] Foo();
console.log(foo \f[B]instanceof\f[R] Foo === Foo[Symbol.hasInstance](foo)); \f[I]// true\f[R]
.EE
.PP
You may want to use this method if you want to invoke the default
\f[CR]instanceof\f[R] behavior, but you don\[cq]t know if a constructor
has a overridden \f[CR][\[at]\[at]hasInstance]()\f[R] method.
.IP
.EX
\f[B]class\f[R] Foo {
  \f[B]static\f[R] [Symbol.hasInstance](value) {
    \f[I]// A custom implementation\f[R]
    \f[B]return\f[R] \f[B]false\f[R];
  }
}

\f[B]const\f[R] foo = \f[B]new\f[R] Foo();
console.log(foo \f[B]instanceof\f[R] Foo); \f[I]// false\f[R]
console.log(Function.prototype[Symbol.hasInstance].call(Foo, foo)); \f[I]// true\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]instanceof\f[R]
.IP \[bu] 2
\f[CR]Symbol.hasInstance\f[R]
