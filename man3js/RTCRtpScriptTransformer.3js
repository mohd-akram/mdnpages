.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "RTCRTPSCRIPTTRANSFORMER" "3JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCRtpScriptTransformer \- RTCRtpScriptTransformer
.SH SYNOPSIS
The \f[B]\f[CB]RTCRtpScriptTransformer\f[B]\f[R] interface of the WebRTC
API provides a worker\-side Stream API interface that a WebRTC Encoded
Transform can use to modify encoded media frames in the incoming and
outgoing WebRTC pipelines.
.RS
.PP
\f[B]Note:\f[R] This feature is available in \f[I]Dedicated\f[R] Web
Workers.
.RE
.SH INSTANCE PROPERTIES
.TP
\f[B]RTCRtpScriptTransformer.readable\f[R] \f[I](read\-only)\f[R]
A \f[CR]ReadableStream\f[R] on which encoded frames from the WebRTC
sender or receiver pipelines may be enqueued.
.TP
\f[B]RTCRtpScriptTransformer.writable\f[R] \f[I](read\-only)\f[R]
A \f[CR]WritableStream\f[R] that encoded frames should be piped to.
.TP
\f[B]RTCRtpScriptTransformer.options\f[R] \f[I](read\-only)\f[R]
Options passed from the \f[CR]RTCRtpScriptTransform\f[R] constructor,
which are used to configure transform code based on whether incoming or
outgoing frames are being processed.
.SH INSTANCE METHODS
.TP
\f[B]RTCRtpScriptTransformer.generateKeyFrame()\f[R]
Requests a video encoder generate a key frame.
May be called by a transformer in the sender pipeline when processing
outgoing frames.
.TP
\f[B]RTCRtpScriptTransformer.sendKeyFrameRequest()\f[R]
Requests the sender send a key frame.
May be called by a transformer in the receiver pipeline when processing
incoming encoded video frames.
.SH DESCRIPTION
A \f[CR]RTCRtpScriptTransformer\f[R] instance is created as part of
construction of an associated \f[CR]RTCRtpScriptTransform\f[R], which
specifies the worker in which the transformer is created and options
that will be passed to it.
.PP
The transformer is made available to a worker through the
\f[CR]rtctransform\f[R] event \f[CR]transformer\f[R] property.
This event is fired on construction of the associated
\f[CR]RTCRtpScriptTransform\f[R] and when an encoded frame is enqueued
on the \f[CR]RTCRtpScriptTransformer.readable\f[R] from a codec
(outgoing) or from the packetizer (incoming).
.PP
The transformer exposes a \f[CR]readable\f[R] and \f[CR]writable\f[R]
stream into the worker, along with an \f[CR]options\f[R] object provided
to the \f[CR]RTCRtpScriptTransform\f[R] on construction.
When the associated \f[CR]RTCRtpScriptTransform\f[R] is assigned to a
\f[CR]RTCRtpSender\f[R] or \f[CR]RTCRtpReceiver\f[R], encoded media
frames from the WebRTC sender or receiver pipelines are enqueued on the
\f[CR]readable\f[R] stream.
.PP
A WebRTC Encoded Transform must read encoded frames from
\f[CR]transformer.readable\f[R], modify them as needed, and write them
to \f[CR]transformer.writable\f[R] in the same order, and without any
duplication.
The \f[CR]transformer.options\f[R] allow an appropriate transform
function to be used, based on whether the encoded media frames are
incoming or outgoing.
The transform is usually implemented by piping frames from the
\f[CR]readable\f[R] through one or more \f[CR]TransformStream\f[R]
instances to the \f[CR]writable\f[R], transforming them as needed.
.PP
The interface also provides methods for a sender to generate get a video
encoder to generate a new keyframe, or for a receiver to request a new
key frame from the sender\(cqs encoder (video encoders commonly send a
key frame containing the full information needed to construct an image,
and subsequently send delta frames containing just the information that
has changed since the previous frame).
.PP
These methods are required in cases where a recipient would be unable to
decode incoming frames until they receive a new key frame.
For example, a new recipient joining a conference call will not be able
see video until they have received a new key frame, since delta frames
can only be decoded if you have the last key frame and all subsequent
delta frames.
Similarly, if frames are encrypted for a recipient, they will only be
able to decode frames once they have received their first encrypted key
frame.
.SH EXAMPLES
This example shows the code for a WebRTC Encoded Transform running in a
worker.
.PP
The code uses \f[CR]addEventListener()\f[R] to register a handler
function for the \f[CR]rtctransform\f[R] event, which makes the
\f[B]\f[CB]RTCRtpScriptTransformer\f[B]\f[R] available as
\f[CR]event.transformer\f[R].
.PP
The handler creates a \f[CR]TransformStream\f[R] and pipes frames from
the \f[CR]event.transformer.readable\f[R] through it to
\f[CR]event.transformer.writable\f[R].
The transform stream \f[CR]transform()\f[R] implementation is called for
each encoded frame queued on the stream: it can read the data from the
frame and in this case negates the bytes and then enqueues the
modifiable frame on the stream.
.IP
.EX
addEventListener(\(dqrtctransform\(dq, (event) \f[B]=>\f[R] {
  \f[B]const\f[R] transform = \f[B]new\f[R] TransformStream({
    start() {}, \f[I]// Called on startup.\f[R]
    flush() {}, \f[I]// Called when the stream is about to be closed.\f[R]
    \f[B]async\f[R] transform(encodedFrame, controller) {
      \f[I]// Reconstruct the original frame.\f[R]
      \f[B]const\f[R] view = \f[B]new\f[R] DataView(encodedFrame.data);

      \f[I]// Construct a new buffer\f[R]
      \f[B]const\f[R] newData = \f[B]new\f[R] ArrayBuffer(encodedFrame.data.byteLength);
      \f[B]const\f[R] newView = \f[B]new\f[R] DataView(newData);

      \f[I]// Negate all bits in the incoming frame\f[R]
      \f[B]for\f[R] (\f[B]let\f[R] i = 0; i < encodedFrame.data.byteLength; ++i) {
        newView.setInt8(i, \(tiview.getInt8(i));
      }

      encodedFrame.data = newData;
      controller.enqueue(encodedFrame);
    },
  });
  event.transformer.readable
    .pipeThrough(transform)
    .pipeTo(event.transformer.writable);
});
.EE
.PP
The only special things to note about the \f[CR]TransformStream\f[R]
above are that it queues encoded media frames
(\f[CR]RTCEncodedVideoFrame\f[R] or \f[CR]RTCEncodedAudioFrame\f[R])
rather than arbitrary \(lqchunks\(rq, and that
\f[CR]writableStrategy\f[R] and \f[CR]readableStrategy\f[R] properties
are not defined (because the queuing strategy is entirely managed by the
user agent).
.PP
A transform can run in either the incoming or outgoing WebRTC pipelines.
This doesn\(cqt matter in the code above, because the same algorithm
might be used in the sender to negate the frames, and in the receiver to
revert them.
If the sender and receiver pipelines need to apply a different transform
algorithm then information about the current pipeline must be passed
from the main thread.
This is done by setting an \f[CR]options\f[R] argument in the
corresponding \f[CR]RTCRtpScriptTransform\f[R] constructor, which is
then made available to the worker in
\f[CR]RTCRtpScriptTransformer.options\f[R].
.PP
Below we use the \f[CR]transformer.options\f[R] to choose either a
sender transform or a receiver transform.
Note that the properties of the object are arbitrary (provided the
values can be serialized) and it is also possible to transfer a
\f[CR]MessageChannel\f[R] and use it to communicate with a transform at
runtime in order to, for example, share encryption keys.
.IP
.EX
\f[I]// Code to instantiate transform and attach them to sender/receiver pipelines.\f[R]
onrtctransform = (event) \f[B]=>\f[R] {
  \f[B]let\f[R] transform;
  \f[B]if\f[R] (event.transformer.options.name == \(dqsenderTransform\(dq)
    transform = createSenderTransform();
  \f[I]// returns a TransformStream (not shown)\f[R]
  \f[B]else\f[R] \f[B]if\f[R] (event.transformer.options.name == \(dqreceiverTransform\(dq)
    transform = createReceiverTransform();
  \f[I]// returns a TransformStream (not shown)\f[R]
  \f[B]else\f[R] \f[B]return\f[R];
  event.transformer.readable
    .pipeThrough(transform)
    .pipeTo(event.transformer.writable);
};
.EE
.PP
Note that the above code is part of more complete examples provided in
Using WebRTC Encoded Transforms.
.SH SEE ALSO
.IP \(bu 2
Using WebRTC Encoded Transforms
.IP \(bu 2
\f[CR]TransformStream\f[R]
