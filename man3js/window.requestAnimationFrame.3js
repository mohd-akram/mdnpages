.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Window.requestAnimationFrame" "JS" "May 24, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Window.requestAnimationFrame \- Window: requestAnimationFrame() method
.SH SYNOPSIS
The \f[B]\f[CB]window.requestAnimationFrame()\f[B]\f[R] method tells the
browser you wish to perform an animation.
It requests the browser to call a user\-supplied callback function
before the next repaint.
.PP
The frequency of calls to the callback function will generally match the
display refresh rate.
The most common refresh rate is 60hz, (60 cycles/frames per second),
though 75hz, 120hz, and 144hz are also widely used.
\f[CR]requestAnimationFrame()\f[R] calls are paused in most browsers
when running in background tabs or hidden \f[CR]<iframe>\f[R]s, in order
to improve performance and battery life.
.RS
.PP
\f[B]Note:\f[R] Your callback function must call
\f[CR]requestAnimationFrame()\f[R] again if you want to animate another
frame.
\f[CR]requestAnimationFrame()\f[R] is one\-shot.
.RE
.RS
.PP
\f[B]Warning:\f[R] Be sure always to use the first argument (or some
other method for getting the current time) to calculate how much the
animation will progress in a frame \[em] \f[B]otherwise, the animation
will run faster on high refresh\-rate screens\f[R].
For ways to do that, see the examples below.
.RE
.SH SYNTAX
.IP
.EX
requestAnimationFrame(callback)
.EE
.SS Parameters
.IP \[bu] 2
\f[CR]callback\f[R]
.RS 2
.IP \[bu] 2
The function to call when it\[cq]s time to update your animation for the
next repaint.
This callback function is passed a single argument: a
\f[CR]DOMHighResTimeStamp\f[R] indicating the end time of the previous
frame\[cq]s rendering (based on the number of milliseconds since time
origin).
.IP \[bu] 2
The timestamp is a decimal number, in milliseconds, but with a minimal
precision of 1 millisecond.
For \f[CR]Window\f[R] objects (not \f[CR]Workers\f[R]), it is equal to
\f[CR]document.timeline.currentTime\f[R].
This timestamp is shared between all windows that run on the same agent
(all same\-origin windows and, more importantly, same\-origin iframes)
\[em] which allows synchronizing animations across multiple
\f[CR]requestAnimationFrame\f[R] callbacks.
The timestamp value is also similar to calling
\f[CR]performance.now()\f[R] at the start of the callback function, but
it is never the same value.
.IP \[bu] 2
When multiple callbacks queued by \f[CR]requestAnimationFrame()\f[R]
begin to fire in a single frame, each receives the same timestamp even
though time has passed during the computation of every previous
callback\[cq]s workload.
.RE
.SS Return value
A \f[CR]long\f[R] integer value, the request ID, that uniquely
identifies the entry in the callback list.
This is a non\-zero value, but you may not make any other assumptions
about its value.
You can pass this value to \f[CR]window.cancelAnimationFrame()\f[R] to
cancel the refresh callback request.
.SH EXAMPLES
In this example, an element is animated for 2 seconds (2000
milliseconds).
The element moves at a speed of 0.1px/ms to the right, so its relative
position (in CSS pixels) can be calculated in function of the time
elapsed since the start of the animation (in milliseconds) with
\f[CR]0.1 * elapsed\f[R].
The element\[cq]s final position is 200px (\f[CR]0.1 * 2000\f[R]) to the
right of its initial position.
.IP
.EX
\f[B]const\f[R] element = document.getElementById(\[dq]some\-element\-you\-want\-to\-animate\[dq]);
\f[B]let\f[R] start, previousTimeStamp;
\f[B]let\f[R] done = \f[B]false\f[R];

\f[B]function\f[R] step(timeStamp) {
  \f[B]if\f[R] (start === \f[B]undefined\f[R]) {
    start = timeStamp;
  }
  \f[B]const\f[R] elapsed = timeStamp \- start;

  \f[B]if\f[R] (previousTimeStamp !== timeStamp) {
    \f[I]// Math.min() is used here to make sure the element stops at exactly 200px\f[R]
    \f[B]const\f[R] count = Math.min(0.1 * elapsed, 200);
    element.style.transform = \[ga]translateX(${count}px)\[ga];
    \f[B]if\f[R] (count === 200) done = \f[B]true\f[R];
  }

  \f[B]if\f[R] (elapsed < 2000) {
    \f[I]// Stop the animation after 2 seconds\f[R]
    previousTimeStamp = timeStamp;
    \f[B]if\f[R] (!done) {
      window.requestAnimationFrame(step);
    }
  }
}

window.requestAnimationFrame(step);
.EE
.PP
The following three examples illustrate different approaches to setting
the zero point in time, the baseline for calculating the progress of
your animation in each frame.
If you want to synchronize to an external clock, such as
\f[CR]BaseAudioContext.currentTime\f[R], the highest precision available
is the duration of a single frame, 16.67ms \[at]60hz.
The callback\[cq]s timestamp argument represents the end of the previous
frame, so the soonest your newly calculated value(s) will be rendered is
in the next frame.
.PP
This example waits until the first callback executes to set
\f[CR]zero\f[R].
If your animation jumps to a new value when it starts, you must
structure it this way.
If you do not need to synchronize to anything external, such as audio,
then this approach is recommended because some browsers have a
multi\-frame delay between the initial call to
\f[CR]requestAnimationFrame()\f[R] and the first call to the callback
function.
.IP
.EX
\f[B]let\f[R] zero;
requestAnimationFrame(firstFrame);
\f[B]function\f[R] firstFrame(timeStamp) {
  zero = timeStamp;
  animate(timeStamp);
}
\f[B]function\f[R] animate(timeStamp) {
  \f[B]const\f[R] value = (timeStamp \- zero) / duration;
  \f[B]if\f[R] (value < 1) {
    element.style.opacity = value;
    requestAnimationFrame((t) \f[B]=>\f[R] animate(t));
  } \f[B]else\f[R] element.style.opacity = 1;
}
.EE
.PP
This example uses \f[CR]document.timeline.currentTime\f[R] to set a zero
value before the first call to \f[CR]requestAnimationFrame\f[R].
\f[CR]document.timeline.currentTime\f[R] aligns with the
\f[CR]timeStamp\f[R] argument, so the zero value is equivalent to the
0th frame\[cq]s timestamp.
.IP
.EX
\f[B]const\f[R] zero = document.timeline.currentTime;
requestAnimationFrame(animate);
\f[B]function\f[R] animate(timeStamp) {
  \f[B]const\f[R] value = (timeStamp \- zero) / duration; \f[I]// animation\-timing\-function: linear\f[R]
  \f[B]if\f[R] (value < 1) {
    element.style.opacity = value;
    requestAnimationFrame((t) \f[B]=>\f[R] animate(t));
  } \f[B]else\f[R] element.style.opacity = 1;
}
.EE
.PP
This example animates using \f[CR]performance.now()\f[R] instead of the
callback\[cq]s timestamp value.
You might use this to achieve slightly higher synchronization precision,
though the extra degree of precision is variable and not much of an
increase.
Note: This example does not allow you to synchronize animation callbacks
reliably.
.IP
.EX
\f[B]const\f[R] zero = performance.now();
requestAnimationFrame(animate);
\f[B]function\f[R] animate() {
  \f[B]const\f[R] value = (performance.now() \- zero) / duration;
  \f[B]if\f[R] (value < 1) {
    element.style.opacity = value;
    requestAnimationFrame((t) \f[B]=>\f[R] animate(t));
  } \f[B]else\f[R] element.style.opacity = 1;
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Window.cancelAnimationFrame()\f[R]
.IP \[bu] 2
\f[CR]DedicatedWorkerGlobalScope.requestAnimationFrame()\f[R]
.IP \[bu] 2
\c
.UR https://hacks.mozilla.org/2011/08/animating-with-javascript-from-setinterval-to-requestanimationframe/
Animating with JavaScript: from setInterval to requestAnimationFrame
.UE \c
\ \- Blog post
.IP \[bu] 2
\c
.UR https://www.testufo.com/#test=animation-time-graph
TestUFO: Test your web browser for requestAnimationFrame() Timing
Deviations
.UE \c
