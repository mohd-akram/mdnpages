.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Math.sumPrecise" "JS" "March 4, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Math.sumPrecise \- Math.sumPrecise()
.SH SYNOPSIS
The \f[B]\f[CB]Math.sumPrecise()\f[B]\f[R] static method takes an
iterable of numbers and returns the sum of them.
It is more precise than summing them up in a loop, because it avoids
floating point precision loss in intermediate results.
.IP
.EX
console.log(Math.sumPrecise([1, 2]));
\f[I]// Expected output: 3\f[R]

console.log(Math.sumPrecise([1e20, 0.1, \-1e20]));
\f[I]// Expected output: 0.1\f[R]
.EE
.SH SYNTAX
.IP
.EX
Math.sumPrecise(numbers)
.EE
.SS Parameters
.TP
\f[B]numbers\f[R]
An iterable (such as an \f[CR]Array\f[R]) of numbers.
.SS Return value
A number that is the sum of the numbers in the \f[CR]numbers\f[R]
iterable.
If the iterable is empty, the return value is \f[CR]\-0\f[R]
(\f[I]not\f[R] \f[CR]0\f[R]).
.SS Exceptions
.TP
\f[B]TypeError\f[R]
If \f[CR]numbers\f[R] is not an iterable, or if any of the numbers in
the iterable is not of the number type.
.SH DESCRIPTION
Because \f[CR]sumPrecise()\f[R] is a static method of \f[CR]Math\f[R],
you always use it as \f[CR]Math.sumPrecise()\f[R], rather than as a
method of a \f[CR]Math\f[R] object you created (\f[CR]Math\f[R] is not a
constructor).
.PP
The method is called \f[CR]Math.sumPrecise()\f[R] because it is more
precise than na√Øvely summing up numbers in a loop.
Consider the following example:
.IP
.EX
\f[B]let\f[R] sum = 0;
\f[B]const\f[R] numbers = [1e20, 0.1, \-1e20];
\f[B]for\f[R] (\f[B]const\f[R] number \f[B]of\f[R] numbers) {
  sum += number;
}
console.log(sum); \f[I]// 0\f[R]
.EE
.PP
The output is 0.
This is because \f[CR]1e20 + 0.1\f[R] cannot be represented precisely in
64\-bit floats, so the intermediate result is rounded to
\f[CR]1e20\f[R].
Then, the sum of \f[CR]1e20\f[R] and \f[CR]\-1e20\f[R] is \f[CR]0\f[R],
so the final result is \f[CR]0\f[R].
.PP
\f[CR]Math.sumPrecise()\f[R] avoids this issue by using some specialized
summing algorithm.
It works as if the floating point numbers are summed up using their
precise mathematical values, and the final result is then converted to
the nearest representable 64\-bit float.
This still cannot avoid the \f[CR]0.1 + 0.2\f[R] precision problem:
.IP
.EX
console.log(Math.sumPrecise([0.1, 0.2])); \f[I]// 0.30000000000000004\f[R]
.EE
.PP
Because the floating point literals \f[CR]0.1\f[R] and \f[CR]0.2\f[R]
already represent mathematical values greater than \f[CR]0.1\f[R] and
\f[CR]0.2\f[R], and their sum\[cq]s closest 64\-bit float representation
is actually \f[CR]0.30000000000000004\f[R].
.SH EXAMPLES
.SS Using Math.sumPrecise()
.IP
.EX
console.log(Math.sumPrecise([1, 2, 3])); \f[I]// 6\f[R]
console.log(Math.sumPrecise([1e20, 0.1, \-1e20])); \f[I]// 0.1\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#mathsumprecise
Polyfill of \f[CR]Math.sumPrecise\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Array.prototype.reduce()\f[R]
