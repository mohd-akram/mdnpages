.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "RTCRtpScriptTransformer.generateKeyFrame" "JS" "February 2, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCRtpScriptTransformer.generateKeyFrame \- RTCRtpScriptTransformer:
generateKeyFrame() method
.SH SYNOPSIS
The \f[B]\f[CB]generateKeyFrame()\f[B]\f[R] method of the
\f[CR]RTCRtpScriptTransformer\f[R] interface causes a video encoder to
generate a key frame.
.SH SYNTAX
.IP
.EX
generateKeyFrame()
generateKeyFrame(rid)
.EE
.SS Parameters
.TP
\f[B]rid\f[R] \f[I](optional)\f[R]
A string containing the \[lq]restriction identifier\[rq] (\[lq]RID\[rq])
of the stream/encoder that must generate the new key frame.
.RS
.PP
The value must have between 1 and 255 characters (inclusive), and
contain only the alphanumeric characters, underscore, and hyphen
(\f[CR]A\-Z\f[R], \f[CR]a\-z\f[R], \f[CR]0\-9\f[R], \f[CR]\-\f[R],
\f[CR]_\f[R]).
RIDs are case sensitive and must be unique for the peer communication
channel.
.PP
The first encoder that matches the specified \f[CR]rid\f[R] is used.
If no encoder matches the \f[CR]rid\f[R] then the first encoder is used,
and \f[CR]rid\f[R] is set to the encoder\[cq]s restrictions.
.RE
.SS Return value
A \f[CR]Promise\f[R] that fulfills with the timestamp of the frame, or
rejects with an exception value.
.SS Exceptions
.TP
\f[B]InvalidStateError\f[R]
The encoder is not processing video frames, or is \f[CR]undefined\f[R].
.TP
\f[B]TypeError\f[R]
The provided \f[CR]rid\f[R] but does not conform to the grammar
requirements.
.TP
\f[B]NotFoundError\f[R]
There are no video encoders.
This might be raised if the corresponding \f[CR]RTCRtpSender\f[R] is not
active or its track is ended.
.SH DESCRIPTION
This method can be called by a transformer that is processing outgoing
encoded video frames to force a new complete (key) frame to be sent.
It might be needed by a WebRTC Encoded Transform that encrypts frames,
to ensure that if a new encryption key is added, a key frame encrypted
with that key is sent as soon as possible.
.PP
The sender can specify a RID (also referred to as a \[lq]restriction
identifier\[rq] or \[lq]RTP stream ID\[rq]) to control what codec
generates the new key frame.
A stream might contain (simulcast) multiple versions of the same source,
each with different properties such as resolution and frame rate.
The RID is used to indicate a specific RTP stream, and hence the encoder
that needs to generate a new frame.
Note that the available RID values are set when the transceiver used by
the connection is created.
The RID values being used can be queried by calling
\f[CR]RTCRtpSender.getParameters()\f[R] and inspecting the
\f[CR]encodings\f[R] property of the returned value.
.PP
The promise returned by the method will resolve just before enqueuing
the corresponding key frame in a \f[CR]RTCRtpScriptTransformer\f[R]
readable.
.RS
.PP
\f[B]Note:\f[R] Sending multiple streams (RID) at a time is called
\[lq]simulcast\[rq].
This feature provides a \c
.UR https://en.wikipedia.org/wiki/Middlebox
middlebox
.UE \c
\ with the same stream in multiple levels of video quality, allowing it
to manage bandwidth by selectively transmitting appropriate levels to
participants and switch resolution rapidly on the fly (i.e.\ switching
to forward low\-quality video for everyone except the active speaker).
The recipient only ever gets one stream, which is why the comparable
receiver method \f[CR]RTCRtpScriptTransformer.sendKeyFrameRequest()\f[R]
does not require that an RID is specified.
.RE
.SH EXAMPLES
.SS Sending a key frame
The example below shows how the main thread might pass an encryption key
to a sender transform, and trigger the codec to generate a key frame.
.PP
Note that the main thread doesn\[cq]t have direct access to the
\f[CR]RTCRtpScriptTransformer\f[R] object, so it needs to pass the key
and RID to the worker.
Here we do that with a \f[CR]MessageChannel\f[R], transferring the
second port to the transformer code running in the worker.
The code assumes there is already a peer connection, and
\f[CR]videoSender\f[R] is an \f[CR]RTCRtpSender\f[R].
.IP
.EX
\f[B]const\f[R] worker = \f[B]new\f[R] Worker(\[dq]worker.js\[dq]);
\f[B]const\f[R] channel = \f[B]new\f[R] MessageChannel();

videoSender.transform = \f[B]new\f[R] RTCRtpScriptTransform(
  worker,
  { name: \[dq]senderTransform\[dq], port: channel.port2 },
  [channel.port2],
);

\f[I]// Post RID and new key to the sender\f[R]
channel.port1.start();
channel.port1.postMessage({
  rid: \[dq]1\[dq],
  key: \[dq]93ae0927a4f8e527f1gce6d10bc6ab6c\[dq],
});
.EE
.PP
The \f[CR]rtctransform\f[R] event handler in the worker gets the port
and uses it to listen for \f[CR]message\f[R] events.
If an event is received it gets the \f[CR]rid\f[R] and \f[CR]key\f[R],
and then calls \f[CR]generateKeyFrame()\f[R].
.IP
.EX
event.transformer.options.port.onmessage = (event) \f[B]=>\f[R] {
  \f[B]const\f[R] { rid, key } = event.data;
  \f[I]// key is used by the transformer to encrypt frames (not shown)\f[R]

  \f[I]// Get codec to generate a new key frame using the rid\f[R]
  \f[I]// Here \[aq]rcEvent\[aq] is the rtctransform event.\f[R]
  rcEvent.transformer.generateKeyFrame(rid);
};
.EE
.SH SEE ALSO
.IP \[bu] 2
Using WebRTC Encoded Transforms
