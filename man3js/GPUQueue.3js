.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPUQUEUE" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPUQueue \- GPUQueue
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]GPUQueue\f[B]\f[R] interface of the WebGPU API controls
execution of encoded commands on the GPU.
.PP
A device\(cqs primary queue is accessed via the
\f[CR]GPUDevice.queue\f[R] property.
.SH INSTANCE PROPERTIES
.TP
\f[B]label\f[R]
A string providing a label that can be used to identify the object, for
example in \f[CR]GPUError\f[R] messages or console warnings.
.SH INSTANCE METHODS
.TP
\f[B]copyExternalImageToTexture()\f[R]
Copies a snapshot taken from a source image, video, or canvas into a
given \f[CR]GPUTexture\f[R].
.TP
\f[B]onSubmittedWorkDone()\f[R]
Returns a \f[CR]Promise\f[R] that resolves when all the work submitted
to the GPU via this \f[CR]GPUQueue\f[R] at the point the method is
called has been processed.
.TP
\f[B]submit()\f[R]
Schedules the execution of command buffers represented by one or more
\f[CR]GPUCommandBuffer\f[R] objects by the GPU.
.TP
\f[B]writeBuffer()\f[R]
Writes a provided data source into a given \f[CR]GPUBuffer\f[R].
.TP
\f[B]writeTexture()\f[R]
Writes a provided data source into a given \f[CR]GPUTexture\f[R].
.SH EXAMPLES
In our \c
.UR https://mdn.github.io/dom-examples/webgpu-render-demo/
basic render demo
.UE \c
, we define some vertex data in a \f[CR]Float32Array\f[R] that we\(cqll
use to draw a triangle:
.IP
.EX
\f[B]const\f[R] vertices = \f[B]new\f[R] Float32Array([
  0.0, 0.6, 0, 1, 1, 0, 0, 1, \-0.5, \-0.6, 0, 1, 0, 1, 0, 1, 0.5, \-0.6, 0, 1, 0,
  0, 1, 1,
]);
.EE
.PP
To use this data in a render pipeline, we need to put it into a
\f[CR]GPUBuffer\f[R].
First we\(cqll create the buffer:
.IP
.EX
\f[B]const\f[R] vertexBuffer = device.createBuffer({
  size: vertices.byteLength, \f[I]// make it big enough to store vertices in\f[R]
  usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
});
.EE
.PP
To get the data into the buffer we can use the \f[CR]writeBuffer()\f[R]
function, which lets the user agent determine most efficient way to copy
the data over:
.IP
.EX
device.queue.writeBuffer(vertexBuffer, 0, vertices, 0, vertices.length);
.EE
.PP
Later on, a set of commands is encoded into a
\f[CR]GPUCommandBuffer\f[R] using the
\f[CR]GPUCommandEncoder.finish()\f[R] method.
The command buffer is then passed into the queue via a
\f[CR]submit()\f[R] call, ready to be processed by the GPU.
.IP
.EX
device.queue.submit([commandEncoder.finish()]);
.EE
.RS
.PP
\f[B]Note:\f[R] Study the \c
.UR https://webgpu.github.io/webgpu-samples/
WebGPU samples
.UE \c
\ to find more queue examples.
.RE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
