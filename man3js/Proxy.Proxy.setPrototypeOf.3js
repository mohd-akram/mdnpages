.\" Automatically generated by Pandoc 3.4
.\"
.TH "Proxy.Proxy.setPrototypeOf" "JS" "July 11, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Proxy.Proxy.setPrototypeOf \- handler.setPrototypeOf()
.SH SYNOPSIS
The \f[B]\f[CB]handler.setPrototypeOf()\f[B]\f[R] method is a trap for
the \f[CR][[SetPrototypeOf]]\f[R] object internal method, which is used
by operations such as \f[CR]Object.setPrototypeOf()\f[R].
.SH SYNTAX
.IP
.EX
new Proxy(target, {
  setPrototypeOf(target, prototype) {
  }
})
.EE
.SS Parameters
The following parameters are passed to the \f[CR]setPrototypeOf()\f[R]
method.
\f[CR]this\f[R] is bound to the handler.
.TP
\f[B]target\f[R]
The target object.
.TP
\f[B]prototype\f[R]
The object\[cq]s new prototype or \f[CR]null\f[R].
.SS Return value
The \f[CR]setPrototypeOf()\f[R] method must return a \f[CR]Boolean\f[R]
indicating whether or not the prototype was successfully changed.
Other values are coerced to booleans.
.PP
Many operations, including \f[CR]Object.setPrototypeOf()\f[R], throw a
\f[CR]TypeError\f[R] if the \f[CR][[SetPrototypeOf]]\f[R] internal
method returns \f[CR]false\f[R].
.SH DESCRIPTION
.SS Interceptions
This trap can intercept these operations:
.IP \[bu] 2
\f[CR]Object.setPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Reflect.setPrototypeOf()\f[R]
.PP
Or any other operation that invokes the \f[CR][[SetPrototypeOf]]\f[R]
internal method.
.SS Invariants
The proxy\[cq]s \f[CR][[SetPrototypeOf]]\f[R] internal method throws a
\f[CR]TypeError\f[R] if the handler definition violates one of the
following invariants:
.IP \[bu] 2
If the target object is not extensible, the prototype cannot be changed.
That is, if \f[CR]Reflect.isExtensible()\f[R] returns \f[CR]false\f[R]
on \f[CR]target\f[R], and \f[CR]prototype\f[R] is not the same as the
result of \f[CR]Reflect.getPrototypeOf(target)\f[R], then the trap must
return a falsy value.
.SH EXAMPLES
If you want to disallow setting a new prototype for your object, your
handler\[cq]s \f[CR]setPrototypeOf()\f[R] method can either return
\f[CR]false\f[R], or it can throw an exception.
.SS Approach 1: Returning false
This approach means that any mutating operation that throws an exception
on failure to mutate, must create the exception itself.
.PP
For example, \f[CR]Object.setPrototypeOf()\f[R] will create and throw a
\f[CR]TypeError\f[R] itself.
If the mutation is performed by an operation that \f[I]doesn\[cq]t\f[R]
ordinarily throw in case of failure, such as
\f[CR]Reflect.setPrototypeOf()\f[R], no exception will be thrown.
.IP
.EX
\f[B]const\f[R] handlerReturnsFalse = {
  setPrototypeOf(target, newProto) {
    \f[B]return\f[R] \f[B]false\f[R];
  },
};

\f[B]const\f[R] newProto = {},
  target = {};

\f[B]const\f[R] p1 = \f[B]new\f[R] Proxy(target, handlerReturnsFalse);
Object.setPrototypeOf(p1, newProto); \f[I]// throws a TypeError\f[R]
Reflect.setPrototypeOf(p1, newProto); \f[I]// returns false\f[R]
.EE
.SS Approach 2: Throwing an Exception
The latter approach will cause \f[I]any\f[R] operation that attempts to
mutate, to throw.
This approach is best if you want even non\-throwing operations to throw
on failure, or you want to throw a custom exception value.
.IP
.EX
\f[B]const\f[R] handlerThrows = {
  setPrototypeOf(target, newProto) {
    \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]custom error\[dq]);
  },
};

\f[B]const\f[R] newProto = {},
  target = {};

\f[B]const\f[R] p2 = \f[B]new\f[R] Proxy(target, handlerThrows);
Object.setPrototypeOf(p2, newProto); \f[I]// throws new Error(\[dq]custom error\[dq])\f[R]
Reflect.setPrototypeOf(p2, newProto); \f[I]// throws new Error(\[dq]custom error\[dq])\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Proxy\f[R]
.IP \[bu] 2
\f[CR]Proxy()\f[R] constructor
.IP \[bu] 2
\f[CR]Object.setPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Reflect.setPrototypeOf()\f[R]
