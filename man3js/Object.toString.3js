.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Object.toString" "JS" "September 30, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.toString \- Object.prototype.toString()
.SH SYNOPSIS
The \f[B]\f[CB]toString()\f[B]\f[R] method of \f[CR]Object\f[R]
instances returns a string representing this object.
This method is meant to be overridden by derived objects for custom type
coercion logic.
.SH SYNTAX
.IP
.EX
toString()
.EE
.SS Parameters
By default \f[CR]toString()\f[R] takes no parameters.
However, objects that inherit from \f[CR]Object\f[R] may override it
with their own implementations that do take parameters.
For example, the \f[CR]Number.prototype.toString()\f[R] and
\f[CR]BigInt.prototype.toString()\f[R] methods take an optional
\f[CR]radix\f[R] parameter.
.SS Return value
A string representing the object.
.SH DESCRIPTION
JavaScript calls the \f[CR]toString\f[R] method to convert an object to
a primitive value.
You rarely need to invoke the \f[CR]toString\f[R] method yourself;
JavaScript automatically invokes it when encountering an object where a
primitive value is expected.
.PP
This method is called in priority by string conversion, but numeric
conversion and primitive conversion call \f[CR]valueOf()\f[R] in
priority.
However, because the base \f[CR]valueOf()\f[R] method returns an object,
the \f[CR]toString()\f[R] method is usually called in the end, unless
the object overrides \f[CR]valueOf()\f[R].
For example, \f[CR]+[1]\f[R] returns \f[CR]1\f[R], because its
\f[CR]toString()\f[R] method returns \f[CR]\[dq]1\[dq]\f[R], which is
then converted to a number.
.PP
All objects that inherit from \f[CR]Object.prototype\f[R] (that is, all
except \f[CR]null\f[R]\-prototype objects) inherit the
\f[CR]toString()\f[R] method.
When you create a custom object, you can override \f[CR]toString()\f[R]
to call a custom method, so that your custom object can be converted to
a string value.
Alternatively, you can add a \f[CR]\[at]\[at]toPrimitive\f[R] method,
which allows even more control over the conversion process, and will
always be preferred over \f[CR]valueOf\f[R] or \f[CR]toString\f[R] for
any type conversion.
.PP
To use the base \f[CR]Object.prototype.toString()\f[R] with an object
that has it overridden (or to invoke it on \f[CR]null\f[R] or
\f[CR]undefined\f[R]), you need to call
\f[CR]Function.prototype.call()\f[R] or
\f[CR]Function.prototype.apply()\f[R] on it, passing the object you want
to inspect as the first parameter (called \f[CR]thisArg\f[R]).
.IP
.EX
const arr = [1, 2, 3];

arr.toString(); // \[dq]1,2,3\[dq]
Object.prototype.toString.call(arr); // \[dq][object Array]\[dq]
.EE
.PP
\f[CR]Object.prototype.toString()\f[R] returns
\f[CR]\[dq][object Type]\[dq]\f[R], where \f[CR]Type\f[R] is the object
type.
If the object has a \f[CR]Symbol.toStringTag\f[R] property whose value
is a string, that value will be used as the \f[CR]Type\f[R].
Many built\-in objects, including \f[CR]Map\f[R] and \f[CR]Symbol\f[R],
have a \f[CR]Symbol.toStringTag\f[R].
Some objects predating ES6 do not have \f[CR]Symbol.toStringTag\f[R],
but have a special tag nonetheless.
They include (the tag is the same as the type name given below):
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Function\f[R] (anything whose \f[CR]typeof\f[R] returns
\f[CR]\[dq]function\[dq]\f[R])
.IP \[bu] 2
\f[CR]Error\f[R]
.IP \[bu] 2
\f[CR]Boolean\f[R]
.IP \[bu] 2
\f[CR]Number\f[R]
.IP \[bu] 2
\f[CR]String\f[R]
.IP \[bu] 2
\f[CR]Date\f[R]
.IP \[bu] 2
\f[CR]RegExp\f[R]
.PP
The \f[CR]arguments\f[R] object returns
\f[CR]\[dq][object Arguments]\[dq]\f[R].
Everything else, including user\-defined classes, unless with a custom
\f[CR]Symbol.toStringTag\f[R], will return
\f[CR]\[dq][object Object]\[dq]\f[R].
.PP
\f[CR]Object.prototype.toString()\f[R] invoked on \f[CR]null\f[R] and
\f[CR]undefined\f[R] returns \f[CR][object Null]\f[R] and
\f[CR][object Undefined]\f[R], respectively.
.SH EXAMPLES
.SS Overriding toString for custom objects
You can create a function to be called in place of the default
\f[CR]toString()\f[R] method.
The \f[CR]toString()\f[R] function you create should return a string
value.
If it returns an object and the method is called implicitly during type
conversion, then its result is ignored and the value of a related
method, \f[CR]valueOf()\f[R], is used instead, or a \f[CR]TypeError\f[R]
is thrown if none of these methods return a primitive.
.PP
The following code defines a \f[CR]Dog\f[R] class.
.IP
.EX
class Dog {
  constructor(name, breed, color, sex) {
    this.name = name;
    this.breed = breed;
    this.color = color;
    this.sex = sex;
  }
}
.EE
.PP
If you call the \f[CR]toString()\f[R] method, either explicitly or
implicitly, on an instance of \f[CR]Dog\f[R], it returns the default
value inherited from \f[CR]Object\f[R]:
.IP
.EX
const theDog = new Dog(\[dq]Gabby\[dq], \[dq]Lab\[dq], \[dq]chocolate\[dq], \[dq]female\[dq]);

theDog.toString(); // \[dq][object Object]\[dq]
\[ga]${theDog}\[ga]; // \[dq][object Object]\[dq]
.EE
.PP
The following code overrides the default \f[CR]toString()\f[R] method.
This method generates a string containing the \f[CR]name\f[R],
\f[CR]breed\f[R], \f[CR]color\f[R], and \f[CR]sex\f[R] of the object.
.IP
.EX
class Dog {
  constructor(name, breed, color, sex) {
    this.name = name;
    this.breed = breed;
    this.color = color;
    this.sex = sex;
  }
  toString() {
    return \[ga]Dog ${this.name} is a ${this.sex} ${this.color} ${this.breed}\[ga];
  }
}
.EE
.PP
With the preceding code in place, any time an instance of \f[CR]Dog\f[R]
is used in a string context, JavaScript automatically calls the
\f[CR]toString()\f[R] method.
.IP
.EX
const theDog = new Dog(\[dq]Gabby\[dq], \[dq]Lab\[dq], \[dq]chocolate\[dq], \[dq]female\[dq]);

\[ga]${theDog}\[ga]; // \[dq]Dog Gabby is a female chocolate Lab\[dq]
.EE
.SS Using toString() to detect object class
\f[CR]toString()\f[R] can be used with every object and (by default)
allows you to get its class.
.IP
.EX
const toString = Object.prototype.toString;

toString.call(new Date()); // [object Date]
toString.call(new String()); // [object String]
// Math has its Symbol.toStringTag
toString.call(Math); // [object Math]

toString.call(undefined); // [object Undefined]
toString.call(null); // [object Null]
.EE
.PP
Using \f[CR]toString()\f[R] in this way is unreliable; objects can
change the behavior of \f[CR]Object.prototype.toString()\f[R] by
defining a \f[CR]Symbol.toStringTag\f[R] property, leading to unexpected
results.
For example:
.IP
.EX
const myDate = new Date();
Object.prototype.toString.call(myDate); // [object Date]

myDate[Symbol.toStringTag] = \[dq]myDate\[dq];
Object.prototype.toString.call(myDate); // [object myDate]

Date.prototype[Symbol.toStringTag] = \[dq]prototype polluted\[dq];
Object.prototype.toString.call(new Date()); // [object prototype polluted]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-object
Polyfill of \f[CR]Object.prototype.toString\f[R] with
\f[CR]Symbol.toStringTag\f[R] support in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Object.prototype.valueOf()\f[R]
.IP \[bu] 2
\f[CR]Number.prototype.toString()\f[R]
.IP \[bu] 2
\f[CR]Symbol.toPrimitive\f[R]
.IP \[bu] 2
\f[CR]Symbol.toStringTag\f[R]
