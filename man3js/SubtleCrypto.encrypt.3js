.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "SubtleCrypto.encrypt" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SubtleCrypto.encrypt \- SubtleCrypto: encrypt() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
The \f[B]\f[CB]encrypt()\f[B]\f[R] method of the \f[CR]SubtleCrypto\f[R]
interface encrypts data.
.PP
It takes as its arguments a key to encrypt with, some
algorithm\-specific parameters, and the data to encrypt (also known as
\[lq]plaintext\[rq]).
It returns a \f[CR]Promise\f[R] which will be fulfilled with the
encrypted data (also known as \[lq]ciphertext\[rq]).
.SH SYNTAX
.IP
.EX
encrypt(algorithm, key, data)
.EE
.SS Parameters
.TP
\f[B]algorithm\f[R]
An object specifying the algorithm to be used and any extra parameters
if required:
.RS
.IP \[bu] 2
To use RSA\-OAEP, pass an \f[CR]RsaOaepParams\f[R] object.
.IP \[bu] 2
To use AES\-CTR, pass an \f[CR]AesCtrParams\f[R] object.
.IP \[bu] 2
To use AES\-CBC, pass an \f[CR]AesCbcParams\f[R] object.
.IP \[bu] 2
To use AES\-GCM, pass an \f[CR]AesGcmParams\f[R] object.
.RE
.TP
\f[B]key\f[R]
A \f[CR]CryptoKey\f[R] containing the key to be used for encryption.
.TP
\f[B]data\f[R]
An \f[CR]ArrayBuffer\f[R], a \f[CR]TypedArray\f[R], or a
\f[CR]DataView\f[R] containing the data to be encrypted (also known as
the plaintext).
.SS Return value
A \f[CR]Promise\f[R] that fulfills with an \f[CR]ArrayBuffer\f[R]
containing the \[lq]ciphertext\[rq].
.SS Exceptions
The promise is rejected when the following exceptions are encountered:
.TP
\f[B]InvalidAccessError\f[R] \f[B]DOMException\f[R]
Raised when the requested operation is not valid for the provided key
(e.g.\ invalid encryption algorithm, or invalid key for the specified
encryption algorithm).
.TP
\f[B]OperationError\f[R] \f[B]DOMException\f[R]
Raised when the operation failed for an operation\-specific reason
(e.g.\ algorithm parameters of invalid sizes, or AES\-GCM plaintext
longer than 2\[ha]39âˆ’256 bytes).
.SH SUPPORTED ALGORITHMS
The Web Crypto API provides four algorithms that support the
\f[CR]encrypt()\f[R] and \f[CR]decrypt()\f[R] operations.
.PP
One of these algorithms \[em] RSA\-OAEP \[em] is a public\-key
cryptosystem.
.PP
The other three encryption algorithms here are all symmetric algorithms,
and they\[cq]re all based on the same underlying cipher, AES (Advanced
Encryption Standard).
The difference between them is the mode.
The Web Crypto API supports three different AES modes:
.IP \[bu] 2
CTR (Counter Mode)
.IP \[bu] 2
CBC (Cipher Block Chaining)
.IP \[bu] 2
GCM (Galois/Counter Mode)
.PP
It\[cq]s strongly recommended to use \f[I]authenticated encryption\f[R],
which includes checks that the ciphertext has not been modified by an
attacker.
Authentication helps protect against \f[I]chosen\-ciphertext\f[R]
attacks, in which an attacker can ask the system to decrypt arbitrary
messages, and use the result to deduce information about the secret key.
While it\[cq]s possible to add authentication to CTR and CBC modes, they
do not provide it by default and when implementing it manually one can
easily make minor, but serious mistakes.
GCM does provide built\-in authentication, and for this reason it\[cq]s
often recommended over the other two AES modes.
.SS RSA\-OAEP
The RSA\-OAEP public\-key encryption system is specified in \c
.UR https://datatracker.ietf.org/doc/html/rfc3447
RFC 3447
.UE \c
\&.
.SS AES\-CTR
This represents AES in Counter Mode, as specified in \c
.UR https://csrc.nist.gov/publications/detail/sp/800-38a/final
NIST SP800\-38A
.UE \c
\&.
.PP
AES is a block cipher, meaning that it splits the message into blocks
and encrypts it a block at a time.
In CTR mode, every time a block of the message is encrypted, an extra
block of data is mixed in.
This extra block is called the \[lq]counter block\[rq].
.PP
A given counter block value must never be used more than once with the
same key:
.IP \[bu] 2
Given a message \f[I]n\f[R] blocks long, a different counter block must
be used for every block.
.IP \[bu] 2
If the same key is used to encrypt more than one message, a different
counter block must be used for all blocks across all messages.
.PP
Typically this is achieved by splitting the initial counter block value
into two concatenated parts:
.IP \[bu] 2
A \c
.UR https://en.wikipedia.org/wiki/Cryptographic_nonce
nonce
.UE \c
\ (that is, a number that may only be used once).
The nonce part of the block stays the same for every block in the
message.
Each time a new message is to be encrypted, a new nonce is chosen.
Nonces don\[cq]t have to be secret, but they must not be reused with the
same key.
.IP \[bu] 2
A counter.
This part of the block gets incremented each time a block is encrypted.
.PP
Essentially: the nonce should ensure that counter blocks are not reused
from one message to the next, while the counter should ensure that
counter blocks are not reused within a single message.
.RS
.PP
\f[B]Note:\f[R] See \c
.UR https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf#%5B%7B%22num%22%3A70%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22Fit%22%7D%5D
Appendix B of the NIST SP800\-38A standard
.UE \c
\ for more information.
.RE
.SS AES\-CBC
This represents AES in Cipher Block Chaining Mode, as specified in \c
.UR https://csrc.nist.gov/publications/detail/sp/800-38a/final
NIST SP800\-38A
.UE \c
\&.
.SS AES\-GCM
This represents AES in Galois/Counter Mode, as specified in \c
.UR https://csrc.nist.gov/publications/detail/sp/800-38d/final
NIST SP800\-38D
.UE \c
\&.
.PP
One major difference between this mode and the others is that GCM is an
\[lq]authenticated\[rq] mode, which means that it includes checks that
the ciphertext has not been modified by an attacker.
.SH EXAMPLES
.RS
.PP
\f[B]Note:\f[R] You can \c
.UR https://mdn.github.io/dom-examples/web-crypto/encrypt-decrypt/index.html
try the working examples
.UE \c
\ out on GitHub.
.RE
.SS RSA\-OAEP
This code fetches the contents of a text box, encodes it for encryption,
and encrypts it with using RSA\-OAEP.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/encrypt-decrypt/rsa-oaep.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]function\f[R] getMessageEncoding() {
  \f[B]const\f[R] messageBox = document.querySelector(\[dq].rsa\-oaep #message\[dq]);
  \f[B]let\f[R] message = messageBox.value;
  \f[B]let\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] enc.encode(message);
}

\f[B]function\f[R] encryptMessage(publicKey) {
  \f[B]let\f[R] encoded = getMessageEncoding();
  \f[B]return\f[R] window.crypto.subtle.encrypt(
    {
      name: \[dq]RSA\-OAEP\[dq],
    },
    publicKey,
    encoded,
  );
}
.EE
.SS AES\-CTR
This code fetches the contents of a text box, encodes it for encryption,
and encrypts it using AES in CTR mode.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/encrypt-decrypt/aes-ctr.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]function\f[R] getMessageEncoding() {
  \f[B]const\f[R] messageBox = document.querySelector(\[dq].aes\-ctr #message\[dq]);
  \f[B]let\f[R] message = messageBox.value;
  \f[B]let\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] enc.encode(message);
}

\f[B]function\f[R] encryptMessage(key) {
  \f[B]let\f[R] encoded = getMessageEncoding();
  \f[I]// counter will be needed for decryption\f[R]
  counter = window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(16));
  \f[B]return\f[R] window.crypto.subtle.encrypt(
    {
      name: \[dq]AES\-CTR\[dq],
      counter,
      length: 64,
    },
    key,
    encoded,
  );
}
.EE
.IP
.EX
\f[B]let\f[R] iv = window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(16));
\f[B]let\f[R] key = window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(16));
\f[B]let\f[R] data = \f[B]new\f[R] Uint8Array(12345);
\f[I]// crypto functions are wrapped in promises so we have to use await and make sure the function that\f[R]
\f[I]// contains this code is an async function\f[R]
\f[I]// encrypt function wants a cryptokey object\f[R]
\f[B]const\f[R] key_encoded = \f[B]await\f[R] crypto.subtle.importKey(
  \[dq]raw\[dq],
  key.buffer,
  \[dq]AES\-CTR\[dq],
  \f[B]false\f[R],
  [\[dq]encrypt\[dq], \[dq]decrypt\[dq]],
);
\f[B]const\f[R] encrypted_content = \f[B]await\f[R] window.crypto.subtle.encrypt(
  {
    name: \[dq]AES\-CTR\[dq],
    counter: iv,
    length: 128,
  },
  key_encoded,
  data,
);

\f[I]// Uint8Array\f[R]
console.log(encrypted_content);
.EE
.SS AES\-CBC
This code fetches the contents of a text box, encodes it for encryption,
and encrypts it using AES in CBC mode.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/encrypt-decrypt/aes-cbc.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]function\f[R] getMessageEncoding() {
  \f[B]const\f[R] messageBox = document.querySelector(\[dq].aes\-cbc #message\[dq]);
  \f[B]let\f[R] message = messageBox.value;
  \f[B]let\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] enc.encode(message);
}

\f[B]function\f[R] encryptMessage(key) {
  \f[B]let\f[R] encoded = getMessageEncoding();
  \f[I]// iv will be needed for decryption\f[R]
  iv = window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(16));
  \f[B]return\f[R] window.crypto.subtle.encrypt(
    {
      name: \[dq]AES\-CBC\[dq],
      iv: iv,
    },
    key,
    encoded,
  );
}
.EE
.SS AES\-GCM
This code fetches the contents of a text box, encodes it for encryption,
and encrypts it using AES in GCM mode.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/encrypt-decrypt/aes-gcm.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]function\f[R] getMessageEncoding() {
  \f[B]const\f[R] messageBox = document.querySelector(\[dq].aes\-gcm #message\[dq]);
  \f[B]const\f[R] message = messageBox.value;
  \f[B]const\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] enc.encode(message);
}

\f[B]function\f[R] encryptMessage(key) {
  \f[B]const\f[R] encoded = getMessageEncoding();
  \f[I]// iv will be needed for decryption\f[R]
  \f[B]const\f[R] iv = window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(12));
  \f[B]return\f[R] window.crypto.subtle.encrypt(
    { name: \[dq]AES\-GCM\[dq], iv: iv },
    key,
    encoded,
  );
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]SubtleCrypto.decrypt()\f[R].
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc3447
RFC 3447
.UE \c
\ specifies RSAOAEP.
.IP \[bu] 2
\c
.UR https://csrc.nist.gov/publications/detail/sp/800-38a/final
NIST SP800\-38A
.UE \c
\ specifies CTR mode.
.IP \[bu] 2
\c
.UR https://csrc.nist.gov/publications/detail/sp/800-38a/final
NIST SP800\-38A
.UE \c
\ specifies CBC mode.
.IP \[bu] 2
\c
.UR https://csrc.nist.gov/publications/detail/sp/800-38d/final
NIST SP800\-38D
.UE \c
\ specifies GCM mode.
