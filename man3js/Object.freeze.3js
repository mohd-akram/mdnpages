.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Object.freeze" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.freeze \- Object.freeze()
.SH SYNOPSIS
The \f[B]\f[CB]Object.freeze()\f[B]\f[R] static method \f[I]freezes\f[R]
an object.
Freezing an object prevents extensions and makes existing properties
non\-writable and non\-configurable.
A frozen object can no longer be changed: new properties cannot be
added, existing properties cannot be removed, their enumerability,
configurability, writability, or value cannot be changed, and the
object\[cq]s prototype cannot be re\-assigned.
\f[CR]freeze()\f[R] returns the same object that was passed in.
.PP
Freezing an object is the highest integrity level that JavaScript
provides.
.IP
.EX
\f[B]const\f[R] obj = {
  prop: 42,
};

Object.freeze(obj);

obj.prop = 33;
\f[I]// Throws an error in strict mode\f[R]

console.log(obj.prop);
\f[I]// Expected output: 42\f[R]
.EE
.SH SYNTAX
.IP
.EX
Object.freeze(obj)
.EE
.SS Parameters
.TP
\f[B]obj\f[R]
The object to freeze.
.SS Return value
The object that was passed to the function.
.SH DESCRIPTION
Freezing an object is equivalent to preventing extensions and then
changing all existing properties\[cq] descriptors\[cq]
\f[CR]configurable\f[R] to \f[CR]false\f[R] \[em] and for data
properties, \f[CR]writable\f[R] to \f[CR]false\f[R] as well.
Nothing can be added to or removed from the properties set of a frozen
object.
Any attempt to do so will fail, either silently or by throwing a
\f[CR]TypeError\f[R] exception (most commonly, but not exclusively, when
in strict mode).
.PP
For data properties of a frozen object, their values cannot be changed
since the \f[CR]writable\f[R] and \f[CR]configurable\f[R] attributes are
set to \f[CR]false\f[R].
Accessor properties (getters and setters) work the same \[em] the
property value returned by the getter may still change, and the setter
can still be called without throwing errors when setting the property.
Note that values that are objects can still be modified, unless they are
also frozen.
As an object, an array can be frozen; after doing so, its elements
cannot be altered and no elements can be added to or removed from the
array.
.PP
Private properties do not have the concept of property descriptors.
Freezing an object with private properties does not prevent the values
of these private properties from being changed.
(Freezing objects is usually meant as a security measure against
external code, but external code cannot access private properties
anyway.)
Private properties cannot be added or removed from the object, whether
the object is frozen or not.
.PP
\f[CR]freeze()\f[R] returns the same object that was passed into the
function.
It \f[I]does not\f[R] create a frozen copy.
.PP
A \f[CR]TypedArray\f[R] or a \f[CR]DataView\f[R] with elements will
cause a \f[CR]TypeError\f[R], as they are views over memory and will
definitely cause other possible issues:
.IP
.EX
Object.freeze(\f[B]new\f[R] Uint8Array(0)); \f[I]// No elements\f[R]
\f[I]// Uint8Array []\f[R]

Object.freeze(\f[B]new\f[R] Uint8Array(1)); \f[I]// Has elements\f[R]
\f[I]// TypeError: Cannot freeze array buffer views with elements\f[R]

Object.freeze(\f[B]new\f[R] DataView(\f[B]new\f[R] ArrayBuffer(32))); \f[I]// No elements\f[R]
\f[I]// DataView {}\f[R]

Object.freeze(\f[B]new\f[R] Float64Array(\f[B]new\f[R] ArrayBuffer(64), 63, 0)); \f[I]// No elements\f[R]
\f[I]// Float64Array []\f[R]

Object.freeze(\f[B]new\f[R] Float64Array(\f[B]new\f[R] ArrayBuffer(64), 32, 2)); \f[I]// Has elements\f[R]
\f[I]// TypeError: Cannot freeze array buffer views with elements\f[R]
.EE
.PP
Note that as the standard three properties (\f[CR]buf.byteLength\f[R],
\f[CR]buf.byteOffset\f[R] and \f[CR]buf.buffer\f[R]) are read\-only (as
are those of an \f[CR]ArrayBuffer\f[R] or \f[CR]SharedArrayBuffer\f[R]),
there is no reason for attempting to freeze these properties.
.PP
Unlike \f[CR]Object.seal()\f[R], existing properties in objects frozen
with \f[CR]Object.freeze()\f[R] are made immutable and data properties
cannot be re\-assigned.
.SH EXAMPLES
.SS Freezing objects
.IP
.EX
\f[B]const\f[R] obj = {
  prop() {},
  foo: \[dq]bar\[dq],
};

\f[I]// Before freezing: new properties may be added,\f[R]
\f[I]// and existing properties may be changed or removed\f[R]
obj.foo = \[dq]baz\[dq];
obj.lumpy = \[dq]woof\[dq];
\f[B]delete\f[R] obj.prop;

\f[I]// Freeze.\f[R]
\f[B]const\f[R] o = Object.freeze(obj);

\f[I]// The return value is just the same object we passed in.\f[R]
o === obj; \f[I]// true\f[R]

\f[I]// The object has become frozen.\f[R]
Object.isFrozen(obj); \f[I]// === true\f[R]

\f[I]// Now any changes will fail\f[R]
obj.foo = \[dq]quux\[dq]; \f[I]// silently does nothing\f[R]
\f[I]// silently doesn\[aq]t add the property\f[R]
obj.quaxxor = \[dq]the friendly duck\[dq];

\f[I]// In strict mode such attempts will throw TypeErrors\f[R]
\f[B]function\f[R] fail() {
  \[dq]use strict\[dq];
  obj.foo = \[dq]sparky\[dq]; \f[I]// throws a TypeError\f[R]
  \f[B]delete\f[R] obj.foo; \f[I]// throws a TypeError\f[R]
  \f[B]delete\f[R] obj.quaxxor; \f[I]// returns true since attribute \[aq]quaxxor\[aq] was never added\f[R]
  obj.sparky = \[dq]arf\[dq]; \f[I]// throws a TypeError\f[R]
}

fail();

\f[I]// Attempted changes through Object.defineProperty;\f[R]
\f[I]// both statements below throw a TypeError.\f[R]
Object.defineProperty(obj, \[dq]ohai\[dq], { value: 17 });
Object.defineProperty(obj, \[dq]foo\[dq], { value: \[dq]eit\[dq] });

\f[I]// It\[aq]s also impossible to change the prototype\f[R]
\f[I]// both statements below will throw a TypeError.\f[R]
Object.setPrototypeOf(obj, { x: 20 });
obj.__proto__ = { x: 20 };
.EE
.SS Freezing arrays
.IP
.EX
\f[B]const\f[R] a = [0];
Object.freeze(a); \f[I]// The array cannot be modified now.\f[R]

a[0] = 1; \f[I]// fails silently\f[R]

\f[I]// In strict mode such attempt will throw a TypeError\f[R]
\f[B]function\f[R] fail() {
  \[dq]use strict\[dq];
  a[0] = 1;
}

fail();

\f[I]// Attempted to push\f[R]
a.push(2); \f[I]// throws a TypeError\f[R]
.EE
.PP
The object being frozen is \f[I]immutable\f[R].
However, it is not necessarily \f[I]constant\f[R].
The following example shows that a frozen object is not constant (freeze
is shallow).
.IP
.EX
\f[B]const\f[R] obj1 = {
  internal: {},
};

Object.freeze(obj1);
obj1.internal.a = \[dq]aValue\[dq];

obj1.internal.a; \f[I]// \[aq]aValue\[aq]\f[R]
.EE
.PP
To be a constant object, the entire reference graph (direct and indirect
references to other objects) must reference only immutable frozen
objects.
The object being frozen is said to be immutable because the entire
object \f[I]state\f[R] (values and references to other objects) within
the whole object is fixed.
Note that strings, numbers, and booleans are always immutable and that
Functions and Arrays are objects.
.SS Deep freezing
The result of calling \f[CR]Object.freeze(object)\f[R] only applies to
the immediate properties of \f[CR]object\f[R] itself and will prevent
future property addition, removal or value re\-assignment operations
\f[I]only\f[R] on \f[CR]object\f[R].
If the value of those properties are objects themselves, those objects
are not frozen and may be the target of property addition, removal or
value re\-assignment operations.
.IP
.EX
\f[B]const\f[R] employee = {
  name: \[dq]Mayank\[dq],
  designation: \[dq]Developer\[dq],
  address: {
    street: \[dq]Rohini\[dq],
    city: \[dq]Delhi\[dq],
  },
};

Object.freeze(employee);

employee.name = \[dq]Dummy\[dq]; \f[I]// fails silently in non\-strict mode\f[R]
employee.address.city = \[dq]Noida\[dq]; \f[I]// attributes of child object can be modified\f[R]

console.log(employee.address.city); \f[I]// \[dq]Noida\[dq]\f[R]
.EE
.PP
To make an object immutable, recursively freeze each non\-primitive
property (deep freeze).
Use the pattern on a case\-by\-case basis based on your design when you
know the object contains no \c
.UR https://en.wikipedia.org/wiki/Cycle_(graph_theory)
cycles
.UE \c
\ in the reference graph, otherwise an endless loop will be triggered.
For example, functions created with the \f[CR]function\f[R] syntax have
a \f[CR]prototype\f[R] property with a \f[CR]constructor\f[R] property
that points to the function itself, so they have cycles by default.
Other functions, such as arrow functions, can still be frozen.
.PP
An enhancement to \f[CR]deepFreeze()\f[R] would be to store the objects
it has already visited, so you can suppress calling
\f[CR]deepFreeze()\f[R] recursively when an object is in the process of
being made immutable.
For one example, see using \f[CR]WeakSet\f[R] to detect circular
references.
You still run a risk of freezing an object that shouldn\[cq]t be frozen,
such as \f[CR]window\f[R].
.IP
.EX
\f[B]function\f[R] deepFreeze(object) {
  \f[I]// Retrieve the property names defined on object\f[R]
  \f[B]const\f[R] propNames = Reflect.ownKeys(object);

  \f[I]// Freeze properties before freezing self\f[R]
  \f[B]for\f[R] (\f[B]const\f[R] name \f[B]of\f[R] propNames) {
    \f[B]const\f[R] value = object[name];

    \f[B]if\f[R] ((value && \f[B]typeof\f[R] value === \[dq]object\[dq]) || \f[B]typeof\f[R] value === \[dq]function\[dq]) {
      deepFreeze(value);
    }
  }

  \f[B]return\f[R] Object.freeze(object);
}

\f[B]const\f[R] obj2 = {
  internal: {
    a: \f[B]null\f[R],
  },
};

deepFreeze(obj2);

obj2.internal.a = \[dq]anotherValue\[dq]; \f[I]// fails silently in non\-strict mode\f[R]
obj2.internal.a; \f[I]// null\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Object.isFrozen()\f[R]
.IP \[bu] 2
\f[CR]Object.preventExtensions()\f[R]
.IP \[bu] 2
\f[CR]Object.isExtensible()\f[R]
.IP \[bu] 2
\f[CR]Object.seal()\f[R]
.IP \[bu] 2
\f[CR]Object.isSealed()\f[R]
