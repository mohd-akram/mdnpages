.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "ArrayBuffer" "JS" "July 15, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ArrayBuffer \- ArrayBuffer
.SH SYNOPSIS
The \f[B]\f[CB]ArrayBuffer\f[B]\f[R] object is used to represent a
generic raw binary data buffer.
.PP
It is an array of bytes, often referred to in other languages as a
\[lq]byte array\[rq].
You cannot directly manipulate the contents of an
\f[CR]ArrayBuffer\f[R]; instead, you create one of the typed array
objects or a \f[CR]DataView\f[R] object which represents the buffer in a
specific format, and use that to read and write the contents of the
buffer.
.PP
The \f[CR]ArrayBuffer()\f[R] constructor creates a new
\f[CR]ArrayBuffer\f[R] of the given length in bytes.
You can also get an array buffer from existing data, for example, from a
Base64 string or from a local file.
.PP
\f[CR]ArrayBuffer\f[R] is a transferable object.
.SH DESCRIPTION
.SS Resizing ArrayBuffers
\f[CR]ArrayBuffer\f[R] objects can be made resizable by including the
\f[CR]maxByteLength\f[R] option when calling the
\f[CR]ArrayBuffer()\f[R] constructor.
You can query whether an \f[CR]ArrayBuffer\f[R] is resizable and what
its maximum size is by accessing its \f[CR]resizable\f[R] and
\f[CR]maxByteLength\f[R] properties, respectively.
You can assign a new size to a resizable \f[CR]ArrayBuffer\f[R] with a
\f[CR]resize()\f[R] call.
New bytes are initialized to 0.
.PP
These features make resizing \f[CR]ArrayBuffer\f[R]s more efficient
\[em] otherwise, you have to make a copy of the buffer with a new size.
It also gives JavaScript parity with WebAssembly in this regard (Wasm
linear memory can be resized with
\f[CR]WebAssembly.Memory.prototype.grow()\f[R]).
.SS Transferring ArrayBuffers
\f[CR]ArrayBuffer\f[R] objects can be transferred between different
execution contexts, like Web Workers or Service Workers, using the
structured clone algorithm.
This is done by passing the \f[CR]ArrayBuffer\f[R] as a transferable
object in a call to \f[CR]Worker.postMessage()\f[R] or
\f[CR]ServiceWorker.postMessage()\f[R].
In pure JavaScript, you can also transfer the ownership of memory from
one \f[CR]ArrayBuffer\f[R] to another using its \f[CR]transfer()\f[R] or
\f[CR]transferToFixedLength()\f[R] method.
.PP
When an \f[CR]ArrayBuffer\f[R] is transferred, its original copy becomes
\f[I]detached\f[R] \[em] this means it is no longer usable.
At any moment, there will only be one copy of the \f[CR]ArrayBuffer\f[R]
that actually has access to the underlying memory.
Detached buffers have the following behaviors:
.IP \[bu] 2
\f[CR]byteLength\f[R] becomes 0 (in both the buffer and the associated
typed array views).
.IP \[bu] 2
Methods, such as \f[CR]resize()\f[R] and \f[CR]slice()\f[R], throw a
\f[CR]TypeError\f[R] when invoked.
The associated typed array views\[cq] methods also throw a
\f[CR]TypeError\f[R].
.PP
You can check whether an \f[CR]ArrayBuffer\f[R] is detached by its
\f[CR]detached\f[R] property.
.SH CONSTRUCTOR
.TP
\f[B]ArrayBuffer()\f[R]
Creates a new \f[CR]ArrayBuffer\f[R] object.
.SH STATIC PROPERTIES
.TP
\f[B]ArrayBuffer[Symbol.species]\f[R]
The constructor function that is used to create derived objects.
.SH STATIC METHODS
.TP
\f[B]ArrayBuffer.isView()\f[R]
Returns \f[CR]true\f[R] if \f[CR]arg\f[R] is one of the ArrayBuffer
views, such as typed array objects or a \f[CR]DataView\f[R].
Returns \f[CR]false\f[R] otherwise.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]ArrayBuffer.prototype\f[R] and
shared by all \f[CR]ArrayBuffer\f[R] instances.
.TP
\f[B]ArrayBuffer.prototype.byteLength\f[R]
The size, in bytes, of the \f[CR]ArrayBuffer\f[R].
This is established when the array is constructed and can only be
changed using the \f[CR]ArrayBuffer.prototype.resize()\f[R] method if
the \f[CR]ArrayBuffer\f[R] is resizable.
.TP
\f[B]ArrayBuffer.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]ArrayBuffer\f[R] instances, the initial value is the
\f[CR]ArrayBuffer\f[R] constructor.
.TP
\f[B]ArrayBuffer.prototype.detached\f[R]
Read\-only.
Returns \f[CR]true\f[R] if the \f[CR]ArrayBuffer\f[R] has been detached
(transferred), or \f[CR]false\f[R] if not.
.TP
\f[B]ArrayBuffer.prototype.maxByteLength\f[R]
The read\-only maximum length, in bytes, that the \f[CR]ArrayBuffer\f[R]
can be resized to.
This is established when the array is constructed and cannot be changed.
.TP
\f[B]ArrayBuffer.prototype.resizable\f[R]
Read\-only.
Returns \f[CR]true\f[R] if the \f[CR]ArrayBuffer\f[R] can be resized, or
\f[CR]false\f[R] if not.
.TP
\f[B]ArrayBuffer.prototype[Symbol.toStringTag]\f[R]
The initial value of the \f[CR][Symbol.toStringTag]\f[R] property is the
string \f[CR]\[dq]ArrayBuffer\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH INSTANCE METHODS
.TP
\f[B]ArrayBuffer.prototype.resize()\f[R]
Resizes the \f[CR]ArrayBuffer\f[R] to the specified size, in bytes.
.TP
\f[B]ArrayBuffer.prototype.slice()\f[R]
Returns a new \f[CR]ArrayBuffer\f[R] whose contents are a copy of this
\f[CR]ArrayBuffer\f[R]\[cq]s bytes from \f[CR]begin\f[R] (inclusive) up
to \f[CR]end\f[R] (exclusive).
If either \f[CR]begin\f[R] or \f[CR]end\f[R] is negative, it refers to
an index from the end of the array, as opposed to from the beginning.
.TP
\f[B]ArrayBuffer.prototype.transfer()\f[R]
Creates a new \f[CR]ArrayBuffer\f[R] with the same byte content as this
buffer, then detaches this buffer.
.TP
\f[B]ArrayBuffer.prototype.transferToFixedLength()\f[R]
Creates a new non\-resizable \f[CR]ArrayBuffer\f[R] with the same byte
content as this buffer, then detaches this buffer.
.SH EXAMPLES
.SS Creating an ArrayBuffer
In this example, we create a 8\-byte buffer with a \f[CR]Int32Array\f[R]
view referring to the buffer:
.IP
.EX
\f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(8);
\f[B]const\f[R] view = \f[B]new\f[R] Int32Array(buffer);
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-typed-arrays
Polyfill of \f[CR]ArrayBuffer\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
JavaScript typed arrays guide
.IP \[bu] 2
\f[CR]SharedArrayBuffer\f[R]
.IP \[bu] 2
RangeError: invalid array length
