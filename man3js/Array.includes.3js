.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ARRAY.INCLUDES" "3JS" "March 14, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.includes \- Array.prototype.includes()
.SH SYNOPSIS
The \f[B]\f[CB]includes()\f[B]\f[R] method of \f[CR]Array\f[R] instances
determines whether an array includes a certain value among its entries,
returning \f[CR]true\f[R] or \f[CR]false\f[R] as appropriate.
.IP
.EX
\f[B]const\f[R] array1 = [1, 2, 3];

console.log(array1.includes(2));
\f[I]// Expected output: true\f[R]

\f[B]const\f[R] pets = [\(dqcat\(dq, \(dqdog\(dq, \(dqbat\(dq];

console.log(pets.includes(\(dqcat\(dq));
\f[I]// Expected output: true\f[R]

console.log(pets.includes(\(dqat\(dq));
\f[I]// Expected output: false\f[R]
.EE
.SH SYNTAX
.IP
.EX
includes(searchElement)
includes(searchElement, fromIndex)
.EE
.SS Parameters
.TP
\f[B]searchElement\f[R]
The value to search for.
.TP
\f[B]fromIndex\f[R] \f[I](optional)\f[R]
Zero\-based index at which to start searching, converted to an integer.
.RS
.IP \(bu 2
Negative index counts back from the end of the array \(em if
\f[CR]\-array.length <= fromIndex < 0\f[R],
\f[CR]fromIndex + array.length\f[R] is used.
However, the array is still searched from front to back in this case.
.IP \(bu 2
If \f[CR]fromIndex < \-array.length\f[R] or \f[CR]fromIndex\f[R] is
omitted, \f[CR]0\f[R] is used, causing the entire array to be searched.
.IP \(bu 2
If \f[CR]fromIndex >= array.length\f[R], the array is not searched and
\f[CR]false\f[R] is returned.
.RE
.SS Return value
A boolean value which is \f[CR]true\f[R] if the value
\f[CR]searchElement\f[R] is found within the array (or the part of the
array indicated by the index \f[CR]fromIndex\f[R], if specified).
.SH DESCRIPTION
The \f[CR]includes()\f[R] method compares \f[CR]searchElement\f[R] to
elements of the array using the SameValueZero algorithm.
Values of zero are all considered to be equal, regardless of sign.
(That is, \f[CR]\-0\f[R] is equal to \f[CR]0\f[R]), but \f[CR]false\f[R]
is \f[I]not\f[R] considered to be the same as \f[CR]0\f[R].
\f[CR]NaN\f[R] can be correctly searched for.
.PP
When used on sparse arrays, the \f[CR]includes()\f[R] method iterates
empty slots as if they have the value \f[CR]undefined\f[R].
.PP
The \f[CR]includes()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
.SH EXAMPLES
.SS Using includes()
.IP
.EX
[1, 2, 3].includes(2); \f[I]// true\f[R]
[1, 2, 3].includes(4); \f[I]// false\f[R]
[1, 2, 3].includes(3, 3); \f[I]// false\f[R]
[1, 2, 3].includes(3, \-1); \f[I]// true\f[R]
[1, 2, \f[B]NaN\f[R]].includes(\f[B]NaN\f[R]); \f[I]// true\f[R]
[\(dq1\(dq, \(dq2\(dq, \(dq3\(dq].includes(3); \f[I]// false\f[R]
.EE
.SS fromIndex is greater than or equal to the array length
If \f[CR]fromIndex\f[R] is greater than or equal to the length of the
array, \f[CR]false\f[R] is returned.
The array will not be searched.
.IP
.EX
\f[B]const\f[R] arr = [\(dqa\(dq, \(dqb\(dq, \(dqc\(dq];

arr.includes(\(dqc\(dq, 3); \f[I]// false\f[R]
arr.includes(\(dqc\(dq, 100); \f[I]// false\f[R]
.EE
.SS Computed index is less than 0
If \f[CR]fromIndex\f[R] is negative, the computed index is calculated to
be used as a position in the array at which to begin searching for
\f[CR]searchElement\f[R].
If the computed index is less than or equal to \f[CR]0\f[R], the entire
array will be searched.
.IP
.EX
\f[I]// array length is 3\f[R]
\f[I]// fromIndex is \-100\f[R]
\f[I]// computed index is 3 + (\-100) = \-97\f[R]

\f[B]const\f[R] arr = [\(dqa\(dq, \(dqb\(dq, \(dqc\(dq];

arr.includes(\(dqa\(dq, \-100); \f[I]// true\f[R]
arr.includes(\(dqb\(dq, \-100); \f[I]// true\f[R]
arr.includes(\(dqc\(dq, \-100); \f[I]// true\f[R]
arr.includes(\(dqa\(dq, \-2); \f[I]// false\f[R]
.EE
.SS Using includes() on sparse arrays
You can search for \f[CR]undefined\f[R] in a sparse array and get
\f[CR]true\f[R].
.IP
.EX
console.log([1, , 3].includes(\f[B]undefined\f[R])); \f[I]// true\f[R]
.EE
.SS Calling includes() on non\-array objects
The \f[CR]includes()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R] and then accesses each property whose key is a
nonnegative integer less than \f[CR]length\f[R].
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
  3: 1, \f[I]// ignored by includes() since length is 3\f[R]
};
console.log(Array.prototype.includes.call(arrayLike, 2));
\f[I]// true\f[R]
console.log(Array.prototype.includes.call(arrayLike, 1));
\f[I]// false\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype.includes\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/array-includes
es\-shims polyfill of \f[CR]Array.prototype.includes\f[R]
.UE \c
.IP \(bu 2
Indexed collections guide
.IP \(bu 2
\f[CR]Array\f[R]
.IP \(bu 2
\f[CR]Array.prototype.indexOf()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.find()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.findIndex()\f[R]
.IP \(bu 2
\f[CR]TypedArray.prototype.includes()\f[R]
.IP \(bu 2
\f[CR]String.prototype.includes()\f[R]
