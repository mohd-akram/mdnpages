.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ARRAY.SYMBOL.ITERATOR" "3JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.Symbol.iterator \- Array.prototypeSymbol.iterator
.SH SYNOPSIS
The \f[B]\f[CB][Symbol.iterator]()\f[B]\f[R] method of \f[CR]Array\f[R]
instances implements the iterable protocol and allows arrays to be
consumed by most syntaxes expecting iterables, such as the spread syntax
and \f[CR]for...of\f[R] loops.
It returns an array iterator object that yields the value of each index
in the array.
.PP
The initial value of this property is the same function object as the
initial value of the \f[CR]Array.prototype.values\f[R] property.
.IP
.EX
\f[B]const\f[R] array1 = [\(dqa\(dq, \(dqb\(dq, \(dqc\(dq];
\f[B]const\f[R] iterator1 = array1[Symbol.iterator]();

\f[B]for\f[R] (\f[B]const\f[R] value \f[B]of\f[R] iterator1) {
  console.log(value);
}

\f[I]// Expected output: \(dqa\(dq\f[R]
\f[I]// Expected output: \(dqb\(dq\f[R]
\f[I]// Expected output: \(dqc\(dq\f[R]
.EE
.SH SYNTAX
.IP
.EX
array[Symbol.iterator]()
.EE
.SS Parameters
None.
.SS Return value
The same return value as \f[CR]Array.prototype.values()\f[R]: a new
iterable iterator object that yields the value of each index in the
array.
.SH EXAMPLES
.SS Iteration using for\&...of loop
Note that you seldom need to call this method directly.
The existence of the \f[CR][Symbol.iterator]()\f[R] method makes arrays
iterable, and iterating syntaxes like the \f[CR]for...of\f[R] loop
automatically call this method to obtain the iterator to loop over.
.SS HTML
.IP
.EX
<\f[B]ul\f[R] id=\(dqletterResult\(dq></\f[B]ul\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] arr = [\(dqa\(dq, \(dqb\(dq, \(dqc\(dq];
\f[B]const\f[R] letterResult = document.getElementById(\(dqletterResult\(dq);
\f[B]for\f[R] (\f[B]const\f[R] letter \f[B]of\f[R] arr) {
  \f[B]const\f[R] li = document.createElement(\(dqli\(dq);
  li.textContent = letter;
  letterResult.appendChild(li);
}
.EE
.SS Result
.SS Manually hand\-rolling the iterator
You may still manually call the \f[CR]next()\f[R] method of the returned
iterator object to achieve maximum control over the iteration process.
.IP
.EX
\f[B]const\f[R] arr = [\(dqa\(dq, \(dqb\(dq, \(dqc\(dq, \(dqd\(dq, \(dqe\(dq];
\f[B]const\f[R] arrIter = arr[Symbol.iterator]();
console.log(arrIter.next().value); \f[I]// a\f[R]
console.log(arrIter.next().value); \f[I]// b\f[R]
console.log(arrIter.next().value); \f[I]// c\f[R]
console.log(arrIter.next().value); \f[I]// d\f[R]
console.log(arrIter.next().value); \f[I]// e\f[R]
.EE
.SS Handling strings and string arrays with the same function
Because both strings and arrays implement the iterable protocol, a
generic function can be designed to handle both inputs in the same
fashion.
This is better than calling \f[CR]Array.prototype.values()\f[R]
directly, which requires the input to be an array, or at least an object
with such a method.
.IP
.EX
\f[B]function\f[R] logIterable(it) {
  \f[B]if\f[R] (\f[B]typeof\f[R] it[Symbol.iterator] !== \(dqfunction\(dq) {
    console.log(it, \(dqis not iterable.\(dq);
    \f[B]return\f[R];
  }
  \f[B]for\f[R] (\f[B]const\f[R] letter \f[B]of\f[R] it) {
    console.log(letter);
  }
}

\f[I]// Array\f[R]
logIterable([\(dqa\(dq, \(dqb\(dq, \(dqc\(dq]);
\f[I]// a\f[R]
\f[I]// b\f[R]
\f[I]// c\f[R]

\f[I]// String\f[R]
logIterable(\(dqabc\(dq);
\f[I]// a\f[R]
\f[I]// b\f[R]
\f[I]// c\f[R]

\f[I]// Number\f[R]
logIterable(123);
\f[I]// 123 is not iterable.\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype[Symbol.iterator]\f[R] in
\f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
Indexed collections guide
.IP \(bu 2
\f[CR]Array\f[R]
.IP \(bu 2
\f[CR]Array.prototype.keys()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.entries()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.values()\f[R]
.IP \(bu 2
\f[CR]TypedArray.prototype[Symbol.iterator]()\f[R]
.IP \(bu 2
\f[CR]String.prototype[Symbol.iterator]()\f[R]
.IP \(bu 2
\f[CR]Symbol.iterator\f[R]
.IP \(bu 2
Iteration protocols
