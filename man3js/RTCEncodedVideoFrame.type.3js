.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "RTCEncodedVideoFrame.type" "JS" "April 23, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCEncodedVideoFrame.type \- RTCEncodedVideoFrame: type property
.SH SYNOPSIS
This feature is available in Dedicated Web Workers.
.PP
The readonly \f[B]\f[CB]type\f[B]\f[R] property of the
\f[CR]RTCEncodedVideoFrame\f[R] interface indicates whether this frame
is a key frame, delta frame, or empty frame.
.SH VALUE
The type can have one of the following values:
.TP
\f[B]key\f[R]
This is a \[lq]key frame\[rq], which contains all the information needed
to render an image.
It can be decoded without reference to any other frames.
.TP
\f[B]delta\f[R]
This is a \[lq]delta frame\[rq], which contains changes to an image
relative to some previous frame.
The frame cannot be decoded without access to the frame(s) that it
references.
.TP
\f[B]empty\f[R]
This frame contains no data.
This value is unexpected, and may indicate that the transform is holding
a reference to frames after they have been transformed and piped to
\f[CR]RTCRtpScriptTransformer.writable\f[R] (after transferring back to
the main\-thread WebRTC pipeline the worker side frame object will have
no data).
.SH EXAMPLES
The implementation of a \f[CR]transform()\f[R] function in a WebRTC
Encoded Transform can look at the \f[CR]type\f[R] and modify the
transform code based on whether it is dealing with a key frame or delta
frame:
.IP
.EX
\f[B]const\f[R] transformer = \f[B]new\f[R] TransformStream({
  transform: \f[B]async\f[R] (encodedFrame, controller) \f[B]=>\f[R] {
    \f[B]if\f[R] (encodedFrame.type === \[dq]key\[dq]) {
      \f[I]// Apply key frame transformation\f[R]
    } \f[B]else\f[R] \f[B]if\f[R] (encodedFrame.type === \[dq]delta\[dq]) {
      \f[I]// Apply delta frame transformation\f[R]
    } \f[B]else\f[R] {
      \f[I]// Empty\f[R]
      \f[I]// Check transform is not holding reference to frames after processing!\f[R]
    }
    controller.enqueue(encodedFrame);
  },
});
.EE
.SH SEE ALSO
.IP \[bu] 2
Using WebRTC Encoded Transforms
