.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "WEBGLRENDERINGCONTEXT.MAKEXRCOMPATIBLE" "3JS" "September 28, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
WebGLRenderingContext.makeXRCompatible \- WebGLRenderingContext:
makeXRCompatible() method
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[CR]WebGLRenderingContext\f[R] method
\f[B]\f[CB]makeXRCompatible()\f[B]\f[R] ensures that the rendering
context described by the \f[CR]WebGLRenderingContext\f[R] is ready to
render the scene for the immersive WebXR device on which it will be
displayed.
If necessary, the WebGL layer may reconfigure the context to be ready to
render to a different device than it originally was.
.PP
This is useful if you have an application which can start out being
presented on a standard 2D display but can then be transitioned to a 3D
immersion system.
.SH SYNTAX
.IP
.EX
makeXRCompatible()
.EE
.SS Parameters
None.
.SS Return value
A \f[CR]Promise\f[R] which successfully resolves once the WebGL context
is ready to be used for rendering WebXR content.
.SS Exceptions
This method doesn\(cqt throw traditional exceptions; instead, the
promise rejects with one of the following errors as the value passed
into the rejection handler:
.TP
\f[B]AbortError\f[R] \f[B]DOMException\f[R]
Returned if switching the context over to the WebXR\-compatible context
failed.
.TP
\f[B]InvalidStateError\f[R] \f[B]DOMException\f[R]
Returned if the WebGL context has been lost or there is no available
WebXR device.
.SH USAGE NOTES
Because \f[CR]makeXRCompatible()\f[R] may involve replacing the
underlying WebGL context with a new one that uses the new rendering
hardware, the existing contents of the context may be lost and,
therefore, would need to be re\-rendered.
This is why the \f[CR]webglcontextlost\f[R] and
\f[CR]webglcontextrestored\f[R] events are used: the first gives you the
opportunity to discard anything you won\(cqt need anymore, while the
second gives you the opportunity to load resources and prepare to render
the scene in its new context.
.PP
While this method is available through the
\f[CR]WebGLRenderingContext\f[R] interface, it\(cqs actually defined by
the WebXR Device API rather than by WebGL.
.SH EXAMPLES
This example demonstrates code logic you might find in a game that
starts up using WebGL to display menus and other UI, and uses WebGL to
render gameplay, but has a button on its main menu that offers an option
to start the game in WebXR mode.
.SS HTML
The HTML for the buttons looks like this:
.IP
.EX
<\f[B]button\f[R] class=\(dqgreen button\(dq type=\(dqbutton\(dq>Start Game</\f[B]button\f[R]>
<\f[B]button\f[R] class=\(dqblue button use\-webxr\(dq type=\(dqbutton\(dq>
  Start Game (VR mode)
</\f[B]button\f[R]>
.EE
.PP
The first button starts the game, continuing to present the game
onscreen as usual.
The second button will be used to start the game in
\f[CR]immersive\-vr\f[R] mode.
Note the inclusion of a \f[CR]use\-webxr\f[R] class on the VR mode
button.
This is important, which we\(cqll explore shortly.
.SS JavaScript
The code that handles starting up graphics, switching to VR mode, and so
forth looks like this:
.IP
.EX
\f[B]const\f[R] outputCanvas = document.querySelector(\(dq.output\-canvas\(dq);
\f[B]const\f[R] gl = outputCanvas.getContext(\(dqwebgl\(dq);
\f[B]let\f[R] xrSession = \f[B]null\f[R];
\f[B]let\f[R] usingXR = \f[B]false\f[R];
\f[B]let\f[R] currentScene = \(dqscene1\(dq;
\f[B]let\f[R] glStartButton;
\f[B]let\f[R] xrStartButton;

window.addEventListener(\(dqload\(dq, (event) \f[B]=>\f[R] {
  loadSceneResources(currentScene);

  glStartButton.addEventListener(\(dqclick\(dq, handleStartButtonClick);
  xrStartButton.addEventListener(\(dqclick\(dq, handleStartButtonClick);
});

outputCanvas.addEventListener(\(dqwebglcontextlost\(dq, (event) \f[B]=>\f[R] {
  \f[I]/* The context has been lost but can be restored */\f[R]
  event.canceled = \f[B]true\f[R];
});

\f[I]/* When the GL context is reconnected, reload the resources for the\f[R]
\f[I]   current scene. */\f[R]
outputCanvas.addEventListener(\(dqwebglcontextrestored\(dq, (event) \f[B]=>\f[R] {
  loadSceneResources(currentScene);
});

\f[B]async\f[R] \f[B]function\f[R] onStartedXRSession(xrSession) {
  \f[B]try\f[R] {
    \f[B]await\f[R] gl.makeXRCompatible();
  } \f[B]catch\f[R] (err) {
    \f[B]switch\f[R] (err) {
      \f[B]case\f[R] AbortError:
        showSimpleMessageBox(
          \(dqUnable to transfer the game to your XR headset.\(dq,
          \(dqCancel\(dq,
        );
        \f[B]break\f[R];
      \f[B]case\f[R] InvalidStateError:
        showSimpleMessageBox(
          \(dqYou don\(aqt appear to have a compatible XR headset available.\(dq,
          \(dqCancel\(dq,
        );
        \f[B]break\f[R];
      \f[B]default\f[R]:
        handleFatalError(err);
        \f[B]break\f[R];
    }
    xrSession.end();
  }
}

\f[B]async\f[R] \f[B]function\f[R] handleStartButtonClick(event) {
  \f[B]if\f[R] (event.target.classList.contains(\(dquse\-webxr\(dq) && navigator.xr) {
    \f[B]try\f[R] {
      xrSession = \f[B]await\f[R] navigator.xr.requestSession(\(dqimmersive\-vr\(dq);
      usingXR = \f[B]true\f[R];
    } \f[B]catch\f[R] (err) {
      xrSession = NULL;
      usingXR = \f[B]false\f[R];
    }
  }
  startGame();
}

\f[B]function\f[R] startGame() {
  currentScene = \(dqscene1\(dq;
  loadSceneResources(currentScene);

  \f[I]/* and so on */\f[R]
}
.EE
.PP
This works by having two buttons, one which starts the game normally and
the other which starts the game in VR mode.
These both use the \f[CR]handleStartButtonClick()\f[R] function as their
event handler.
The function determines that the button clicked was the one requesting
\f[CR]immersive\-vr\f[R] mode by checking to see if the button has the
\f[CR]use\-webxr\f[R] class on it.
If the button clicked by the user has that class (and we\(cqve confirmed
that WebXR is available by ensuring that the \f[CR]navigator.xr\f[R]
property exists), we use \f[CR]requestSession()\f[R] to request a new
WebXR session and set the \f[CR]usingXR\f[R] flag to \f[CR]true\f[R].
.PP
If the other button was clicked, we ensure that \f[CR]xrSession\f[R] is
\f[CR]NULL\f[R] and clear \f[CR]usingXR\f[R] to \f[CR]false\f[R].
.PP
Then the \f[CR]startGame()\f[R] function is called to trigger the
beginning of gameplay.
.PP
Handlers are provided for both \f[CR]webglcontextlost\f[R] and
\f[CR]webglcontextrestored\f[R]; in the first case, we make sure
we\(cqre aware that the state can be recovered, while in the latter we
actually reload the scene to ensure we have the correct resources for
the current screen or headset configuration.
