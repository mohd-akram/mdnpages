'\" t
.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "PerformanceEventTiming" "JS" "November 20, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
PerformanceEventTiming \- PerformanceEventTiming
.SH SYNOPSIS
The \f[CR]PerformanceEventTiming\f[R] interface of the Event Timing API
provides insights into the latency of certain event types triggered by
user interaction.
.SH DESCRIPTION
This API enables visibility into slow events by providing event
timestamps and duration for certain event types (see below).
For example, you can monitor the time between a user action and the
start of its event handler, or the time an event handler takes to run.
.PP
This API is particularly useful for measuring the Interaction to Next
Paint (INP): the longest time (minus some outliers) from the point when
a user interacts with your app to the point until the browser was
actually able to respond to that interaction.
.PP
You typically work with \f[CR]PerformanceEventTiming\f[R] objects by
creating a \f[CR]PerformanceObserver\f[R] instance and then calling its
\f[CR]observe()\f[R] method, passing in \f[CR]\[dq]event\[dq]\f[R] or
\f[CR]\[dq]first\-input\[dq]\f[R] as the value of the \f[CR]type\f[R]
option.
The \f[CR]PerformanceObserver\f[R] object\[cq]s callback will then be
called with a list of \f[CR]PerformanceEventTiming\f[R] objects which
you can analyze.
See the example below for more.
.PP
By default, \f[CR]PerformanceEventTiming\f[R] entries are exposed when
their \f[CR]duration\f[R] is 104ms or greater.
Research suggests that user input that is not handled within 100ms is
considered slow and 104ms is the first multiple of 8 greater than 100ms
(for security reasons, this API is rounded to the nearest multiple of
8ms).
However, you can set the \f[CR]PerformanceObserver\f[R] to a different
threshold using the \f[CR]durationThreshold\f[R] option in the
\f[CR]observe()\f[R] method.
.PP
This interface inherits methods and properties from its parent,
\f[CR]PerformanceEntry\f[R]:
.SS Events exposed
The following event types are exposed by the Event Timing API:
.PP
.TS
tab(@);
l l.
T{
Click events
T}@T{
\[ga]auxclick\[ga], \[ga]click\[ga], \[ga]contextmenu\[ga],
\[ga]dblclick\[ga]
T}
T{
Composition events
T}@T{
\[ga]compositionend\[ga], \[ga]compositionstart\[ga],
\[ga]compositionupdate\[ga]
T}
T{
Drag & drop events
T}@T{
\[ga]dragend\[ga], \[ga]dragenter\[ga], \[ga]dragleave\[ga],
\[ga]dragover\[ga], \[ga]dragstart\[ga], \[ga]drop\[ga]
T}
T{
Input events
T}@T{
\[ga]beforeinput\[ga], \[ga]input\[ga]
T}
T{
Keyboard events
T}@T{
\[ga]keydown\[ga], \[ga]keypress\[ga], \[ga]keyup\[ga]
T}
T{
Mouse events
T}@T{
\[ga]mousedown\[ga], \[ga]mouseenter\[ga], \[ga]mouseleave\[ga],
\[ga]mouseout\[ga], \[ga]mouseover\[ga], \[ga]mouseup\[ga]
T}
T{
Pointer events
T}@T{
\[ga]pointerover\[ga], \[ga]pointerenter\[ga], \[ga]pointerdown\[ga],
\[ga]pointerup\[ga], \[ga]pointercancel\[ga], \[ga]pointerout\[ga],
\[ga]pointerleave\[ga], \[ga]gotpointercapture\[ga],
\[ga]lostpointercapture\[ga]
T}
T{
Touch events
T}@T{
\[ga]touchstart\[ga], \[ga]touchend\[ga], \[ga]touchcancel\[ga]
T}
.TE
.PP
Note that the following events are not included in the list because they
are continuous events and no meaningful event counts or performance
metrics can be obtained at this point: \f[CR]mousemove\f[R],
\f[CR]pointermove\f[R], \f[CR]pointerrawupdate\f[R],
\f[CR]touchmove\f[R], \f[CR]wheel\f[R], \f[CR]drag\f[R].
.PP
To get a list of all exposed events, you can also look up keys in the
\f[CR]performance.eventCounts\f[R] map:
.IP
.EX
\f[B]const\f[R] exposedEventsList = [...performance.eventCounts.keys()];
.EE
.SH CONSTRUCTOR
This interface has no constructor on its own.
See the example below for how to typically get the information the
\f[CR]PerformanceEventTiming\f[R] interface holds.
.SH INSTANCE PROPERTIES
This interface extends the following \f[CR]PerformanceEntry\f[R]
properties for event timing performance entry types by qualifying them
as follows:
.TP
\f[B]PerformanceEntry.duration\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]DOMHighResTimeStamp\f[R] representing the time from
\f[CR]startTime\f[R] to the next rendering paint (rounded to the nearest
8ms).
.TP
\f[B]PerformanceEntry.entryType\f[R] \f[I](read\-only)\f[R]
Returns \f[CR]\[dq]event\[dq]\f[R] (for long events) or
\f[CR]\[dq]first\-input\[dq]\f[R] (for the first user interaction).
.TP
\f[B]PerformanceEntry.name\f[R] \f[I](read\-only)\f[R]
Returns the associated event\[cq]s type.
.TP
\f[B]PerformanceEntry.startTime\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]DOMHighResTimeStamp\f[R] representing the associated
event\[cq]s \f[CR]timestamp\f[R] property.
This is the time the event was created and can be considered as a proxy
for the time the user interaction occurred.
.PP
This interface also supports the following properties:
.TP
\f[B]PerformanceEventTiming.cancelable\f[R] \f[I](read\-only)\f[R]
Returns the associated event\[cq]s \f[CR]cancelable\f[R] property.
.TP
\f[B]PerformanceEventTiming.interactionId\f[R] \f[I](read\-only)\f[R] \f[I](experimental)\f[R]
Returns the ID that uniquely identifies the user interaction which
triggered the associated event.
.TP
\f[B]PerformanceEventTiming.processingStart\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]DOMHighResTimeStamp\f[R] representing the time at which
event dispatch started.
To measure the time between a user action and the time the event handler
starts to run, calculate \f[CR]processingStart\-startTime\f[R].
.TP
\f[B]PerformanceEventTiming.processingEnd\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]DOMHighResTimeStamp\f[R] representing the time at which
the event dispatch ended.
To measure the time the event handler took to run, calculate
\f[CR]processingEnd\-processingStart\f[R].
.TP
\f[B]PerformanceEventTiming.target\f[R] \f[I](read\-only)\f[R]
Returns the associated event\[cq]s last target, if it is not removed.
.SH INSTANCE METHODS
.TP
\f[B]PerformanceEventTiming.toJSON()\f[R]
Returns a JSON representation of the \f[CR]PerformanceEventTiming\f[R]
object.
.SH EXAMPLES
.SS Getting event timing information
To get event timing information, create a \f[CR]PerformanceObserver\f[R]
instance and then call its \f[CR]observe()\f[R] method, passing in
\f[CR]\[dq]event\[dq]\f[R] or \f[CR]\[dq]first\-input\[dq]\f[R] as the
value of the \f[CR]type\f[R] option.
You also need to set \f[CR]buffered\f[R] to \f[CR]true\f[R] to get
access to events the user agent buffered while constructing the
document.
The \f[CR]PerformanceObserver\f[R] object\[cq]s callback will then be
called with a list of \f[CR]PerformanceEventTiming\f[R] objects which
you can analyze.
.IP
.EX
\f[B]const\f[R] observer = \f[B]new\f[R] PerformanceObserver((list) \f[B]=>\f[R] {
  list.getEntries().forEach((entry) \f[B]=>\f[R] {
    \f[I]// Full duration\f[R]
    \f[B]const\f[R] duration = entry.duration;

    \f[I]// Input delay (before processing event)\f[R]
    \f[B]const\f[R] delay = entry.processingStart \- entry.startTime;

    \f[I]// Synchronous event processing time\f[R]
    \f[I]// (between start and end dispatch)\f[R]
    \f[B]const\f[R] eventHandlerTime = entry.processingEnd \- entry.processingStart;
    console.log(\[ga]Total duration: ${duration}\[ga]);
    console.log(\[ga]Event delay: ${delay}\[ga]);
    console.log(\[ga]Event handler duration: ${eventHandlerTime}\[ga]);
  });
});

\f[I]// Register the observer for events\f[R]
observer.observe({ type: \[dq]event\[dq], buffered: \f[B]true\f[R] });
.EE
.PP
You can also set a different \f[CR]durationThreshold\f[R].
The default is 104ms and the minimum possible duration threshold is
16ms.
.IP
.EX
observer.observe({ type: \[dq]event\[dq], durationThreshold: 16, buffered: \f[B]true\f[R] });
.EE
.SH SEE ALSO
.IP \[bu] 2
Intersection Observer API
.IP \[bu] 2
Page Visibility API
