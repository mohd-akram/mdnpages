.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ARRAY.VALUES" "3JS" "March 14, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.values \- Array.prototype.values()
.SH SYNOPSIS
The \f[B]\f[CB]values()\f[B]\f[R] method of \f[CR]Array\f[R] instances
returns a new \f[I]array iterator\f[R] object that iterates the value of
each item in the array.
.IP
.EX
\f[B]const\f[R] array1 = [\(dqa\(dq, \(dqb\(dq, \(dqc\(dq];
\f[B]const\f[R] iterator = array1.values();

\f[B]for\f[R] (\f[B]const\f[R] value \f[B]of\f[R] iterator) {
  console.log(value);
}

\f[I]// Expected output: \(dqa\(dq\f[R]
\f[I]// Expected output: \(dqb\(dq\f[R]
\f[I]// Expected output: \(dqc\(dq\f[R]
.EE
.SH SYNTAX
.IP
.EX
values()
.EE
.SS Parameters
None.
.SS Return value
A new iterable iterator object.
.SH DESCRIPTION
\f[CR]Array.prototype.values()\f[R] is the default implementation of
\f[CR]Array.prototype[Symbol.iterator]()\f[R].
.IP
.EX
Array.prototype.values === Array.prototype[Symbol.iterator]; \f[I]// true\f[R]
.EE
.PP
When used on sparse arrays, the \f[CR]values()\f[R] method iterates
empty slots as if they have the value \f[CR]undefined\f[R].
.PP
The \f[CR]values()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
.SH EXAMPLES
.SS Iteration using for\&...of loop
Because \f[CR]values()\f[R] returns an iterable iterator, you can use a
\f[CR]for...of\f[R] loop to iterate it.
.IP
.EX
\f[B]const\f[R] arr = [\(dqa\(dq, \(dqb\(dq, \(dqc\(dq, \(dqd\(dq, \(dqe\(dq];
\f[B]const\f[R] iterator = arr.values();

\f[B]for\f[R] (\f[B]const\f[R] letter \f[B]of\f[R] iterator) {
  console.log(letter);
} \f[I]// \(dqa\(dq \(dqb\(dq \(dqc\(dq \(dqd\(dq \(dqe\(dq\f[R]
.EE
.SS Iteration using next()
Because the return value is also an iterator, you can directly call its
\f[CR]next()\f[R] method.
.IP
.EX
\f[B]const\f[R] arr = [\(dqa\(dq, \(dqb\(dq, \(dqc\(dq, \(dqd\(dq, \(dqe\(dq];
\f[B]const\f[R] iterator = arr.values();
iterator.next(); \f[I]// { value: \(dqa\(dq, done: false }\f[R]
iterator.next(); \f[I]// { value: \(dqb\(dq, done: false }\f[R]
iterator.next(); \f[I]// { value: \(dqc\(dq, done: false }\f[R]
iterator.next(); \f[I]// { value: \(dqd\(dq, done: false }\f[R]
iterator.next(); \f[I]// { value: \(dqe\(dq, done: false }\f[R]
iterator.next(); \f[I]// { value: undefined, done: true }\f[R]
console.log(iterator.next().value); \f[I]// undefined\f[R]
.EE
.SS Reusing the iterable
.RS
.PP
\f[B]Warning:\f[R] The array iterator object should be a one\-time use
object.
Do not reuse it.
.RE
.PP
The iterable returned from \f[CR]values()\f[R] is not reusable.
When \f[CR]next().done = true\f[R] or \f[CR]currentIndex > length\f[R],
the \f[CR]for...of\f[R] loop ends, and further iterating it has no
effect.
.IP
.EX
\f[B]const\f[R] arr = [\(dqa\(dq, \(dqb\(dq, \(dqc\(dq, \(dqd\(dq, \(dqe\(dq];
\f[B]const\f[R] values = arr.values();
\f[B]for\f[R] (\f[B]const\f[R] letter \f[B]of\f[R] values) {
  console.log(letter);
}
\f[I]// \(dqa\(dq \(dqb\(dq \(dqc\(dq \(dqd\(dq \(dqe\(dq\f[R]
\f[B]for\f[R] (\f[B]const\f[R] letter \f[B]of\f[R] values) {
  console.log(letter);
}
\f[I]// undefined\f[R]
.EE
.PP
If you use a \f[CR]break\f[R] statement to end the iteration early, the
iterator can resume from the current position when continuing to iterate
it.
.IP
.EX
\f[B]const\f[R] arr = [\(dqa\(dq, \(dqb\(dq, \(dqc\(dq, \(dqd\(dq, \(dqe\(dq];
\f[B]const\f[R] values = arr.values();
\f[B]for\f[R] (\f[B]const\f[R] letter \f[B]of\f[R] values) {
  console.log(letter);
  \f[B]if\f[R] (letter === \(dqb\(dq) {
    \f[B]break\f[R];
  }
}
\f[I]// \(dqa\(dq \(dqb\(dq\f[R]

\f[B]for\f[R] (\f[B]const\f[R] letter \f[B]of\f[R] values) {
  console.log(letter);
}
\f[I]// \(dqc\(dq \(dqd\(dq \(dqe\(dq\f[R]
.EE
.SS Mutations during iteration
There are no values stored in the array iterator object returned from
\f[CR]values()\f[R]; instead, it stores the address of the array used in
its creation, and reads the currently visited index on each iteration.
Therefore, its iteration output depends on the value stored in that
index at the time of stepping.
If the values in the array changed, the array iterator object\(cqs
values change too.
.IP
.EX
\f[B]const\f[R] arr = [\(dqa\(dq, \(dqb\(dq, \(dqc\(dq, \(dqd\(dq, \(dqe\(dq];
\f[B]const\f[R] iterator = arr.values();
console.log(iterator); \f[I]// Array Iterator { }\f[R]
console.log(iterator.next().value); \f[I]// \(dqa\(dq\f[R]
arr[1] = \(dqn\(dq;
console.log(iterator.next().value); \f[I]// \(dqn\(dq\f[R]
.EE
.PP
Unlike iterative methods, the array iterator object does not save the
array\(cqs length at the time of its creation, but reads it once on each
iteration.
Therefore, if the array grows during iteration, the iterator will visit
the new elements too.
This may lead to infinite loops.
.IP
.EX
\f[B]const\f[R] arr = [1, 2, 3];
\f[B]for\f[R] (\f[B]const\f[R] e \f[B]of\f[R] arr) {
  arr.push(e * 10);
}
\f[I]// RangeError: invalid array length\f[R]
.EE
.SS Iterating sparse arrays
\f[CR]values()\f[R] will visit empty slots as if they are
\f[CR]undefined\f[R].
.IP
.EX
\f[B]for\f[R] (\f[B]const\f[R] element \f[B]of\f[R] [, \(dqa\(dq].values()) {
  console.log(element);
}
\f[I]// undefined\f[R]
\f[I]// \(aqa\(aq\f[R]
.EE
.SS Calling values() on non\-array objects
The \f[CR]values()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R] and then accesses each property whose key is a
nonnegative integer less than \f[CR]length\f[R].
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  0: \(dqa\(dq,
  1: \(dqb\(dq,
  2: \(dqc\(dq,
  3: \(dqd\(dq, \f[I]// ignored by values() since length is 3\f[R]
};
\f[B]for\f[R] (\f[B]const\f[R] entry \f[B]of\f[R] Array.prototype.values.call(arrayLike)) {
  console.log(entry);
}
\f[I]// a\f[R]
\f[I]// b\f[R]
\f[I]// c\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype.values\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/array.prototype.values
es\-shims polyfill of \f[CR]Array.prototype.values\f[R]
.UE \c
.IP \(bu 2
Indexed collections guide
.IP \(bu 2
\f[CR]Array\f[R]
.IP \(bu 2
\f[CR]Array.prototype.entries()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.keys()\f[R]
.IP \(bu 2
\f[CR]Array.prototype[Symbol.iterator]()\f[R]
.IP \(bu 2
\f[CR]TypedArray.prototype.values()\f[R]
.IP \(bu 2
Iteration protocols
