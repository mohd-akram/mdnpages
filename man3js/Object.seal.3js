.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "OBJECT.SEAL" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.seal \- Object.seal()
.SH SYNOPSIS
The \f[B]\f[CB]Object.seal()\f[B]\f[R] static method \f[I]seals\f[R] an
object.
Sealing an object prevents extensions and makes existing properties
non\-configurable.
A sealed object has a fixed set of properties: new properties cannot be
added, existing properties cannot be removed, their enumerability and
configurability cannot be changed, and its prototype cannot be
re\-assigned.
Values of existing properties can still be changed as long as they are
writable.
\f[CR]seal()\f[R] returns the same object that was passed in.
.IP
.EX
\f[B]const\f[R] object1 = {
  property1: 42,
};

Object.seal(object1);
object1.property1 = 33;
console.log(object1.property1);
\f[I]// Expected output: 33\f[R]

\f[B]delete\f[R] object1.property1; \f[I]// Cannot delete when sealed\f[R]
console.log(object1.property1);
\f[I]// Expected output: 33\f[R]
.EE
.SH SYNTAX
.IP
.EX
Object.seal(obj)
.EE
.SS Parameters
.TP
\f[B]obj\f[R]
The object which should be sealed.
.SS Return value
The object being sealed.
.SH DESCRIPTION
Sealing an object is equivalent to preventing extensions and then
changing all existing properties\(cq descriptors to
\f[CR]configurable: false\f[R].
This has the effect of making the set of properties on the object fixed.
Making all properties non\-configurable also prevents them from being
converted from data properties to accessor properties and vice versa,
but it does not prevent the values of data properties from being
changed.
Attempting to delete or add properties to a sealed object, or to convert
a data property to accessor or vice versa, will fail, either silently or
by throwing a \f[CR]TypeError\f[R] (most commonly, although not
exclusively, when in strict mode code).
.PP
Private properties do not have the concept of property descriptors.
Private properties cannot be added or removed from the object, whether
the object is sealed or not.
.PP
The prototype chain remains untouched.
However, due to the effect of preventing extensions, the
\f[CR][[Prototype]]\f[R] cannot be reassigned.
.PP
Unlike \f[CR]Object.freeze()\f[R], objects sealed with
\f[CR]Object.seal()\f[R] may have their existing properties changed, as
long as they are writable.
.SH EXAMPLES
.SS Using Object.seal
.IP
.EX
\f[B]const\f[R] obj = {
  prop() {},
  foo: \(dqbar\(dq,
};

\f[I]// New properties may be added, existing properties\f[R]
\f[I]// may be changed or removed.\f[R]
obj.foo = \(dqbaz\(dq;
obj.lumpy = \(dqwoof\(dq;
\f[B]delete\f[R] obj.prop;

\f[B]const\f[R] o = Object.seal(obj);

o === obj; \f[I]// true\f[R]
Object.isSealed(obj); \f[I]// true\f[R]

\f[I]// Changing property values on a sealed object\f[R]
\f[I]// still works.\f[R]
obj.foo = \(dqquux\(dq;

\f[I]// But you can\(aqt convert data properties to accessors,\f[R]
\f[I]// or vice versa.\f[R]
Object.defineProperty(obj, \(dqfoo\(dq, {
  \f[B]get\f[R]() {
    \f[B]return\f[R] \(dqg\(dq;
  },
}); \f[I]// throws a TypeError\f[R]

\f[I]// Now any changes, other than to property values,\f[R]
\f[I]// will fail.\f[R]
obj.quaxxor = \(dqthe friendly duck\(dq;
\f[I]// silently doesn\(aqt add the property\f[R]
\f[B]delete\f[R] obj.foo;
\f[I]// silently doesn\(aqt delete the property\f[R]

\f[I]// \&... and in strict mode such attempts\f[R]
\f[I]// will throw TypeErrors.\f[R]
\f[B]function\f[R] fail() {
  \(dquse strict\(dq;
  \f[B]delete\f[R] obj.foo; \f[I]// throws a TypeError\f[R]
  obj.sparky = \(dqarf\(dq; \f[I]// throws a TypeError\f[R]
}
fail();

\f[I]// Attempted additions through\f[R]
\f[I]// Object.defineProperty will also throw.\f[R]
Object.defineProperty(obj, \(dqohai\(dq, {
  value: 17,
}); \f[I]// throws a TypeError\f[R]
Object.defineProperty(obj, \(dqfoo\(dq, {
  value: \(dqeit\(dq,
}); \f[I]// changes existing property value\f[R]
.EE
.SS Non\-object argument
In ES5, if the argument to this method is not an object (a primitive),
then it will cause a \f[CR]TypeError\f[R].
In ES2015, a non\-object argument will be returned as\-is without any
errors, since primitives are already, by definition, immutable.
.IP
.EX
Object.seal(1);
\f[I]// TypeError: 1 is not an object (ES5 code)\f[R]

Object.seal(1);
\f[I]// 1                             (ES2015 code)\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Object.isSealed()\f[R]
.IP \(bu 2
\f[CR]Object.preventExtensions()\f[R]
.IP \(bu 2
\f[CR]Object.isExtensible()\f[R]
.IP \(bu 2
\f[CR]Object.freeze()\f[R]
.IP \(bu 2
\f[CR]Object.isFrozen()\f[R]
