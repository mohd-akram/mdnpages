.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "INTL.SEGMENTER.SEGMENT.SEGMENTS.CONTAINING" "3JS" "March 14, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.Segmenter.segment.Segments.containing \-
Segments.prototype.containing()
.SH SYNOPSIS
The \f[B]\f[CB]containing()\f[B]\f[R] method of \f[CR]Segments\f[R]
instances returns an object describing the segment in the string that
includes the code unit at the specified index.
.IP
.EX
\f[B]const\f[R] segmenterFr = \f[B]new\f[R] Intl.Segmenter(\(dqfr\(dq, { granularity: \(dqword\(dq });
\f[B]const\f[R] string1 = \(dqQue ma joie demeure\(dq;

\f[B]const\f[R] segments = segmenterFr.segment(string1);

console.log(segments.containing(5));
\f[I]// Expected output:\f[R]
\f[I]// Object {segment: \(aqma\(aq, index: 4, input: \(aqQue ma joie demeure\(aq, isWordLike: true}\f[R]
.EE
.SH SYNTAX
.IP
.EX
containing(codeUnitIndex)
.EE
.SS Parameters
.TP
\f[B]codeUnitIndex\f[R] \f[I](optional)\f[R]
A number specifying the index of the code unit in the original input
string.
If the value is omitted, it defaults to \f[CR]0\f[R].
.SS Return value
An object describing the segment of the original string with the
following properties, or \f[CR]undefined\f[R] if the supplied index
value is out of bounds.
.TP
\f[B]segment\f[R]
A string containing the segment extracted from the original input
string.
.TP
\f[B]index\f[R]
The code unit index in the original input string at which the segment
begins.
.TP
\f[B]input\f[R]
The complete input string that was segmented.
.TP
\f[B]isWordLike\f[R]
A boolean value only if \f[CR]granularity\f[R] is
\f[CR]\(dqword\(dq\f[R]; otherwise, \f[CR]undefined\f[R].
If \f[CR]granularity\f[R] is \f[CR]\(dqword\(dq\f[R], then
\f[CR]isWordLike\f[R] is \f[CR]true\f[R] when the segment is word\-like
(i.e., consists of letters/numbers/ideographs/etc.); otherwise,
\f[CR]false\f[R].
.SH EXAMPLES
.IP
.EX
\f[I]// ┃0 1 2 3 4 5┃6┃7┃8┃9  ← code unit index\f[R]
\f[I]// ┃A l l o n s┃\-┃y┃!┃   ← code unit\f[R]
\f[B]const\f[R] input = \(dqAllons\-y!\(dq;

\f[B]const\f[R] segmenter = \f[B]new\f[R] Intl.Segmenter(\(dqfr\(dq, { granularity: \(dqword\(dq });
\f[B]const\f[R] segments = segmenter.segment(input);

\f[B]let\f[R] current = segments.containing();
\f[I]// { index: 0, segment: \(dqAllons\(dq, isWordLike: true }\f[R]

current = segments.containing(4);
\f[I]// { index: 0, segment: \(dqAllons\(dq, isWordLike: true }\f[R]

current = segments.containing(6);
\f[I]// { index: 6, segment: \(dq\-\(dq, isWordLike: false }\f[R]

current = segments.containing(current.index + current.segment.length);
\f[I]// { index: 7, segment: \(dqy\(dq, isWordLike: true }\f[R]

current = segments.containing(current.index + current.segment.length);
\f[I]// { index: 8, segment: \(dq!\(dq, isWordLike: false }\f[R]

current = segments.containing(current.index + current.segment.length);
\f[I]// undefined\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Intl.Segmenter\f[R]
.IP \(bu 2
\f[CR]Intl.Segmenter.prototype.segment()\f[R]
