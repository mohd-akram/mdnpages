.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Intl.Segmenter.segment.Segments.containing" "JS" "August 25, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.Segmenter.segment.Segments.containing \-
Segments.prototype.containing()
.SH SYNOPSIS
The \f[B]\f[CB]containing()\f[B]\f[R] method of \f[CR]Segments\f[R]
instances returns an object describing the segment in the string that
includes the code unit at the specified index.
.SH SYNTAX
.IP
.EX
containing(codeUnitIndex)
.EE
.SS Parameters
.TP
\f[B]codeUnitIndex\f[R] \f[I](optional)\f[R]
A number specifying the index of the code unit in the original input
string.
If the value is omitted, it defaults to \f[CR]0\f[R].
.SS Return value
An object describing the segment of the original string with the
following properties, or \f[CR]undefined\f[R] if the supplied index
value is out of bounds.
.TP
\f[B]segment\f[R]
A string containing the segment extracted from the original input
string.
.TP
\f[B]index\f[R]
The code unit index in the original input string at which the segment
begins.
.TP
\f[B]input\f[R]
The complete input string that was segmented.
.TP
\f[B]isWordLike\f[R]
A boolean value only if \f[CR]granularity\f[R] is
\f[CR]\[dq]word\[dq]\f[R]; otherwise, \f[CR]undefined\f[R].
If \f[CR]granularity\f[R] is \f[CR]\[dq]word\[dq]\f[R], then
\f[CR]isWordLike\f[R] is \f[CR]true\f[R] when the segment is word\-like
(i.e., consists of letters/numbers/ideographs/etc.); otherwise,
\f[CR]false\f[R].
.SH EXAMPLES
.IP
.EX
\f[I]// ┃0 1 2 3 4 5┃6┃7┃8┃9  ← code unit index\f[R]
\f[I]// ┃A l l o n s┃\-┃y┃!┃   ← code unit\f[R]
\f[B]const\f[R] input = \[dq]Allons\-y!\[dq];

\f[B]const\f[R] segmenter = \f[B]new\f[R] Intl.Segmenter(\[dq]fr\[dq], { granularity: \[dq]word\[dq] });
\f[B]const\f[R] segments = segmenter.segment(input);

\f[B]let\f[R] current = segments.containing();
\f[I]// { index: 0, segment: \[dq]Allons\[dq], isWordLike: true }\f[R]

current = segments.containing(4);
\f[I]// { index: 0, segment: \[dq]Allons\[dq], isWordLike: true }\f[R]

current = segments.containing(6);
\f[I]// { index: 6, segment: \[dq]\-\[dq], isWordLike: false }\f[R]

current = segments.containing(current.index + current.segment.length);
\f[I]// { index: 7, segment: \[dq]y\[dq], isWordLike: true }\f[R]

current = segments.containing(current.index + current.segment.length);
\f[I]// { index: 8, segment: \[dq]!\[dq], isWordLike: false }\f[R]

current = segments.containing(current.index + current.segment.length);
\f[I]// undefined\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Intl.Segmenter\f[R]
.IP \[bu] 2
\f[CR]Intl.Segmenter.prototype.segment()\f[R]
