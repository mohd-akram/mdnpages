.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ARRAY.REVERSE" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.reverse \- Array.prototype.reverse()
.SH SYNOPSIS
The \f[B]\f[CB]reverse()\f[B]\f[R] method of \f[CR]Array\f[R] instances
reverses an array \f[I]\c
.UR https://en.wikipedia.org/wiki/In-place_algorithm
in place
.UE \c
\f[R] and returns the reference to the same array, the first array
element now becoming the last, and the last array element becoming the
first.
In other words, elements order in the array will be turned towards the
direction opposite to that previously stated.
.PP
To reverse the elements in an array without mutating the original array,
use \f[CR]toReversed()\f[R].
.IP
.EX
\f[B]const\f[R] array1 = [\(dqone\(dq, \(dqtwo\(dq, \(dqthree\(dq];
console.log(\(dqarray1:\(dq, array1);
\f[I]// Expected output: \(dqarray1:\(dq Array [\(dqone\(dq, \(dqtwo\(dq, \(dqthree\(dq]\f[R]

\f[B]const\f[R] reversed = array1.reverse();
console.log(\(dqreversed:\(dq, reversed);
\f[I]// Expected output: \(dqreversed:\(dq Array [\(dqthree\(dq, \(dqtwo\(dq, \(dqone\(dq]\f[R]

\f[I]// Careful: reverse is destructive \-\- it changes the original array.\f[R]
console.log(\(dqarray1:\(dq, array1);
\f[I]// Expected output: \(dqarray1:\(dq Array [\(dqthree\(dq, \(dqtwo\(dq, \(dqone\(dq]\f[R]
.EE
.SH SYNTAX
.IP
.EX
reverse()
.EE
.SS Parameters
None.
.SS Return value
The reference to the original array, now reversed.
Note that the array is reversed \f[I]\c
.UR https://en.wikipedia.org/wiki/In-place_algorithm
in place
.UE \c
\f[R], and no copy is made.
.SH DESCRIPTION
The \f[CR]reverse()\f[R] method transposes the elements of the calling
array object in place, mutating the array, and returning a reference to
the array.
.PP
The \f[CR]reverse()\f[R] method preserves empty slots.
If the source array is sparse, the empty slots\(cq corresponding new
indices are deleted and also become empty slots.
.PP
The \f[CR]reverse()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
Although strings are also array\-like, this method is not suitable to be
applied on them, as strings are immutable.
.SH EXAMPLES
.SS Reversing the elements in an array
The following example creates an array \f[CR]items\f[R], containing
three elements, then reverses the array.
The call to \f[CR]reverse()\f[R] returns a reference to the reversed
array \f[CR]items\f[R].
.IP
.EX
\f[B]const\f[R] items = [1, 2, 3];
console.log(items); \f[I]// [1, 2, 3]\f[R]

items.reverse();
console.log(items); \f[I]// [3, 2, 1]\f[R]
.EE
.SS The reverse() method returns the reference to the same array
The \f[CR]reverse()\f[R] method returns reference to the original array,
so mutating the returned array will mutate the original array as well.
.IP
.EX
\f[B]const\f[R] numbers = [3, 2, 4, 1, 5];
\f[B]const\f[R] reversed = numbers.reverse();
\f[I]// numbers and reversed are both in reversed order [5, 1, 4, 2, 3]\f[R]
reversed[0] = 5;
console.log(numbers[0]); \f[I]// 5\f[R]
.EE
.PP
In case you want \f[CR]reverse()\f[R] to not mutate the original array,
but return a shallow\-copied array like other array methods (e.g.,
\f[CR]map()\f[R]) do, use the \f[CR]toReversed()\f[R] method.
Alternatively, you can do a shallow copy before calling
\f[CR]reverse()\f[R], using the spread syntax or
\f[CR]Array.from()\f[R].
.IP
.EX
\f[B]const\f[R] numbers = [3, 2, 4, 1, 5];
\f[I]// [...numbers] creates a shallow copy, so reverse() does not mutate the original\f[R]
\f[B]const\f[R] reverted = [...numbers].reverse();
reverted[0] = 5;
console.log(numbers[0]); \f[I]// 3\f[R]
.EE
.SS Using reverse() on sparse arrays
Sparse arrays remain sparse after calling \f[CR]reverse()\f[R].
Empty slots are copied over to their respective new indices as empty
slots.
.IP
.EX
console.log([1, , 3].reverse()); \f[I]// [3, empty, 1]\f[R]
console.log([1, , 3, 4].reverse()); \f[I]// [4, 3, empty, 1]\f[R]
.EE
.SS Calling reverse() on non\-array objects
The \f[CR]reverse()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R].
It then visits each property having an integer key between \f[CR]0\f[R]
and \f[CR]length / 2\f[R], and swaps the two corresponding indices on
both ends, deleting any destination property for which the source
property did not exist.
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  unrelated: \(dqfoo\(dq,
  2: 4,
  3: 33, \f[I]// ignored by reverse() since length is 3\f[R]
};
console.log(Array.prototype.reverse.call(arrayLike));
\f[I]// { 0: 4, 3: 33, length: 3, unrelated: \(aqfoo\(aq }\f[R]
\f[I]// The index 2 is deleted because there was no index 0 present originally\f[R]
\f[I]// The index 3 is unchanged since the length is 3\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype.reverse\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/array.prototype.reverse
es\-shims polyfill of \f[CR]Array.prototype.reverse\f[R]
.UE \c
.IP \(bu 2
Indexed collections guide
.IP \(bu 2
\f[CR]Array\f[R]
.IP \(bu 2
\f[CR]Array.prototype.join()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.sort()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.toReversed()\f[R]
.IP \(bu 2
\f[CR]TypedArray.prototype.reverse()\f[R]
