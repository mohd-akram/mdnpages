.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Math.hypot" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Math.hypot \- Math.hypot()
.SH SYNOPSIS
The \f[B]\f[CB]Math.hypot()\f[B]\f[R] static method returns the square
root of the sum of squares of its arguments.
That is,
.PP
\ 𝙼𝚊𝚝𝚑.𝚑𝚢𝚙𝚘𝚝(v1,v2,\&...,vn)=∑i=1nvi2=v12+v22+\&...+vn2 =  =  
.IP
.EX
console.log(Math.hypot(3, 4));
\f[I]// Expected output: 5\f[R]

console.log(Math.hypot(5, 12));
\f[I]// Expected output: 13\f[R]

console.log(Math.hypot(3, 4, 5));
\f[I]// Expected output: 7.0710678118654755\f[R]

console.log(Math.hypot(\-5));
\f[I]// Expected output: 5\f[R]
.EE
.SH SYNTAX
.IP
.EX
Math.hypot()
Math.hypot(value1)
Math.hypot(value1, value2)
Math.hypot(value1, value2, /* \&..., */ valueN)
.EE
.SS Parameters
.TP
\f[B]value1\f[R], \&..., \f[B]valueN\f[R]
Numbers.
.SS Return value
The square root of the sum of squares of the given arguments.
Returns \f[CR]Infinity\f[R] if any of the arguments is ±Infinity.
Otherwise, if at least one of the arguments is or is converted to
\f[CR]NaN\f[R], returns \f[CR]NaN\f[R].
Returns \f[CR]0\f[R] if no arguments are given or all arguments are ±0.
.SH DESCRIPTION
Calculating the hypotenuse of a right triangle, or the magnitude of a
complex number, uses the formula \f[CR]Math.sqrt(v1*v1 + v2*v2)\f[R],
where v1 and v2 are the lengths of the triangle\[cq]s legs, or the
complex number\[cq]s real and complex components.
The corresponding distance in 2 or more dimensions can be calculated by
adding more squares under the square root:
\f[CR]Math.sqrt(v1*v1 + v2*v2 + v3*v3 + v4*v4)\f[R].
.PP
This function makes this calculation easier and faster; you call
\f[CR]Math.hypot(v1, v2)\f[R], or
\f[CR]Math.hypot(v1, /* \&..., */, vN)\f[R].
.PP
\f[CR]Math.hypot\f[R] also avoids overflow/underflow problems if the
magnitude of your numbers is very large.
The largest number you can represent in JS is
\f[CR]Number.MAX_VALUE\f[R], which is around 10\[ha]308.
If your numbers are larger than about 10\[ha]154, taking the square of
them will result in Infinity.
For example, \f[CR]Math.sqrt(1e200*1e200 + 1e200*1e200) = Infinity\f[R].
If you use \f[CR]hypot()\f[R] instead, you get a better answer:
\f[CR]Math.hypot(1e200, 1e200) = 1.4142...e+200\f[R].
This is also true with very small numbers.
\f[CR]Math.sqrt(1e\-200*1e\-200 + 1e\-200*1e\-200) = 0\f[R], but
\f[CR]Math.hypot(1e\-200, 1e\-200) = 1.4142...e\-200\f[R].
.PP
With one argument, \f[CR]Math.hypot()\f[R] is equivalent to
\f[CR]Math.abs()\f[R].
\f[CR]Math.hypot.length\f[R] is 2, which weakly signals that it\[cq]s
designed to handle at least two parameters.
.PP
Because \f[CR]hypot()\f[R] is a static method of \f[CR]Math\f[R], you
always use it as \f[CR]Math.hypot()\f[R], rather than as a method of a
\f[CR]Math\f[R] object you created (\f[CR]Math\f[R] is not a
constructor).
.SH EXAMPLES
.SS Using Math.hypot()
.IP
.EX
Math.hypot(3, 4); \f[I]// 5\f[R]
Math.hypot(3, 4, 5); \f[I]// 7.0710678118654755\f[R]
Math.hypot(); \f[I]// 0\f[R]
Math.hypot(\f[B]NaN\f[R]); \f[I]// NaN\f[R]
Math.hypot(\f[B]NaN\f[R], \f[B]Infinity\f[R]); \f[I]// Infinity\f[R]
Math.hypot(3, 4, \[dq]foo\[dq]); \f[I]// NaN, since +\[aq]foo\[aq] => NaN\f[R]
Math.hypot(3, 4, \[dq]5\[dq]); \f[I]// 7.0710678118654755, +\[aq]5\[aq] => 5\f[R]
Math.hypot(\-3); \f[I]// 3, the same as Math.abs(\-3)\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-math
Polyfill of \f[CR]Math.hypot\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Math.abs()\f[R]
.IP \[bu] 2
\f[CR]Math.pow()\f[R]
.IP \[bu] 2
\f[CR]Math.sqrt()\f[R]
