.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Math.hypot" "JS" "September 1, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Math.hypot \- Math.hypot()
.SH SYNOPSIS
The \f[B]\f[CB]Math.hypot()\f[B]\f[R] static method returns the square
root of the sum of squares of its arguments.
That is,
.PP
ð™¼ðšŠðšðš‘.ðš‘ðš¢ðš™ðš˜ðš(v1,v2,\&...,vn)=âˆ‘i=1nvi2=v12+v22+\&...+vn2 =  =
.SH SYNTAX
.IP
.EX
Math.hypot()
Math.hypot(value1)
Math.hypot(value1, value2)
Math.hypot(value1, value2, /* \&..., */ valueN)
.EE
.SS Parameters
.TP
\f[B]value1\f[R], \&..., \f[B]valueN\f[R]
Numbers.
.SS Return value
The square root of the sum of squares of the given arguments.
Returns \f[CR]Infinity\f[R] if any of the arguments is Â±Infinity.
Otherwise, if at least one of the arguments is or is converted to
\f[CR]NaN\f[R], returns \f[CR]NaN\f[R].
Returns \f[CR]0\f[R] if no arguments are given or all arguments are Â±0.
.SH DESCRIPTION
Calculating the hypotenuse of a right triangle, or the magnitude of a
complex number, uses the formula \f[CR]Math.sqrt(v1*v1 + v2*v2)\f[R],
where v1 and v2 are the lengths of the triangle\[cq]s legs, or the
complex number\[cq]s real and complex components.
The corresponding distance in 2 or more dimensions can be calculated by
adding more squares under the square root:
\f[CR]Math.sqrt(v1*v1 + v2*v2 + v3*v3 + v4*v4)\f[R].
.PP
This function makes this calculation easier and faster; you call
\f[CR]Math.hypot(v1, v2)\f[R], or
\f[CR]Math.hypot(v1, /* \&..., */, vN)\f[R].
.PP
\f[CR]Math.hypot\f[R] also avoids overflow/underflow problems if the
magnitude of your numbers is very large.
The largest number you can represent in JS is
\f[CR]Number.MAX_VALUE\f[R], which is around 10308.
If your numbers are larger than about 10154, taking the square of them
will result in Infinity.
For example, \f[CR]Math.sqrt(1e200*1e200 + 1e200*1e200) = Infinity\f[R].
If you use \f[CR]hypot()\f[R] instead, you get a better answer:
\f[CR]Math.hypot(1e200, 1e200) = 1.4142...e+200\f[R] .
This is also true with very small numbers.
\f[CR]Math.sqrt(1e\-200*1e\-200 + 1e\-200*1e\-200) = 0\f[R], but
\f[CR]Math.hypot(1e\-200, 1e\-200) = 1.4142...e\-200\f[R].
.PP
With one argument, \f[CR]Math.hypot()\f[R] is equivalent to
\f[CR]Math.abs()\f[R].
\f[CR]Math.hypot.length\f[R] is 2, which weakly signals that it\[cq]s
designed to handle at least two parameters.
.PP
Because \f[CR]hypot()\f[R] is a static method of \f[CR]Math\f[R], you
always use it as \f[CR]Math.hypot()\f[R], rather than as a method of a
\f[CR]Math\f[R] object you created (\f[CR]Math\f[R] is not a
constructor).
.SH EXAMPLES
.SS Using Math.hypot()
.IP
.EX
Math.hypot(3, 4); // 5
Math.hypot(3, 4, 5); // 7.0710678118654755
Math.hypot(); // 0
Math.hypot(NaN); // NaN
Math.hypot(NaN, Infinity); // Infinity
Math.hypot(3, 4, \[dq]foo\[dq]); // NaN, since +\[aq]foo\[aq] => NaN
Math.hypot(3, 4, \[dq]5\[dq]); // 7.0710678118654755, +\[aq]5\[aq] => 5
Math.hypot(\-3); // 3, the same as Math.abs(\-3)
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-math
Polyfill of \f[CR]Math.hypot\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Math.abs()\f[R]
.IP \[bu] 2
\f[CR]Math.pow()\f[R]
.IP \[bu] 2
\f[CR]Math.sqrt()\f[R]
