.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "CanvasRenderingContext2D.setTransform" "JS" "June 20, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
CanvasRenderingContext2D.setTransform \- CanvasRenderingContext2D:
setTransform() method
.SH SYNOPSIS
The \f[B]\f[CB]CanvasRenderingContext2D.setTransform()\f[B]\f[R] method
of the Canvas 2D API resets (overrides) the current transformation to
the identity matrix, and then invokes a transformation described by the
arguments of this method.
This lets you scale, rotate, translate (move), and skew the context.
.RS
.PP
\f[B]Note:\f[R] See also the \f[CR]transform()\f[R] method; instead of
overriding the current transform matrix, it multiplies it with a given
one.
.RE
.SH SYNTAX
.IP
.EX
setTransform(a, b, c, d, e, f)
setTransform(matrix)
.EE
.PP
The transformation matrix is described by: [ a c e b d f 0 0 1 ]
.PP
This transformation matrix gets multiplied on the left of a column
vector representing each point being drawn on the canvas, to produce the
final coordinate used on the canvas.
.SS Parameters
\f[CR]setTransform()\f[R] has two types of parameter that it can accept.
The older type consists of several parameters representing the
individual components of the transformation matrix to set:
.TP
\f[B]a\f[R] (\f[B]m11\f[R])
The cell in the first row and first column of the matrix.
.TP
\f[B]b\f[R] (\f[B]m12\f[R])
The cell in the second row and first column of the matrix.
.TP
\f[B]c\f[R] (\f[B]m21\f[R])
The cell in the first row and second column of the matrix.
.TP
\f[B]d\f[R] (\f[B]m22\f[R])
The cell in the second row and second column of the matrix.
.TP
\f[B]e\f[R] (\f[B]m41\f[R])
The cell in the first row and third column of the matrix.
.TP
\f[B]f\f[R] (\f[B]m42\f[R])
The cell in the second row and third column of the matrix.
.PP
Alternatively, you can pass a single parameter which is an object
containing the values above as properties.
The parameter names are the property keys, and if two synonymous names
are both present (e.g.\ \f[CR]m11\f[R] and \f[CR]a\f[R]), they must be
the same number value, or a \f[CR]TypeError\f[R] will be thrown.
Using the object form allows omitting some parameters \[em] \f[CR]a\f[R]
and \f[CR]d\f[R] default to \f[CR]1\f[R], while the rest default to
\f[CR]0\f[R].
.PP
If a point originally had coordinates (x,y)(x, y), then after the
transformation it will have coordinates (ax+cy+e,bx+dy+f)(ax + cy + e,
bx + dy + f).
This means:
.IP \[bu] 2
\f[CR]e\f[R] and \f[CR]f\f[R] control the horizontal and vertical
translation of the context.
.IP \[bu] 2
When \f[CR]b\f[R] and \f[CR]c\f[R] are \f[CR]0\f[R], \f[CR]a\f[R] and
\f[CR]d\f[R] control the horizontal and vertical scaling of the context.
.IP \[bu] 2
When \f[CR]a\f[R] and \f[CR]d\f[R] are \f[CR]1\f[R], \f[CR]b\f[R] and
\f[CR]c\f[R] control the horizontal and vertical skewing of the context.
.SS Return value
None (\f[CR]undefined\f[R]).
.SH EXAMPLES
.SS Skewing a shape
This example skews a rectangle both vertically (\f[CR].2\f[R]) and
horizontally (\f[CR].8\f[R]).
Scaling and translation remain unchanged.
.SS HTML
.IP
.EX
<canvas id=\[dq]canvas\[dq]></canvas>
.EE
.SS JavaScript
.IP
.EX
const canvas = document.getElementById(\[dq]canvas\[dq]);
const ctx = canvas.getContext(\[dq]2d\[dq]);

ctx.setTransform(1, 0.2, 0.8, 1, 0, 0);
ctx.fillRect(0, 0, 100, 100);
.EE
.SS Result
.SS Retrieving and passing a DOMMatrix object
In the following example, we have two \f[CR]<canvas>\f[R] elements.
We apply a transform to the first one\[cq]s context using the first type
of \f[CR]setTransform()\f[R] and draw a square on it, then retrieve the
matrix from it using \f[CR]CanvasRenderingContext2D.getTransform()\f[R].
.PP
We then apply the retrieved matrix directly to the second canvas context
by passing the \f[CR]DOMMatrix\f[R] object directly to
\f[CR]setTransform()\f[R] (i.e.\ the second type), and draw a circle on
it.
.SS HTML
.IP
.EX
<!\-\- First canvas (ctx1) \-\->
<canvas width=\[dq]240\[dq]></canvas>
<!\-\- Second canvas (ctx2) \-\->
<canvas width=\[dq]240\[dq]></canvas>
.EE
.SS CSS
.IP
.EX
canvas {
  border: 1px solid black;
}
.EE
.SS JavaScript
.IP
.EX
const canvases = document.querySelectorAll(\[dq]canvas\[dq]);
const ctx1 = canvases[0].getContext(\[dq]2d\[dq]);
const ctx2 = canvases[1].getContext(\[dq]2d\[dq]);

ctx1.setTransform(1, 0.2, 0.8, 1, 0, 0);
ctx1.fillRect(25, 25, 50, 50);

let storedTransform = ctx1.getTransform();
console.log(storedTransform);

ctx2.setTransform(storedTransform);
ctx2.beginPath();
ctx2.arc(50, 50, 50, 0, 2 * Math.PI);
ctx2.fill();
.EE
.SS Result
.SH SEE ALSO
.IP \[bu] 2
The interface defining this method: \f[CR]CanvasRenderingContext2D\f[R]
.IP \[bu] 2
\f[CR]CanvasRenderingContext2D.transform()\f[R]
