.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "ReadableStreamBYOBRequest" "JS" "April 22, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ReadableStreamBYOBRequest \- ReadableStreamBYOBRequest
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]ReadableStreamBYOBRequest\f[B]\f[R] interface of the
Streams API represents a \[lq]pull request\[rq] for data from an
underlying source that will made as a zero\-copy transfer to a consumer
(bypassing the stream\[cq]s internal queues).
.PP
\f[CR]ReadableStreamBYOBRequest\f[R] objects are created in \[lq]BYOB
mode\[rq] when a consumer makes a request for data and the stream\[cq]s
internal queue is \f[I]empty\f[R].
(The stream will resolve the consumer\[cq]s request directly if it
already has buffered data).
An underlying byte source can access active BYOB requests through its
controller\[cq]s \f[CR]ReadableByteStreamController.byobRequest\f[R]
property, which will be set to \f[CR]null\f[R] if there is no
outstanding request.
.PP
An underlying source that supports \[lq]BYOB mode\[rq] should check for
\f[CR]ReadableByteStreamController.byobRequest\f[R] and must use it for
transferring data, if present.
If data arrives from the underlying source when
\f[CR]ReadableByteStreamController.byobRequest\f[R] is \f[CR]null\f[R],
it can be queued using
\f[CR]ReadableByteStreamController.enqueue()\f[R].
This might happen when an underlying push source receives new data when
the stream\[cq]s internal buffers are not empty.
.PP
An underlying source uses the request by writing data to the BYOB
request\[cq]s \f[CR]view\f[R] and then calling \f[CR]respond()\f[R], or
by calling \f[CR]respondWithNewView()\f[R] and passing a new view as an
argument.
Note that the \[lq]new view\[rq] must actually be a view over the
\f[I]same\f[R] buffer as the original \f[CR]view\f[R], starting at the
same offset.
This might be used to return a shorter buffer if the underlying source
is unable to fill the entire original view.
.PP
Note that a \f[CR]ReadableByteStreamController\f[R] is only created for
underlying sources when \f[CR]type=\[dq]bytes\[dq]\f[R] is specified for
the source in the \f[CR]ReadableStream()\f[R] constructor.
\[lq]BYOB mode\[rq] is enabled when either
\f[CR]autoAllocateChunkSize\f[R] is specified in the
\f[CR]ReadableController()\f[R] constructor or when using a
\f[CR]ReadableStreamBYOBReader\f[R] (typically constructed by calling
\f[CR]ReadableStream.getReader()\f[R] with the argument
\f[CR]{ mode: \[aq]byob\[aq] }\f[R]).
.SH CONSTRUCTOR
None.
\f[CR]ReadableStreamBYOBRequest\f[R] instance is created automatically
by \f[CR]ReadableByteStreamController\f[R] as needed.
.SH INSTANCE PROPERTIES
.TP
\f[B]ReadableStreamBYOBRequest.view\f[R] \f[I](read\-only)\f[R]
Returns the current view.
This is a view on a buffer that will be transferred to the consumer when
\f[CR]ReadableStreamBYOBRequest.respond()\f[R] is called.
.SH INSTANCE METHODS
.TP
\f[B]ReadableStreamBYOBRequest.respond()\f[R]
Signals the associated readable byte stream that the specified number of
bytes were written into the current \f[CR]view\f[R], which then causes
the pending request from the consumer to be resolved.
Note that after this method is called the \f[CR]view\f[R] is transferred
and no longer modifiable.
.TP
\f[B]ReadableStreamBYOBRequest.respondWithNewView()\f[R]
Signals to the associated readable byte stream view passed as an
argument should be transferred to the consumer of the readable byte
stream.
This new view must use the same buffer as the original \f[CR]view\f[R],
start at the same offset, and be the same length or shorter.
Note that after this method is called the \f[CR]view\f[R] is transferred
and no longer modifiable.
.SH EXAMPLES
The following code is taken from the live example in Using readable byte
streams > Creating a readable socket push byte stream.
.PP
A push underlying byte source with data to transfer should first check
that \f[CR]controller.byobRequest\f[R] is non\-\f[CR]null\f[R].
Pul A pull underlying byte source would only need this check if auto
chunk allocation was not enabled and it was used with a default reader.
.IP
.EX
\f[B]if\f[R] (controller.byobRequest) {
  \f[I]/* code to transfer data */\f[R]
}
.EE
.PP
There are two ways to read data into a
\f[CR]ReadableStreamBYOBRequest\f[R] and then transfer it.
The first is to write the data into the
\f[CR]ReadableStreamBYOBRequest.view\f[R] property and then call
\f[CR]ReadableStreamBYOBRequest.respond()\f[R] to indicate the amount of
data to be transferred.
After the operation the \f[CR]byobRequest.view\f[R] is detached and the
request should be discarded.
.PP
The code below shows this case using a hypothetical
\f[CR]readInto()\f[R] method to copy data into the view:
.IP
.EX
\f[B]const\f[R] v = controller.byobRequest.view;
bytesRead = socket.readInto(v.buffer, v.byteOffset, v.byteLength);
controller.byobRequest.respond(bytesRead);
.EE
.PP
The other approach is to call
\f[CR]ReadableStreamBYOBRequest.respondWithNewView()\f[R] passing your
own view on the same underlying backing data.
Note that this just another way of specifying the range of the
underlying buffer/memory backing that is actually transferred.
The \f[CR]respondWithNewView\f[R] equivalent to the code above would be:
.IP
.EX
\f[B]const\f[R] v = controller.byobRequest.view;
bytesRead = socket.readInto(v.buffer, v.byteOffset, v.byteLength);
\f[B]const\f[R] newView = \f[B]new\f[R] Uint8Array(v.buffer, v.byteOffset, bytesRead);
controller.byobRequest.respondWithNewView(newView);
.EE
.SH SEE ALSO
.IP \[bu] 2
Using readable byte stream
