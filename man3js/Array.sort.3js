'\" t
.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Array.sort" "JS" "March 15, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.sort \- Array.prototype.sort()
.SH SYNOPSIS
The \f[B]\f[CB]sort()\f[B]\f[R] method of \f[CR]Array\f[R] instances
sorts the elements of an array \f[I]\c
.UR https://en.wikipedia.org/wiki/In-place_algorithm
in place
.UE \c
\f[R] and returns the reference to the same array, now sorted.
The default sort order is ascending, built upon converting the elements
into strings, then comparing their sequences of UTF\-16 code units
values.
.PP
The time and space complexity of the sort cannot be guaranteed as it
depends on the implementation.
.PP
To sort the elements in an array without mutating the original array,
use \f[CR]toSorted()\f[R].
.SH SYNTAX
.IP
.EX
sort()
sort(compareFn)
.EE
.SS Parameters
.TP
\f[B]compareFn\f[R] \f[I](optional)\f[R]
A function that determines the order of the elements.
The function is called with the following arguments:
.RS
.TP
\f[B]a\f[R]
The first element for comparison.
Will never be \f[CR]undefined\f[R].
.TP
\f[B]b\f[R]
The second element for comparison.
Will never be \f[CR]undefined\f[R].
.PP
It should return a number where:
.IP \[bu] 2
A negative value indicates that \f[CR]a\f[R] should come before
\f[CR]b\f[R].
.IP \[bu] 2
A positive value indicates that \f[CR]a\f[R] should come after
\f[CR]b\f[R].
.IP \[bu] 2
Zero or \f[CR]NaN\f[R] indicates that \f[CR]a\f[R] and \f[CR]b\f[R] are
considered equal.
.PP
To memorize this, remember that \f[CR](a, b) => a \- b\f[R] sorts
numbers in ascending order.
.PP
If omitted, the array elements are converted to strings, then sorted
according to each character\[cq]s Unicode code point value.
.RE
.SS Return value
The reference to the original array, now sorted.
Note that the array is sorted \f[I]\c
.UR https://en.wikipedia.org/wiki/In-place_algorithm
in place
.UE \c
\f[R], and no copy is made.
.SH DESCRIPTION
If \f[CR]compareFn\f[R] is not supplied, all non\-\f[CR]undefined\f[R]
array elements are sorted by converting them to strings and comparing
strings in UTF\-16 code units order.
For example, \[lq]banana\[rq] comes before \[lq]cherry\[rq].
In a numeric sort, 9 comes before 80, but because numbers are converted
to strings, \[lq]80\[rq] comes before \[lq]9\[rq] in the Unicode order.
All \f[CR]undefined\f[R] elements are sorted to the end of the array.
.PP
The \f[CR]sort()\f[R] method preserves empty slots.
If the source array is sparse, the empty slots are moved to the end of
the array, and always come after all the \f[CR]undefined\f[R].
.RS
.PP
\f[B]Note:\f[R] In UTF\-16, Unicode characters above
\f[CR]\[rs]uFFFF\f[R] are encoded as two surrogate code units, of the
range \f[CR]\[rs]uD800\f[R] \- \f[CR]\[rs]uDFFF\f[R].
The value of each code unit is taken separately into account for the
comparison.
Thus the character formed by the surrogate pair
\f[CR]\[rs]uD855\[rs]uDE51\f[R] will be sorted before the character
\f[CR]\[rs]uFF3A\f[R].
.RE
.PP
If \f[CR]compareFn\f[R] is supplied, all non\-\f[CR]undefined\f[R] array
elements are sorted according to the return value of the compare
function (all \f[CR]undefined\f[R] elements are sorted to the end of the
array, with no call to \f[CR]compareFn\f[R]).
.PP
.TS
tab(@);
l l.
T{
\f[CR]compareFn(a, b)\f[R] return value
T}@T{
sort order
T}
_
T{
> 0
T}@T{
sort \f[CR]a\f[R] after \f[CR]b\f[R], e.g.\ \f[CR][b, a]\f[R]
T}
T{
< 0
T}@T{
sort \f[CR]a\f[R] before \f[CR]b\f[R], e.g.\ \f[CR][a, b]\f[R]
T}
T{
=== 0
T}@T{
keep original order of \f[CR]a\f[R] and \f[CR]b\f[R]
T}
.TE
.PP
So, the compare function has the following form:
.IP
.EX
function compareFn(a, b) {
  if (a is less than b by some ordering criterion) {
    return \-1;
  } else if (a is greater than b by the ordering criterion) {
    return 1;
  }
  // a must be equal to b
  return 0;
}
.EE
.PP
More formally, the comparator is expected to have the following
properties, in order to ensure proper sort behavior:
.IP \[bu] 2
\f[I]Pure\f[R]: The comparator does not mutate the objects being
compared or any external state.
(This is important because there\[cq]s no guarantee \f[I]when\f[R] and
\f[I]how\f[R] the comparator will be called, so any particular call
should not produce visible effects to the outside.)
.IP \[bu] 2
\f[I]Stable\f[R]: The comparator returns the same result with the same
pair of input.
.IP \[bu] 2
\f[I]Reflexive\f[R]: \f[CR]compareFn(a, a) === 0\f[R].
.IP \[bu] 2
\f[I]Anti\-symmetric\f[R]: \f[CR]compareFn(a, b)\f[R] and
\f[CR]compareFn(b, a)\f[R] must both be \f[CR]0\f[R] or have opposite
signs.
.IP \[bu] 2
\f[I]Transitive\f[R]: If \f[CR]compareFn(a, b)\f[R] and
\f[CR]compareFn(b, c)\f[R] are both positive, zero, or negative, then
\f[CR]compareFn(a, c)\f[R] has the same positivity as the previous two.
.PP
A comparator conforming to the constraints above will always be able to
return all of \f[CR]1\f[R], \f[CR]0\f[R], and \f[CR]\-1\f[R], or
consistently return \f[CR]0\f[R].
For example, if a comparator only returns \f[CR]1\f[R] and \f[CR]0\f[R],
or only returns \f[CR]0\f[R] and \f[CR]\-1\f[R], it will not be able to
sort reliably because \f[I]anti\-symmetry\f[R] is broken.
A comparator that always returns \f[CR]0\f[R] will cause the array to
not be changed at all, but is reliable nonetheless.
.PP
The default lexicographic comparator satisfies all constraints above.
.PP
To compare numbers instead of strings, the compare function can subtract
\f[CR]b\f[R] from \f[CR]a\f[R].
The following function will sort the array in ascending order (if it
doesn\[cq]t contain \f[CR]NaN\f[R]):
.IP
.EX
\f[B]function\f[R] compareNumbers(a, b) {
  \f[B]return\f[R] a \- b;
}
.EE
.PP
The \f[CR]sort()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
Although strings are also array\-like, this method is not suitable to be
applied on them, as strings are immutable.
.SH EXAMPLES
.SS Creating, displaying, and sorting an array
The following example creates four arrays and displays the original
array, then the sorted arrays.
The numeric arrays are sorted without a compare function, then sorted
using one.
.IP
.EX
\f[B]const\f[R] stringArray = [\[dq]Blue\[dq], \[dq]Humpback\[dq], \[dq]Beluga\[dq]];
\f[B]const\f[R] numberArray = [40, 1, 5, 200];
\f[B]const\f[R] numericStringArray = [\[dq]80\[dq], \[dq]9\[dq], \[dq]700\[dq]];
\f[B]const\f[R] mixedNumericArray = [\[dq]80\[dq], \[dq]9\[dq], \[dq]700\[dq], 40, 1, 5, 200];

\f[B]function\f[R] compareNumbers(a, b) {
  \f[B]return\f[R] a \- b;
}

stringArray.join(); \f[I]// \[aq]Blue,Humpback,Beluga\[aq]\f[R]
stringArray.sort(); \f[I]// [\[aq]Beluga\[aq], \[aq]Blue\[aq], \[aq]Humpback\[aq]]\f[R]

numberArray.join(); \f[I]// \[aq]40,1,5,200\[aq]\f[R]
numberArray.sort(); \f[I]// [1, 200, 40, 5]\f[R]
numberArray.sort(compareNumbers); \f[I]// [1, 5, 40, 200]\f[R]

numericStringArray.join(); \f[I]// \[aq]80,9,700\[aq]\f[R]
numericStringArray.sort(); \f[I]// [\[aq]700\[aq], \[aq]80\[aq], \[aq]9\[aq]]\f[R]
numericStringArray.sort(compareNumbers); \f[I]// [\[aq]9\[aq], \[aq]80\[aq], \[aq]700\[aq]]\f[R]

mixedNumericArray.join(); \f[I]// \[aq]80,9,700,40,1,5,200\[aq]\f[R]
mixedNumericArray.sort(); \f[I]// [1, 200, 40, 5, \[aq]700\[aq], \[aq]80\[aq], \[aq]9\[aq]]\f[R]
mixedNumericArray.sort(compareNumbers); \f[I]// [1, 5, \[aq]9\[aq], 40, \[aq]80\[aq], 200, \[aq]700\[aq]]\f[R]
.EE
.SS Sorting array of objects
Arrays of objects can be sorted by comparing the value of one of their
properties.
.IP
.EX
\f[B]const\f[R] items = [
  { name: \[dq]Edward\[dq], value: 21 },
  { name: \[dq]Sharpe\[dq], value: 37 },
  { name: \[dq]And\[dq], value: 45 },
  { name: \[dq]The\[dq], value: \-12 },
  { name: \[dq]Magnetic\[dq], value: 13 },
  { name: \[dq]Zeros\[dq], value: 37 },
];

\f[I]// sort by value\f[R]
items.sort((a, b) \f[B]=>\f[R] a.value \- b.value);

\f[I]// sort by name\f[R]
items.sort((a, b) \f[B]=>\f[R] {
  \f[B]const\f[R] nameA = a.name.toUpperCase(); \f[I]// ignore upper and lowercase\f[R]
  \f[B]const\f[R] nameB = b.name.toUpperCase(); \f[I]// ignore upper and lowercase\f[R]
  \f[B]if\f[R] (nameA < nameB) {
    \f[B]return\f[R] \-1;
  }
  \f[B]if\f[R] (nameA > nameB) {
    \f[B]return\f[R] 1;
  }

  \f[I]// names must be equal\f[R]
  \f[B]return\f[R] 0;
});
.EE
.SS Sorting non\-ASCII characters
For sorting strings with non\-ASCII characters, i.e.\ strings with
accented characters (e, é, è, a, ä, etc.), strings from languages other
than English, use \f[CR]String.prototype.localeCompare()\f[R].
This function can compare those characters so they appear in the right
order.
.IP
.EX
\f[B]const\f[R] items = [\[dq]réservé\[dq], \[dq]premier\[dq], \[dq]communiqué\[dq], \[dq]café\[dq], \[dq]adieu\[dq], \[dq]éclair\[dq]];
items.sort((a, b) \f[B]=>\f[R] a.localeCompare(b));

\f[I]// items is [\[aq]adieu\[aq], \[aq]café\[aq], \[aq]communiqué\[aq], \[aq]éclair\[aq], \[aq]premier\[aq], \[aq]réservé\[aq]]\f[R]
.EE
.SS Sorting with map
The \f[CR]compareFn\f[R] can be invoked multiple times per element
within the array.
Depending on the \f[CR]compareFn\f[R]\[cq]s nature, this may yield a
high overhead.
The more work a \f[CR]compareFn\f[R] does and the more elements there
are to sort, it may be more efficient to use \f[CR]map()\f[R] for
sorting.
The idea is to traverse the array once to extract the actual values used
for sorting into a temporary array, sort the temporary array, and then
traverse the temporary array to achieve the right order.
.IP
.EX
\f[I]// the array to be sorted\f[R]
\f[B]const\f[R] data = [\[dq]delta\[dq], \[dq]alpha\[dq], \[dq]charlie\[dq], \[dq]bravo\[dq]];

\f[I]// temporary array holds objects with position and sort\-value\f[R]
\f[B]const\f[R] mapped = data.map((v, i) \f[B]=>\f[R] {
  \f[B]return\f[R] { i, value: someSlowOperation(v) };
});

\f[I]// sorting the mapped array containing the reduced values\f[R]
mapped.sort((a, b) \f[B]=>\f[R] {
  \f[B]if\f[R] (a.value > b.value) {
    \f[B]return\f[R] 1;
  }
  \f[B]if\f[R] (a.value < b.value) {
    \f[B]return\f[R] \-1;
  }
  \f[B]return\f[R] 0;
});

\f[B]const\f[R] result = mapped.map((v) \f[B]=>\f[R] data[v.i]);
.EE
.PP
There is an open source library available called \c
.UR https://github.com/Pimm/mapsort
mapsort
.UE \c
\ which applies this approach.
.SS sort() returns the reference to the same array
The \f[CR]sort()\f[R] method returns a reference to the original array,
so mutating the returned array will mutate the original array as well.
.IP
.EX
\f[B]const\f[R] numbers = [3, 1, 4, 1, 5];
\f[B]const\f[R] sorted = numbers.sort((a, b) \f[B]=>\f[R] a \- b);
\f[I]// numbers and sorted are both [1, 1, 3, 4, 5]\f[R]
sorted[0] = 10;
console.log(numbers[0]); \f[I]// 10\f[R]
.EE
.PP
In case you want \f[CR]sort()\f[R] to not mutate the original array, but
return a shallow\-copied array like other array methods
(e.g.\ \f[CR]map()\f[R]) do, use the \f[CR]toSorted()\f[R] method.
Alternatively, you can do a shallow copy before calling
\f[CR]sort()\f[R], using the spread syntax or \f[CR]Array.from()\f[R].
.IP
.EX
\f[B]const\f[R] numbers = [3, 1, 4, 1, 5];
\f[I]// [...numbers] creates a shallow copy, so sort() does not mutate the original\f[R]
\f[B]const\f[R] sorted = [...numbers].sort((a, b) \f[B]=>\f[R] a \- b);
sorted[0] = 10;
console.log(numbers[0]); \f[I]// 3\f[R]
.EE
.SS Sort stability
Since version 10 (or ECMAScript 2019), the specification dictates that
\f[CR]Array.prototype.sort\f[R] is stable.
.PP
For example, say you had a list of students alongside their grades.
Note that the list of students is already pre\-sorted by name in
alphabetical order:
.IP
.EX
\f[B]const\f[R] students = [
  { name: \[dq]Alex\[dq], grade: 15 },
  { name: \[dq]Devlin\[dq], grade: 15 },
  { name: \[dq]Eagle\[dq], grade: 13 },
  { name: \[dq]Sam\[dq], grade: 14 },
];
.EE
.PP
After sorting this array by \f[CR]grade\f[R] in ascending order:
.IP
.EX
students.sort((firstItem, secondItem) \f[B]=>\f[R] firstItem.grade \- secondItem.grade);
.EE
.PP
The \f[CR]students\f[R] variable will then have the following value:
.IP
.EX
[
  { name: \[dq]Eagle\[dq], grade: 13 },
  { name: \[dq]Sam\[dq], grade: 14 },
  { name: \[dq]Alex\[dq], grade: 15 }, \f[I]// original maintained for similar grade (stable sorting)\f[R]
  { name: \[dq]Devlin\[dq], grade: 15 }, \f[I]// original maintained for similar grade (stable sorting)\f[R]
];
.EE
.PP
It\[cq]s important to note that students that have the same grade (for
example, Alex and Devlin), will remain in the same order as before
calling the sort.
This is what a stable sorting algorithm guarantees.
.PP
Before version 10 (or ECMAScript 2019), sort stability was not
guaranteed, meaning that you could end up with the following:
.IP
.EX
[
  { name: \[dq]Eagle\[dq], grade: 13 },
  { name: \[dq]Sam\[dq], grade: 14 },
  { name: \[dq]Devlin\[dq], grade: 15 }, \f[I]// original order not maintained\f[R]
  { name: \[dq]Alex\[dq], grade: 15 }, \f[I]// original order not maintained\f[R]
];
.EE
.SS Sorting with non\-well\-formed comparator
If a comparing function does not satisfy all of purity, stability,
reflexivity, anti\-symmetry, and transitivity rules, as explained in the
description, the program\[cq]s behavior is not well\-defined.
.PP
For example, consider this code:
.IP
.EX
\f[B]const\f[R] arr = [3, 1, 4, 1, 5, 9];
\f[B]const\f[R] compareFn = (a, b) \f[B]=>\f[R] (a > b ? 1 : 0);
arr.sort(compareFn);
.EE
.PP
The \f[CR]compareFn\f[R] function here is not well\-formed, because it
does not satisfy anti\-symmetry: if \f[CR]a > b\f[R], it returns
\f[CR]1\f[R]; but by swapping \f[CR]a\f[R] and \f[CR]b\f[R], it returns
\f[CR]0\f[R] instead of a negative value.
Therefore, the resulting array will be different across engines.
For example, V8 (used by Chrome, Node.js, etc.)
and JavaScriptCore (used by Safari) would not sort the array at all and
return \f[CR][3, 1, 4, 1, 5, 9]\f[R], while SpiderMonkey (used by
Firefox) will return the array sorted ascendingly, as
\f[CR][1, 1, 3, 4, 5, 9]\f[R].
.PP
However, if the \f[CR]compareFn\f[R] function is changed slightly so
that it returns \f[CR]\-1\f[R] or \f[CR]0\f[R]:
.IP
.EX
\f[B]const\f[R] arr = [3, 1, 4, 1, 5, 9];
\f[B]const\f[R] compareFn = (a, b) \f[B]=>\f[R] (a > b ? \-1 : 0);
arr.sort(compareFn);
.EE
.PP
Then V8 and JavaScriptCore sorts it descendingly, as
\f[CR][9, 5, 4, 3, 1, 1]\f[R], while SpiderMonkey returns it as\-is:
\f[CR][3, 1, 4, 1, 5, 9]\f[R].
.PP
Due to this implementation inconsistency, you are always advised to make
your comparator well\-formed by following the five constraints.
.SS Using sort() on sparse arrays
Empty slots are moved to the end of the array.
.IP
.EX
console.log([\[dq]a\[dq], \[dq]c\[dq], , \[dq]b\[dq]].sort()); \f[I]// [\[aq]a\[aq], \[aq]b\[aq], \[aq]c\[aq], empty]\f[R]
console.log([, \f[B]undefined\f[R], \[dq]a\[dq], \[dq]b\[dq]].sort()); \f[I]// [\[dq]a\[dq], \[dq]b\[dq], undefined, empty]\f[R]
.EE
.SS Calling sort() on non\-array objects
The \f[CR]sort()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R].
It then collects all existing integer\-keyed properties in the range of
\f[CR]0\f[R] to \f[CR]length \- 1\f[R], sorts them, and writes them
back.
If there are missing properties in the range, the corresponding trailing
properties are deleted, as if the non\-existent properties are sorted
towards the end.
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  unrelated: \[dq]foo\[dq],
  0: 5,
  2: 4,
};
console.log(Array.prototype.sort.call(arrayLike));
\f[I]// { \[aq]0\[aq]: 4, \[aq]1\[aq]: 5, length: 3, unrelated: \[aq]foo\[aq] }\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype.sort\f[R] with modern behavior like
stable sort in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Indexed collections guide
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.reverse()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.toSorted()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.localeCompare()\f[R]
.IP \[bu] 2
\f[CR]TypedArray.prototype.sort()\f[R]
.IP \[bu] 2
\c
.UR https://v8.dev/blog/array-sort
Getting things sorted in V8
.UE \c
\ on v8.dev (2018)
.IP \[bu] 2
\c
.UR https://v8.dev/features/stable-sort
Stable \f[CR]Array.prototype.sort\f[R]
.UE \c
\ on v8.dev (2019)
.IP \[bu] 2
\c
.UR https://mathiasbynens.be/demo/sort-stability
\f[CR]Array.prototype.sort\f[R] stability
.UE \c
\ by Mathias Bynens
