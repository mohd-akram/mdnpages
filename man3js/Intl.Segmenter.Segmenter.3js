.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Intl.Segmenter.Segmenter" "JS" "September 5, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.Segmenter.Segmenter - Intl.Segmenter() constructor
.SH SYNOPSIS
The \f[B]\f[CB]Intl.Segmenter()\f[B]\f[R] constructor creates
\f[CR]Intl.Segmenter\f[R] objects.
.SH SYNTAX
.IP
.EX
new Intl.Segmenter()
new Intl.Segmenter(locales)
new Intl.Segmenter(locales, options)
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]Intl.Segmenter()\f[R] can only be constructed with
\f[CR]new\f[R].
Attempting to call it without \f[CR]new\f[R] throws a
\f[CR]TypeError\f[R].
.RE
.SS Parameters
.TP
\f[B]locales\f[R] \f[I](optional)\f[R]
A string with a BCP 47 language tag or an \f[CR]Intl.Locale\f[R]
instance, or an array of such locale identifiers.
For the general form and interpretation of the \f[CR]locales\f[R]
argument, see the parameter description on the \f[CR]Intl\f[R] main
page.
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object containing the following properties, in the order they are
retrieved (all of them are optional):
.RS
.TP
\f[B]localeMatcher\f[R]
The locale matching algorithm to use.
Possible values are \f[CR]\[dq]lookup\[dq]\f[R] and
\f[CR]\[dq]best fit\[dq]\f[R]; the default is
\f[CR]\[dq]best fit\[dq]\f[R].
For information about this option, see Locale identification and
negotiation.
.TP
\f[B]granularity\f[R]
How granularly should the input be split.
Possible values are:
.RS
.TP
\f[B]\[dq]grapheme\[dq]\f[R] (default)
Split the input into segments at grapheme cluster (user-perceived
character) boundaries, as determined by the locale.
.TP
\f[B]\[dq]word\[dq]\f[R]
Split the input into segments at word boundaries, as determined by the
locale.
.TP
\f[B]\[dq]sentence\[dq]\f[R]
Split the input into segments at sentence boundaries, as determined by
the locale.
.RE
.RE
.SS Return value
A new \f[CR]Intl.Segmenter\f[R] instance.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]locales\f[R] or \f[CR]options\f[R] contain invalid
values.
.SH EXAMPLES
.SS Basic usage
The following example shows how to count words in a string using the
Japanese language (where splitting the string using \f[CR]String\f[R]
methods would have given an incorrect result).
.IP
.EX
const text = \[dq]吾輩は猫である。名前はたぬき。\[dq];
const japaneseSegmenter = new Intl.Segmenter(\[dq]ja-JP\[dq], { granularity: \[dq]word\[dq] });
console.log(
  [...japaneseSegmenter.segment(text)].filter((segment) => segment.isWordLike)
    .length,
);
// 8, as the text is segmented as \[aq]吾輩\[aq]|\[aq]は\[aq]|\[aq]猫\[aq]|\[aq]で\[aq]|\[aq]ある\[aq]|\[aq]。\[aq]|\[aq]名前\[aq]|\[aq]は\[aq]|\[aq]たぬき\[aq]|\[aq]。\[aq]
.EE
