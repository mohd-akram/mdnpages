.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "DataView" "JS" "January 31, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
DataView \- DataView
.SH SYNOPSIS
The \f[B]\f[CB]DataView\f[B]\f[R] view provides a low\-level interface
for reading and writing multiple number types in a binary
\f[CR]ArrayBuffer\f[R], without having to care about the platform\[cq]s
endianness.
.SH DESCRIPTION
.SS Endianness
Multi\-byte number formats are represented in memory differently
depending on machine architecture \[em] see Endianness for an
explanation.
\f[CR]DataView\f[R] accessors provide explicit control of how data is
accessed, regardless of the executing computer\[cq]s endianness.
For example, WebAssembly memory is always little\-endian, so you should
use \f[CR]DataView\f[R] instead of typed arrays to read and write
multi\-byte values.
See \f[CR]WebAssembly.Memory\f[R] for an example.
.IP
.EX
\f[B]const\f[R] littleEndian = (() \f[B]=>\f[R] {
  \f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(2);
  \f[B]new\f[R] DataView(buffer).setInt16(0, 256, \f[B]true\f[R] \f[I]/* littleEndian */\f[R]);
  \f[I]// Int16Array uses the platform\[aq]s endianness.\f[R]
  \f[B]return\f[R] \f[B]new\f[R] Int16Array(buffer)[0] === 256;
})();
console.log(littleEndian); \f[I]// true or false\f[R]
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]DataView\f[R] defaults to big\-endian read and
write, but most platforms use little\-endian.
.RE
.SH CONSTRUCTOR
.TP
\f[B]DataView()\f[R]
Creates a new \f[CR]DataView\f[R] object.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]DataView.prototype\f[R] and shared
by all \f[CR]DataView\f[R] instances.
.TP
\f[B]DataView.prototype.buffer\f[R]
The \f[CR]ArrayBuffer\f[R] referenced by this view.
Fixed at construction time and thus \f[B]read only.\f[R]
.TP
\f[B]DataView.prototype.byteLength\f[R]
The length (in bytes) of this view.
Fixed at construction time and thus \f[B]read only.\f[R]
.TP
\f[B]DataView.prototype.byteOffset\f[R]
The offset (in bytes) of this view from the start of its
\f[CR]ArrayBuffer\f[R].
Fixed at construction time and thus \f[B]read only.\f[R]
.TP
\f[B]DataView.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]DataView\f[R] instances, the initial value is the
\f[CR]DataView\f[R] constructor.
.TP
\f[B]DataView.prototype[Symbol.toStringTag]\f[R]
The initial value of the \f[CR][Symbol.toStringTag]\f[R] property is the
string \f[CR]\[dq]DataView\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH INSTANCE METHODS
.TP
\f[B]DataView.prototype.getBigInt64()\f[R]
Reads 8 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 64\-bit signed integer.
.TP
\f[B]DataView.prototype.getBigUint64()\f[R]
Reads 8 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 64\-bit unsigned integer.
.TP
\f[B]DataView.prototype.getFloat16()\f[R]
Reads 2 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 16\-bit floating point
number.
.TP
\f[B]DataView.prototype.getFloat32()\f[R]
Reads 4 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 32\-bit floating point
number.
.TP
\f[B]DataView.prototype.getFloat64()\f[R]
Reads 8 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 64\-bit floating point
number.
.TP
\f[B]DataView.prototype.getInt16()\f[R]
Reads 2 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 16\-bit signed integer.
.TP
\f[B]DataView.prototype.getInt32()\f[R]
Reads 4 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 32\-bit signed integer.
.TP
\f[B]DataView.prototype.getInt8()\f[R]
Reads 1 byte at the specified byte offset of this \f[CR]DataView\f[R]
and interprets it as an 8\-bit signed integer.
.TP
\f[B]DataView.prototype.getUint16()\f[R]
Reads 2 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 16\-bit unsigned integer.
.TP
\f[B]DataView.prototype.getUint32()\f[R]
Reads 4 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 32\-bit unsigned integer.
.TP
\f[B]DataView.prototype.getUint8()\f[R]
Reads 1 byte at the specified byte offset of this \f[CR]DataView\f[R]
and interprets it as an 8\-bit unsigned integer.
.TP
\f[B]DataView.prototype.setBigInt64()\f[R]
Takes a BigInt and stores it as a 64\-bit signed integer in the 8 bytes
starting at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setBigUint64()\f[R]
Takes a BigInt and stores it as a 64\-bit unsigned integer in the 8
bytes starting at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setFloat16()\f[R]
Takes a number and stores it as a 16\-bit float in the 2 bytes starting
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setFloat32()\f[R]
Takes a number and stores it as a 32\-bit float in the 4 bytes starting
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setFloat64()\f[R]
Takes a number and stores it as a 64\-bit float in the 8 bytes starting
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setInt16()\f[R]
Takes a number and stores it as a 16\-bit signed integer in the 2 bytes
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setInt32()\f[R]
Takes a number and stores it as a 32\-bit signed integer in the 4 bytes
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setInt8()\f[R]
Takes a number and stores it as an 8\-bit signed integer in the byte at
the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setUint16()\f[R]
Takes a number and stores it as a 16\-bit unsigned integer in the 2
bytes at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setUint32()\f[R]
Takes a number and stores it as a 32\-bit unsigned integer in the 4
bytes at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setUint8()\f[R]
Takes a number and stores it as an 8\-bit unsigned integer in the byte
at the specified byte offset of this \f[CR]DataView\f[R].
.SH EXAMPLES
.SS Using DataView
.IP
.EX
\f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(16);
\f[B]const\f[R] view = \f[B]new\f[R] DataView(buffer, 0);

view.setInt16(1, 42);
view.getInt16(1); \f[I]// 42\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-typed-arrays
Polyfill of \f[CR]DataView\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]ArrayBuffer\f[R]
.IP \[bu] 2
\f[CR]SharedArrayBuffer\f[R]
