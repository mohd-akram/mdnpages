.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "DataView" "JS" "August 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
DataView \- DataView
.SH SYNOPSIS
The \f[B]\f[CB]DataView\f[B]\f[R] view provides a low\-level interface
for reading and writing multiple number types in a binary
\f[CR]ArrayBuffer\f[R], without having to care about the platform\[cq]s
endianness.
.SH DESCRIPTION
.SS Endianness
Multi\-byte number formats are represented in memory differently
depending on machine architecture \[em] see Endianness for an
explanation.
\f[CR]DataView\f[R] accessors provide explicit control of how data is
accessed, regardless of the executing computer\[cq]s endianness.
.IP
.EX
\f[B]const\f[R] littleEndian = (() \f[B]=>\f[R] {
  \f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(2);
  \f[B]new\f[R] DataView(buffer).setInt16(0, 256, \f[B]true\f[R] \f[I]/* littleEndian */\f[R]);
  \f[I]// Int16Array uses the platform\[aq]s endianness.\f[R]
  \f[B]return\f[R] \f[B]new\f[R] Int16Array(buffer)[0] === 256;
})();
console.log(littleEndian); \f[I]// true or false\f[R]
.EE
.SS 64\-bit Integer Values
Some browsers don\[cq]t have support for
\f[CR]DataView.prototype.setBigInt64()\f[R] and
\f[CR]DataView.prototype.setBigUint64()\f[R].
So to enable 64\-bit operations in your code that will work across
browsers, you could implement your own \f[CR]getUint64()\f[R] function,
to obtain values with precision up to \f[CR]Number.MAX_SAFE_INTEGER\f[R]
\[em] which could suffice for certain cases.
.IP
.EX
\f[B]function\f[R] getUint64(dataview, byteOffset, littleEndian) {
  \f[I]// split 64\-bit number into two 32\-bit (4\-byte) parts\f[R]
  \f[B]const\f[R] left = dataview.getUint32(byteOffset, littleEndian);
  \f[B]const\f[R] right = dataview.getUint32(byteOffset + 4, littleEndian);

  \f[I]// combine the two 32\-bit values\f[R]
  \f[B]const\f[R] combined = littleEndian
    ? left + 2 ** 32 * right
    : 2 ** 32 * left + right;

  \f[B]if\f[R] (!Number.isSafeInteger(combined))
    console.warn(combined, \[dq]exceeds MAX_SAFE_INTEGER. Precision may be lost\[dq]);

  \f[B]return\f[R] combined;
}
.EE
.PP
Alternatively, if you need full 64\-bit range, you can create a
\f[CR]BigInt\f[R].
Further, although native BigInts are much faster than user\-land library
equivalents, BigInts will always be much slower than 32\-bit integers in
JavaScript due to the nature of their variable size.
.IP
.EX
\f[B]const\f[R] BigInt = window.BigInt,
  bigThirtyTwo = BigInt(32),
  bigZero = BigInt(0);
\f[B]function\f[R] getUint64BigInt(dataview, byteOffset, littleEndian) {
  \f[I]// split 64\-bit number into two 32\-bit (4\-byte) parts\f[R]
  \f[B]const\f[R] left = BigInt(dataview.getUint32(byteOffset | 0, !!littleEndian) >>> 0);
  \f[B]const\f[R] right = BigInt(
    dataview.getUint32(((byteOffset | 0) + 4) | 0, !!littleEndian) >>> 0,
  );

  \f[I]// combine the two 32\-bit values and return\f[R]
  \f[B]return\f[R] littleEndian
    ? (right << bigThirtyTwo) | left
    : (left << bigThirtyTwo) | right;
}
.EE
.SH CONSTRUCTOR
.TP
\f[B]DataView()\f[R]
Creates a new \f[CR]DataView\f[R] object.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]DataView.prototype\f[R] and shared
by all \f[CR]DataView\f[R] instances.
.TP
\f[B]DataView.prototype.buffer\f[R]
The \f[CR]ArrayBuffer\f[R] referenced by this view.
Fixed at construction time and thus \f[B]read only.\f[R]
.TP
\f[B]DataView.prototype.byteLength\f[R]
The length (in bytes) of this view.
Fixed at construction time and thus \f[B]read only.\f[R]
.TP
\f[B]DataView.prototype.byteOffset\f[R]
The offset (in bytes) of this view from the start of its
\f[CR]ArrayBuffer\f[R].
Fixed at construction time and thus \f[B]read only.\f[R]
.TP
\f[B]DataView.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]DataView\f[R] instances, the initial value is the
\f[CR]DataView\f[R] constructor.
.TP
\f[B]DataView.prototype[\[at]\[at]toStringTag]\f[R]
The initial value of the \f[CR]\[at]\[at]toStringTag\f[R] property is
the string \f[CR]\[dq]DataView\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH INSTANCE METHODS
.TP
\f[B]DataView.prototype.getBigInt64()\f[R]
Reads 8 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 64\-bit signed integer.
.TP
\f[B]DataView.prototype.getBigUint64()\f[R]
Reads 8 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 64\-bit unsigned integer.
.TP
\f[B]DataView.prototype.getFloat32()\f[R]
Reads 4 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 32\-bit floating point
number.
.TP
\f[B]DataView.prototype.getFloat64()\f[R]
Reads 8 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 64\-bit floating point
number.
.TP
\f[B]DataView.prototype.getInt16()\f[R]
Reads 2 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 16\-bit signed integer.
.TP
\f[B]DataView.prototype.getInt32()\f[R]
Reads 4 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 32\-bit signed integer.
.TP
\f[B]DataView.prototype.getInt8()\f[R]
Reads 1 byte at the specified byte offset of this \f[CR]DataView\f[R]
and interprets it as an 8\-bit signed integer.
.TP
\f[B]DataView.prototype.getUint16()\f[R]
Reads 2 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 16\-bit unsigned integer.
.TP
\f[B]DataView.prototype.getUint32()\f[R]
Reads 4 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 32\-bit unsigned integer.
.TP
\f[B]DataView.prototype.getUint8()\f[R]
Reads 1 byte at the specified byte offset of this \f[CR]DataView\f[R]
and interprets it as an 8\-bit unsigned integer.
.TP
\f[B]DataView.prototype.setBigInt64()\f[R]
Takes a BigInt and stores it as a 64\-bit signed integer in the 8 bytes
starting at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setBigUint64()\f[R]
Takes a BigInt and stores it as a 64\-bit unsigned integer in the 8
bytes starting at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setFloat32()\f[R]
Takes a number and stores it as a 32\-bit float in the 4 bytes starting
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setFloat64()\f[R]
Takes a number and stores it as a 64\-bit float in the 8 bytes starting
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setInt16()\f[R]
Takes a number and stores it as a 16\-bit signed integer in the 2 bytes
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setInt32()\f[R]
Takes a number and stores it as a 32\-bit signed integer in the 4 bytes
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setInt8()\f[R]
Takes a number and stores it as an 8\-bit signed integer in the byte at
the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setUint16()\f[R]
Takes a number and stores it as a 16\-bit unsigned integer in the 2
bytes at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setUint32()\f[R]
Takes a number and stores it as a 32\-bit unsigned integer in the 4
bytes at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setUint8()\f[R]
Takes a number and stores it as an 8\-bit unsigned integer in the byte
at the specified byte offset of this \f[CR]DataView\f[R].
.SH EXAMPLES
.SS Using DataView
.IP
.EX
\f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(16);
\f[B]const\f[R] view = \f[B]new\f[R] DataView(buffer, 0);

view.setInt16(1, 42);
view.getInt16(1); \f[I]// 42\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-typed-arrays
Polyfill of \f[CR]DataView\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]ArrayBuffer\f[R]
.IP \[bu] 2
\f[CR]SharedArrayBuffer\f[R]
