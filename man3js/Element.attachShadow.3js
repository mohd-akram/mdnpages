.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Element.attachShadow" "JS" "January 31, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Element.attachShadow \- Element: attachShadow() method
.SH SYNOPSIS
The \f[B]\f[CB]Element.attachShadow()\f[B]\f[R] method attaches a shadow
DOM tree to the specified element and returns a reference to its
\f[CR]ShadowRoot\f[R].
.SH ELEMENTS YOU CAN ATTACH A SHADOW TO
Note that you can\[cq]t attach a shadow root to every type of element.
There are some that can\[cq]t have a shadow DOM for security reasons
(for example \f[CR]<a>\f[R]).
.PP
The following is a list of elements you \f[I]can\f[R] attach a shadow
root to:
.IP \[bu] 2
Any autonomous custom element with a \c
.UR https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
valid name
.UE \c
.IP \[bu] 2
\f[CR]<article>\f[R]
.IP \[bu] 2
\f[CR]<aside>\f[R]
.IP \[bu] 2
\f[CR]<blockquote>\f[R]
.IP \[bu] 2
\f[CR]<body>\f[R]
.IP \[bu] 2
\f[CR]<div>\f[R]
.IP \[bu] 2
\f[CR]<footer>\f[R]
.IP \[bu] 2
\f[CR]h1\f[R]
.IP \[bu] 2
\f[CR]h2\f[R]
.IP \[bu] 2
\f[CR]h3\f[R]
.IP \[bu] 2
\f[CR]h4\f[R]
.IP \[bu] 2
\f[CR]h5\f[R]
.IP \[bu] 2
\f[CR]h6\f[R]
.IP \[bu] 2
\f[CR]<header>\f[R]
.IP \[bu] 2
\f[CR]<main>\f[R]
.IP \[bu] 2
\f[CR]<nav>\f[R]
.IP \[bu] 2
\f[CR]<p>\f[R]
.IP \[bu] 2
\f[CR]<section>\f[R]
.IP \[bu] 2
\f[CR]<span>\f[R]
.SH SYNTAX
.IP
.EX
attachShadow(options)
.EE
.SS Parameters
.TP
\f[B]options\f[R]
An object which contains the following fields:
.RS
.TP
\f[B]mode\f[R]
A string specifying the \f[I]encapsulation mode\f[R] for the shadow DOM
tree.
This can be one of:
.RS
.TP
\f[B]open\f[R]
Elements of the shadow root are accessible from JavaScript outside the
root, for example using \f[CR]Element.shadowRoot\f[R]:
.RS
.IP
.EX
element.attachShadow({ mode: \[dq]open\[dq] });
element.shadowRoot; \f[I]// Returns a ShadowRoot obj\f[R]
.EE
.RE
.TP
\f[B]closed\f[R]
Denies access to the node(s) of a closed shadow root from JavaScript
outside it:
.RS
.IP
.EX
element.attachShadow({ mode: \[dq]closed\[dq] });
element.shadowRoot; \f[I]// Returns null\f[R]
.EE
.RE
.RE
.TP
\f[B]clonable\f[R] \f[I](optional)\f[R]
A boolean that specifies whether the shadow root is clonable: when set
to \f[CR]true\f[R], the shadow host cloned with
\f[CR]Node.cloneNode()\f[R] or \f[CR]Document.importNode()\f[R] will
include shadow root in the copy.
Its default value is \f[CR]false\f[R], unless the shadow root is created
via declarative shadow DOM.
.TP
\f[B]delegatesFocus\f[R] \f[I](optional)\f[R]
A boolean that, when set to \f[CR]true\f[R], specifies behavior that
mitigates custom element issues around focusability.
When a non\-focusable part of the shadow DOM is clicked, the first
focusable part is given focus, and the shadow host is given any
available \f[CR]:focus\f[R] styling.
Its default value is \f[CR]false\f[R].
.TP
\f[B]slotAssignment\f[R] \f[I](optional)\f[R]
A string specifying the \f[I]slot assignment mode\f[R] for the shadow
DOM tree.
This can be one of:
.RS
.TP
\f[B]named\f[R]
Elements are automatically assigned to \f[CR]<slot>\f[R] elements within
this shadow root.
Any descendants of the host with a \f[CR]slot\f[R] attribute which
matches the \f[CR]name\f[R] attribute of a \f[CR]<slot>\f[R] within this
shadow root will be assigned to that slot.
Any top\-level children of the host with no \f[CR]slot\f[R] attribute
will be assigned to a \f[CR]<slot>\f[R] with no \f[CR]name\f[R]
attribute (the \[lq]default slot\[rq]) if one is present.
.TP
\f[B]manual\f[R]
Elements are not automatically assigned to \f[CR]<slot>\f[R] elements.
Instead, they must be manually assigned with
\f[CR]HTMLSlotElement.assign()\f[R].
Its default value is \f[CR]named\f[R].
.RE
.RE
.SS Return value
Returns a \f[CR]ShadowRoot\f[R] object.
.SS Exceptions
.TP
\f[B]InvalidStateError\f[R] \f[B]DOMException\f[R]
The element you are trying to attach to is already a shadow host.
.TP
\f[B]NotSupportedError\f[R] \f[B]DOMException\f[R]
You are trying to attach a shadow root to an element outside the HTML
namespace, the element cannot have a shadow attached to it, or the
static property \f[CR]disabledFeatures\f[R] has been given a value of
\f[CR]\[dq]shadow\[dq]\f[R] in the element definition.
.SH EXAMPLES
.SS Word count custom element
The following example is taken from our \c
.UR https://github.com/mdn/web-components-examples/tree/main/word-count-web-component
word\-count\-web\-component
.UE \c
\ demo (\c
.UR https://mdn.github.io/web-components-examples/word-count-web-component/
see it live also
.UE \c
).
You can see that we use \f[CR]attachShadow()\f[R] in the middle of the
code to create a shadow root, which we then attach our custom
element\[cq]s contents to.
.IP
.EX
\f[I]// Create a class for the element\f[R]
\f[B]class\f[R] WordCount \f[B]extends\f[R] HTMLParagraphElement {
  constructor() {
    \f[I]// Always call super first in constructor\f[R]
    \f[B]super\f[R]();

    \f[I]// count words in element\[aq]s parent element\f[R]
    \f[B]const\f[R] wcParent = \f[B]this\f[R].parentNode;

    \f[B]function\f[R] countWords(node) {
      \f[B]const\f[R] text = node.innerText || node.textContent;
      \f[B]return\f[R] text
        .trim()
        .split(/\[rs]s+/g)
        .filter((a) \f[B]=>\f[R] a.trim().length > 0).length;
    }

    \f[B]const\f[R] count = \[ga]Words: ${countWords(wcParent)}\[ga];

    \f[I]// Create a shadow root\f[R]
    \f[B]const\f[R] shadow = \f[B]this\f[R].attachShadow({ mode: \[dq]open\[dq] });

    \f[I]// Create text node and add word count to it\f[R]
    \f[B]const\f[R] text = document.createElement(\[dq]span\[dq]);
    text.textContent = count;

    \f[I]// Append it to the shadow root\f[R]
    shadow.appendChild(text);

    \f[I]// Update count when element content changes\f[R]
    setInterval(() \f[B]=>\f[R] {
      \f[B]const\f[R] count = \[ga]Words: ${countWords(wcParent)}\[ga];
      text.textContent = count;
    }, 200);
  }
}

\f[I]// Define the new element\f[R]
customElements.define(\[dq]word\-count\[dq], WordCount, { extends: \[dq]p\[dq] });
.EE
.SS Disabling shadow DOM
If the element has a static property named \f[CR]disabledFeatures\f[R],
which is an array containing the string \f[CR]\[dq]shadow\[dq]\f[R],
then the \f[CR]attachShadow()\f[R] call will throw an exception.
.PP
For example:
.IP
.EX
\f[B]class\f[R] MyCustomElement \f[B]extends\f[R] HTMLElement {
  \f[I]// Disable shadow DOM for this element.\f[R]
  \f[B]static\f[R] disabledFeatures = [\[dq]shadow\[dq]];

  constructor() {
    \f[B]super\f[R]();
  }

  connectedCallback() {
    \f[I]// Create a shadow root.\f[R]
    \f[I]// This will throw an exception.\f[R]
    \f[B]const\f[R] shadow = \f[B]this\f[R].attachShadow({ mode: \[dq]open\[dq] });
  }
}

\f[I]// Define the new element\f[R]
customElements.define(\[dq]my\-custom\-element\[dq], MyCustomElement);
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]ShadowRoot.mode\f[R]
.IP \[bu] 2
\f[CR]ShadowRoot.delegatesFocus\f[R]
.IP \[bu] 2
\f[CR]ShadowRoot.slotAssignment\f[R]
