.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPURENDERPASSENCODER.EXECUTEBUNDLES" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPURenderPassEncoder.executeBundles \- GPURenderPassEncoder:
executeBundles() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]executeBundles()\f[B]\f[R] method of the
\f[CR]GPURenderPassEncoder\f[R] interface executes commands previously
recorded into the referenced \f[CR]GPURenderBundle\f[R]s, as part of
this render pass.
.RS
.PP
\f[B]Note:\f[R] After calling \f[CR]executeBundles()\f[R] the currently
set vertex buffers, index buffers, bind groups, and pipeline are all
cleared, even if no bundles are actually executed.
.RE
.SH SYNTAX
.IP
.EX
executeBundles(bundles)
.EE
.SS Parameters
.TP
\f[B]bundles\f[R]
An array of \f[CR]GPURenderBundle\f[R] objects, containing the
pre\-recorded commands to execute.
.SS Return value
None (\f[CR]Undefined\f[R]).
.SS Validation
The following criteria must be met when calling
\f[B]\f[CB]executeBundles()\f[B]\f[R], otherwise a
\f[CR]GPUValidationError\f[R] is generated and the
\f[CR]GPURenderPassEncoder\f[R] becomes invalid.
.PP
For each \f[CR]GPURenderBundle\f[R]:
.IP \(bu 2
If the render pass\(cqs \f[CR]depthReadOnly\f[R] property (as specified
in the descriptor of the originating
\f[CR]GPUCommandEncoder.beginRenderPass()\f[R] call) is \f[CR]true\f[R],
then the bundle\(cqs \f[CR]depthReadOnly\f[R] property (as specified in
the descriptor of the \f[CR]GPUDevice.createRenderBundleEncoder()\f[R]
call that created the originating \f[CR]GPURenderBundleEncoder\f[R]) is
also \f[CR]true\f[R].
.IP \(bu 2
If the render pass\(cqs \f[CR]stencilReadOnly\f[R] property (as
specified in the descriptor of the originating
\f[CR]GPUCommandEncoder.beginRenderPass()\f[R] call) is \f[CR]true\f[R],
then the bundle\(cqs \f[CR]stencilReadOnly\f[R] property (as specified
in the descriptor of the
\f[CR]GPUDevice.createRenderBundleEncoder()\f[R] call that created the
originating \f[CR]GPURenderBundleEncoder\f[R]) is also \f[CR]true\f[R].
.IP \(bu 2
The layout of the render pipeline specified in
\f[CR]GPURenderPassEncoder.setPipeline()\f[R] (as defined in the
descriptor of the originating
\f[CR]GPUDevice.createRenderPipeline()\f[R] call) equals the layout of
the render bundle pipeline specified in
\f[CR]GPURenderBundleEncoder.setPipeline()\f[R].
.SH EXAMPLES
In the WebGPU Samples \c
.UR https://webgpu.github.io/webgpu-samples/samples/animometer/
Animometer example
.UE \c
, a lot of like operations are done on many different objects
simultaneously.
\f[CR]executeBundles()\f[R] is used to reuse the work on multiple render
passes to improve performance.
Study the example code listing for the full context.
.IP
.EX
\f[I]// \&...\f[R]

\f[B]return\f[R] \f[B]function\f[R] doDraw(timestamp) {
  \f[B]if\f[R] (startTime === \f[B]undefined\f[R]) {
    startTime = timestamp;
  }
  uniformTime[0] = (timestamp \- startTime) / 1000;
  device.queue.writeBuffer(uniformBuffer, timeOffset, uniformTime.buffer);

  renderPassDescriptor.colorAttachments[0].view = context
    .getCurrentTexture()
    .createView();

  \f[B]const\f[R] commandEncoder = device.createCommandEncoder();
  \f[B]const\f[R] passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);

  \f[B]if\f[R] (settings.renderBundles) {
    passEncoder.executeBundles([renderBundle]);
  } \f[B]else\f[R] {
    recordRenderPass(passEncoder);
  }

  passEncoder.end();
  device.queue.submit([commandEncoder.finish()]);
};

\f[I]// \&...\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
