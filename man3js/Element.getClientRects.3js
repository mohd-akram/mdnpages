.\" Automatically generated by Pandoc 3.4
.\"
.TH "Element.getClientRects" "JS" "June 22, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Element.getClientRects \- Element: getClientRects() method
.SH SYNOPSIS
The \f[B]\f[CB]getClientRects()\f[B]\f[R] method of the
\f[CR]Element\f[R] interface returns a collection of \f[CR]DOMRect\f[R]
objects that indicate the bounding rectangles for each CSS border box in
a client.
.PP
Most elements only have one border box each, but a multiline
inline\-level element (such as a multiline \f[CR]<span>\f[R] element, by
default) has a border box around each line.
.SH SYNTAX
.IP
.EX
getClientRects()
.EE
.SS Parameters
None.
.SS Return value
The returned value is a collection of \f[CR]DOMRect\f[R] objects, one
for each CSS border box associated with the element.
Each \f[CR]DOMRect\f[R] object describes the border box, in pixels, with
the top\-left relative to the top\-left of the viewport.
For tables with captions, the caption is included even though it\[cq]s
outside the border box of the table.
When called on SVG elements other than an outer\-\f[CR]<svg>\f[R], the
\[lq]viewport\[rq] that the resulting rectangles are relative to is the
viewport that the element\[cq]s outer\-\f[CR]<svg>\f[R] establishes (and
to be clear, the rectangles are also transformed by the
outer\-\f[CR]<svg>\f[R]\[cq]s \f[CR]viewBox\f[R] transform, if any).
.PP
The amount of scrolling that has been done of the viewport area (or any
other scrollable element) is taken into account when computing the
rectangles.
.PP
The returned rectangles do not include the bounds of any child elements
that might happen to overflow.
.PP
For HTML \f[CR]<area>\f[R] elements, SVG elements that do not render
anything themselves, \f[CR]display:none\f[R] elements, and generally any
elements that are not directly rendered, an empty list is returned.
.PP
Rectangles are returned even for CSS boxes that have empty
border\-boxes.
The \f[CR]left\f[R], \f[CR]top\f[R], \f[CR]right\f[R], and
\f[CR]bottom\f[R] coordinates can still be meaningful.
.PP
Fractional pixel offsets are possible.
.SH EXAMPLES
These examples draw client rects in various colors.
Note that the JavaScript function that paints the client rects is
connected to the markup via the class \f[CR]withClientRectsOverlay\f[R].
.SS HTML
Example 1: This HTML creates three paragraphs with a \f[CR]<span>\f[R]
inside, each embedded in a \f[CR]<div>\f[R] block.
Client rects are painted for the paragraph in the second block, and for
the \f[CR]<span>\f[R] element in the third block.
.IP
.EX
<\f[B]h3\f[R]>A paragraph with a span inside</\f[B]h3\f[R]>
<\f[B]p\f[R]>
  Both the span and the paragraph have a border set. The client rects are in
  red. Note that the p has only one border box, while the span has multiple
  border boxes.
</\f[B]p\f[R]>

<\f[B]div\f[R]>
  <\f[B]strong\f[R]>Original</\f[B]strong\f[R]>
  <\f[B]p\f[R]>
    <\f[B]span\f[R]>Paragraph that spans multiple lines</\f[B]span\f[R]>
  </\f[B]p\f[R]>
</\f[B]div\f[R]>

<\f[B]div\f[R]>
  <\f[B]strong\f[R]>p\[aq]s rect</\f[B]strong\f[R]>
  <\f[B]p\f[R] class=\[dq]withClientRectsOverlay\[dq]>
    <\f[B]span\f[R]>Paragraph that spans multiple lines</\f[B]span\f[R]>
  </\f[B]p\f[R]>
</\f[B]div\f[R]>

<\f[B]div\f[R]>
  <\f[B]strong\f[R]>span\[aq]s rect</\f[B]strong\f[R]>
  <\f[B]p\f[R]>
    <\f[B]span\f[R] class=\[dq]withClientRectsOverlay\[dq]
      >Paragraph that spans multiple lines</\f[B]span\f[R]
    >
  </\f[B]p\f[R]>
</\f[B]div\f[R]>
.EE
.PP
Example 2: This HTML creates three ordered lists.
Client rects are painted for the \f[CR]<ol>\f[R] in the second block,
and for each \f[CR]<li>\f[R] element in the third block.
.IP
.EX
<\f[B]h3\f[R]>A list</\f[B]h3\f[R]>
<\f[B]p\f[R]>
  Note that the border box doesn\[aq]t include the number, so neither do the client
  rects.
</\f[B]p\f[R]>

<\f[B]div\f[R]>
  <\f[B]strong\f[R]>Original</\f[B]strong\f[R]>
  <\f[B]ol\f[R]>
    <\f[B]li\f[R]>Item 1</\f[B]li\f[R]>
    <\f[B]li\f[R]>Item 2</\f[B]li\f[R]>
  </\f[B]ol\f[R]>
</\f[B]div\f[R]>

<\f[B]div\f[R]>
  <\f[B]strong\f[R]>ol\[aq]s rect</\f[B]strong\f[R]>
  <\f[B]ol\f[R] class=\[dq]withClientRectsOverlay\[dq]>
    <\f[B]li\f[R]>Item 1</\f[B]li\f[R]>
    <\f[B]li\f[R]>Item 2</\f[B]li\f[R]>
  </\f[B]ol\f[R]>
</\f[B]div\f[R]>

<\f[B]div\f[R]>
  <\f[B]strong\f[R]>each li\[aq]s rect</\f[B]strong\f[R]>
  <\f[B]ol\f[R]>
    <\f[B]li\f[R] class=\[dq]withClientRectsOverlay\[dq]>Item 1</\f[B]li\f[R]>
    <\f[B]li\f[R] class=\[dq]withClientRectsOverlay\[dq]>Item 2</\f[B]li\f[R]>
  </\f[B]ol\f[R]>
</\f[B]div\f[R]>
.EE
.PP
Example 3: This HTML creates two tables with captions.
Client rects are painted for the \f[CR]<table>\f[R] in the second block.
.IP
.EX
<\f[B]h3\f[R]>A table with a caption</\f[B]h3\f[R]>
<\f[B]p\f[R]>
  Although the table\[aq]s border box doesn\[aq]t include the caption, the client rects
  do include the caption.
</\f[B]p\f[R]>

<\f[B]div\f[R]>
  <\f[B]strong\f[R]>Original</\f[B]strong\f[R]>
  <\f[B]table\f[R]>
    <\f[B]caption\f[R]>
      caption
    </\f[B]caption\f[R]>
    <\f[B]thead\f[R]>
      <\f[B]tr\f[R]>
        <\f[B]th\f[R]>thead</\f[B]th\f[R]>
      </\f[B]tr\f[R]>
    </\f[B]thead\f[R]>
    <\f[B]tbody\f[R]>
      <\f[B]tr\f[R]>
        <\f[B]td\f[R]>tbody</\f[B]td\f[R]>
      </\f[B]tr\f[R]>
    </\f[B]tbody\f[R]>
  </\f[B]table\f[R]>
</\f[B]div\f[R]>

<\f[B]div\f[R]>
  <\f[B]strong\f[R]>table\[aq]s rect</\f[B]strong\f[R]>
  <\f[B]table\f[R] class=\[dq]withClientRectsOverlay\[dq]>
    <\f[B]caption\f[R]>
      caption
    </\f[B]caption\f[R]>
    <\f[B]thead\f[R]>
      <\f[B]tr\f[R]>
        <\f[B]th\f[R]>thead</\f[B]th\f[R]>
      </\f[B]tr\f[R]>
    </\f[B]thead\f[R]>
    <\f[B]tbody\f[R]>
      <\f[B]tr\f[R]>
        <\f[B]td\f[R]>tbody</\f[B]td\f[R]>
      </\f[B]tr\f[R]>
    </\f[B]tbody\f[R]>
  </\f[B]table\f[R]>
</\f[B]div\f[R]>
.EE
.SS CSS
The CSS draws borders around the paragraph and the \f[CR]<span>\f[R]
inside each \f[CR]<div>\f[R] block for the first example, around the
\f[CR]<ol>\f[R] and \f[CR]<li>\f[R] for the second example, and around
\f[CR]<table>\f[R], \f[CR]<th>\f[R], and \f[CR]<td>\f[R] elements for
the third example.
.IP
.EX
strong {
  \f[B]text\-align\f[R]: center;
}
div {
  \f[B]display\f[R]: inline\-block;
  \f[B]width\f[R]: 150px;
}
div p,
ol,
table {
  \f[B]border\f[R]: 1px solid blue;
}
span,
li,
th,
td {
  \f[B]border\f[R]: 1px solid green;
}
.EE
.SS JavaScript
The JavaScript code draws the client rects for all HTML elements that
have CSS class \f[CR]withClientRectsOverlay\f[R] assigned.
.IP
.EX
\f[B]function\f[R] addClientRectsOverlay(elt) {
  \f[I]/* Absolutely position a div over each client rect so that its border width\f[R]
\f[I]     is the same as the rectangle\[aq]s width.\f[R]
\f[I]     Note: the overlays will be out of place if the user resizes or zooms. */\f[R]
  \f[B]const\f[R] rects = elt.getClientRects();
  \f[B]for\f[R] (\f[B]const\f[R] rect \f[B]of\f[R] rects) {
    \f[B]const\f[R] tableRectDiv = document.createElement(\[dq]div\[dq]);
    tableRectDiv.style.position = \[dq]absolute\[dq];
    tableRectDiv.style.border = \[dq]1px solid red\[dq];
    \f[B]const\f[R] scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop;
    \f[B]const\f[R] scrollLeft =
      document.documentElement.scrollLeft || document.body.scrollLeft;
    tableRectDiv.style.margin = tableRectDiv.style.padding = \[dq]0\[dq];
    tableRectDiv.style.top = \[ga]${rect.top + scrollTop}px\[ga];
    tableRectDiv.style.left = \[ga]${rect.left + scrollLeft}px\[ga];
    \f[I]// We want rect.width to be the border width, so content width is 2px less.\f[R]
    tableRectDiv.style.width = \[ga]${rect.width \- 2}px\[ga];
    tableRectDiv.style.height = \[ga]${rect.height \- 2}px\[ga];
    document.body.appendChild(tableRectDiv);
  }
}

(() \f[B]=>\f[R] {
  \f[I]/* Call function addClientRectsOverlay(elt) for all elements with\f[R]
\f[I]     assigned class \[dq]withClientRectsOverlay\[dq] */\f[R]
  \f[B]const\f[R] elts = document.getElementsByClassName(\[dq]withClientRectsOverlay\[dq]);
  \f[B]for\f[R] (\f[B]const\f[R] elt \f[B]of\f[R] elts) {
    addClientRectsOverlay(elt);
  }
})();
.EE
.SS Result
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Element.getBoundingClientRect()\f[R]
