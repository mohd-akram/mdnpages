.\" Automatically generated by Pandoc 3.4
.\"
.TH "Array.with" "JS" "February 8, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.with \- Array.prototype.with()
.SH SYNOPSIS
The \f[B]\f[CB]with()\f[B]\f[R] method of \f[CR]Array\f[R] instances is
the copying version of using the bracket notation to change the value of
a given index.
It returns a new array with the element at the given index replaced with
the given value.
.SH SYNTAX
.IP
.EX
arrayInstance.with(index, value)
.EE
.SS Parameters
.TP
\f[B]index\f[R]
Zero\-based index at which to change the array, converted to an integer.
.RS
.IP \[bu] 2
Negative index counts back from the end of the array \[em] if
\f[CR]\-array.length <= index < 0\f[R], \f[CR]index + array.length\f[R]
is used.
.IP \[bu] 2
If the index after normalization is out of bounds, a
\f[CR]RangeError\f[R] is thrown.
.RE
.TP
\f[B]value\f[R]
Any value to be assigned to the given index.
.SS Return value
A new array with the element at \f[CR]index\f[R] replaced with
\f[CR]value\f[R].
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]index >= array.length\f[R] or
\f[CR]index < \-array.length\f[R].
.SH DESCRIPTION
The \f[CR]with()\f[R] method changes the value of a given index in the
array, returning a new array with the element at the given index
replaced with the given value.
The original array is not modified.
This allows you to chain array methods while doing manipulations.
.PP
By combining \f[CR]with()\f[R] with \f[CR]at()\f[R], you can both write
and read (respectively) an array using negative indices.
.PP
The \f[CR]with()\f[R] method never produces a sparse array.
If the source array is sparse, the empty slots will be replaced with
\f[CR]undefined\f[R] in the new array.
.PP
The \f[CR]with()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
.SH EXAMPLES
.SS Creating a new array with a single element changed
.IP
.EX
\f[B]const\f[R] arr = [1, 2, 3, 4, 5];
console.log(arr.with(2, 6)); \f[I]// [1, 2, 6, 4, 5]\f[R]
console.log(arr); \f[I]// [1, 2, 3, 4, 5]\f[R]
.EE
.SS Chaining array methods
With the \f[CR]with()\f[R] method, you can update a single element in an
array and then apply other array methods.
.IP
.EX
\f[B]const\f[R] arr = [1, 2, 3, 4, 5];
console.log(arr.with(2, 6).map((x) \f[B]=>\f[R] x ** 2)); \f[I]// [1, 4, 36, 16, 25]\f[R]
.EE
.SS Using with() on sparse arrays
The \f[CR]with()\f[R] method always creates a dense array.
.IP
.EX
\f[B]const\f[R] arr = [1, , 3, 4, , 6];
console.log(arr.with(0, 2)); \f[I]// [2, undefined, 3, 4, undefined, 6]\f[R]
.EE
.SS Calling with() on non\-array objects
The \f[CR]with()\f[R] method creates and returns a new array.
It reads the \f[CR]length\f[R] property of \f[CR]this\f[R] and then
accesses each property whose key is a nonnegative integer less than
\f[CR]length\f[R].
As each property of \f[CR]this\f[R] is accessed, the array element
having an index equal to the key of the property is set to the value of
the property.
Finally, the array value at \f[CR]index\f[R] is set to \f[CR]value\f[R].
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  unrelated: \[dq]foo\[dq],
  0: 5,
  2: 4,
  3: 3, \f[I]// ignored by with() since length is 3\f[R]
};
console.log(Array.prototype.with.call(arrayLike, 0, 1));
\f[I]// [ 1, undefined, 4 ]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#change-array-by-copy
Polyfill of \f[CR]Array.prototype.with\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Indexed collections guide
.IP \[bu] 2
\f[CR]Array.prototype.toReversed()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.toSorted()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.toSpliced()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.at()\f[R]
.IP \[bu] 2
\f[CR]TypedArray.prototype.with()\f[R]
