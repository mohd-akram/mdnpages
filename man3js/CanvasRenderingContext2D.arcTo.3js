.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "CanvasRenderingContext2D.arcTo" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
CanvasRenderingContext2D.arcTo \- CanvasRenderingContext2D: arcTo()
method
.SH SYNOPSIS
The \f[B]\f[CB]CanvasRenderingContext2D.arcTo()\f[B]\f[R] method of the
Canvas 2D API adds a circular arc to the current sub\-path, using the
given control points and radius.
The arc is automatically connected to the path\[cq]s latest point with a
straight line if necessary, for example if the starting point and
control points are in a line.
.PP
This method is commonly used for making rounded corners.
.RS
.PP
\f[B]Note:\f[R] You may get unexpected results when using a relatively
large radius: the arc\[cq]s connecting line will go in whatever
direction it must to meet the specified radius.
.RE
.SH SYNTAX
.IP
.EX
arcTo(x1, y1, x2, y2, radius)
.EE
.SS Parameters
.TP
\f[B]x1\f[R]
The x\-axis coordinate of the first control point.
.TP
\f[B]y1\f[R]
The y\-axis coordinate of the first control point.
.TP
\f[B]x2\f[R]
The x\-axis coordinate of the second control point.
.TP
\f[B]y2\f[R]
The y\-axis coordinate of the second control point.
.TP
\f[B]radius\f[R]
The arc\[cq]s radius.
Must be non\-negative.
.SS Usage notes
Assume P_0 is the point on the path when \f[CR]arcTo()\f[R] is called,
P_1 = (\f[CR]x1\f[R], \f[CR]y1\f[R]) and P_2 = (\f[CR]x2\f[R],
\f[CR]y2\f[R]) are the first and second control points, respectively,
and \f[I]r\f[R] is the \f[CR]radius\f[R] specified in the call:
.IP \[bu] 2
If \f[I]r\f[R] is negative, an \f[CR]IndexSizeError\f[R] exception is
raised.
.IP \[bu] 2
If \f[I]r\f[R] is 0, \f[CR]arcTo()\f[R] behaves as if P_0, P_1, and P_2
are collinear (in a line).
.IP \[bu] 2
In the case of all of the points being collinear, a line from P_0 to P_1
is drawn unless the points P_0 and P_1 are coincident (having the same
coordinates), in which case nothing is drawn.
.PP
These conditions can be created in the Constructing an arcTo() path
example below to see the results.
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.TP
\f[B]IndexSizeError\f[R] \f[B]DOMException\f[R]
Thrown if \f[CR]radius\f[R] is a negative value.
.SH EXAMPLES
.SS How \f[CR]arcTo()\f[R] works
One way to think about \f[CR]arcTo()\f[R] is to imagine two straight
segments: one from the starting point to a first control point, and
another from there to a second control point.
Without \f[CR]arcTo()\f[R], these two segments would form a sharp
corner: \f[CR]arcTo()\f[R] creates a circular arc at this corner and
smooths it out.
In other words, the arc is tangential to both segments.
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]canvas\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);

\f[I]// Tangential lines\f[R]
ctx.beginPath();
ctx.strokeStyle = \[dq]gray\[dq];
ctx.moveTo(200, 20);
ctx.lineTo(200, 130);
ctx.lineTo(50, 20);
ctx.stroke();

\f[I]// Arc\f[R]
ctx.beginPath();
ctx.strokeStyle = \[dq]black\[dq];
ctx.lineWidth = 5;
ctx.moveTo(200, 20);
ctx.arcTo(200, 130, 50, 20, 40);
ctx.stroke();

\f[I]// Start point\f[R]
ctx.beginPath();
ctx.fillStyle = \[dq]blue\[dq];
ctx.arc(200, 20, 5, 0, 2 * Math.PI);
ctx.fill();

\f[I]// Control points\f[R]
ctx.beginPath();
ctx.fillStyle = \[dq]red\[dq];
ctx.arc(200, 130, 5, 0, 2 * Math.PI); \f[I]// Control point one\f[R]
ctx.arc(50, 20, 5, 0, 2 * Math.PI); \f[I]// Control point two\f[R]
ctx.fill();
.EE
.SS Result
In this example, the path created by \f[CR]arcTo()\f[R] is \f[B]thick
and black\f[R].
Tangent lines are gray, control points are red, and the start point is
blue.
.SS Creating a rounded corner
This example creates a rounded corner using \f[CR]arcTo()\f[R].
This is one of the method\[cq]s most common uses.
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]canvas\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
The arc begins at the point specified by \f[CR]moveTo()\f[R]: (230, 20).
It is shaped to fit control points at (90, 130) and (20, 20), and has a
radius of 50.
The \f[CR]lineTo()\f[R] method connects the arc to (20, 20) with a
straight line.
Note that the arc\[cq]s second control point and the point specified by
\f[CR]lineTo()\f[R] are the same, which produces a totally smooth
corner.
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);
\f[B]const\f[R] p0 = { x: 230, y: 20 };
\f[B]const\f[R] p1 = { x: 90, y: 130 };
\f[B]const\f[R] p2 = { x: 20, y: 20 };

\f[B]const\f[R] labelPoint = (p) \f[B]=>\f[R] {
  \f[B]const\f[R] offset = 10;
  ctx.fillText(\[ga](${p.x},${p.y})\[ga], p.x + offset, p.y + offset);
};

ctx.beginPath();
ctx.lineWidth = 4;
ctx.font = \[dq]1em sans\-serif\[dq];
ctx.moveTo(p0.x, p0.y);
ctx.arcTo(p1.x, p1.y, p2.x, p2.y, 50);
ctx.lineTo(p2.x, p2.y);

labelPoint(p0);
labelPoint(p1);
labelPoint(p2);

ctx.stroke();
.EE
.SS Result
.SS Result of a large radius
If you use a relatively large radius, the arc may appear in a place you
didn\[cq]t expect.
In this example, the arc\[cq]s connecting line goes above, instead of
below, the coordinate specified by \f[CR]moveTo()\f[R].
This happens because the radius is too large for the arc to fit entirely
below the starting point.
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]canvas\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);

ctx.beginPath();
ctx.moveTo(180, 90);
ctx.arcTo(180, 130, 110, 130, 130);
ctx.lineTo(110, 130);
ctx.stroke();
.EE
.SS Result
.SS Constructing an arcTo() path
The demo shows the semi\-infinite lines and circle with center
\f[I]C\f[R] tangent to the lines at T_1 and T_2 used to determine the
path rendered by \f[CR]arcTo()\f[R].
.PP
Note that \f[CR]arcTo\f[R] will create a straight line from P_0 to P_1
when all points are in a line.
Additionally, nothing is drawn by \f[CR]arcTo\f[R] if P_0 and P_1 have
the same coordinates.
.PP
Besides being able to set the arc radius with the slider, the initial
point P_0 and control points P_1 and P_2 can be moved by dragging them
with the mouse with the left button down.
The numeric values can also be edited, and the arrow keys can be used to
change an underlined element that is in focus.
.SS Animating \f[CR]arcTo()\f[R] drawing
For this example, you can play around with the arc radius to see how the
path changes.
The path is drawn from the starting point \f[I]p0\f[R] using
\f[CR]arcTo()\f[R] with control points \f[I]p1\f[R] and \f[I]p2\f[R] and
a radius that varies from 0 to the maximum radius selected with the
slider.
Then a \f[CR]lineTo()\f[R] call completes the path to \f[I]p2\f[R].
.SS HTML
.IP
.EX
<\f[B]div\f[R]>
  <\f[B]label\f[R] for=\[dq]radius\[dq]>Radius: </\f[B]label\f[R]>
  <\f[B]input\f[R] name=\[dq]radius\[dq] type=\[dq]range\[dq] id=\[dq]radius\[dq] min=\[dq]0\[dq] max=\[dq]100\[dq] value=\[dq]50\[dq] />
  <\f[B]label\f[R] for=\[dq]radius\[dq] id=\[dq]radius\-output\[dq]>50</\f[B]label\f[R]>
</\f[B]div\f[R]>
<\f[B]canvas\f[R] id=\[dq]canvas\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);
\f[B]const\f[R] controlOut = document.getElementById(\[dq]radius\-output\[dq]);
\f[B]const\f[R] control = document.getElementById(\[dq]radius\[dq]);
control.oninput = () \f[B]=>\f[R] {
  controlOut.textContent = radius = control.value;
};

\f[B]const\f[R] p1 = { x: 100, y: 100 };
\f[B]const\f[R] p2 = { x: 150, y: 50 };
\f[B]const\f[R] p3 = { x: 200, y: 100 };
\f[B]let\f[R] radius = control.value; \f[I]// match with init control value\f[R]

\f[B]function\f[R] labelPoint(p, offset, i = 0) {
  \f[B]const\f[R] { x, y } = offset;
  ctx.beginPath();
  ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillText(\[ga]${i}:(${p.x}, ${p.y})\[ga], p.x + x, p.y + y);
}

\f[B]function\f[R] drawPoints(points) {
  points.forEach((p, i) \f[B]=>\f[R] {
    labelPoint(p, { x: 0, y: \-20 }, \[ga]p${i}\[ga]);
  });
}

\f[I]// Draw arc\f[R]
\f[B]function\f[R] drawArc([p0, p1, p2], r) {
  ctx.beginPath();
  ctx.moveTo(p0.x, p0.y);
  ctx.arcTo(p1.x, p1.y, p2.x, p2.y, r);
  ctx.lineTo(p2.x, p2.y);
  ctx.stroke();
}

\f[B]function\f[R] loop(t) {
  \f[B]const\f[R] angle = (t / 1000) % (2 * Math.PI);
  \f[B]const\f[R] rr = Math.abs(Math.cos(angle) * radius);

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawArc([p1, p2, p3], rr);
  drawPoints([p1, p2, p3]);
  requestAnimationFrame(loop);
}

loop(0);
.EE
.SS Result
.SH SEE ALSO
.IP \[bu] 2
The interface defining this method: \f[CR]CanvasRenderingContext2D\f[R]
