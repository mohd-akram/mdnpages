.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Object.setPrototypeOf" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.setPrototypeOf \- Object.setPrototypeOf()
.SH SYNOPSIS
The \f[B]\f[CB]Object.setPrototypeOf()\f[B]\f[R] static method sets the
prototype (i.e., the internal \f[CR][[Prototype]]\f[R] property) of a
specified object to another object or \f[CR]null\f[R].
.RS
.PP
\f[B]Warning:\f[R] Changing the \f[CR][[Prototype]]\f[R] of an object
is, by the nature of how modern JavaScript engines optimize property
accesses, currently a very slow operation in every browser and
JavaScript engine.
In addition, the effects of altering inheritance are subtle and
far\-flung, and are not limited to the time spent in the
\f[CR]Object.setPrototypeOf(...)\f[R] statement, but may extend to
\f[B]\f[BI]any\f[B]\f[R] code that has access to any object whose
\f[CR][[Prototype]]\f[R] has been altered.
You can read more in \c
.UR https://mathiasbynens.be/notes/prototypes
JavaScript engine fundamentals: optimizing prototypes
.UE \c
\&.
.PP
Because this feature is a part of the language, it is still the burden
on engine developers to implement that feature performantly (ideally).
Until engine developers address this issue, if you are concerned about
performance, you should avoid setting the \f[CR][[Prototype]]\f[R] of an
object.
Instead, create a new object with the desired \f[CR][[Prototype]]\f[R]
using \f[CR]Object.create()\f[R].
.RE
.SH SYNTAX
.IP
.EX
Object.setPrototypeOf(obj, prototype)
.EE
.SS Parameters
.TP
\f[B]obj\f[R]
The object which is to have its prototype set.
.TP
\f[B]prototype\f[R]
The object\[cq]s new prototype (an object or \f[CR]null\f[R]).
.SS Return value
The specified object.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown in one of the following cases:
.RS
.IP \[bu] 2
The \f[CR]obj\f[R] parameter is \f[CR]undefined\f[R] or \f[CR]null\f[R].
.IP \[bu] 2
The \f[CR]obj\f[R] parameter is non\-extensible, or it\[cq]s an \c
.UR https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-immutable-prototype-exotic-objects
immutable prototype exotic object
.UE \c
, such as \f[CR]Object.prototype\f[R] or \f[CR]window\f[R].
However, the error is not thrown if the new prototype is the same value
as the original prototype of \f[CR]obj\f[R].
.IP \[bu] 2
The \f[CR]prototype\f[R] parameter is not an object or \f[CR]null\f[R].
.RE
.SH DESCRIPTION
\f[CR]Object.setPrototypeOf()\f[R] is generally considered the proper
way to set the prototype of an object.
You should always use it in favor of the deprecated
\f[CR]Object.prototype.__proto__\f[R] accessor.
.PP
If the \f[CR]obj\f[R] parameter is not an object (e.g.\ number, string,
etc.), this method does nothing \[em] without coercing it to an object
or attempting to set its prototype \[em] and directly returns
\f[CR]obj\f[R] as a primitive value.
If \f[CR]prototype\f[R] is the same value as the prototype of
\f[CR]obj\f[R], then \f[CR]obj\f[R] is directly returned, without
causing a \f[CR]TypeError\f[R] even when \f[CR]obj\f[R] has immutable
prototype.
.PP
For security concerns, there are certain built\-in objects that are
designed to have an \f[I]immutable prototype\f[R].
This prevents prototype pollution attacks, especially \c
.UR https://github.com/tc39/ecma262/issues/272
proxy\-related ones
.UE \c
\&.
The core language only specifies \f[CR]Object.prototype\f[R] as an
immutable prototype exotic object, whose prototype is always
\f[CR]null\f[R].
In browsers, \f[CR]window\f[R] and \f[CR]location\f[R] are two other
very common examples.
.IP
.EX
Object.isExtensible(Object.prototype); \f[I]// true; you can add more properties\f[R]
Object.setPrototypeOf(Object.prototype, {}); \f[I]// TypeError: Immutable prototype object \[aq]#<Object>\[aq] cannot have their prototype set\f[R]
Object.setPrototypeOf(Object.prototype, \f[B]null\f[R]); \f[I]// No error; the prototype of \[ga]Object.prototype\[ga] is already \[ga]null\[ga]\f[R]
.EE
.SH EXAMPLES
.SS Pseudoclassical inheritance using Object.setPrototypeOf()
Inheritance in JS using classes.
.IP
.EX
\f[B]class\f[R] Human {}
\f[B]class\f[R] SuperHero \f[B]extends\f[R] Human {}

\f[B]const\f[R] superMan = \f[B]new\f[R] SuperHero();
.EE
.PP
However, if we want to implement subclasses without using
\f[CR]class\f[R], we can do the following:
.IP
.EX
\f[B]function\f[R] Human(name, level) {
  \f[B]this\f[R].name = name;
  \f[B]this\f[R].level = level;
}

\f[B]function\f[R] SuperHero(name, level) {
  Human.call(\f[B]this\f[R], name, level);
}

Object.setPrototypeOf(SuperHero.prototype, Human.prototype);

\f[I]// Set the \[ga][[Prototype]]\[ga] of \[ga]SuperHero.prototype\[ga]\f[R]
\f[I]// to \[ga]Human.prototype\[ga]\f[R]
\f[I]// To set the prototypal inheritance chain\f[R]

Human.prototype.speak = \f[B]function\f[R] () {
  \f[B]return\f[R] \[ga]${\f[B]this\f[R].name} says hello.\[ga];
};

SuperHero.prototype.fly = \f[B]function\f[R] () {
  \f[B]return\f[R] \[ga]${\f[B]this\f[R].name} is flying.\[ga];
};

\f[B]const\f[R] superMan = \f[B]new\f[R] SuperHero(\[dq]Clark Kent\[dq], 1);

console.log(superMan.fly());
console.log(superMan.speak());
.EE
.PP
The similarity between classical inheritance (with classes) and
pseudoclassical inheritance (with constructors\[cq] \f[CR]prototype\f[R]
property) as done above is mentioned in Inheritance chains.
.PP
Since function constructors\[cq] \f[CR]prototype\f[R] property is
writable, you can reassign it to a new object created with
\f[CR]Object.create()\f[R] to achieve the same inheritance chain as
well.
There are caveats to watch out when using \f[CR]create()\f[R], such as
remembering to re\-add the \f[CR]constructor\f[R] property.
.PP
In the example below, which also uses classes, \f[CR]SuperHero\f[R] is
made to inherit from \f[CR]Human\f[R] without using \f[CR]extends\f[R]
by using \f[CR]setPrototypeOf()\f[R] instead.
.RS
.PP
\f[B]Warning:\f[R] It is not advisable to use
\f[CR]setPrototypeOf()\f[R] instead of \f[CR]extends\f[R] due to
performance and readability reasons.
.RE
.IP
.EX
\f[B]class\f[R] Human {}
\f[B]class\f[R] SuperHero {}

\f[I]// Set the instance properties\f[R]
Object.setPrototypeOf(SuperHero.prototype, Human.prototype);

\f[I]// Hook up the static properties\f[R]
Object.setPrototypeOf(SuperHero, Human);

\f[B]const\f[R] superMan = \f[B]new\f[R] SuperHero();
.EE
.PP
Subclassing without \f[CR]extends\f[R] is mentioned in \c
.UR https://hacks.mozilla.org/2015/08/es6-in-depth-subclassing/
ES\-6 subclassing
.UE \c
\&.
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-object
Polyfill of \f[CR]Object.setPrototypeOf\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Reflect.setPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Object.prototype.isPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Object.getPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Object.prototype.__proto__\f[R]
.IP \[bu] 2
Inheritance chain
.IP \[bu] 2
\c
.UR https://hacks.mozilla.org/2015/08/es6-in-depth-subclassing/
ES6 In Depth: Subclassing
.UE \c
\ on hacks.mozilla.org (2015)
