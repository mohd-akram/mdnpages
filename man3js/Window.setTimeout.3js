.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Window.setTimeout" "JS" "October 16, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Window.setTimeout \- Window: setTimeout() method
.SH SYNOPSIS
The \f[B]\f[CB]setTimeout()\f[B]\f[R] method of the \f[CR]Window\f[R]
interface sets a timer which executes a function or specified piece of
code once the timer expires.
.SH SYNTAX
.IP
.EX
setTimeout(code)
setTimeout(code, delay)

setTimeout(functionRef)
setTimeout(functionRef, delay)
setTimeout(functionRef, delay, param1)
setTimeout(functionRef, delay, param1, param2)
setTimeout(functionRef, delay, param1, param2, /* \&..., */ paramN)
.EE
.SS Parameters
.TP
\f[B]functionRef\f[R]
A \f[CR]function\f[R] to be executed after the timer expires.
.TP
\f[B]code\f[R]
An alternative syntax that allows you to include a string instead of a
function, which is compiled and executed when the timer expires.
This syntax is \f[B]not recommended\f[R] for the same reasons that make
using \f[CR]eval()\f[R] a security risk.
.TP
\f[B]delay\f[R] \f[I](optional)\f[R]
The time, in milliseconds that the timer should wait before the
specified function or code is executed.
If this parameter is omitted, a value of 0 is used, meaning execute
\[lq]immediately\[rq], or more accurately, the next event cycle.
.RS
.PP
Note that in either case, the actual delay may be longer than intended;
see Reasons for delays longer than specified below.
.PP
Also note that if the value isn\[cq]t a number, implicit type coercion
is silently done on the value to convert it to a number \[em] which can
lead to unexpected and surprising results; see Non\-number delay values
are silently coerced into numbers for an example.
.RE
.TP
\f[B]param1\f[R], \&..., \f[B]paramN\f[R] \f[I](optional)\f[R]
Additional arguments which are passed through to the function specified
by \f[CR]functionRef\f[R].
.SS Return value
The returned \f[CR]timeoutID\f[R] is a positive integer value which
identifies the timer created by the call to \f[CR]setTimeout()\f[R].
This value can be passed to \f[CR]clearTimeout()\f[R] to cancel the
timeout.
.PP
It is guaranteed that a \f[CR]timeoutID\f[R] value will never be reused
by a subsequent call to \f[CR]setTimeout()\f[R] or
\f[CR]setInterval()\f[R] on the same window while the timer is still
active.
However, different objects use separate pools of IDs.
.SH DESCRIPTION
Timeouts are cancelled using \f[CR]Window.clearTimeout()\f[R].
.PP
To call a function repeatedly (e.g., every \f[I]N\f[R] milliseconds),
consider using \f[CR]setInterval()\f[R].
.SS Non\-number delay values are silently coerced into numbers
If \f[CR]setTimeout()\f[R] is called with \f[I]delay\f[R] value
that\[cq]s not a number, implicit type coercion is silently done on the
value to convert it to a number.
For example, the following code incorrectly uses the string
\f[CR]\[dq]1000\[dq]\f[R] for the \f[I]delay\f[R] value, rather than the
number \f[CR]1000\f[R] \[en] but it nevertheless works, because when the
code runs, the string is coerced into the number \f[CR]1000\f[R], and so
the code executes 1 second later.
.PP
\f[B]Bad\f[R]
.IP
.EX
setTimeout(() \f[B]=>\f[R] {
  console.log(\[dq]Delayed for 1 second.\[dq]);
}, \[dq]1000\[dq]);
.EE
.PP
But in many cases, the implicit type coercion can lead to unexpected and
surprising results.
For example, when the following code runs, the string
\f[CR]\[dq]1 second\[dq]\f[R] ultimately gets coerced into the number
\f[CR]0\f[R] \[em] and so, the code executes immediately, with zero
delay.
.PP
\f[B]Bad\f[R]
.IP
.EX
setTimeout(() \f[B]=>\f[R] {
  console.log(\[dq]Delayed for 1 second.\[dq]);
}, \[dq]1 second\[dq]);
.EE
.PP
Therefore, don\[cq]t use strings for the \f[I]delay\f[R] value but
instead always use numbers:
.PP
\f[B]Good\f[R]
.IP
.EX
setTimeout(() \f[B]=>\f[R] {
  console.log(\[dq]Delayed for 1 second.\[dq]);
}, 1000);
.EE
.SS Working with asynchronous functions
\f[CR]setTimeout()\f[R] is an asynchronous function, meaning that the
timer function will not pause execution of other functions in the
functions stack.
In other words, you cannot use \f[CR]setTimeout()\f[R] to create a
\[lq]pause\[rq] before the next function in the function stack fires.
.PP
See the following example:
.IP
.EX
setTimeout(() \f[B]=>\f[R] {
  console.log(\[dq]this is the first message\[dq]);
}, 5000);
setTimeout(() \f[B]=>\f[R] {
  console.log(\[dq]this is the second message\[dq]);
}, 3000);
setTimeout(() \f[B]=>\f[R] {
  console.log(\[dq]this is the third message\[dq]);
}, 1000);

\f[I]// Output:\f[R]

\f[I]// this is the third message\f[R]
\f[I]// this is the second message\f[R]
\f[I]// this is the first message\f[R]
.EE
.PP
Notice that the first function does not create a 5\-second
\[lq]pause\[rq] before calling the second function.
Instead, the first function is called, but waits 5 seconds to execute.
While the first function is waiting to execute, the second function is
called, and a 3\-second wait is applied to the second function before it
executes.
Since neither the first nor the second function\[cq]s timers have
completed, the third function is called and completes its execution
first.
Then the second follows.
Then finally the first function is executed after its timer finally
completes.
.PP
To create a progression in which one function only fires after the
completion of another function, see the documentation on Promises.
.SS The \[lq]this\[rq] problem
When you pass a method to \f[CR]setTimeout()\f[R], it will be invoked
with a \f[CR]this\f[R] value that may differ from your expectation.
The general issue is explained in detail in the JavaScript reference.
.PP
Code executed by \f[CR]setTimeout()\f[R] is called from an execution
context separate from the function from which \f[CR]setTimeout\f[R] was
called.
The usual rules for setting the \f[CR]this\f[R] keyword for the called
function apply, and if you have not set \f[CR]this\f[R] in the call or
with \f[CR]bind\f[R], it will default to the \f[CR]window\f[R] (or
\f[CR]global\f[R]) object, even in strict mode.
It will not be the same as the \f[CR]this\f[R] value for the function
that called \f[CR]setTimeout\f[R].
.PP
See the following example:
.IP
.EX
\f[B]const\f[R] myArray = [\[dq]zero\[dq], \[dq]one\[dq], \[dq]two\[dq]];
myArray.myMethod = \f[B]function\f[R] (sProperty) {
  console.log(\f[B]arguments\f[R].length > 0 ? \f[B]this\f[R][sProperty] : \f[B]this\f[R]);
};

myArray.myMethod(); \f[I]// prints \[dq]zero,one,two\[dq]\f[R]
myArray.myMethod(1); \f[I]// prints \[dq]one\[dq]\f[R]
.EE
.PP
The above works because when \f[CR]myMethod\f[R] is called, its
\f[CR]this\f[R] is set to \f[CR]myArray\f[R] by the call, so within the
function, \f[CR]this[sProperty]\f[R] is equivalent to
\f[CR]myArray[sProperty]\f[R].
However, in the following:
.IP
.EX
setTimeout(myArray.myMethod, 1.0 * 1000); \f[I]// prints \[dq][object Window]\[dq] after 1 second\f[R]
setTimeout(myArray.myMethod, 1.5 * 1000, \[dq]1\[dq]); \f[I]// prints \[dq]undefined\[dq] after 1.5 seconds\f[R]
.EE
.PP
The \f[CR]myArray.myMethod\f[R] function is passed to
\f[CR]setTimeout\f[R], then when it\[cq]s called, its \f[CR]this\f[R] is
not set, so it defaults to the \f[CR]window\f[R] object.
.PP
There\[cq]s also no option to pass a \f[CR]thisArg\f[R] to
\f[CR]setTimeout\f[R] as there is in Array methods such as
\f[CR]forEach()\f[R] and \f[CR]reduce()\f[R].
As shown below, using \f[CR]call\f[R] to set \f[CR]this\f[R] doesn\[cq]t
work either.
.IP
.EX
setTimeout.call(myArray, myArray.myMethod, 2.0 * 1000); \f[I]// error\f[R]
setTimeout.call(myArray, myArray.myMethod, 2.5 * 1000, 2); \f[I]// same error\f[R]
.EE
.SS Solutions
.SS Use a wrapper function
A common way to solve the problem is to use a wrapper function that sets
\f[CR]this\f[R] to the required value:
.IP
.EX
setTimeout(\f[B]function\f[R] () {
  myArray.myMethod();
}, 2.0 * 1000); \f[I]// prints \[dq]zero,one,two\[dq] after 2 seconds\f[R]
setTimeout(\f[B]function\f[R] () {
  myArray.myMethod(\[dq]1\[dq]);
}, 2.5 * 1000); \f[I]// prints \[dq]one\[dq] after 2.5 seconds\f[R]
.EE
.PP
The wrapper function can be an arrow function:
.IP
.EX
setTimeout(() \f[B]=>\f[R] {
  myArray.myMethod();
}, 2.0 * 1000); \f[I]// prints \[dq]zero,one,two\[dq] after 2 seconds\f[R]
setTimeout(() \f[B]=>\f[R] {
  myArray.myMethod(\[dq]1\[dq]);
}, 2.5 * 1000); \f[I]// prints \[dq]one\[dq] after 2.5 seconds\f[R]
.EE
.SS Use bind()
Alternatively, you can use \f[CR]bind()\f[R] to set the value of
\f[CR]this\f[R] for all calls to a given function:
.IP
.EX
\f[B]const\f[R] myArray = [\[dq]zero\[dq], \[dq]one\[dq], \[dq]two\[dq]];
\f[B]const\f[R] myBoundMethod = \f[B]function\f[R] (sProperty) {
  console.log(\f[B]arguments\f[R].length > 0 ? \f[B]this\f[R][sProperty] : \f[B]this\f[R]);
}.bind(myArray);

myBoundMethod(); \f[I]// prints \[dq]zero,one,two\[dq] because \[aq]this\[aq] is bound to myArray in the function\f[R]
myBoundMethod(1); \f[I]// prints \[dq]one\[dq]\f[R]
setTimeout(myBoundMethod, 1.0 * 1000); \f[I]// still prints \[dq]zero,one,two\[dq] after 1 second because of the binding\f[R]
setTimeout(myBoundMethod, 1.5 * 1000, \[dq]1\[dq]); \f[I]// prints \[dq]one\[dq] after 1.5 seconds\f[R]
.EE
.SS Passing string literals
Passing a string instead of a function to \f[CR]setTimeout()\f[R] has
the same problems as using \f[CR]eval()\f[R].
.PP
\f[B]Bad\f[R]
.IP
.EX
\f[I]// Don\[aq]t do this\f[R]
setTimeout(\[dq]console.log(\[aq]Hello World!\[aq]);\[dq], 500);
.EE
.PP
\f[B]Good\f[R]
.IP
.EX
\f[I]// Do this instead\f[R]
setTimeout(() \f[B]=>\f[R] {
  console.log(\[dq]Hello World!\[dq]);
}, 500);
.EE
.PP
A string passed to \f[CR]setTimeout()\f[R] is evaluated in the global
context, so local symbols in the context where \f[CR]setTimeout()\f[R]
was called will not be available when the string is evaluated as code.
.SS Reasons for delays longer than specified
There are a number of reasons why a timeout may take longer to fire than
anticipated.
This section describes the most common reasons.
.SS Nested timeouts
As specified in the \c
.UR https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
HTML standard
.UE \c
, browsers will enforce a minimum timeout of 4 milliseconds once a
nested call to \f[CR]setTimeout\f[R] has been scheduled 5 times.
.PP
This can be seen in the following example, in which we nest a call to
\f[CR]setTimeout\f[R] with a delay of \f[CR]0\f[R] milliseconds, and log
the delay each time the handler is called.
The first four times, the delay is approximately 0 milliseconds, and
after that it is approximately 4 milliseconds:
.IP
.EX
<\f[B]button\f[R] id=\[dq]run\[dq]>Run</\f[B]button\f[R]>
<\f[B]table\f[R]>
  <\f[B]thead\f[R]>
    <\f[B]tr\f[R]>
      <\f[B]th\f[R]>Previous</\f[B]th\f[R]>
      <\f[B]th\f[R]>This</\f[B]th\f[R]>
      <\f[B]th\f[R]>Actual delay</\f[B]th\f[R]>
    </\f[B]tr\f[R]>
  </\f[B]thead\f[R]>
  <\f[B]tbody\f[R] id=\[dq]log\[dq]></\f[B]tbody\f[R]>
</\f[B]table\f[R]>
.EE
.IP
.EX
\f[B]let\f[R] last = 0;
\f[B]let\f[R] iterations = 10;

\f[B]function\f[R] timeout() {
  \f[I]// log the time of this call\f[R]
  log(\f[B]new\f[R] Date().getMilliseconds());
  \f[I]// if we are not finished, schedule the next call\f[R]
  \f[B]if\f[R] (iterations\-\- > 0) {
    setTimeout(timeout, 0);
  }
}

\f[B]function\f[R] run() {
  \f[I]// clear the log\f[R]
  \f[B]const\f[R] log = document.querySelector(\[dq]#log\[dq]);
  \f[B]while\f[R] (log.lastElementChild) {
    log.removeChild(log.lastElementChild);
  }

  \f[I]// initialize iteration count and the starting timestamp\f[R]
  iterations = 10;
  last = \f[B]new\f[R] Date().getMilliseconds();
  \f[I]// start timer\f[R]
  setTimeout(timeout, 0);
}

\f[B]function\f[R] log(now) {
  \f[I]// log the last timestamp, the new timestamp, and the difference\f[R]
  \f[B]const\f[R] tableBody = document.getElementById(\[dq]log\[dq]);
  \f[B]const\f[R] logRow = tableBody.insertRow();
  logRow.insertCell().textContent = last;
  logRow.insertCell().textContent = now;
  logRow.insertCell().textContent = now \- last;
  last = now;
}

document.querySelector(\[dq]#run\[dq]).addEventListener(\[dq]click\[dq], run);
.EE
.SS Timeouts in inactive tabs
To reduce the load (and associated battery usage) from background tabs,
browsers will enforce a minimum timeout delay in inactive tabs.
It may also be waived if a page is playing sound using a Web Audio API
\f[CR]AudioContext\f[R].
.PP
The specifics of this are browser\-dependent:
.IP \[bu] 2
Firefox Desktop and Chrome both have a minimum timeout of 1 second for
inactive tabs.
.IP \[bu] 2
Firefox for Android has a minimum timeout of 15 minutes for inactive
tabs and may unload them entirely.
.IP \[bu] 2
Firefox does not throttle inactive tabs if the tab contains an
\f[CR]AudioContext\f[R].
.SS Throttling of tracking scripts
Firefox enforces additional throttling for scripts that it recognizes as
tracking scripts.
When running in the foreground, the throttling minimum delay is still
4ms.
In background tabs, however, the throttling minimum delay is 10,000 ms,
or 10 seconds, which comes into effect 30 seconds after a document has
first loaded.
.PP
See \c
.UR https://wiki.mozilla.org/Security/Tracking_protection
Tracking Protection
.UE \c
\ for more details.
.SS Late timeouts
The timeout can also fire later than expected if the page (or the
OS/browser) is busy with other tasks.
One important case to note is that the function or code snippet cannot
be executed until the thread that called \f[CR]setTimeout()\f[R] has
terminated.
For example:
.IP
.EX
\f[B]function\f[R] foo() {
  console.log(\[dq]foo has been called\[dq]);
}
setTimeout(foo, 0);
console.log(\[dq]After setTimeout\[dq]);
.EE
.PP
Will write to the console:
.IP
.EX
After setTimeout
foo has been called
.EE
.PP
This is because even though \f[CR]setTimeout\f[R] was called with a
delay of zero, it\[cq]s placed on a queue and scheduled to run at the
next opportunity; not immediately.
Currently\-executing code must complete before functions on the queue
are executed, thus the resulting execution order may not be as expected.
.SS Deferral of timeouts during pageload
Firefox will defer firing \f[CR]setTimeout()\f[R] timers while the
current tab is loading.
Firing is deferred until the main thread is deemed idle (similar to
\f[CR]Window.requestIdleCallback()\f[R]), or until the load event is
fired.
.SS WebExtension background pages and timers
In WebExtensions, \f[CR]setTimeout()\f[R] does not work reliably.
Extension authors should use the \f[CR]alarms\f[R] API instead.
.SS Maximum delay value
Browsers store the delay as a 32\-bit signed integer internally.
This causes an integer overflow when using delays larger than
2,147,483,647 ms (about 24.8 days).
So for example, this code:
.IP
.EX
setTimeout(() \f[B]=>\f[R] console.log(\[dq]hi!\[dq]), 2 ** 32 \- 5000);
.EE
.PP
\&...results in the timeout being executed immediately (since
\f[CR]2**32 \- 5000\f[R] overflows to a negative number), while the
following code:
.IP
.EX
setTimeout(() \f[B]=>\f[R] console.log(\[dq]hi!\[dq]), 2 ** 32 + 5000);
.EE
.PP
\&...results in the timeout being executed after approximately 5
seconds.
.PP
\f[B]Note\f[R]: That doesn\[cq]t match \f[CR]setTimeout\f[R] behavior in
Node.js, where any timeout larger than 2,147,483,647 ms results in an
immediate execution.
.SH EXAMPLES
.SS Setting and clearing timeouts
The following example sets up two simple buttons in a web page and hooks
them to the \f[CR]setTimeout()\f[R] and \f[CR]clearTimeout()\f[R]
routines.
Pressing the first button will set a timeout which shows a message after
two seconds and stores the timeout id for use by
\f[CR]clearTimeout()\f[R].
You may optionally cancel this timeout by pressing on the second button.
.SS HTML
.IP
.EX
<\f[B]button\f[R] onclick=\[dq]delayedMessage();\[dq]>Show a message after two seconds</\f[B]button\f[R]>
<\f[B]button\f[R] onclick=\[dq]clearMessage();\[dq]>Cancel message before it happens</\f[B]button\f[R]>

<\f[B]div\f[R] id=\[dq]output\[dq]></\f[B]div\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]let\f[R] timeoutID;

\f[B]function\f[R] setOutput(outputContent) {
  document.querySelector(\[dq]#output\[dq]).textContent = outputContent;
}

\f[B]function\f[R] delayedMessage() {
  setOutput(\[dq]\[dq]);
  timeoutID = setTimeout(setOutput, 2 * 1000, \[dq]That was really slow!\[dq]);
}

\f[B]function\f[R] clearMessage() {
  clearTimeout(timeoutID);
}
.EE
.SS Result
See also the \f[CR]clearTimeout()\f[R] example.
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#settimeout-and-setinterval
Polyfill of \f[CR]setTimeout\f[R] which allows passing arguments to the
callback in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Window.clearTimeout()\f[R]
.IP \[bu] 2
\f[CR]WorkerGlobalScope.setTimeout()\f[R]
.IP \[bu] 2
\f[CR]Window.setInterval()\f[R]
.IP \[bu] 2
\f[CR]Window.requestAnimationFrame()\f[R]
.IP \[bu] 2
\f[CR]Window.queueMicrotask()\f[R]
