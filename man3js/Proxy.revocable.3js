.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Proxy.revocable" "JS" "November 8, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Proxy.revocable \- Proxy.revocable()
.SH SYNOPSIS
The \f[B]\f[CB]Proxy.revocable()\f[B]\f[R] static method creates a
revocable \f[CR]Proxy\f[R] object.
.SH SYNTAX
.IP
.EX
Proxy.revocable(target, handler)
.EE
.SS Parameters
.TP
\f[B]target\f[R]
A target object to wrap with \f[CR]Proxy\f[R].
It can be any sort of object, including a native array, a function, or
even another proxy.
.TP
\f[B]handler\f[R]
An object whose properties are functions defining the behavior of
\f[CR]proxy\f[R] when an operation is performed on it.
.SS Return value
A plain object with the following two properties:
.TP
\f[B]proxy\f[R]
A Proxy object exactly the same as one created with a
\f[CR]new Proxy(target, handler)\f[R] call.
.TP
\f[B]revoke\f[R]
A function with no parameters to revoke (switch off) the
\f[CR]proxy\f[R].
.SH DESCRIPTION
The \f[CR]Proxy.revocable()\f[R] factory function is the same as the
\f[CR]Proxy()\f[R] constructor, except that in addition to creating a
proxy object, it also creates a \f[CR]revoke\f[R] function that can be
called to disable the proxy.
The proxy object and the \f[CR]revoke\f[R] function are wrapped in a
plain object.
.PP
The \f[CR]revoke\f[R] function does not take any parameters, nor does it
rely on the \f[CR]this\f[R] value.
The created \f[CR]proxy\f[R] object is attached to the \f[CR]revoke\f[R]
function as a private property that the \f[CR]revoke\f[R] function
accesses on itself when called (the existence of the private property is
not observable from the outside, but it has implications on how garbage
collection happens).
The \f[CR]proxy\f[R] object is \f[I]not\f[R] captured within the closure
of the \f[CR]revoke\f[R] function (which will make garbage collection of
\f[CR]proxy\f[R] impossible if \f[CR]revoke\f[R] is still alive).
.PP
After the \f[CR]revoke()\f[R] function gets called, the proxy becomes
unusable: any trap to a handler throws a \f[CR]TypeError\f[R].
Once a proxy is revoked, it remains revoked, and calling
\f[CR]revoke()\f[R] again has no effect \[em] in fact, the call to
\f[CR]revoke()\f[R] detaches the \f[CR]proxy\f[R] object from the
\f[CR]revoke\f[R] function, so the \f[CR]revoke\f[R] function will not
be able to access the proxy again at all.
If the proxy is not referenced elsewhere, it will then be eligible for
garbage collection.
The \f[CR]revoke\f[R] function also detaches \f[CR]target\f[R] and
\f[CR]handler\f[R] from the \f[CR]proxy\f[R], so if \f[CR]target\f[R] is
not referenced elsewhere, it will also be eligible for garbage
collection, even when its proxy is still alive, since there\[cq]s no
longer a way to meaningfully interact with the target object.
.PP
Letting users interact with an object through a revocable proxy allows
you to control the lifetime of the object exposed to the user \[em] you
can make the object garbage\-collectable even when the user is still
holding a reference to its proxy.
.SH EXAMPLES
.SS Using Proxy.revocable()
.IP
.EX
\f[B]const\f[R] revocable = Proxy.revocable(
  {},
  {
    \f[B]get\f[R](target, name) {
      \f[B]return\f[R] \[ga][[${name}]]\[ga];
    },
  },
);
\f[B]const\f[R] proxy = revocable.proxy;
console.log(proxy.foo); \f[I]// \[dq][[foo]]\[dq]\f[R]

revocable.revoke();

console.log(proxy.foo); \f[I]// TypeError is thrown\f[R]
proxy.foo = 1; \f[I]// TypeError again\f[R]
\f[B]delete\f[R] proxy.foo; \f[I]// still TypeError\f[R]
\f[B]typeof\f[R] proxy; \f[I]// \[dq]object\[dq], typeof doesn\[aq]t trigger any trap\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Proxy\f[R]
