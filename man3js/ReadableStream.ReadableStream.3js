.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "READABLESTREAM.READABLESTREAM" "3JS" "April 3, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ReadableStream.ReadableStream \- ReadableStream: ReadableStream()
constructor
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]ReadableStream()\f[B]\f[R] constructor creates and
returns a readable stream object from the given handlers.
.PP
Note that while all parameters are technically optional, omitting the
\f[CR]underlyingSource\f[R] will result in a stream that has no source,
and that can\(cqt be read from (readers return a promise that will never
be resolved).
.SH SYNTAX
.IP
.EX
new ReadableStream()
new ReadableStream(underlyingSource)
new ReadableStream(underlyingSource, queuingStrategy)
.EE
.SS Parameters
.TP
\f[B]underlyingSource\f[R] \f[I](optional)\f[R]
An object containing methods and properties that define how the
constructed stream instance will behave.
\f[CR]underlyingSource\f[R] can contain the following:
.RS
.TP
\f[B]start\f[R] (controller) \f[I](optional)\f[R]
This is a method, called immediately when the object is constructed.
The contents of this method are defined by the developer, and should aim
to get access to the stream source, and do anything else required to set
up the stream functionality.
If this process is to be done asynchronously, it can return a promise to
signal success or failure.
The \f[CR]controller\f[R] parameter passed to this method is a
\f[CR]ReadableStreamDefaultController\f[R] or a
\f[CR]ReadableByteStreamController\f[R], depending on the value of the
\f[CR]type\f[R] property.
This can be used by the developer to control the stream during set up.
.TP
\f[B]pull\f[R] (controller) \f[I](optional)\f[R]
This method, also defined by the developer, will be called repeatedly
when the stream\(cqs internal queue of chunks is not full, up until it
reaches its high water mark.
If \f[CR]pull()\f[R] returns a promise, then it won\(cqt be called again
until that promise fulfills; if the promise rejects, the stream will
become errored.
The \f[CR]controller\f[R] parameter passed to this method is a
\f[CR]ReadableStreamDefaultController\f[R] or a
\f[CR]ReadableByteStreamController\f[R], depending on the value of the
\f[CR]type\f[R] property.
This can be used by the developer to control the stream as more chunks
are fetched.
This function will not be called until \f[CR]start()\f[R] successfully
completes.
Additionally, it will only be called repeatedly if it enqueues at least
one chunk or fulfills a BYOB request; a no\-op \f[CR]pull()\f[R]
implementation will not be continually called.
.TP
\f[B]cancel\f[R] (reason) \f[I](optional)\f[R]
This method, also defined by the developer, will be called if the app
signals that the stream is to be cancelled (e.g., if
\f[CR]ReadableStream.cancel()\f[R] is called).
The contents should do whatever is necessary to release access to the
stream source.
If this process is asynchronous, it can return a promise to signal
success or failure.
The \f[CR]reason\f[R] parameter contains a string describing why the
stream was cancelled.
.TP
\f[B]type\f[R] \f[I](optional)\f[R]
This property controls what type of readable stream is being dealt with.
If it is included with a value set to \f[CR]\(dqbytes\(dq\f[R], the
passed controller object will be a
\f[CR]ReadableByteStreamController\f[R] capable of handling a BYOB
(bring your own buffer)/byte stream.
If it is not included, the passed controller will be a
\f[CR]ReadableStreamDefaultController\f[R].
.TP
\f[B]autoAllocateChunkSize\f[R] \f[I](optional)\f[R]
For byte streams, the developer can set the
\f[CR]autoAllocateChunkSize\f[R] with a positive integer value to turn
on the stream\(cqs auto\-allocation feature.
With this is set, the stream implementation will automatically allocate
a view buffer of the specified size in
\f[CR]ReadableByteStreamController.byobRequest\f[R] when required.
.RS
.PP
This must be set to enable zero\-copy transfers to be used with a
default \f[CR]ReadableStreamDefaultReader\f[R].
If not set, a default reader will still stream data, but
\f[CR]ReadableByteStreamController.byobRequest\f[R] will always be
\f[CR]null\f[R] and transfers to the consumer must be via the
stream\(cqs internal queues.
.RE
.RE
.TP
\f[B]queuingStrategy\f[R] \f[I](optional)\f[R]
An object that optionally defines a queuing strategy for the stream.
This takes two parameters:
.RS
.TP
\f[B]highWaterMark\f[R]
A non\-negative integer \(em this defines the total number of chunks
that can be contained in the internal queue before backpressure is
applied.
.TP
\f[B]size(chunk)\f[R]
A method containing a parameter \f[CR]chunk\f[R] \(em this indicates the
size to use for each chunk, in bytes.
.RS
.PP
\f[B]Note:\f[R] You could define your own custom
\f[CR]queuingStrategy\f[R], or use an instance of
\f[CR]ByteLengthQueuingStrategy\f[R] or \f[CR]CountQueuingStrategy\f[R]
for this object value.
If no \f[CR]queuingStrategy\f[R] is supplied, the default used is the
same as a \f[CR]CountQueuingStrategy\f[R] with a high water mark of 1.
.RE
.RE
.SS Return value
An instance of the \f[CR]ReadableStream\f[R] object.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if the supplied type value is neither \f[CR]\(dqbytes\(dq\f[R]
nor \f[CR]undefined\f[R].
.SH EXAMPLES
In the following simple example, a custom \f[CR]ReadableStream\f[R] is
created using a constructor (see our \c
.UR https://mdn.github.io/dom-examples/streams/simple-random-stream/
Simple random stream example
.UE \c
\ for the full code).
The \f[CR]start()\f[R] function generates a random string of text every
second and enqueues it into the stream.
A \f[CR]cancel()\f[R] function is also provided to stop the generation
if \f[CR]ReadableStream.cancel()\f[R] is called for any reason.
.PP
When a button is pressed, the generation is stopped, the stream is
closed using \f[CR]ReadableStreamDefaultController.close()\f[R], and
another function is run, which reads the data back out of the stream.
.IP
.EX
\f[B]let\f[R] interval;
\f[B]const\f[R] stream = \f[B]new\f[R] ReadableStream({
  start(controller) {
    interval = setInterval(() \f[B]=>\f[R] {
      \f[B]let\f[R] string = randomChars();

      \f[I]// Add the string to the stream\f[R]
      controller.enqueue(string);

      \f[I]// show it on the screen\f[R]
      \f[B]let\f[R] listItem = document.createElement(\(dqli\(dq);
      listItem.textContent = string;
      list1.appendChild(listItem);
    }, 1000);

    button.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
      clearInterval(interval);
      fetchStream();
      controller.close();
    });
  },
  pull(controller) {
    \f[I]// We don\(aqt really need a pull in this example\f[R]
  },
  cancel() {
    \f[I]// This is called if the reader cancels,\f[R]
    \f[I]// so we should stop generating strings\f[R]
    clearInterval(interval);
  },
});
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]ReadableStream\f[R]
.IP \(bu 2
\f[CR]ReadableByteStreamController\f[R]
.IP \(bu 2
\f[CR]ReadableStreamDefaultController\f[R]
.IP \(bu 2
Using readable streams
