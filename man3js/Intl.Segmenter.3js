.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Intl.Segmenter" "JS" "July 13, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.Segmenter \- Intl.Segmenter
.SH SYNOPSIS
The \f[B]\f[CB]Intl.Segmenter\f[B]\f[R] object enables locale\-sensitive
text segmentation, enabling you to get meaningful items (graphemes,
words or sentences) from a string.
.SH CONSTRUCTOR
.TP
\f[B]Intl.Segmenter()\f[R]
Creates a new \f[CR]Intl.Segmenter\f[R] object.
.SH STATIC METHODS
.TP
\f[B]Intl.Segmenter.supportedLocalesOf()\f[R]
Returns an array containing those of the provided locales that are
supported without having to fall back to the runtime\[cq]s default
locale.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]Intl.Segmenter.prototype\f[R] and
shared by all \f[CR]Intl.Segmenter\f[R] instances.
.TP
\f[B]Intl.Segmenter.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]Intl.Segmenter\f[R] instances, the initial value is the
\f[CR]Intl.Segmenter\f[R] constructor.
.TP
\f[B]Intl.Segmenter.prototype[Symbol.toStringTag]\f[R]
The initial value of the \f[CR][Symbol.toStringTag]\f[R] property is the
string \f[CR]\[dq]Intl.Segmenter\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH INSTANCE METHODS
.TP
\f[B]Intl.Segmenter.prototype.resolvedOptions()\f[R]
Returns a new object with properties reflecting the locale and
granularity options computed during initialization of this
\f[CR]Intl.Segmenter\f[R] object.
.TP
\f[B]Intl.Segmenter.prototype.segment()\f[R]
Returns a new iterable \f[CR]Segments\f[R] instance representing the
segments of a string according to the locale and granularity of this
\f[CR]Intl.Segmenter\f[R] instance.
.SH EXAMPLES
.SS Basic usage and difference from String.prototype.split()
If we were to use \f[CR]String.prototype.split(\[dq] \[dq])\f[R] to
segment a text in words, we would not get the correct result if the
locale of the text does not use whitespaces between words (which is the
case for Japanese, Chinese, Thai, Lao, Khmer, Myanmar, etc.).
.PP
\f[B]Bad\f[R]
.IP
.EX
\f[B]const\f[R] str = \[dq]吾輩は猫である。名前はたぬき。\[dq];
console.table(str.split(\[dq] \[dq]));
\f[I]// [\[aq]吾輩は猫である。名前はたぬき。\[aq]]\f[R]
\f[I]// The two sentences are not correctly segmented.\f[R]
.EE
.PP
\f[B]Good\f[R]
.IP
.EX
\f[B]const\f[R] str = \[dq]吾輩は猫である。名前はたぬき。\[dq];
\f[B]const\f[R] segmenterJa = \f[B]new\f[R] Intl.Segmenter(\[dq]ja\-JP\[dq], { granularity: \[dq]word\[dq] });

\f[B]const\f[R] segments = segmenterJa.segment(str);
console.table(Array.from(segments));
\f[I]// [{segment: \[aq]吾輩\[aq], index: 0, input: \[aq]吾輩は猫である。名前はたぬき。\[aq], isWordLike: true},\f[R]
\f[I]// etc.\f[R]
\f[I]// ]\f[R]
.EE
