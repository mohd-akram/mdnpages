.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPUQUEUE.ONSUBMITTEDWORKDONE" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPUQueue.onSubmittedWorkDone \- GPUQueue: onSubmittedWorkDone() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]onSubmittedWorkDone()\f[B]\f[R] method of the
\f[CR]GPUQueue\f[R] interface returns a \f[CR]Promise\f[R] that resolves
when all the work submitted to the GPU via this \f[CR]GPUQueue\f[R] at
the point the method is called has been processed.
.PP
This includes the completion of any \f[CR]mapAsync()\f[R] calls made on
\f[CR]GPUBuffer\f[R]s used in commands submitted to the queue, before
\f[CR]onSubmittedWorkDone()\f[R] is called.
.PP
Note: In most cases, you do \f[I]not\f[R] need to call
\f[CR]onSubmittedWorkDone()\f[R].
You do \f[B]\f[BI]not\f[B]\f[R] need to call it for mapping a buffer.
\f[CR]mapAsync\f[R] guarantees work submitted to the queue before
calling \f[CR]mapAsync\f[R] happens before the \f[CR]mapAsync\f[R]
returns (see \c
.UR https://gpuweb.github.io/gpuweb/#buffer-mapping
WebGPU spec
.UE \c
).
.PP
The two use cases for \f[CR]onSubmittedWorkDone\f[R]
.IP "1." 3
Waiting for multiple buffer mapping (slow)
.RS 4
.IP
.EX
\f[I]// good\f[R]
\f[B]await\f[R] Promise.all([
  buffer1.mapAsync(),
  buffer2.mapAsync(),
  buffer3.mapAsync(),
]);
data1 = buffer1.getMappedRange();
data2 = buffer2.getMappedRange();
data3 = buffer3.getMappedRange();
.EE
.IP
.EX
\f[I]// works but slow\f[R]
buffer1.mapAsync();
buffer2.mapAsync();
buffer3.mapAsync();
\f[B]await\f[R] device.queue.onSubmittedWorkDone();
data1 = buffer1.getMappedRange();
data2 = buffer2.getMappedRange();
data3 = buffer3.getMappedRange();
.EE
.PP
The reason the second method is slow is, the implementation may be able
to map the buffers before all the submitted work is done.
For example, if all the buffers are finished being used, but more work
(unrelated to the buffers) is already submitted, then you\(cqll end up
waiting longer using the second method than the first.
.RE
.IP "2." 3
Throttling work
.RS 4
.PP
If you are doing heavy compute work and you submit too much work at
once, the browser may kill your work.
You can throttle the work by only submitting more work when the work
you\(cqve already submitted is done.
.RE
.SH SYNTAX
.IP
.EX
onSubmittedWorkDone()
.EE
.SS Parameters
None.
.SS Return value
A \f[CR]Promise\f[R] that resolves with \f[CR]Undefined\f[R].
.SH EXAMPLES
.IP
.EX
device.queue.submit([commandEncoder.finish()]);
device.queue.onSubmittedWorkDone().then(() \f[B]=>\f[R] {
  console.log(\(dqAll submitted commands processed.\(dq);
});
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
