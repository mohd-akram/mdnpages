.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "MEDIASTREAMTRACKPROCESSOR" "3JS" "May 23, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
MediaStreamTrackProcessor \- MediaStreamTrackProcessor
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is only available in Dedicated Web Workers.
.RS
.PP
\f[B]Warning:\f[R] Browsers differ on which global context they expose
this interface in (e.g., only window in some browsers and only dedicated
worker in others), making them incompatible.
Keep this in mind when comparing support.
.RE
.PP
The \f[B]\f[CB]MediaStreamTrackProcessor\f[B]\f[R] interface of the
Insertable Streams for MediaStreamTrack API consumes a video
\f[CR]MediaStreamTrack\f[R] object\(cqs source and generates a stream of
\f[CR]VideoFrame\f[R] objects.
.SH CONSTRUCTOR
.TP
\f[B]MediaStreamTrackProcessor()\f[R]
Creates a new \f[CR]MediaStreamTrackProcessor\f[R] object.
.TP
\f[B]window.MediaStreamTrackProcessor()\f[R] \f[I](experimental)\f[R] \f[I](non\-standard)\f[R]
Creates a new \f[CR]MediaStreamTrackProcessor\f[R] object on the main
thread that can process both video and audio.
.SH INSTANCE PROPERTIES
.TP
\f[B]MediaStreamTrackProcessor.readable\f[R]
Returns a \f[CR]ReadableStream\f[R].
.SH EXAMPLES
The following example is from the article \c
.UR https://blog.mozilla.org/webrtc/unbundling-mediastreamtrackprocessor-and-videotrackgenerator/
Unbundling MediaStreamTrackProcessor and VideoTrackGenerator
.UE \c
\&.
It transfers a camera \f[CR]MediaStreamTrack\f[R] to a worker for
processing.
The worker creates a pipeline that applies a sepia tone filter to the
video frames and mirrors them.
The pipeline culminates in a \f[CR]VideoTrackGenerator\f[R] whose
\f[CR]MediaStreamTrack\f[R] is transferred back and played.
The media now flows in real time through the transform off the main
thread.
.IP
.EX
\f[B]const\f[R] stream = \f[B]await\f[R] navigator.mediaDevices.getUserMedia({ video: \f[B]true\f[R] });
\f[B]const\f[R] [track] = stream.getVideoTracks();
\f[B]const\f[R] worker = \f[B]new\f[R] Worker(\(dqworker.js\(dq);
worker.postMessage({ track }, [track]);
\f[B]const\f[R] { data } = \f[B]await\f[R] \f[B]new\f[R] Promise((r) \f[B]=>\f[R] {
  worker.onmessage = r;
});
video.srcObject = \f[B]new\f[R] MediaStream([data.track]);
.EE
.PP
worker.js:
.IP
.EX
onmessage = \f[B]async\f[R] ({ data: { track } }) \f[B]=>\f[R] {
  \f[B]const\f[R] vtg = \f[B]new\f[R] VideoTrackGenerator();
  self.postMessage({ track: vtg.track }, [vtg.track]);
  \f[B]const\f[R] { readable } = \f[B]new\f[R] MediaStreamTrackProcessor({ track });
  \f[B]await\f[R] readable
    .pipeThrough(\f[B]new\f[R] TransformStream({ transform }))
    .pipeTo(vtg.writable);
};
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]VideoTrackGenerator\f[R]
.IP \(bu 2
\c
.UR https://developer.chrome.com/docs/capabilities/web-apis/mediastreamtrack-insertable-media-processing
Insertable streams for MediaStreamTrack
.UE \c
\ on developer.chrome.com > \f[B]Note:\f[R] > This article was written
before the API was restricted to workers and video.
Beware its use of the non\-standard version of
\f[CR]MediaStreamTrackProcessor\f[R] which blocks on the main thread.
