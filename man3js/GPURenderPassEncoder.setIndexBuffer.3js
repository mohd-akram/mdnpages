.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPURENDERPASSENCODER.SETINDEXBUFFER" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPURenderPassEncoder.setIndexBuffer \- GPURenderPassEncoder:
setIndexBuffer() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]setIndexBuffer()\f[B]\f[R] method of the
\f[CR]GPURenderPassEncoder\f[R] interface sets the current
\f[CR]GPUBuffer\f[R] that will provide index data for subsequent drawing
commands.
.SH SYNTAX
.IP
.EX
setIndexBuffer(buffer, indexFormat, offset, size)
.EE
.SS Parameters
.TP
\f[B]buffer\f[R]
A \f[CR]GPUBuffer\f[R] representing the buffer containing the index data
to use for subsequent drawing commands.
.TP
\f[B]indexFormat\f[R]
An enumerated value that defines the format of the index data contained
in \f[CR]buffer\f[R].
Possible values are:
.RS
.IP \(bu 2
\f[CR]\(dquint16\(dq\f[R]
.IP \(bu 2
\f[CR]\(dquint32\(dq\f[R]
.RE
.TP
\f[B]offset\f[R] \f[I](optional)\f[R]
A number representing the offset, in bytes, into \f[CR]buffer\f[R] where
the index data begins.
If omitted, \f[CR]offset\f[R] defaults to 0.
.TP
\f[B]size\f[R] \f[I](optional)\f[R]
A number representing the size, in bytes, of the index data contained in
\f[CR]buffer\f[R].
If omitted, \f[CR]size\f[R] defaults to the \f[CR]buffer\f[R]\(cqs
\f[CR]GPUBuffer.size\f[R] \- \f[CR]offset\f[R].
.SS Note on indexFormat
\f[CR]indexFormat\f[R] determines both the data type of index values in
a buffer and, when used with a pipeline that specifies a strip primitive
topology (\f[CR]\(dqline\-strip\(dq\f[R] or
\f[CR]\(dqtriangle\-strip\(dq\f[R]), also determines the primitive
restart value.
The primitive restart value is an index value indicating that a new
primitive should be started rather than continuing to construct the
strip with the prior indexed vertices.
The value is \f[CR]0xFFFF\f[R] for \f[CR]\(dquint16\(dq\f[R], or
\f[CR]0xFFFFFFFF\f[R] for \f[CR]\(dquint32\(dq\f[R].
.SS Return value
None (\f[CR]Undefined\f[R]).
.SS Validation
The following criteria must be met when calling
\f[B]\f[CB]setIndexBuffer()\f[B]\f[R], otherwise a
\f[CR]GPUValidationError\f[R] is generated and the
\f[CR]GPURenderPassEncoder\f[R] becomes invalid:
.IP \(bu 2
\f[CR]buffer\f[R]\(cqs \f[CR]GPUBuffer.usage\f[R] contains the
\f[CR]GPUBufferUsage.INDEX\f[R] flag.
.IP \(bu 2
\f[CR]offset\f[R] + \f[CR]size\f[R] is less than or equal to the
\f[CR]buffer\f[R]\(cqs \f[CR]GPUBuffer.size\f[R].
.IP \(bu 2
\f[CR]offset\f[R] is a multiple of \f[CR]indexFormat\f[R]\(cqs byte size
(2 for \f[CR]\(dquint16\(dq\f[R], 4 for \f[CR]\(dquint32\(dq\f[R]).
.SH EXAMPLES
In the WebGPU Samples \c
.UR https://webgpu.github.io/webgpu-samples/samples/shadowMapping/
Shadow Mapping
.UE \c
\ example, \f[CR]setIndexBuffer()\f[R] is used in two separate render
passes in each animation frame, one to draw the main model and one to
draw its shadow.
Study the example code listing for the full context.
.IP
.EX
\f[I]// \&...\f[R]

\f[B]const\f[R] commandEncoder = device.createCommandEncoder();
{
  \f[B]const\f[R] shadowPass = commandEncoder.beginRenderPass(shadowPassDescriptor);
  shadowPass.setPipeline(shadowPipeline);
  shadowPass.setBindGroup(0, sceneBindGroupForShadow);
  shadowPass.setBindGroup(1, modelBindGroup);
  shadowPass.setVertexBuffer(0, vertexBuffer);
  shadowPass.setIndexBuffer(indexBuffer, \(dquint16\(dq);
  shadowPass.drawIndexed(indexCount);

  shadowPass.end();
}
{
  \f[B]const\f[R] renderPass = commandEncoder.beginRenderPass(renderPassDescriptor);
  renderPass.setPipeline(pipeline);
  renderPass.setBindGroup(0, sceneBindGroupForRender);
  renderPass.setBindGroup(1, modelBindGroup);
  renderPass.setVertexBuffer(0, vertexBuffer);
  renderPass.setIndexBuffer(indexBuffer, \(dquint16\(dq);
  renderPass.drawIndexed(indexCount);

  renderPass.end();
}

\f[I]// \&...\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
