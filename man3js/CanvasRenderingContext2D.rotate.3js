.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "CanvasRenderingContext2D.rotate" "JS" "April 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
CanvasRenderingContext2D.rotate \- CanvasRenderingContext2D: rotate()
method
.SH SYNOPSIS
The \f[B]\f[CB]CanvasRenderingContext2D.rotate()\f[B]\f[R] method of the
Canvas 2D API adds a rotation to the transformation matrix.
.SH SYNTAX
.IP
.EX
rotate(angle)
.EE
[IMAGE: Rectangular coordinate system with the rotation of the abscissa
axis by the alpha angle]
Rectangular coordinate system with the rotation of the abscissa axis by
the alpha angle
.SS Parameters
.TP
\f[B]angle\f[R]
The rotation angle, clockwise in radians.
You can use \f[CR]degree * Math.PI / 180\f[R] to calculate a radian from
a degree.
.PP
The rotation center point is always the canvas origin.
To change the center point, you will need to move the canvas by using
the \f[CR]translate()\f[R] method.
.SS Return value
None (\f[CR]undefined\f[R]).
.SH EXAMPLES
.SS Rotating a shape
This example rotates a rectangle by 45Â°.
Note that the center of rotation is the top\-left corner of the canvas,
and not a location relative to any shape.
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]canvas\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);

\f[I]// Point of transform origin\f[R]
ctx.arc(0, 0, 5, 0, 2 * Math.PI);
ctx.fillStyle = \[dq]blue\[dq];
ctx.fill();

\f[I]// Non\-rotated rectangle\f[R]
ctx.fillStyle = \[dq]gray\[dq];
ctx.fillRect(100, 0, 80, 20);

\f[I]// Rotated rectangle\f[R]
ctx.rotate((45 * Math.PI) / 180);
ctx.fillStyle = \[dq]red\[dq];
ctx.fillRect(100, 0, 80, 20);

\f[I]// Reset transformation matrix to the identity matrix\f[R]
ctx.setTransform(1, 0, 0, 1, 0, 0);
.EE
.SS Result
The center of rotation is blue.
The non\-rotated rectangle is gray, and the rotated rectangle is red.
.SS Rotating a shape around its center
This example rotates a shape around its center point.
To do this, the following steps are applied to the matrix:
.IP "1." 3
First, \f[CR]translate()\f[R] moves the matrix\[cq]s origin to the
shape\[cq]s center.
.IP "2." 3
\f[CR]rotate()\f[R] rotates the matrix by the desired amount.
.IP "3." 3
Finally, \f[CR]translate()\f[R] moves the matrix\[cq]s origin back to
its starting point.
This is done by applying the values of the shape\[cq]s center
coordinates in a negative direction.
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]canvas\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
The shape is a rectangle with its corner at (80, 60), a width of 140, a
height of 30.
Its horizontal center is at (80 + 140 / 2), or 150.
Its vertical center is at (60 + 30 / 2), or 75.
Thus, the center point is at (150, 75).
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);

\f[I]// Non\-rotated rectangle\f[R]
ctx.fillStyle = \[dq]gray\[dq];
ctx.fillRect(80, 60, 140, 30);

\f[I]// Matrix transformation\f[R]
ctx.translate(150, 75);
ctx.rotate(Math.PI / 2);
ctx.translate(\-150, \-75);

\f[I]// Rotated rectangle\f[R]
ctx.fillStyle = \[dq]red\[dq];
ctx.fillRect(80, 60, 140, 30);
.EE
.SS Result
The non\-rotated rectangle is gray, and the rotated rectangle is red.
.SH SEE ALSO
.IP \[bu] 2
The interface defining this method: \f[CR]CanvasRenderingContext2D\f[R]
