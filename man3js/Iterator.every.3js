.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Iterator.every" "JS" "November 16, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator.every \- Iterator.prototype.every()
.SH SYNOPSIS
The \f[B]\f[CB]every()\f[B]\f[R] method of \f[CR]Iterator\f[R] instances
is similar to \f[CR]Array.prototype.every()\f[R]: it tests whether all
elements produced by the iterator pass the test implemented by the
provided function.
It returns a boolean value.
.SH SYNTAX
.IP
.EX
every(callbackFn)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element produced by the iterator.
It should return a truthy value to indicate the element passes the test,
and a falsy value otherwise.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed.
.TP
\f[B]index\f[R]
The index of the current element being processed.
.RE
.SS Return value
\f[CR]true\f[R] if \f[CR]callbackFn\f[R] returns a truthy value for
every element.
Otherwise, \f[CR]false\f[R].
.SH DESCRIPTION
\f[CR]every()\f[R] iterates the iterator and invokes the
\f[CR]callbackFn\f[R] function once for each element.
It returns \f[CR]false\f[R] immediately if the callback function returns
a falsy value.
Otherwise, it iterates until the end of the iterator and returns
\f[CR]true\f[R].
If \f[CR]every()\f[R] returns \f[CR]false\f[R], the underlying iterator
is closed by calling its \f[CR]return()\f[R] method.
.PP
The main advantage of iterator helpers over array methods is that they
are lazy, meaning that they only produce the next value when requested.
This avoids unnecessary computation and also allows them to be used with
infinite iterators.
With infinite iterators, \f[CR]every()\f[R] returns \f[CR]false\f[R] as
soon as the first falsy value is found.
If the \f[CR]callbackFn\f[R] always returns a truthy value, the method
never returns.
.SH EXAMPLES
.SS Using every()
.IP
.EX
\f[B]function\f[R]* fibonacci() {
  \f[B]let\f[R] current = 1;
  \f[B]let\f[R] next = 1;
  \f[B]while\f[R] (\f[B]true\f[R]) {
    \f[B]yield\f[R] current;
    [current, next] = [next, current + next];
  }
}

\f[B]const\f[R] isEven = (x) \f[B]=>\f[R] x % 2 === 0;
console.log(fibonacci().every(isEven)); \f[I]// false\f[R]

\f[B]const\f[R] isPositive = (x) \f[B]=>\f[R] x > 0;
console.log(fibonacci().take(10).every(isPositive)); \f[I]// true\f[R]
console.log(fibonacci().every(isPositive)); \f[I]// Never completes\f[R]
.EE
.PP
Calling \f[CR]every()\f[R] always closes the underlying iterator, even
if the method early\-returns.
The iterator is never left in a half\-way state.
.IP
.EX
\f[B]const\f[R] seq = fibonacci();
console.log(seq.every(isEven)); \f[I]// false\f[R]
console.log(seq.next()); \f[I]// { value: undefined, done: true }\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#iterator-helpers
Polyfill of \f[CR]Iterator.prototype.every\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Iterator\f[R]
.IP \[bu] 2
\f[CR]Iterator.prototype.find()\f[R]
.IP \[bu] 2
\f[CR]Iterator.prototype.some()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.every()\f[R]
