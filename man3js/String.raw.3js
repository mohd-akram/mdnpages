.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "String.raw" "JS" "May 31, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.raw \- String.raw()
.SH SYNOPSIS
The \f[B]\f[CB]String.raw()\f[B]\f[R] static method is a tag function of
template literals.
This is similar to the \f[CR]r\f[R] prefix in Python, or the
\f[CR]\[at]\f[R] prefix in C# for string literals.
It\[cq]s used to get the raw string form of template literals \[em] that
is, substitutions (e.g.\ \f[CR]${foo}\f[R]) are processed, but escape
sequences (e.g.\ \f[CR]\[rs]n\f[R]) are not.
.SH SYNTAX
.IP
.EX
String.raw(strings)
String.raw(strings, sub1)
String.raw(strings, sub1, sub2)
String.raw(strings, sub1, sub2, /* \&..., */ subN)

String.raw\[ga]templateString\[ga]
.EE
.SS Parameters
.TP
\f[B]strings\f[R]
Well\-formed template literal array object, like
\f[CR]{ raw: [\[aq]foo\[aq], \[aq]bar\[aq], \[aq]baz\[aq]] }\f[R].
Should be an object with a \f[CR]raw\f[R] property whose value is an
array\-like object of strings.
.TP
\f[B]sub1\f[R], \&..., \f[B]subN\f[R]
Contains substitution values.
.TP
\f[B]templateString\f[R]
A template literal, optionally with substitutions (\f[CR]${...}\f[R]).
.SS Return value
The raw string form of a given template literal.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if the first argument doesn\[cq]t have a \f[CR]raw\f[R] property,
or the \f[CR]raw\f[R] property is \f[CR]undefined\f[R] or
\f[CR]null\f[R].
.SH DESCRIPTION
In most cases, \f[CR]String.raw()\f[R] is used with template literals.
The first syntax mentioned above is only rarely used, because the
JavaScript engine will call this with proper arguments for you, (just
like with other tag functions).
.PP
\f[CR]String.raw()\f[R] is the only built\-in template literal tag.
It has close semantics to an untagged literal since it concatenates all
arguments and returns a string.
You can even re\-implement it with normal JavaScript code.
.RS
.PP
\f[B]Warning:\f[R] You should not use \f[CR]String.raw\f[R] directly as
an \[lq]identity\[rq] tag.
See Building an identity tag for how to implement this.
.RE
.PP
If \f[CR]String.raw()\f[R] is called with an object whose \f[CR]raw\f[R]
property doesn\[cq]t have a \f[CR]length\f[R] property or a
non\-positive \f[CR]length\f[R], it returns an empty string
\f[CR]\[dq]\[dq]\f[R].
If \f[CR]substitutions.length < strings.raw.length \- 1\f[R]
(i.e.\ there are not enough substitutions to fill the placeholders \[em]
which can\[cq]t happen in a well\-formed tagged template literal), the
rest of the placeholders are filled with empty strings.
.SH EXAMPLES
.SS Using String.raw()
.IP
.EX
String.raw\[ga]Hi\[rs]n${2 + 3}!\[ga];
\f[I]// \[aq]Hi\[rs]\[rs]n5!\[aq], the character after \[aq]Hi\[aq]\f[R]
\f[I]// is not a newline character,\f[R]
\f[I]// \[aq]\[rs]\[aq] and \[aq]n\[aq] are two characters.\f[R]

String.raw\[ga]Hi\[rs]u000A!\[ga];
\f[I]// \[aq]Hi\[rs]\[rs]u000A!\[aq], same here, this time we will get the\f[R]
\f[I]// \[rs], u, 0, 0, 0, A, 6 characters.\f[R]
\f[I]// All kinds of escape characters will be ineffective\f[R]
\f[I]// and backslashes will be present in the output string.\f[R]
\f[I]// You can confirm this by checking the .length property\f[R]
\f[I]// of the string.\f[R]

\f[B]const\f[R] name = \[dq]Bob\[dq];
String.raw\[ga]Hi\[rs]n${name}!\[ga];
\f[I]// \[aq]Hi\[rs]\[rs]nBob!\[aq], substitutions are processed.\f[R]

String.raw\[ga]Hi \[rs]${name}!\[ga];
\f[I]// \[aq]Hi \[rs]\[rs]${name}!\[aq], the dollar sign is escaped; there\[aq]s no interpolation.\f[R]
.EE
.SS Using String.raw with RegExp
Combining a \f[CR]String.raw\f[R] template literal with the
\f[CR]RegExp()\f[R] constructor allows you to create regular expressions
with dynamic parts (which is not possible with regex literals) without
double\-escaping (\f[CR]\[rs]\[rs]\f[R]) regular expression escape
sequences (which is not possible with normal string literals).
This is also valuable in strings that contain a lot of slashes, such as
file paths or URLs.
.IP
.EX
\f[I]// A String.raw template allows a fairly readable regular expression matching a URL:\f[R]
\f[B]const\f[R] reRawTemplate = \f[B]new\f[R] RegExp(
  String.raw\[ga]https://developer\[rs].mozilla\[rs].org/en\-US/docs/Web/JavaScript/Reference/\[ga],
);

\f[I]// The same thing with a regexp literal looks like this, with \[rs]/ for\f[R]
\f[I]// each forward slash:\f[R]
\f[B]const\f[R] reRegexpLiteral =
  /https:\[rs]/\[rs]/developer\[rs].mozilla\[rs].org\[rs]/en\-US\[rs]/docs\[rs]/Web\[rs]/JavaScript\[rs]/Reference\[rs]//;

\f[I]// And the same thing written with the RegExp constructor and a\f[R]
\f[I]// traditional string literal, with \[rs]\[rs]. for each period:\f[R]
\f[B]const\f[R] reStringLiteral = \f[B]new\f[R] RegExp(
  \[dq]https://developer\[rs]\[rs].mozilla\[rs]\[rs].org/en\-US/docs/Web/JavaScript/Reference/\[dq],
);

\f[I]// String.raw also allows dynamic parts to be included\f[R]
\f[B]function\f[R] makeURLRegExp(path) {
  \f[B]return\f[R] \f[B]new\f[R] RegExp(String.raw\[ga]https://developer\[rs].mozilla\[rs].org/${path}\[ga]);
}

\f[B]const\f[R] reDynamic = makeURLRegExp(\[dq]en\-US/docs/Web/JavaScript/Reference/\[dq]);
\f[B]const\f[R] reWildcard = makeURLRegExp(\[dq].*\[dq]);
.EE
.SS Building an identity tag
Many tools give special treatment to literals tagged by a particular
name.
.IP
.EX
// Some formatters will format this literal\[aq]s content as HTML
const doc = html\[ga]<!DOCTYPE html>
<html lang=\[dq]en\-US\[dq]>
  <head>
    <title>Hello</title>
  </head>
  <body>
    <h1>Hello world!</h1>
  </body>
</html>
\[ga];
.EE
.PP
One might na√Øvely implement the \f[CR]html\f[R] tag as:
.IP
.EX
\f[B]const\f[R] html = String.raw;
.EE
.PP
This, in fact, works for the case above.
However, because \f[CR]String.raw\f[R] would concatenate the
\f[I]raw\f[R] string literals instead of the \[lq]cooked\[rq] ones,
escape sequences would not be processed.
.IP
.EX
const doc = html\[ga]<canvas>\[rs]n</canvas>\[ga];
// \[dq]<canvas>\[rs]\[rs]n</canvas>\[dq]
.EE
.PP
This may not be what you want for a \[lq]true identity\[rq] tag, where
the tag is purely for markup and doesn\[cq]t change the literal\[cq]s
value.
In this case, you can create a custom tag and pass the \[lq]cooked\[rq]
(i.e.\ escape sequences are processed) literal array to
\f[CR]String.raw\f[R], pretending they are raw strings.
.IP
.EX
const html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal\[aq]s content as HTML
const doc = html\[ga]<canvas>\[rs]n</canvas>\[ga];
// \[dq]<canvas>\[rs]n</canvas>\[dq]; the \[dq]\[rs]n\[dq] becomes a line break
.EE
.PP
Notice the first argument is an object with a \f[CR]raw\f[R] property,
whose value is an array\-like object (with a \f[CR]length\f[R] property
and integer indexes) representing the separated strings in the template
literal.
The rest of the arguments are the substitutions.
Since the \f[CR]raw\f[R] value can be any array\-like object, it can
even be a string!
For example, \f[CR]\[aq]test\[aq]\f[R] is treated as
\f[CR][\[aq]t\[aq], \[aq]e\[aq], \[aq]s\[aq], \[aq]t\[aq]]\f[R].
The following is equivalent to \f[CR]\[ga]t${0}e${1}s${2}t\[ga]\f[R]:
.IP
.EX
String.raw({ raw: \[dq]test\[dq] }, 0, 1, 2); \f[I]// \[aq]t0e1s2t\[aq]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-string-and-regexp
Polyfill of \f[CR]String.raw\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Template literals
.IP \[bu] 2
\f[CR]String\f[R]
.IP \[bu] 2
Lexical grammar
