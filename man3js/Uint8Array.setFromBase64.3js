.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "UINT8ARRAY.SETFROMBASE64" "3JS" "March 5, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Uint8Array.setFromBase64 \- Uint8Array.prototype.setFromBase64()
.SH SYNOPSIS
The \f[B]\f[CB]setFromBase64()\f[B]\f[R] method of \f[CR]Uint8Array\f[R]
instances populates this \f[CR]Uint8Array\f[R] object with bytes from a
base64\-encoded string, returning an object indicating how many bytes
were read and written.
.PP
This method is most suitable for populating a pre\-allocated array
buffer.
If you just want to create a new \f[CR]Uint8Array\f[R] object from a
base64\-encoded string, use the static method
\f[CR]Uint8Array.fromBase64()\f[R] instead.
.SH SYNTAX
.IP
.EX
setFromBase64(string)
setFromBase64(string, options)
.EE
.SS Parameters
.TP
\f[B]string\f[R]
A base64 string encoding bytes to write into a \f[CR]Uint8Array\f[R].
It has the same requirements as the \f[CR]string\f[R] parameter of
\f[CR]Uint8Array.fromBase64()\f[R].
Note that the string is only read up to the point where the array is
filled, so any invalid base64 syntax after that point is ignored.
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object customizing the base64 string interpretation process.
It has the same requirements as the \f[CR]options\f[R] parameter of
\f[CR]Uint8Array.fromBase64()\f[R].
.SS Return value
An object containing the following properties:
.TP
\f[B]read\f[R]
The number of base64 characters read from the input string.
If the decoded data fits into the array, this is the length of the input
string (including padding); otherwise, it is the length up to the last
complete 4\-character chunk that fits into the array.
Chunks will never be split (because the remaining bits cannot be
partially \(lqput back\(rq into the base64 without completely
re\-encoding it); if the next chunk cannot fit into the remainder of the
array, it will be entirely unread, resulting in the last one or two
bytes of the array not being written.
.TP
\f[B]written\f[R]
The number of bytes written to the \f[CR]Uint8Array\f[R].
Will never be greater than this \f[CR]Uint8Array\f[R]\(cqs
\f[CR]byteLength\f[R].
.SS Exceptions
.TP
\f[B]SyntaxError\f[R]
Thrown if the input string contains characters outside the specified
alphabet, or if the last chunk does not satisfy the
\f[CR]lastChunkHandling\f[R] option.
.TP
\f[B]TypeError\f[R]
Thrown in one of the following cases:
.RS
.IP \(bu 2
The input string is not a string.
.IP \(bu 2
The \f[CR]options\f[R] object is not an object or \f[CR]undefined\f[R].
.IP \(bu 2
The options are not of the expected values or \f[CR]undefined\f[R].
.RE
.SH EXAMPLES
.SS Decoding a base64 string
This example uses the default \f[CR]alphabet\f[R] and
\f[CR]lastChunkHandling\f[R] options to decode a base64 string into an
existing \f[CR]Uint8Array\f[R].
.IP
.EX
\f[B]const\f[R] uint8Array = \f[B]new\f[R] Uint8Array(16);
\f[B]const\f[R] result = uint8Array.setFromBase64(\(dqPGI+ TURO PC9i Pg==\(dq);
console.log(result); \f[I]// { read: 19, written: 10 }\f[R]
console.log(uint8Array);
\f[I]// Uint8Array(16) [60, 98, 62, 77, 68, 78, 60, 47, 98, 62, 0, 0, 0, 0, 0, 0]\f[R]
.EE
.SS Decoding a big string into a small array
If the string contains more data than the array can hold, the method
will only write as many bytes as the array can hold, without discarding
any bits.
.IP
.EX
\f[B]const\f[R] uint8Array = \f[B]new\f[R] Uint8Array(8);
\f[B]const\f[R] result = uint8Array.setFromBase64(\(dqPGI+ TURO PC9i Pg==\(dq);
console.log(result); \f[I]// { read: 9, written: 6 }\f[R]
console.log(uint8Array);
\f[I]// Uint8Array(8) [60, 98, 62, 77, 68, 78, 0, 0]\f[R]
.EE
.PP
Note how the last two bytes of the array are not written.
To decode these two bytes, we need to read at least three more base64
characters, which represent 18 bits.
These can\(cqt fit into the remaining two bytes of the array, so we can
only write 2 chunks, or 6 bytes.
.SS Setting data at a specific offset
The \f[CR]setFromBase64()\f[R] method always starts writing at the
beginning of the \f[CR]Uint8Array\f[R].
If you want to write to the middle of the array, you can write to a
\f[CR]TypedArray.prototype.subarray()\f[R] instead.
.IP
.EX
\f[B]const\f[R] uint8Array = \f[B]new\f[R] Uint8Array(16);
\f[I]// Start writing at offset 2\f[R]
\f[B]const\f[R] result = uint8Array.subarray(2).setFromBase64(\(dqPGI+ TURO PC9i Pg==\(dq);
console.log(result); \f[I]// { read: 19, written: 10 }\f[R]
console.log(uint8Array);
\f[I]// Uint8Array(16) [0, 0, 60, 98, 62, 77, 68, 78, 60, 47, 98, 62, 0, 0, 0, 0]\f[R]
.EE
.SS Stream decoding
This example is adapted from the \c
.UR https://github.com/tc39/proposal-arraybuffer-base64/blob/main/stream.mjs
original proposal
.UE \c
\&.
It mimics the \f[CR]TextDecoder\f[R] API with the \f[CR]stream\f[R]
option.
Note the use of
\f[CR]lastChunkHandling: \(dqstop\-before\-partial\(dq\f[R] to handle
incomplete chunks.
.IP
.EX
\f[B]class\f[R] Base64Decoder {
  #extra = \(dq\(dq;

  decode(chunk = \(dq\(dq, options = {}) {
    \f[B]const\f[R] opts = { ...options };
    \f[I]// match TextEncoder API\f[R]
    \f[B]if\f[R] (opts.stream) {
      opts.lastChunkHandling = \(dqstop\-before\-partial\(dq;
    }
    chunk = \f[B]this\f[R].#extra + chunk;
    \f[B]this\f[R].#extra = \(dq\(dq;
    \f[I]// For simplicity, allocate new memory every time\f[R]
    \f[I]// the calculation below is guaranteed to be enough,\f[R]
    \f[I]// but may be too much if there is whitespace\f[R]
    \f[I]// if you\(aqre really concerned about memory, a TextDecoder style API is a bad choice\f[R]
    \f[B]let\f[R] buffer = \f[B]new\f[R] Uint8Array(Math.ceil((chunk.length * 3) / 4));
    \f[B]const\f[R] { read, written } = buffer.setFromBase64(chunk, opts);
    buffer = buffer.subarray(0, written);
    \f[B]this\f[R].#extra = chunk.slice(read);
    \f[B]return\f[R] buffer;
  }
}

\f[B]const\f[R] decoder = \f[B]new\f[R] Base64Decoder();

console.log(decoder.decode(\(dqSG Vsb \(dq, { stream: \f[B]true\f[R] }));
\f[I]// Uint8Array(3) [72, 101, 108]\f[R]
console.log(decoder.decode(\(dqG8gV29ybGR \(dq, { stream: \f[B]true\f[R] }));
\f[I]// Uint8Array(6) [108, 111, 32, 87, 111, 114]\f[R]
console.log(decoder.decode(\(dq\(dq));
\f[I]// Uint8Array(2) [108, 100]\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#uint8array-to--from-base64-and-hex
Polyfill of \f[CR]Uint8Array.prototype.setFromBase64\f[R] in
\f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/es-arraybuffer-base64
es\-shims polyfill of \f[CR]Uint8Array.prototype.setFromBase64\f[R]
.UE \c
.IP \(bu 2
\f[CR]Uint8Array\f[R]
.IP \(bu 2
\f[CR]Uint8Array.fromBase64()\f[R]
.IP \(bu 2
\f[CR]Uint8Array.prototype.toBase64()\f[R]
.IP \(bu 2
\f[CR]Window.atob()\f[R]
