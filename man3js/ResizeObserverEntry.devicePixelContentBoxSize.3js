.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "ResizeObserverEntry.devicePixelContentBoxSize" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ResizeObserverEntry.devicePixelContentBoxSize \- ResizeObserverEntry:
devicePixelContentBoxSize property
.SH SYNOPSIS
The \f[B]\f[CB]devicePixelContentBoxSize\f[B]\f[R] read\-only property
of the \f[CR]ResizeObserverEntry\f[R] interface returns an array
containing the size in device pixels of the observed element when the
callback is run.
.SH VALUE
An array containing objects with the new size of the observed element in
device pixels.
The array is necessary to support elements that have multiple fragments,
which occur in multi\-column scenarios.
Each object in the array contains two properties:
.TP
\f[B]blockSize\f[R]
The size of the content\-box, in device pixels, of the block dimension
of the observed element.
For boxes with a horizontal \f[CR]writing\-mode\f[R], this is the
vertical dimension, or height; if the writing\-mode is vertical, this is
the horizontal dimension, or width.
.TP
\f[B]inlineSize\f[R]
The size of the content box, in device pixels, of the inline direction
of the observed element.
For boxes with a horizontal \f[CR]writing\-mode\f[R], this is the
horizontal dimension, or width; if the writing\-mode is vertical, this
is the vertical dimension, or height.
.RS
.PP
\f[B]Note:\f[R] For more information about writing modes and block and
inline dimensions, read Handling different text directions.
.RE
.SH EXAMPLES
The following example is taken from the article \c
.UR https://web.dev/articles/device-pixel-content-box
Pixel\-perfect rendering with devicePixelContentBox
.UE \c
\&.
As the callback function of a \f[CR]ResizeObserver\f[R] is called after
layout but before paint.
This provides an opportunity to log the exact size in physical pixels to
ensure a one\-to\-one mapping of canvas pixels to physical pixels.
.IP
.EX
\f[B]const\f[R] observer = \f[B]new\f[R] ResizeObserver((entries) \f[B]=>\f[R] {
  \f[B]const\f[R] entry = entries.find((entry) \f[B]=>\f[R] entry.target === canvas);
  canvas.width = entry.devicePixelContentBoxSize[0].inlineSize;
  canvas.height = entry.devicePixelContentBoxSize[0].blockSize;

  \f[I]/* \&... render to canvas \&... */\f[R]
});
observer.observe(canvas, { box: \[dq]device\-pixel\-content\-box\[dq] });
.EE
