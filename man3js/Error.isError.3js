.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Error.isError" "JS" "February 24, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Error.isError \- Error.isError()
.SH SYNOPSIS
The \f[B]\f[CB]Error.isError()\f[B]\f[R] static method determines
whether the passed value is an \f[CR]Error\f[R].
.SH SYNTAX
.IP
.EX
Error.isError(value)
.EE
.SS Parameters
.TP
\f[B]value\f[R]
The value to be checked.
.SS Return value
\f[CR]true\f[R] if \f[CR]value\f[R] is an \f[CR]Error\f[R]; otherwise,
\f[CR]false\f[R].
.SH DESCRIPTION
\f[CR]Error.isError()\f[R] checks if the passed value is an
\f[CR]Error\f[R].
It does so by performing a \f[I]branded check\f[R] for a private
property initialized by the \f[CR]Error()\f[R] constructor.
This is the same mechanism used by \f[CR]Array.isArray()\f[R], which is
in turn similar to the mechanism used by the \f[CR]in\f[R] operator.
.PP
It is a more robust alternative to \f[CR]instanceof Error\f[R] because
it avoids false positives and false negatives:
.IP \[bu] 2
\f[CR]Error.isError()\f[R] rejects values that aren\[cq]t actual
\f[CR]Error\f[R] instances, even if they have \f[CR]Error.prototype\f[R]
their prototype chain \[em] \f[CR]instanceof Error\f[R] would accept
these as it does check the prototype chain.
.IP \[bu] 2
\f[CR]Error.isError()\f[R] accepts \f[CR]Error\f[R] objects constructed
in another realm \[em] \f[CR]instanceof Error\f[R] returns
\f[CR]false\f[R] for these because the identity of the \f[CR]Error\f[R]
constructor is different across realms.
.PP
\f[CR]Error.isError()\f[R] returns \f[CR]true\f[R] for
\f[CR]DOMException\f[R] instances.
This is because, although \f[CR]DOMException\f[R] is not specified as a
real subclass of \f[CR]Error\f[R] (the \f[CR]Error\f[R] constructor is
not the prototype of the \f[CR]DOMException\f[R] constructor),
\f[CR]DOMException\f[R] still behaves like \f[CR]Error\f[R] for all
branded checking purposes.
.SH EXAMPLES
.SS Using Error.isError()
.IP
.EX
\f[I]// all following calls return true\f[R]
Error.isError(\f[B]new\f[R] Error());
Error.isError(\f[B]new\f[R] TypeError());
Error.isError(\f[B]new\f[R] DOMException());
\f[B]try\f[R] {
  1 + 1n;
} \f[B]catch\f[R] (e) {
  console.log(Error.isError(e)); \f[I]// The operation threw a TypeError, so this returns true\f[R]
}

\f[I]// all following calls return false\f[R]
Error.isError();
Error.isError({});
Error.isError(\f[B]null\f[R]);
Error.isError(\f[B]undefined\f[R]);
Error.isError(17);
Error.isError(\[dq]Error\[dq]);
Error.isError(\f[B]true\f[R]);
Error.isError(\f[B]false\f[R]);
\f[I]// This is not an error, because the object does not have the private property\f[R]
\f[I]// initialized by the Error constructor\f[R]
Error.isError({ __proto__: Error.prototype });
.EE
.SS instanceof vs.\ Error.isError()
When checking for \f[CR]Error\f[R] instance, \f[CR]Error.isError()\f[R]
is preferred over \f[CR]instanceof\f[R] because it works across realms.
.IP
.EX
\f[B]const\f[R] iframe = document.createElement(\[dq]iframe\[dq]);
document.body.appendChild(iframe);
\f[B]const\f[R] xError = window.frames[window.frames.length \- 1].Error;
\f[B]const\f[R] error = \f[B]new\f[R] xError();

\f[I]// Correctly checking for Error\f[R]
Error.isERror(error); \f[I]// true\f[R]
\f[I]// The prototype of error is xError.prototype, which is a\f[R]
\f[I]// different object from Error.prototype\f[R]
error \f[B]instanceof\f[R] Error; \f[I]// false\f[R]
.EE
.SS Normalizing caught errors
You can use \f[CR]Error.isError()\f[R] to detect if the caught value is
an error and normalize it to an error object.
.IP
.EX
\f[B]try\f[R] {
  \f[B]throw\f[R] \[dq]Oops; this is not an Error object\[dq];
} \f[B]catch\f[R] (e) {
  \f[B]if\f[R] (!Error.isError(e)) {
    e = \f[B]new\f[R] Error(e);
  }
  console.error(e.message);
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#erroriserror
Polyfill of \f[CR]Error.isError\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Error\f[R]
