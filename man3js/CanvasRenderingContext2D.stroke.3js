.\" Automatically generated by Pandoc 3.4
.\"
.TH "CanvasRenderingContext2D.stroke" "JS" "March 12, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
CanvasRenderingContext2D.stroke \- CanvasRenderingContext2D: stroke()
method
.SH SYNOPSIS
The \f[B]\f[CB]CanvasRenderingContext2D.stroke()\f[B]\f[R] method of the
Canvas 2D API strokes (outlines) the current or given path with the
current stroke style.
.PP
Strokes are aligned to the center of a path; in other words, half of the
stroke is drawn on the inner side, and half on the outer side.
.PP
The stroke is drawn using the \c
.UR https://en.wikipedia.org/wiki/Nonzero-rule
non\-zero winding rule
.UE \c
, which means that path intersections will still get filled.
.SH SYNTAX
.IP
.EX
stroke()
stroke(path)
.EE
.SS Parameters
.TP
\f[B]path\f[R]
A \f[CR]Path2D\f[R] path to stroke.
.SS Return value
None (\f[CR]undefined\f[R]).
.SH EXAMPLES
.SS A simple stroked rectangle
This example creates a rectangle using the \f[CR]rect()\f[R] method, and
then draws it to the canvas using \f[CR]stroke()\f[R].
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]canvas\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);
ctx.rect(10, 10, 150, 100);
ctx.stroke();
.EE
.SS Result
.SS Re\-stroking paths
Typically, you\[cq]ll want to call \f[CR]beginPath()\f[R] for each new
thing you want to stroke.
If you don\[cq]t, the previous sub\-paths will remain part of the
current path, and get stroked every time you call the
\f[CR]stroke()\f[R] method.
In some cases, however, this may be the desired effect.
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]canvas\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
This code strokes the first path three times, the second path two times,
and the third path only once.
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);

\f[I]// First sub\-path\f[R]
ctx.lineWidth = 26;
ctx.strokeStyle = \[dq]orange\[dq];
ctx.moveTo(20, 20);
ctx.lineTo(160, 20);
ctx.stroke();

\f[I]// Second sub\-path\f[R]
ctx.lineWidth = 14;
ctx.strokeStyle = \[dq]green\[dq];
ctx.moveTo(20, 80);
ctx.lineTo(220, 80);
ctx.stroke();

\f[I]// Third sub\-path\f[R]
ctx.lineWidth = 4;
ctx.strokeStyle = \[dq]pink\[dq];
ctx.moveTo(20, 140);
ctx.lineTo(280, 140);
ctx.stroke();
.EE
.SS Result
.SS Stroking and filling
If you want to both stroke and fill a path, the order in which you
perform these actions will determine the result.
In this example, the square on the left is drawn with the stroke on top
of the fill.
The square on the right is drawn with the fill on top of the stroke.
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]canvas\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);

ctx.lineWidth = 16;
ctx.strokeStyle = \[dq]red\[dq];

\f[I]// Stroke on top of fill\f[R]
ctx.beginPath();
ctx.rect(25, 25, 100, 100);
ctx.fill();
ctx.stroke();

\f[I]// Fill on top of stroke\f[R]
ctx.beginPath();
ctx.rect(175, 25, 100, 100);
ctx.stroke();
ctx.fill();
.EE
.SS Result
.SH SEE ALSO
.IP \[bu] 2
The interface defining this method: \f[CR]CanvasRenderingContext2D\f[R]
