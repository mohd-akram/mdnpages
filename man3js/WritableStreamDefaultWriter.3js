.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "WritableStreamDefaultWriter" "JS" "April 22, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
WritableStreamDefaultWriter \- WritableStreamDefaultWriter
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]WritableStreamDefaultWriter\f[B]\f[R] interface of the
Streams API is the object returned by
\f[CR]WritableStream.getWriter()\f[R] and once created locks the writer
to the \f[CR]WritableStream\f[R] ensuring that no other streams can
write to the underlying sink.
.SH CONSTRUCTOR
.TP
\f[B]WritableStreamDefaultWriter()\f[R]
Creates a new \f[CR]WritableStreamDefaultWriter\f[R] object instance.
.SH INSTANCE PROPERTIES
.TP
\f[B]WritableStreamDefaultWriter.closed\f[R] \f[I](read\-only)\f[R]
Allows you to write code that responds to an end to the streaming
process.
Returns a promise that fulfills if the stream becomes closed, or rejects
if the stream errors or the writer\[cq]s lock is released.
.TP
\f[B]WritableStreamDefaultWriter.desiredSize\f[R] \f[I](read\-only)\f[R]
Returns the desired size required to fill the stream\[cq]s internal
queue.
.TP
\f[B]WritableStreamDefaultWriter.ready\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]Promise\f[R] that resolves when the desired size of the
stream\[cq]s internal queue transitions from non\-positive to positive,
signaling that it is no longer applying backpressure.
.SH INSTANCE METHODS
.TP
\f[B]WritableStreamDefaultWriter.abort()\f[R]
Aborts the stream, signaling that the producer can no longer
successfully write to the stream and it is to be immediately moved to an
error state, with any queued writes discarded.
.TP
\f[B]WritableStreamDefaultWriter.close()\f[R]
Closes the associated writable stream.
.TP
\f[B]WritableStreamDefaultWriter.releaseLock()\f[R]
Releases the writer\[cq]s lock on the corresponding stream.
After the lock is released, the writer is no longer active.
If the associated stream is errored when the lock is released, the
writer will appear errored in the same way from now on; otherwise, the
writer will appear closed.
.TP
\f[B]WritableStreamDefaultWriter.write()\f[R]
Writes a passed chunk of data to a \f[CR]WritableStream\f[R] and its
underlying sink, then returns a \f[CR]Promise\f[R] that resolves to
indicate the success or failure of the write operation.
.SH EXAMPLES
The following example shows the creation of a \f[CR]WritableStream\f[R]
with a custom sink and an API\-supplied queuing strategy.
It then calls a function called \f[CR]sendMessage()\f[R], passing the
newly created stream and a string.
Inside this function it calls the stream\[cq]s \f[CR]getWriter()\f[R]
method, which returns an instance of
\f[CR]WritableStreamDefaultWriter\f[R].
A \f[CR]forEach()\f[R] call is used to write each chunk of the string to
the stream.
Finally, \f[CR]write()\f[R] and \f[CR]close()\f[R] return promises that
are processed to deal with success or failure of chunks and streams.
.IP
.EX
\f[B]const\f[R] list = document.querySelector(\[dq]ul\[dq]);

\f[B]async\f[R] \f[B]function\f[R] sendMessage(message, writableStream) {
  \f[I]// defaultWriter is of type WritableStreamDefaultWriter\f[R]
  \f[B]const\f[R] defaultWriter = writableStream.getWriter();
  \f[B]const\f[R] encoder = \f[B]new\f[R] TextEncoder();
  \f[B]const\f[R] encoded = encoder.encode(message);

  \f[B]try\f[R] {
    \f[B]for\f[R] (\f[B]const\f[R] chunk \f[B]of\f[R] encoded) {
      \f[B]await\f[R] defaultWriter.ready;
      \f[B]await\f[R] defaultWriter.write(chunk);
      console.log(\[dq]Chunk written to sink.\[dq]);
    }
    \f[I]// Call ready again to ensure that all chunks are written\f[R]
    \f[I]// before closing the writer.\f[R]
    \f[B]await\f[R] defaultWriter.ready;
    \f[B]await\f[R] defaultWriter.close();
    console.log(\[dq]All chunks written\[dq]);
  } \f[B]catch\f[R] (err) {
    console.log(\[dq]Error:\[dq], err);
  }
}

\f[B]const\f[R] decoder = \f[B]new\f[R] TextDecoder(\[dq]utf\-8\[dq]);
\f[B]const\f[R] queuingStrategy = \f[B]new\f[R] CountQueuingStrategy({ highWaterMark: 1 });
\f[B]let\f[R] result = \[dq]\[dq];
\f[B]const\f[R] writableStream = \f[B]new\f[R] WritableStream(
  {
    \f[I]// Implement the sink\f[R]
    write(chunk) {
      \f[B]return\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
        \f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(1);
        \f[B]const\f[R] view = \f[B]new\f[R] Uint8Array(buffer);
        view[0] = chunk;
        \f[B]const\f[R] decoded = decoder.decode(view, { stream: \f[B]true\f[R] });
        \f[B]const\f[R] listItem = document.createElement(\[dq]li\[dq]);
        listItem.textContent = \[ga]Chunk decoded: ${decoded}\[ga];
        list.appendChild(listItem);
        result += decoded;
        resolve();
      });
    },
    close() {
      \f[B]const\f[R] listItem = document.createElement(\[dq]li\[dq]);
      listItem.textContent = \[ga][MESSAGE RECEIVED] ${result}\[ga];
      list.appendChild(listItem);
    },
    abort(err) {
      console.log(\[dq]Sink error:\[dq], err);
    },
  },
  queuingStrategy,
);

sendMessage(\[dq]Hello, world.\[dq], writableStream);
.EE
.PP
You can find the full code in our \c
.UR https://mdn.github.io/dom-examples/streams/simple-writer/
Simple writer example
.UE \c
\&.
