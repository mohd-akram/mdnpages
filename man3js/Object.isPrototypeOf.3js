.\" Automatically generated by Pandoc 3.4
.\"
.TH "Object.isPrototypeOf" "JS" "November 8, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.isPrototypeOf \- Object.prototype.isPrototypeOf()
.SH SYNOPSIS
The \f[B]\f[CB]isPrototypeOf()\f[B]\f[R] method of \f[CR]Object\f[R]
instances checks if this object exists in another object\[cq]s prototype
chain.
.RS
.PP
\f[B]Note:\f[R] \f[CR]isPrototypeOf()\f[R] differs from the
\f[CR]instanceof\f[R] operator.
In the expression \f[CR]object instanceof AFunction\f[R],
\f[CR]object\f[R]\[cq]s prototype chain is checked against
\f[CR]AFunction.prototype\f[R], not against \f[CR]AFunction\f[R] itself.
.RE
.SH SYNTAX
.IP
.EX
isPrototypeOf(object)
.EE
.SS Parameters
.TP
\f[B]object\f[R]
The object whose prototype chain will be searched.
.SS Return value
A boolean indicating whether the calling object (\f[CR]this\f[R]) lies
in the prototype chain of \f[CR]object\f[R].
Directly returns \f[CR]false\f[R] when \f[CR]object\f[R] is not an
object (i.e.\ a primitive).
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if \f[CR]this\f[R] is \f[CR]null\f[R] or \f[CR]undefined\f[R]
(because it can\[cq]t be converted to an object).
.SH DESCRIPTION
All objects that inherit from \f[CR]Object.prototype\f[R] (that is, all
except \f[CR]null\f[R]\-prototype objects) inherit the
\f[CR]isPrototypeOf()\f[R] method.
This method allows you to check whether or not the object exists within
another object\[cq]s prototype chain.
If the \f[CR]object\f[R] passed as the parameter is not an object
(i.e.\ a primitive), the method directly returns \f[CR]false\f[R].
Otherwise, the \f[CR]this\f[R] value is converted to an object, and the
prototype chain of \f[CR]object\f[R] is searched for the \f[CR]this\f[R]
value, until the end of the chain is reached or the \f[CR]this\f[R]
value is found.
.SH EXAMPLES
.SS Using isPrototypeOf()
This example demonstrates that \f[CR]Baz.prototype\f[R],
\f[CR]Bar.prototype\f[R], \f[CR]Foo.prototype\f[R] and
\f[CR]Object.prototype\f[R] exist in the prototype chain for object
\f[CR]baz\f[R]:
.IP
.EX
\f[B]class\f[R] Foo {}
\f[B]class\f[R] Bar \f[B]extends\f[R] Foo {}
\f[B]class\f[R] Baz \f[B]extends\f[R] Bar {}

\f[B]const\f[R] foo = \f[B]new\f[R] Foo();
\f[B]const\f[R] bar = \f[B]new\f[R] Bar();
\f[B]const\f[R] baz = \f[B]new\f[R] Baz();

\f[I]// prototype chains:\f[R]
\f[I]// foo: Foo \-\-> Object\f[R]
\f[I]// bar: Bar \-\-> Foo \-\-> Object\f[R]
\f[I]// baz: Baz \-\-> Bar \-\-> Foo \-\-> Object\f[R]
console.log(Baz.prototype.isPrototypeOf(baz)); \f[I]// true\f[R]
console.log(Baz.prototype.isPrototypeOf(bar)); \f[I]// false\f[R]
console.log(Baz.prototype.isPrototypeOf(foo)); \f[I]// false\f[R]
console.log(Bar.prototype.isPrototypeOf(baz)); \f[I]// true\f[R]
console.log(Bar.prototype.isPrototypeOf(foo)); \f[I]// false\f[R]
console.log(Foo.prototype.isPrototypeOf(baz)); \f[I]// true\f[R]
console.log(Foo.prototype.isPrototypeOf(bar)); \f[I]// true\f[R]
console.log(Object.prototype.isPrototypeOf(baz)); \f[I]// true\f[R]
.EE
.PP
The \f[CR]isPrototypeOf()\f[R] method \[em] along with the
\f[CR]instanceof\f[R] operator \[em] comes in particularly handy if you
have code that can only function when dealing with objects descended
from a specific prototype chain; e.g., to guarantee that certain methods
or properties will be present on that object.
.PP
For example, to execute some code that\[cq]s only safe to run if a
\f[CR]baz\f[R] object has \f[CR]Foo.prototype\f[R] in its prototype
chain, you can do this:
.IP
.EX
\f[B]if\f[R] (Foo.prototype.isPrototypeOf(baz)) {
  \f[I]// do something safe\f[R]
}
.EE
.PP
However, \f[CR]Foo.prototype\f[R] existing in \f[CR]baz\f[R]\[cq]s
prototype chain doesn\[cq]t imply \f[CR]baz\f[R] was created using
\f[CR]Foo\f[R] as its constructor.
For example, \f[CR]baz\f[R] could be directly assigned with
\f[CR]Foo.prototype\f[R] as its prototype.
In this case, if your code reads private fields of \f[CR]Foo\f[R] from
\f[CR]baz\f[R], it would still fail:
.IP
.EX
\f[B]class\f[R] Foo {
  #value = \[dq]foo\[dq];
  \f[B]static\f[R] getValue(x) {
    \f[B]return\f[R] x.#value;
  }
}

\f[B]const\f[R] baz = { __proto__: Foo.prototype };

\f[B]if\f[R] (Foo.prototype.isPrototypeOf(baz)) {
  console.log(Foo.getValue(baz)); \f[I]// TypeError: Cannot read private member #value from an object whose class did not declare it\f[R]
}
.EE
.PP
The same applies to \f[CR]instanceof\f[R].
If you need to read private fields in a secure way, offer a branded
check method using \f[CR]in\f[R] instead.
.IP
.EX
\f[B]class\f[R] Foo {
  #value = \[dq]foo\[dq];
  \f[B]static\f[R] getValue(x) {
    \f[B]return\f[R] x.#value;
  }
  \f[B]static\f[R] isFoo(x) {
    \f[B]return\f[R] #value \f[B]in\f[R] x;
  }
}

\f[B]const\f[R] baz = { __proto__: Foo.prototype };

\f[B]if\f[R] (Foo.isFoo(baz)) {
  \f[I]// Doesn\[aq]t run, because baz is not a Foo\f[R]
  console.log(Foo.getValue(baz));
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]instanceof\f[R]
.IP \[bu] 2
\f[CR]Object.getPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Object.setPrototypeOf()\f[R]
.IP \[bu] 2
Inheritance and the prototype chain
