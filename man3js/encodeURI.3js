.\" Automatically generated by Pandoc 3.4
.\"
.TH "encodeURI" "JS" "May 22, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
encodeURI \- encodeURI()
.SH SYNOPSIS
The \f[B]\f[CB]encodeURI()\f[B]\f[R] function encodes a URI by replacing
each instance of certain characters by one, two, three, or four escape
sequences representing the UTF\-8 encoding of the character (will only
be four escape sequences for characters composed of two surrogate
characters).
Compared to \f[CR]encodeURIComponent()\f[R], this function encodes fewer
characters, preserving those that are part of the URI syntax.
.SH SYNTAX
.IP
.EX
encodeURI(uri)
.EE
.SS Parameters
.TP
\f[B]uri\f[R]
A string to be encoded as a URI.
.SS Return value
A new string representing the provided string encoded as a URI.
.SS Exceptions
.TP
\f[B]URIError\f[R]
Thrown if \f[CR]uri\f[R] contains a lone surrogate.
.SH DESCRIPTION
\f[CR]encodeURI()\f[R] is a function property of the global object.
.PP
The \f[CR]encodeURI()\f[R] function escapes characters by UTF\-8 code
units, with each octet encoded in the format \f[CR]%XX\f[R],
left\-padded with 0 if necessary.
Because lone surrogates in UTF\-16 do not encode any valid Unicode
character, they cause \f[CR]encodeURI()\f[R] to throw a
\f[CR]URIError\f[R].
.PP
\f[CR]encodeURI()\f[R] escapes all characters \f[B]except\f[R]:
.IP
.EX
A\[en]Z a\[en]z 0\[en]9 \- _ . ! \[ti] * \[aq] ( )

; / ? : \[at] & = + $ , #
.EE
.PP
The characters on the second line are characters that may be part of the
URI syntax, and are only escaped by \f[CR]encodeURIComponent()\f[R].
Both \f[CR]encodeURI()\f[R] and \f[CR]encodeURIComponent()\f[R] do not
encode the characters \f[CR]\-.!\[ti]*\[aq]()\f[R], known as
\[lq]unreserved marks\[rq], which do not have a reserved purpose but are
allowed in a URI \[lq]as is\[rq].
(See \c
.UR https://datatracker.ietf.org/doc/html/rfc2396
RFC2396
.UE \c
)
.PP
The \f[CR]encodeURI()\f[R] function does not encode characters that have
special meaning (reserved characters) for a URI.
The following example shows all the parts that a URI can possibly
contain.
Note how certain characters are used to signify special meaning:
.IP
.EX
http://username:password\[at]www.example.com:80/path/to/file.php?foo=316&bar=this+has+spaces#anchor
.EE
.PP
\f[CR]encodeURI\f[R], as the name implies, is used to encode a URL as a
whole, assuming it is already well\-formed.
If you want to dynamically assemble string values into a URL, you
probably want to use \f[CR]encodeURIComponent()\f[R] on each dynamic
segment instead, to avoid URL syntax characters in unwanted places.
.IP
.EX
\f[B]const\f[R] name = \[dq]Ben & Jerry\[aq]s\[dq];

\f[I]// This is bad:\f[R]
\f[B]const\f[R] link = encodeURI(\[ga]https://example.com/?choice=${name}\[ga]); \f[I]// \[dq]https://example.com/?choice=Ben%20&%20Jerry\[aq]s\[dq]\f[R]
console.log([...\f[B]new\f[R] URL(link).searchParams]); \f[I]// [[\[aq]choice\[aq], \[aq]Ben \[aq]], [\[dq] Jerry\[aq]s\[dq], \[aq]\[aq]]\f[R]

\f[I]// Instead:\f[R]
\f[B]const\f[R] link = encodeURI(
  \[ga]https://example.com/?choice=${encodeURIComponent(name)}\[ga],
);
\f[I]// \[dq]https://example.com/?choice=Ben%2520%2526%2520Jerry\[aq]s\[dq]\f[R]
console.log([...\f[B]new\f[R] URL(link).searchParams]); \f[I]// [[\[aq]choice\[aq], \[dq]Ben%20%26%20Jerry\[aq]s\[dq]]]\f[R]
.EE
.SH EXAMPLES
.SS encodeURI() vs.\ encodeURIComponent()
\f[CR]encodeURI()\f[R] differs from \f[CR]encodeURIComponent()\f[R] as
follows:
.IP
.EX
\f[B]const\f[R] set1 = \[dq];/?:\[at]&=+$,#\[dq]; \f[I]// Reserved Characters\f[R]
\f[B]const\f[R] set2 = \[dq]\-.!\[ti]*\[aq]()\[dq]; \f[I]// Unreserved Marks\f[R]
\f[B]const\f[R] set3 = \[dq]ABC abc 123\[dq]; \f[I]// Alphanumeric Characters + Space\f[R]

console.log(encodeURI(set1)); \f[I]// ;/?:\[at]&=+$,#\f[R]
console.log(encodeURI(set2)); \f[I]// \-.!\[ti]*\[aq]()\f[R]
console.log(encodeURI(set3)); \f[I]// ABC%20abc%20123 (the space gets encoded as %20)\f[R]

console.log(encodeURIComponent(set1)); \f[I]// %3B%2C%2F%3F%3A%40%26%3D%2B%24%23\f[R]
console.log(encodeURIComponent(set2)); \f[I]// \-.!\[ti]*\[aq]()\f[R]
console.log(encodeURIComponent(set3)); \f[I]// ABC%20abc%20123 (the space gets encoded as %20)\f[R]
.EE
.SS Encoding a lone surrogate throws
A \f[CR]URIError\f[R] will be thrown if one attempts to encode a
surrogate which is not part of a high\-low pair.
For example:
.IP
.EX
\f[I]// High\-low pair OK\f[R]
encodeURI(\[dq]\[rs]uD800\[rs]uDFFF\[dq]); \f[I]// \[dq]%F0%90%8F%BF\[dq]\f[R]

\f[I]// Lone high\-surrogate code unit throws \[dq]URIError: malformed URI sequence\[dq]\f[R]
encodeURI(\[dq]\[rs]uD800\[dq]);

\f[I]// Lone low\-surrogate code unit throws \[dq]URIError: malformed URI sequence\[dq]\f[R]
encodeURI(\[dq]\[rs]uDFFF\[dq]);
.EE
.PP
You can use \f[CR]String.prototype.toWellFormed()\f[R], which replaces
lone surrogates with the Unicode replacement character (U+FFFD), to
avoid this error.
You can also use \f[CR]String.prototype.isWellFormed()\f[R] to check if
a string contains lone surrogates before passing it to
\f[CR]encodeURI()\f[R].
.SS Encoding for RFC3986
The more recent \c
.UR https://datatracker.ietf.org/doc/html/rfc3986
RFC3986
.UE \c
\ makes square brackets reserved (for IPv6) and thus not encoded when
forming something which could be part of a URL (such as a host).
It also reserves !, \[cq], (, ), and *, even though these characters
have no formalized URI delimiting uses.
The following function encodes a string for RFC3986\-compliant URL
format.
.IP
.EX
\f[B]function\f[R] encodeRFC3986URI(str) {
  \f[B]return\f[R] encodeURI(str)
    .replace(/%5B/g, \[dq][\[dq])
    .replace(/%5D/g, \[dq]]\[dq])
    .replace(
      /[!\[aq]()*]/g,
      (c) \f[B]=>\f[R] \[ga]%${c.charCodeAt(0).toString(16).toUpperCase()}\[ga],
    );
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]decodeURI()\f[R]
.IP \[bu] 2
\f[CR]encodeURIComponent()\f[R]
.IP \[bu] 2
\f[CR]decodeURIComponent()\f[R]
