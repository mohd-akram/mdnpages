.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "KeyboardEvent.key" "JS" "January 8, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
KeyboardEvent.key \- KeyboardEvent: key property
.SH SYNOPSIS
The \f[CR]KeyboardEvent\f[R] interface\[cq]s \f[B]\f[CB]key\f[B]\f[R]
read\-only property returns the value of the key pressed by the user,
taking into consideration the state of modifier keys such as Shift as
well as the keyboard locale and layout.
.SH VALUE
A string.
.PP
Its value is determined as follows:
.IP \[bu] 2
If the pressed key has a printed representation, the returned value is a
non\-empty Unicode character string containing the printable
representation of the key.
.IP \[bu] 2
If the pressed key is a Space key, the returned value is a single space.
.IP \[bu] 2
If the pressed key is a control or special character, the returned value
is one of the pre\-defined key values.
.IP \[bu] 2
If the \f[CR]KeyboardEvent\f[R] represents the press of a \c
.UR https://en.wikipedia.org/wiki/Dead_key
dead key
.UE \c
, the key value must be \[lq]\f[CR]Dead\f[R]\[rq].
.IP \[bu] 2
Some specialty keyboard keys (such as the extended keys for controlling
media on multimedia keyboards) don\[cq]t generate key codes on Windows;
instead, they trigger \f[CR]WM_APPCOMMAND\f[R] events.
These events get mapped to DOM keyboard events, and are listed among the
\[lq]Virtual key codes\[rq] for Windows, even though they aren\[cq]t
actually key codes.
.IP \[bu] 2
If the key cannot be identified, the returned value is
\f[CR]Unidentified\f[R].
.RS
.PP
\f[B]Callout:\f[R]
.PP
See a full list of key values.
.RE
.SH KEYBOARDEVENT SEQUENCE
Every \f[CR]KeyboardEvent\f[R] is fired in a pre\-determined sequence.
For a given key press, the sequence of \f[CR]KeyboardEvent\f[R]s fired
is as follows assuming that \f[CR]Event.preventDefault\f[R] is not
called:
.IP "1." 3
A \f[CR]keydown\f[R] event is first fired.
If the key is held down further and the key produces a character key,
then the event continues to be emitted in a platform implementation
dependent interval and the \f[CR]KeyboardEvent.repeat\f[R] read only
property is set to \f[CR]true\f[R].
.IP "2." 3
If the key produces a character key that would result in a character
being inserted into possibly an \f[CR]<input>\f[R],
\f[CR]<textarea>\f[R] or an element with
\f[CR]HTMLElement.contentEditable\f[R] set to true, the
\f[CR]beforeinput\f[R] and \f[CR]input\f[R] event types are fired in
that order.
Note that some other implementations may fire \f[CR]keypress\f[R] event
if supported.
The events will be fired repeatedly while the key is held down.
.IP "3." 3
A \f[CR]keyup\f[R] event is fired once the key is released.
This completes the process.
.PP
In sequence 1 & 3, the \f[CR]KeyboardEvent.key\f[R] attribute is defined
and is set appropriately to a value according to the rules defined
earlier.
.SH KEYBOARDEVENT SEQUENCE EXAMPLE
Consider the event sequence generated when we interact with the Shift
and the 2 key using a U.S keyboard layout as compared to when we do so
using a UK keyboard layout.
.PP
Try experimenting using the following two test cases:
.IP "1." 3
Press and hold the
.RS 4
.PP
Shift
.PP
key, then press
.PP
2
.PP
and release it.
Next, release the
.PP
Shift
.PP
key.
.RE
.IP "2." 3
Press and hold the
.RS 4
.PP
Shift
.PP
key, then press and hold
.PP
2
.PP
\&.
Release the
.PP
Shift
.PP
key.
Finally, release
.PP
2
.PP
\&.
.RE
.SS HTML
.IP
.EX
<\f[B]div\f[R] class=\[dq]fx\[dq]>
  <\f[B]div\f[R]>
    <\f[B]textarea\f[R] rows=\[dq]5\[dq] name=\[dq]test\-target\[dq] id=\[dq]test\-target\[dq]></\f[B]textarea\f[R]>
    <\f[B]button\f[R] type=\[dq]button\[dq] name=\[dq]btn\-reset\[dq] id=\[dq]btn\-reset\[dq]>Reset</\f[B]button\f[R]>
  </\f[B]div\f[R]>
  <\f[B]div\f[R] class=\[dq]flex\[dq]>
    <\f[B]pre\f[R] id=\[dq]console\-log\[dq]></\f[B]pre\f[R]>
  </\f[B]div\f[R]>
</\f[B]div\f[R]>
.EE
.SS CSS
.IP
.EX
\&.fx {
  \f[B]\-webkit\-display\f[R]: flex;
  \f[B]display\f[R]: flex;
  \f[B]margin\-left\f[R]: \-20px;
  \f[B]margin\-right\f[R]: \-20px;
}

\&.fx > div {
  \f[B]padding\-left\f[R]: 20px;
  \f[B]padding\-right\f[R]: 20px;
}

\&.fx > div\f[BI]:first\-child\f[R] {
  \f[B]width\f[R]: 30%;
}

\&.flex {
  \f[B]\-webkit\-flex\f[R]: 1;
  \f[B]flex\f[R]: 1;
}

test\-target {
  \f[B]display\f[R]: block;
  \f[B]width\f[R]: 100%;
  \f[B]margin\-bottom\f[R]: 10px;
}
.EE
.SS JavaScript
.IP
.EX
\f[B]let\f[R] textarea = document.getElementById(\[dq]test\-target\[dq]),
  consoleLog = document.getElementById(\[dq]console\-log\[dq]),
  btnReset = document.getElementById(\[dq]btn\-reset\[dq]);

\f[B]function\f[R] logMessage(message) {
  consoleLog.innerHTML += \[ga]${message}<br>\[ga];
}

textarea.addEventListener(\[dq]keydown\[dq], (e) \f[B]=>\f[R] {
  \f[B]if\f[R] (!e.repeat) {
    logMessage(\[ga]Key \[dq]${e.key}\[dq] pressed [event: keydown]\[ga]);
  } \f[B]else\f[R] {
    logMessage(\[ga]Key \[dq]${e.key}\[dq] repeating [event: keydown]\[ga]);
  }
});

textarea.addEventListener(\[dq]beforeinput\[dq], (e) \f[B]=>\f[R] {
  logMessage(\[ga]Key \[dq]${e.data}\[dq] about to be input [event: beforeinput]\[ga]);
});

textarea.addEventListener(\[dq]input\[dq], (e) \f[B]=>\f[R] {
  logMessage(\[ga]Key \[dq]${e.data}\[dq] input [event: input]\[ga]);
});

textarea.addEventListener(\[dq]keyup\[dq], (e) \f[B]=>\f[R] {
  logMessage(\[ga]Key \[dq]${e.key}\[dq] released [event: keyup]\[ga]);
});

btnReset.addEventListener(\[dq]click\[dq], (e) \f[B]=>\f[R] {
  \f[B]let\f[R] child = consoleLog.firstChild;
  \f[B]while\f[R] (child) {
    consoleLog.removeChild(child);
    child = consoleLog.firstChild;
  }
  textarea.value = \[dq]\[dq];
});
.EE
.SS Result
.RS
.PP
\f[B]Note:\f[R] On browsers that don\[cq]t fully implement the
\f[CR]InputEvent\f[R] interface which is used for the
\f[CR]beforeinput\f[R] and \f[CR]input\f[R] events, you may get
incorrect output on those lines of the log output.
.RE
.SS Case 1
When the shift key is pressed, a \f[CR]keydown\f[R] event is first
fired, and the \f[CR]key\f[R] property value is set to the string
\f[CR]Shift\f[R].
As we keep holding this key, the \f[CR]keydown\f[R] event does not
continue to fire repeatedly because it does not produce a character key.
.PP
When \f[CR]key 2\f[R] is pressed, another \f[CR]keydown\f[R] event is
fired for this new key press, and the \f[CR]key\f[R] property value for
the event is set to the string \f[CR]\[at]\f[R] for the U.S keyboard
type and \f[CR]\[dq]\f[R] for the UK keyboard type, because of the
active modifier \f[CR]shift\f[R] key.
The \f[CR]beforeinput\f[R] and \f[CR]input\f[R] events are fired next
because a character key has been produced.
.PP
As we release the \f[CR]key 2\f[R], a \f[CR]keyup\f[R] event is fired
and the \f[CR]key\f[R] property will maintain the string values
\f[CR]\[at]\f[R] and \f[CR]\[dq]\f[R] for the different keyboard layouts
respectively.
.PP
As we finally release the \f[CR]shift\f[R] key, another \f[CR]keyup\f[R]
event is fired for it, and the key attribute value remains
\f[CR]Shift\f[R].
.SS Case 2
When the shift key is pressed, a \f[CR]keydown\f[R] event is first
fired, and the \f[CR]key\f[R] property value is set to be the string
\f[CR]Shift\f[R].
As we keep holding this key, the keydown event does not continue to fire
repeatedly because it produced no character key.
.PP
When \f[CR]key 2\f[R] is pressed, another \f[CR]keydown\f[R] event is
fired for this new key press, and the \f[CR]key\f[R] property value for
the event is set to be the string \f[CR]\[at]\f[R] for the U.S keyboard
type and \f[CR]\[dq]\f[R] for the UK keyboard type, because of the
active modifier \f[CR]shift\f[R] key.
The \f[CR]beforeinput\f[R] and \f[CR]input\f[R] events are fired next
because a character key has been produced.
As we keep holding the key, the \f[CR]keydown\f[R] event continues to
fire repeatedly and the \f[CR]KeyboardEvent.repeat\f[R] property is set
to \f[CR]true\f[R].
The \f[CR]beforeinput\f[R] and \f[CR]input\f[R] events are fired
repeatedly as well.
.PP
As we release the \f[CR]shift\f[R] key, a \f[CR]keyup\f[R] event is
fired for it, and the key attribute value remains \f[CR]Shift\f[R].
At this point, notice that the \f[CR]key\f[R] property value for the
repeating keydown event of the \f[CR]key 2\f[R] key press is now
\[lq]2\[rq] because the modifier \f[CR]shift\f[R] key is no longer
active.
The same goes for the \f[CR]InputEvent.data\f[R] property of the
\f[CR]beforeinput\f[R] and \f[CR]input\f[R] events.
.PP
As we finally release the \f[CR]key 2\f[R], a \f[CR]keyup\f[R] event is
fired but the \f[CR]key\f[R] property will be set to the string value
\f[CR]2\f[R] for both keyboard layouts because the modifier
\f[CR]shift\f[R] key is no longer active.
.SH EXAMPLES
This example uses \f[CR]EventTarget.addEventListener()\f[R] to listen
for \f[CR]keydown\f[R] events.
When they occur, the key\[cq]s value is checked to see if it\[cq]s one
of the keys the code is interested in, and if it is, it gets processed
in some way (possibly by steering a spacecraft, perhaps by changing the
selected cell in a spreadsheet).
.IP
.EX
window.addEventListener(
  \[dq]keydown\[dq],
  (event) \f[B]=>\f[R] {
    \f[B]if\f[R] (event.defaultPrevented) {
      \f[B]return\f[R]; \f[I]// Do nothing if the event was already processed\f[R]
    }

    \f[B]switch\f[R] (event.key) {
      \f[B]case\f[R] \[dq]ArrowDown\[dq]:
        \f[I]// Do something for \[dq]down arrow\[dq] key press.\f[R]
        \f[B]break\f[R];
      \f[B]case\f[R] \[dq]ArrowUp\[dq]:
        \f[I]// Do something for \[dq]up arrow\[dq] key press.\f[R]
        \f[B]break\f[R];
      \f[B]case\f[R] \[dq]ArrowLeft\[dq]:
        \f[I]// Do something for \[dq]left arrow\[dq] key press.\f[R]
        \f[B]break\f[R];
      \f[B]case\f[R] \[dq]ArrowRight\[dq]:
        \f[I]// Do something for \[dq]right arrow\[dq] key press.\f[R]
        \f[B]break\f[R];
      \f[B]case\f[R] \[dq]Enter\[dq]:
        \f[I]// Do something for \[dq]enter\[dq] or \[dq]return\[dq] key press.\f[R]
        \f[B]break\f[R];
      \f[B]case\f[R] \[dq] \[dq]:
        \f[I]// Do something for \[dq]space\[dq] key press.\f[R]
        \f[B]break\f[R];
      \f[B]case\f[R] \[dq]Escape\[dq]:
        \f[I]// Do something for \[dq]esc\[dq] key press.\f[R]
        \f[B]break\f[R];
      \f[B]default\f[R]:
        \f[B]return\f[R]; \f[I]// Quit when this doesn\[aq]t handle the key event.\f[R]
    }

    \f[I]// Cancel the default action to avoid it being handled twice\f[R]
    event.preventDefault();
  },
  \f[B]true\f[R],
);
.EE
