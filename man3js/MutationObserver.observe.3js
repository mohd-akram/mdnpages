.\" Automatically generated by Pandoc 3.4
.\"
.TH "MutationObserver.observe" "JS" "October 28, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
MutationObserver.observe \- MutationObserver: observe() method
.SH SYNOPSIS
The \f[CR]MutationObserver\f[R] method \f[B]\f[CB]observe()\f[B]\f[R]
configures the \f[CR]MutationObserver\f[R] callback to begin receiving
notifications of changes to the DOM that match the given options.
.PP
Depending on the configuration, the observer may watch a single
\f[CR]Node\f[R] in the DOM tree, or that node and some or all of its
descendant nodes.
The same node can be observed by multiple observers, and the same
\f[CR]MutationObserver\f[R] can watch for changes to different parts of
the DOM tree and/or different types of changes by calling
\f[CR]observe()\f[R] multiple times on the same
\f[CR]MutationObserver\f[R].
.PP
To stop the \f[CR]MutationObserver\f[R] (so that none of its callbacks
will be triggered any longer), call
\f[CR]MutationObserver.disconnect()\f[R].
.SH SYNTAX
.IP
.EX
observe(target, options)
.EE
.SS Parameters
.TP
\f[B]target\f[R]
A DOM \f[CR]Node\f[R] (which may be an \f[CR]Element\f[R]) within the
DOM tree to watch for changes, or to be the root of a subtree of nodes
to be watched.
.TP
\f[B]options\f[R]
An object providing options that describe which DOM mutations should be
reported to \f[CR]mutationObserver\f[R]\[cq]s \f[CR]callback\f[R].
At a minimum, one of \f[CR]childList\f[R], \f[CR]attributes\f[R], and/or
\f[CR]characterData\f[R] must be \f[CR]true\f[R] when you call
\f[CR]observe()\f[R].
Otherwise, a \f[CR]TypeError\f[R] exception will be thrown.
.RS
.PP
Options are as follows:
.TP
\f[B]subtree\f[R] \f[I](optional)\f[R]
Set to \f[CR]true\f[R] to extend monitoring to the entire subtree of
nodes rooted at \f[CR]target\f[R].
All of the other properties are then extended to all of the nodes in the
subtree instead of applying solely to the \f[CR]target\f[R] node.
The default value is \f[CR]false\f[R].
Note that if a descendant of \f[CR]target\f[R] is removed, changes in
that descendant subtree will continue to be observed, until the
notification about the removal itself has been delivered.
.TP
\f[B]childList\f[R] \f[I](optional)\f[R]
Set to \f[CR]true\f[R] to monitor the target node (and, if
\f[CR]subtree\f[R] is \f[CR]true\f[R], its descendants) for the addition
of new child nodes or removal of existing child nodes.
The default value is \f[CR]false\f[R].
.TP
\f[B]attributes\f[R] \f[I](optional)\f[R]
Set to \f[CR]true\f[R] to watch for changes to the value of attributes
on the node or nodes being monitored.
The default value is \f[CR]true\f[R] if either of
\f[CR]attributeFilter\f[R] or \f[CR]attributeOldValue\f[R] is specified,
otherwise the default value is \f[CR]false\f[R].
.TP
\f[B]attributeFilter\f[R] \f[I](optional)\f[R]
An array of specific attribute names to be monitored.
If this property isn\[cq]t included, changes to all attributes cause
mutation notifications.
.TP
\f[B]attributeOldValue\f[R] \f[I](optional)\f[R]
Set to \f[CR]true\f[R] to record the previous value of any attribute
that changes when monitoring the node or nodes for attribute changes;
See Monitoring attribute values for an example of watching for attribute
changes and recording values.
The default value is \f[CR]false\f[R].
.TP
\f[B]characterData\f[R] \f[I](optional)\f[R]
Set to \f[CR]true\f[R] to monitor the specified target node (and, if
\f[CR]subtree\f[R] is \f[CR]true\f[R], its descendants) for changes to
the character data contained within the node or nodes.
The default value is \f[CR]true\f[R] if \f[CR]characterDataOldValue\f[R]
is specified, otherwise the default value is \f[CR]false\f[R].
.TP
\f[B]characterDataOldValue\f[R] \f[I](optional)\f[R]
Set to \f[CR]true\f[R] to record the previous value of a node\[cq]s text
whenever the text changes on nodes being monitored.
The default value is \f[CR]false\f[R].
.RE
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown in any of the following circumstances:
.RS
.IP \[bu] 2
The \f[CR]options\f[R] are configured such that nothing will actually be
monitored.
(For example, if \f[CR]childList\f[R], \f[CR]attributes\f[R], and
\f[CR]characterData\f[R] are all \f[CR]false\f[R].)
.IP \[bu] 2
The value of \f[CR]options.attributes\f[R] is \f[CR]false\f[R]
(indicating that attribute changes are not to be monitored), but
\f[CR]attributeOldValue\f[R] is \f[CR]true\f[R] and/or
\f[CR]attributeFilter\f[R] is present.
.IP \[bu] 2
The \f[CR]characterDataOldValue\f[R] option is \f[CR]true\f[R] but
\f[CR]characterData\f[R] is \f[CR]false\f[R] (indicating that character
changes are not to be monitored).
.RE
.SH EXAMPLES
.SS Basic usage
In this example, we demonstrate how to call the method
\f[B]\f[CB]observe()\f[B]\f[R] on an instance of
\f[CR]MutationObserver\f[R], once it has been set up, passing it a
target element and an \f[CR]options\f[R] object.
.IP
.EX
\f[I]// create a new instance of \[ga]MutationObserver\[ga] named \[ga]observer\[ga],\f[R]
\f[I]// passing it a callback function\f[R]
\f[B]const\f[R] observer = \f[B]new\f[R] MutationObserver(() \f[B]=>\f[R] {
  console.log(\[dq]callback that runs when observer is triggered\[dq]);
});

\f[I]// call \[ga]observe()\[ga], passing it the element to observe, and the options object\f[R]
observer.observe(document.querySelector(\[dq]#element\-to\-observe\[dq]), {
  subtree: \f[B]true\f[R],
  childList: \f[B]true\f[R],
});
.EE
.SS Removed descendants when using \f[CR]subtree\f[R]
If you watch a node using the \f[CR]subtree\f[R] option, you will
continue to receive notifications of changes to the descendants of the
node, even after a part of the subtree is removed.
However, once the notification about the removal is delivered, further
changes to the detached subtree will no longer trigger the observer.
.PP
This prevents you from missing changes that occur after the connection
is severed and before you have a chance to specifically begin monitoring
the moved node or subtree for changes.
Theoretically, this means that if you keep track of the
\f[CR]MutationRecord\f[R] objects describing the changes that occur, you
should be able to \[lq]undo\[rq] the changes, rewinding the DOM back to
its initial state.
.IP
.EX
<\f[B]div\f[R] id=\[dq]target\[dq]>
  <\f[B]div\f[R] id=\[dq]child\[dq]></\f[B]div\f[R]>
</\f[B]div\f[R]>
.EE
.IP
.EX
\f[B]const\f[R] target = document.getElementById(\[dq]target\[dq]);
\f[B]const\f[R] child = document.getElementById(\[dq]child\[dq]);

\f[B]const\f[R] observer = \f[B]new\f[R] MutationObserver((mutations) \f[B]=>\f[R] {
  mutations.forEach((mutation) \f[B]=>\f[R] {
    console.log(mutation.type, mutation.target.id, mutation.attributeName);

    \f[B]if\f[R] (mutation.type === \[dq]childList\[dq] && mutation.target.id === \[dq]target\[dq]) {
      \f[I]// After receiving the notification that the child was removed,\f[R]
      \f[I]// further modifications to the detached subtree no longer trigger the observer.\f[R]
      child.setAttribute(\[dq]data\-bar\[dq], \[dq]\[dq]);
    }
  });
});

observer.observe(target, {
  attributes: \f[B]true\f[R],
  childList: \f[B]true\f[R],
  subtree: \f[B]true\f[R],
});

target.removeChild(child);
\f[I]// This change happens before the \[dq]childList target\[dq] notification is delivered,\f[R]
\f[I]// so it will also trigger the observer.\f[R]
child.setAttribute(\[dq]data\-foo\[dq], \[dq]\[dq]);

\f[I]// Output:\f[R]
\f[I]// childList target null\f[R]
\f[I]// attributes child data\-foo\f[R]
\f[I]// There is no \[dq]attributes child data\-bar\[dq] notification.\f[R]
.EE
.SS Using \f[CR]attributeFilter\f[R]
In this example, a Mutation Observer is set up to watch for changes to
the \f[CR]status\f[R] and \f[CR]username\f[R] attributes in any elements
contained within a subtree that displays the names of users in a chat
room.
This lets the code, for example, reflect changes to users\[cq]
nicknames, or to mark them as away from keyboard (AFK) or offline.
.IP
.EX
\f[B]function\f[R] callback(mutationList) {
  mutationList.forEach((mutation) \f[B]=>\f[R] {
    \f[B]switch\f[R] (mutation.type) {
      \f[B]case\f[R] \[dq]attributes\[dq]:
        \f[B]switch\f[R] (mutation.attributeName) {
          \f[B]case\f[R] \[dq]status\[dq]:
            userStatusChanged(mutation.target.username, mutation.target.status);
            \f[B]break\f[R];
          \f[B]case\f[R] \[dq]username\[dq]:
            usernameChanged(mutation.oldValue, mutation.target.username);
            \f[B]break\f[R];
        }
        \f[B]break\f[R];
    }
  });
}

\f[B]const\f[R] userListElement = document.querySelector(\[dq]#user\-list\[dq]);

\f[B]const\f[R] observer = \f[B]new\f[R] MutationObserver(callback);
observer.observe(userListElement, {
  attributeFilter: [\[dq]status\[dq], \[dq]username\[dq]],
  attributeOldValue: \f[B]true\f[R],
  subtree: \f[B]true\f[R],
});
.EE
.SS Monitoring attribute values
In this example we observe an element for attribute value changes, and
add a button which toggles the element\[cq]s \f[CR]dir\f[R] attribute
between \f[CR]\[dq]ltr\[dq]\f[R] and \f[CR]\[dq]rtl\[dq]\f[R].
Inside the observer\[cq]s callback, we log the old value of the
attribute.
.SS HTML
.IP
.EX
<\f[B]button\f[R] id=\[dq]toggle\[dq]>Toggle direction</\f[B]button\f[R]><\f[B]br\f[R] />
<\f[B]div\f[R] id=\[dq]container\[dq]>
  <\f[B]input\f[R] type=\[dq]text\[dq] id=\[dq]rhubarb\[dq] dir=\[dq]ltr\[dq] value=\[dq]Tofu\[dq] />
</\f[B]div\f[R]>
<\f[B]pre\f[R] id=\[dq]output\[dq]></\f[B]pre\f[R]>
.EE
.SS CSS
.IP
.EX
body {
  \f[B]background\-color\f[R]: paleturquoise;
}

button,
input,
pre {
  \f[B]margin\f[R]: 0.5rem;
}
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] toggle = document.querySelector(\[dq]#toggle\[dq]);
\f[B]const\f[R] rhubarb = document.querySelector(\[dq]#rhubarb\[dq]);
\f[B]const\f[R] observerTarget = document.querySelector(\[dq]#container\[dq]);
\f[B]const\f[R] output = document.querySelector(\[dq]#output\[dq]);

toggle.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
  rhubarb.dir = rhubarb.dir === \[dq]ltr\[dq] ? \[dq]rtl\[dq] : \[dq]ltr\[dq];
});

\f[B]const\f[R] config = {
  subtree: \f[B]true\f[R],
  attributeOldValue: \f[B]true\f[R],
};

\f[B]const\f[R] callback = (mutationList) \f[B]=>\f[R] {
  \f[B]for\f[R] (\f[B]const\f[R] mutation \f[B]of\f[R] mutationList) {
    \f[B]if\f[R] (mutation.type === \[dq]attributes\[dq]) {
      output.textContent = \[ga]The ${mutation.attributeName} attribute was modified from \[dq]${mutation.oldValue}\[dq].\[ga];
    }
  }
};

\f[B]const\f[R] observer = \f[B]new\f[R] MutationObserver(callback);
observer.observe(observerTarget, config);
.EE
.SS Result
