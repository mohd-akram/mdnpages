.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "DedicatedWorkerGlobalScope.requestAnimationFrame" "JS" "August 12, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
DedicatedWorkerGlobalScope.requestAnimationFrame \-
DedicatedWorkerGlobalScope: requestAnimationFrame() method
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is only available in Dedicated Web Workers.
.PP
The \f[B]\f[CB]requestAnimationFrame()\f[B]\f[R] method of the
\f[CR]DedicatedWorkerGlobalScope\f[R] interface tells the browser you
wish to perform an animation frame request and call a user\-supplied
callback function before the next repaint.
.PP
The frequency of calls to the callback function will generally match the
display refresh rate.
The most common refresh rate is 60 Hz, (60 cycles/frames per second),
though 75 Hz, 120 Hz, and 144 Hz are also widely used.
\f[CR]requestAnimationFrame()\f[R] calls are paused in most browsers
when running in background tabs or hidden \f[CR]<iframe>\f[R]s, to
improve performance and battery life.
.PP
A call to the \f[CR]requestAnimationFrame()\f[R] method schedules only
one single call to the callback function.
If you want to animate another frame, your callback function must call
\f[CR]requestAnimationFrame()\f[R] again.
.RS
.PP
\f[B]Warning:\f[R] Be sure always to use the first argument (or some
other method for getting the current time) to calculate how much the
animation will progress in a frame \[em] \f[B]otherwise, the animation
will run faster on high refresh\-rate screens\f[R].
For ways to do that, see the examples below.
.RE
.PP
Calling the \f[CR]requestAnimationFrame()\f[R] method requires the
current worker to have an associated owner \f[CR]window\f[R].
That means that the current worker must be created by \f[CR]window\f[R]
or by a dedicated worker that also has an associated owner
\f[CR]window\f[R].
.SH SYNTAX
.IP
.EX
requestAnimationFrame(callback)
.EE
.SS Parameters
.TP
\f[B]callback\f[R]
The function to call when it\[cq]s time to update your animation for the
next repaint.
This callback function is passed a single argument:
.RS
.TP
\f[B]timestamp\f[R]
A \f[CR]DOMHighResTimeStamp\f[R] indicating the end time of the previous
frame\[cq]s rendering (based on the number of milliseconds since time
origin).
The timestamp is a decimal number, in milliseconds, but with a minimal
precision of 1 millisecond.
The timestamp value is also similar to calling
\f[CR]performance.now()\f[R] at the start of the callback function, but
it is never the same value.
.RS
.PP
When multiple callbacks queued by \f[CR]requestAnimationFrame()\f[R]
begin to fire in a single frame, each receives the same timestamp even
though time has passed during the computation of every previous
callback\[cq]s workload.
.RE
.RE
.SS Return value
A \f[CR]long\f[R] integer value that is the request ID uniquely
identifying the entry in the callback list.
This is a non\-zero value, but you may not make any other assumptions
about it.
You can pass this value to \f[CR]cancelAnimationFrame()\f[R] to cancel
the refresh callback request, the cancel action must have been made in
the same worker.
.SS Exceptions
.TP
\f[B]NotSupportedError\f[R] \f[B]DOMException\f[R]
Thrown if the method is not supported by the current worker.
.SH EXAMPLES
On the main thread, we start by transferring the control of a
\f[CR]<canvas>\f[R] element to an \f[CR]OffscreenCanvas\f[R], using
\f[CR]HTMLCanvasElement.transferControlToOffscreen()\f[R], then send a
message to the worker to \f[CR]\[dq]start\[dq]\f[R] its work with the
offscreen canvas:
.IP
.EX
\f[B]const\f[R] offscreenCanvas = document
  .querySelector(\[dq]canvas\[dq])
  .transferControlToOffscreen();

worker.postMessage(
  {
    type: \[dq]start\[dq],
    canvas: offscreenCanvas,
  },
  [offscreenCanvas],
);
.EE
.PP
When receiving the \f[CR]\[dq]start\[dq]\f[R] message, the worker starts
the animation, moving the rectangle from left to right.
Upon reception of a \f[CR]\[dq]stop\[dq]\f[R] message, it will stop the
animation.
.IP
.EX
\f[B]let\f[R] ctx;
\f[B]let\f[R] pos = 0;
\f[B]let\f[R] handle;

\f[B]function\f[R] draw(dt) {
  ctx.clearRect(0, 0, 100, 100);
  ctx.fillRect(pos, 0, 10, 10);
  pos += 10 * dt;
  handle = self.requestAnimationFrame(draw);
}

self.addEventListener(\[dq]message\[dq], (e) \f[B]=>\f[R] {
  \f[B]if\f[R] (e.data.type === \[dq]start\[dq]) {
    \f[B]const\f[R] transferredCanvas = e.data.canvas;
    ctx = transferredCanvas.getContext(\[dq]2d\[dq]);
    handle = self.requestAnimationFrame(draw);
  }
  \f[B]if\f[R] (e.data.type === \[dq]stop\[dq]) {
    self.cancelAnimationFrame(handle);
  }
});
.EE
.PP
Finally, if needed, the main thread can send a \f[CR]\[dq]stop\[dq]\f[R]
message to the worker to stop the animation:
.IP
.EX
worker.postMessage({
  type: \[dq]stop\[dq],
});
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]DedicatedWorkerGlobalScope.cancelAnimationFrame()\f[R]
.IP \[bu] 2
\f[CR]Window.requestAnimationFrame()\f[R]
