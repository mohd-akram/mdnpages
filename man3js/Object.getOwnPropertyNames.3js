.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Object.getOwnPropertyNames" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.getOwnPropertyNames \- Object.getOwnPropertyNames()
.SH SYNOPSIS
The \f[B]\f[CB]Object.getOwnPropertyNames()\f[B]\f[R] static method
returns an array of all properties (including non\-enumerable properties
except for those which use Symbol) found directly in a given object.
.IP
.EX
\f[B]const\f[R] object1 = {
  a: 1,
  b: 2,
  c: 3,
};

console.log(Object.getOwnPropertyNames(object1));
\f[I]// Expected output: Array [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq]]\f[R]
.EE
.SH SYNTAX
.IP
.EX
Object.getOwnPropertyNames(obj)
.EE
.SS Parameters
.TP
\f[B]obj\f[R]
The object whose enumerable and non\-enumerable properties are to be
returned.
.SS Return value
An array of strings that corresponds to the properties found directly in
the given object.
.SH DESCRIPTION
\f[CR]Object.getOwnPropertyNames()\f[R] returns an array whose elements
are strings corresponding to the enumerable and non\-enumerable
properties found directly in a given object \f[CR]obj\f[R].
The ordering of the enumerable properties in the array is consistent
with the ordering exposed by a \f[CR]for...in\f[R] loop (or by
\f[CR]Object.keys()\f[R]) over the properties of the object.
The non\-negative integer keys of the object (both enumerable and
non\-enumerable) are added in ascending order to the array first,
followed by the string keys in the order of insertion.
.PP
In ES5, if the argument to this method is not an object (a primitive),
then it will cause a \f[CR]TypeError\f[R].
In ES2015, a non\-object argument will be coerced to an object.
.IP
.EX
Object.getOwnPropertyNames(\[dq]foo\[dq]);
\f[I]// TypeError: \[dq]foo\[dq] is not an object (ES5 code)\f[R]

Object.getOwnPropertyNames(\[dq]foo\[dq]);
\f[I]// [\[dq]0\[dq], \[dq]1\[dq], \[dq]2\[dq], \[dq]length\[dq]]  (ES2015 code)\f[R]
.EE
.SH EXAMPLES
.SS Using Object.getOwnPropertyNames()
.IP
.EX
\f[B]const\f[R] arr = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq]];
console.log(Object.getOwnPropertyNames(arr).sort());
\f[I]// [\[dq]0\[dq], \[dq]1\[dq], \[dq]2\[dq], \[dq]length\[dq]]\f[R]

\f[I]// Array\-like object\f[R]
\f[B]const\f[R] obj = { 0: \[dq]a\[dq], 1: \[dq]b\[dq], 2: \[dq]c\[dq] };
console.log(Object.getOwnPropertyNames(obj).sort());
\f[I]// [\[dq]0\[dq], \[dq]1\[dq], \[dq]2\[dq]]\f[R]

Object.getOwnPropertyNames(obj).forEach((val, idx, array) \f[B]=>\f[R] {
  console.log(\[ga]${val} \-> ${obj[val]}\[ga]);
});
\f[I]// 0 \-> a\f[R]
\f[I]// 1 \-> b\f[R]
\f[I]// 2 \-> c\f[R]

\f[I]// non\-enumerable property\f[R]
\f[B]const\f[R] myObj = Object.create(
  {},
  {
    getFoo: {
      value() {
        \f[B]return\f[R] \f[B]this\f[R].foo;
      },
      enumerable: \f[B]false\f[R],
    },
  },
);
myObj.foo = 1;

console.log(Object.getOwnPropertyNames(myObj).sort()); \f[I]// [\[dq]foo\[dq], \[dq]getFoo\[dq]]\f[R]
.EE
.PP
If you want only the enumerable properties, see \f[CR]Object.keys()\f[R]
or use a \f[CR]for...in\f[R] loop (note that this will also return
enumerable properties found along the prototype chain for the object
unless the latter is filtered with \f[CR]Object.hasOwn()\f[R]).
.PP
Items on the prototype chain are not listed:
.IP
.EX
\f[B]function\f[R] ParentClass() {}
ParentClass.prototype.inheritedMethod = \f[B]function\f[R] () {};

\f[B]function\f[R] ChildClass() {
  \f[B]this\f[R].prop = 5;
  \f[B]this\f[R].method = \f[B]function\f[R] () {};
}
ChildClass.prototype = \f[B]new\f[R] ParentClass();
ChildClass.prototype.prototypeMethod = \f[B]function\f[R] () {};

console.log(Object.getOwnPropertyNames(\f[B]new\f[R] ChildClass()));
\f[I]// [\[dq]prop\[dq], \[dq]method\[dq]]\f[R]
.EE
.SS Get non\-enumerable properties only
This uses the \f[CR]Array.prototype.filter()\f[R] function to remove the
enumerable keys (obtained with \f[CR]Object.keys()\f[R]) from a list of
all keys (obtained with \f[CR]Object.getOwnPropertyNames()\f[R]) thus
giving only the non\-enumerable keys as output.
.IP
.EX
\f[B]const\f[R] target = myObject;
\f[B]const\f[R] enumAndNonEnum = Object.getOwnPropertyNames(target);
\f[B]const\f[R] enumOnly = \f[B]new\f[R] Set(Object.keys(target));
\f[B]const\f[R] nonEnumOnly = enumAndNonEnum.filter((key) \f[B]=>\f[R] !enumOnly.has(key));

console.log(nonEnumOnly);
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-object
Polyfill of \f[CR]Object.getOwnPropertyNames\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Enumerability and ownership of properties
.IP \[bu] 2
\f[CR]Object.hasOwn()\f[R]
.IP \[bu] 2
\f[CR]Object.prototype.propertyIsEnumerable()\f[R]
.IP \[bu] 2
\f[CR]Object.create()\f[R]
.IP \[bu] 2
\f[CR]Object.keys()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.forEach()\f[R]
