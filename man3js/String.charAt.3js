.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "String.charAt" "JS" "August 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.charAt \- String.prototype.charAt()
.SH SYNOPSIS
The \f[B]\f[CB]charAt()\f[B]\f[R] method of \f[CR]String\f[R] values
returns a new string consisting of the single UTF\-16 code unit at the
given index.
.PP
\f[CR]charAt()\f[R] always indexes the string as a sequence of UTF\-16
code units, so it may return lone surrogates.
To get the full Unicode code point at the given index, use
\f[CR]String.prototype.codePointAt()\f[R] and
\f[CR]String.fromCodePoint()\f[R].
.SH SYNTAX
.IP
.EX
charAt(index)
.EE
.SS Parameters
.TP
\f[B]index\f[R]
Zero\-based index of the character to be returned.
Converted to an integer \[em] \f[CR]undefined\f[R] is converted to 0.
.SS Return value
A string representing the character (exactly one UTF\-16 code unit) at
the specified \f[CR]index\f[R].
If \f[CR]index\f[R] is out of the range of \f[CR]0\f[R] \[en]
\f[CR]str.length \- 1\f[R], \f[CR]charAt()\f[R] returns an empty string.
.SH DESCRIPTION
Characters in a string are indexed from left to right.
The index of the first character is \f[CR]0\f[R], and the index of the
last character in a string called \f[CR]str\f[R] is
\f[CR]str.length \- 1\f[R].
.PP
Unicode code points range from \f[CR]0\f[R] to \f[CR]1114111\f[R]
(\f[CR]0x10FFFF\f[R]).
\f[CR]charAt()\f[R] always returns a character whose value is less than
\f[CR]65536\f[R], because the higher code points are represented by
\f[I]a pair\f[R] of 16\-bit surrogate pseudo\-characters.
Therefore, in order to get a full character with value greater than
\f[CR]65535\f[R], it is necessary to retrieve not only
\f[CR]charAt(i)\f[R], but also \f[CR]charAt(i + 1)\f[R] (as if
manipulating a string with two characters), or to use
\f[CR]codePointAt(i)\f[R] and \f[CR]String.fromCodePoint()\f[R] instead.
For information on Unicode, see UTF\-16 characters, Unicode code points,
and grapheme clusters.
.PP
\f[CR]charAt()\f[R] is very similar to using bracket notation to access
a character at the specified index.
The main differences are:
.IP \[bu] 2
\f[CR]charAt()\f[R] attempts to convert \f[CR]index\f[R] to an integer,
while bracket notation does not, and directly uses \f[CR]index\f[R] as a
property name.
.IP \[bu] 2
\f[CR]charAt()\f[R] returns an empty string if \f[CR]index\f[R] is out
of range, while bracket notation returns \f[CR]undefined\f[R].
.SH EXAMPLES
.SS Using charAt()
The following example displays characters at different locations in the
string \f[CR]\[dq]Brave new world\[dq]\f[R]:
.IP
.EX
const anyString = \[dq]Brave new world\[dq];
console.log(\[ga]The character at index 0   is \[aq]${anyString.charAt()}\[aq]\[ga]);
// No index was provided, used 0 as default

console.log(\[ga]The character at index 0   is \[aq]${anyString.charAt(0)}\[aq]\[ga]);
console.log(\[ga]The character at index 1   is \[aq]${anyString.charAt(1)}\[aq]\[ga]);
console.log(\[ga]The character at index 2   is \[aq]${anyString.charAt(2)}\[aq]\[ga]);
console.log(\[ga]The character at index 3   is \[aq]${anyString.charAt(3)}\[aq]\[ga]);
console.log(\[ga]The character at index 4   is \[aq]${anyString.charAt(4)}\[aq]\[ga]);
console.log(\[ga]The character at index 999 is \[aq]${anyString.charAt(999)}\[aq]\[ga]);
.EE
.PP
These lines display the following:
.IP
.EX
The character at index 0   is \[aq]B\[aq]

The character at index 0   is \[aq]B\[aq]
The character at index 1   is \[aq]r\[aq]
The character at index 2   is \[aq]a\[aq]
The character at index 3   is \[aq]v\[aq]
The character at index 4   is \[aq]e\[aq]
The character at index 999 is \[aq]\[aq]
.EE
.PP
\f[CR]charAt()\f[R] may return lone surrogates, which are not valid
Unicode characters.
.IP
.EX
const str = \[dq]𠮷𠮾\[dq];
console.log(str.charAt(0)); // \[dq]\[rs]ud842\[dq], which is not a valid Unicode character
console.log(str.charAt(1)); // \[dq]\[rs]udfb7\[dq], which is not a valid Unicode character
.EE
.PP
To get the full Unicode code point at the given index, use an indexing
method that splits by Unicode code points, such as
\f[CR]String.prototype.codePointAt()\f[R] and spreading strings into an
array of Unicode code points.
.IP
.EX
const str = \[dq]𠮷𠮾\[dq];
console.log(String.fromCodePoint(str.codePointAt(0))); // \[dq]𠮷\[dq]
console.log([...str][0]); // \[dq]𠮷\[dq]
.EE
.RS
.PP
\f[B]Note:\f[R] Avoid re\-implementing the solutions above using
\f[CR]charAt()\f[R].
The detection of lone surrogates and their pairing is complex, and
built\-in APIs may be more performant as they directly use the internal
representation of the string.
Install a polyfill for the APIs mentioned above if necessary.
.RE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]String.prototype.indexOf()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.lastIndexOf()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.charCodeAt()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.codePointAt()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.split()\f[R]
.IP \[bu] 2
\f[CR]String.fromCodePoint()\f[R]
.IP \[bu] 2
\c
.UR https://mathiasbynens.be/notes/javascript-unicode
JavaScript has a Unicode problem
.UE \c
\ by Mathias Bynens (2013)
