.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "MessageEvent" "JS" "November 23, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
MessageEvent \- MessageEvent
.SH SYNOPSIS
The \f[B]\f[CB]MessageEvent\f[B]\f[R] interface represents a message
received by a target object.
.PP
This is used to represent messages in:
.IP \[bu] 2
Server\-sent events (see \f[CR]EventSource.message_event\f[R]).
.IP \[bu] 2
Web sockets (see the \f[CR]onmessage\f[R] property of the WebSocket
interface).
.IP \[bu] 2
Cross\-document messaging (see \f[CR]Window.postMessage()\f[R] and
\f[CR]Window.message_event\f[R]).
.IP \[bu] 2
Channel messaging (see \f[CR]MessagePort.postMessage()\f[R] and
\f[CR]MessagePort.message_event\f[R]).
.IP \[bu] 2
Cross\-worker/document messaging (see the above two entries, but also
\f[CR]Worker.postMessage()\f[R], \f[CR]Worker.message_event\f[R],
\f[CR]ServiceWorkerGlobalScope.message_event\f[R], etc.)
.IP \[bu] 2
Broadcast channels (see \f[CR]BroadcastChannel.postMessage()\f[R]) and
\f[CR]BroadcastChannel.message_event\f[R]).
.IP \[bu] 2
WebRTC data channels (see \f[CR]onmessage\f[R]).
.PP
The action triggered by this event is defined in a function set as the
event handler for the relevant \f[CR]message\f[R] event (e.g.\ using an
\f[CR]onmessage\f[R] handler as listed above).
.PP
This feature is available in Web Workers.
.SH CONSTRUCTOR
.TP
\f[B]MessageEvent()\f[R]
Creates a new \f[CR]MessageEvent\f[R].
.SH INSTANCE PROPERTIES
\f[I]This interface also inherits properties from its parent,
\f[CI]Event\f[I].\f[R]
.TP
\f[B]MessageEvent.data\f[R] \f[I](read\-only)\f[R]
The data sent by the message emitter.
.TP
\f[B]MessageEvent.origin\f[R] \f[I](read\-only)\f[R]
A string representing the origin of the message emitter.
.TP
\f[B]MessageEvent.lastEventId\f[R] \f[I](read\-only)\f[R]
A string representing a unique ID for the event.
.TP
\f[B]MessageEvent.source\f[R] \f[I](read\-only)\f[R]
A \f[CR]MessageEventSource\f[R] (which can be a WindowProxy,
\f[CR]MessagePort\f[R], or \f[CR]ServiceWorker\f[R] object) representing
the message emitter.
.TP
\f[B]MessageEvent.ports\f[R] \f[I](read\-only)\f[R]
An array of \f[CR]MessagePort\f[R] objects representing the ports
associated with the channel the message is being sent through (where
appropriate, e.g.\ in channel messaging or when sending a message to a
shared worker).
.SH INSTANCE METHODS
\f[I]This interface also inherits methods from its parent,
\f[CI]Event\f[I].\f[R]
.TP
\f[B]initMessageEvent()\f[R] \f[I](deprecated)\f[R]
Initializes a message event.
\f[B]Do not use this anymore\f[R] \[em] \f[B]use the
\f[CB]MessageEvent()\f[B] constructor instead.\f[R]
.SH EXAMPLES
In our \c
.UR
https://github.com/mdn/dom-examples/tree/main/web-workers/simple-shared-worker
Basic shared worker example
.UE \c
\ (\c
.UR https://mdn.github.io/dom-examples/web-workers/simple-shared-worker/
run shared worker
.UE \c
), we have two HTML pages, each of which uses some JavaScript to perform
a simple calculation.
The different scripts are using the same worker file to perform the
calculation \[em] they can both access it, even if their pages are
running inside different windows.
.PP
The following code snippet shows creation of a \f[CR]SharedWorker\f[R]
object using the \f[CR]SharedWorker()\f[R] constructor.
Both scripts contain this:
.IP
.EX
const myWorker = new SharedWorker(\[dq]worker.js\[dq]);
.EE
.PP
Both scripts then access the worker through a \f[CR]MessagePort\f[R]
object created using the \f[CR]SharedWorker.port\f[R] property.
If the onmessage event is attached using addEventListener, the port is
manually started using its \f[CR]start()\f[R] method:
.IP
.EX
myWorker.port.start();
.EE
.PP
When the port is started, both scripts post messages to the worker and
handle messages sent from it using \f[CR]port.postMessage()\f[R] and
\f[CR]port.onmessage\f[R], respectively:
.IP
.EX
first.onchange = () => {
  myWorker.port.postMessage([first.value, second.value]);
  console.log(\[dq]Message posted to worker\[dq]);
};

second.onchange = () => {
  myWorker.port.postMessage([first.value, second.value]);
  console.log(\[dq]Message posted to worker\[dq]);
};

myWorker.port.onmessage = (e) => {
  result1.textContent = e.data;
  console.log(\[dq]Message received from worker\[dq]);
};
.EE
.PP
Inside the worker we use the \f[CR]onconnect\f[R] handler to connect to
the same port discussed above.
The ports associated with that worker are accessible in the
\f[CR]connect\f[R] event\[cq]s \f[CR]ports\f[R] property \[em] we then
use \f[CR]MessagePort\f[R] \f[CR]start()\f[R] method to start the port,
and the \f[CR]onmessage\f[R] handler to deal with messages sent from the
main threads.
.IP
.EX
onconnect = (e) => {
  const port = e.ports[0];

  port.addEventListener(\[dq]message\[dq], (e) => {
    const workerResult = \[ga]Result: ${e.data[0] * e.data[1]}\[ga];
    port.postMessage(workerResult);
  });

  port.start(); // Required when using addEventListener. Otherwise called implicitly by onmessage setter.
};
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]ExtendableMessageEvent\f[R] \[em] similar to this interface but
used in interfaces that needs to give more flexibility to authors.
