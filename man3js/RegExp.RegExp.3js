.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "RegExp.RegExp" "JS" "September 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RegExp.RegExp \- RegExp() constructor
.SH SYNOPSIS
The \f[B]\f[CB]RegExp()\f[B]\f[R] constructor creates \f[CR]RegExp\f[R]
objects.
.PP
For an introduction to regular expressions, read the Regular Expressions
chapter in the JavaScript Guide.
.SH SYNTAX
.IP
.EX
new RegExp(pattern)
new RegExp(pattern, flags)
RegExp(pattern)
RegExp(pattern, flags)
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]RegExp()\f[R] can be called with or without
\f[CR]new\f[R], but sometimes with different effects.
See Return value.
.RE
.SS Parameters
.TP
\f[B]pattern\f[R]
The text of the regular expression.
This can also be another \f[CR]RegExp\f[R] object.
.TP
\f[B]flags\f[R] \f[I](optional)\f[R]
If specified, \f[CR]flags\f[R] is a string that contains the flags to
add.
Alternatively, if a \f[CR]RegExp\f[R] object is supplied for the
\f[CR]pattern\f[R], the \f[CR]flags\f[R] string will replace any of that
object\[cq]s flags (and \f[CR]lastIndex\f[R] will be reset to
\f[CR]0\f[R]).
.RS
.PP
\f[CR]flags\f[R] may contain any combination of the following
characters:
.TP
\f[B]d\f[R] (indices)
Generate indices for substring matches.
.TP
\f[B]g\f[R] (global)
Find all matches rather than stopping after the first match.
.TP
\f[B]i\f[R] (ignore case)
When matching, casing differences are ignored.
.TP
\f[B]m\f[R] (multiline)
Treat beginning and end assertions (\f[CR]\[ha]\f[R] and \f[CR]$\f[R])
as working over multiple lines.
In other words, match the beginning or end of \f[I]each\f[R] line
(delimited by \f[CR]\[rs]n\f[R] or \f[CR]\[rs]r\f[R]), not only the very
beginning or end of the whole input string.
.TP
\f[B]s\f[R] (dotAll)
Allows \f[CR].\f[R] to match newlines.
.TP
\f[B]u\f[R] (unicode)
Treat \f[CR]pattern\f[R] as a sequence of Unicode code points.
.TP
\f[B]v\f[R] (unicodeSets)
An upgrade to the \f[CR]u\f[R] flag that enables set notation in
character classes as well as properties of strings.
.TP
\f[B]y\f[R] (sticky)
Matches only from the index indicated by the \f[CR]lastIndex\f[R]
property of this regular expression in the target string.
Does not attempt to match from any later indexes.
.RE
.SS Return value
\f[CR]RegExp(pattern)\f[R] returns \f[CR]pattern\f[R] directly if all of
the following are true:
.IP \[bu] 2
\f[CR]RegExp()\f[R] is called without \f[CR]new\f[R];
.IP \[bu] 2
\f[CR]pattern\f[R] is a regex;
.IP \[bu] 2
\f[CR]pattern.constructor === RegExp\f[R] (usually meaning it\[cq]s not
a subclass);
.IP \[bu] 2
\f[CR]flags\f[R] is \f[CR]undefined\f[R].
.PP
In all other cases, calling \f[CR]RegExp()\f[R] with or without
\f[CR]new\f[R] both create a new \f[CR]RegExp\f[R] object.
If \f[CR]pattern\f[R] is a regex, the new object\[cq]s source is
\f[CR]pattern.source\f[R]; otherwise, its source is \f[CR]pattern\f[R]
coerced to a string.
If the \f[CR]flags\f[R] parameter is not \f[CR]undefined\f[R], the new
object\[cq]s \f[CR]flags\f[R] is the parameter\[cq]s value; otherwise,
its \f[CR]flags\f[R] is \f[CR]pattern.flags\f[R] (if \f[CR]pattern\f[R]
is a regex).
.SS Exceptions
.TP
\f[B]SyntaxError\f[R]
Thrown in one of the following cases:
.RS
.IP \[bu] 2
\f[CR]pattern\f[R] cannot be parsed as a valid regular expression.
.IP \[bu] 2
\f[CR]flags\f[R] contains repeated characters or any character outside
of those allowed.
.RE
.SH EXAMPLES
.SS Literal notation and constructor
There are two ways to create a \f[CR]RegExp\f[R] object: a \f[I]literal
notation\f[R] and a \f[I]constructor\f[R].
.IP \[bu] 2
The \f[I]literal notation\f[R] takes a pattern between two slashes,
followed by optional flags, after the second slash.
.IP \[bu] 2
The \f[I]constructor function\f[R] takes either a string or a
\f[CR]RegExp\f[R] object as its first parameter and a string of optional
flags as its second parameter.
.PP
The following three expressions create the same regular expression:
.IP
.EX
/ab+c/i;
\f[B]new\f[R] RegExp(/ab+c/, \[dq]i\[dq]); \f[I]// literal notation\f[R]
\f[B]new\f[R] RegExp(\[dq]ab+c\[dq], \[dq]i\[dq]); \f[I]// constructor\f[R]
.EE
.PP
Before regular expressions can be used, they have to be compiled.
This process allows them to perform matches more efficiently.
There are two ways to compile and get a \f[CR]RegExp\f[R] object.
.PP
The literal notation results in compilation of the regular expression
when the expression is evaluated.
On the other hand, the constructor of the \f[CR]RegExp\f[R] object,
\f[CR]new RegExp(\[aq]ab+c\[aq])\f[R], results in runtime compilation of
the regular expression.
.PP
Use a string as the first argument to the \f[CR]RegExp()\f[R]
constructor when you want to build the regular expression from dynamic
input.
.SS Building a regular expression from dynamic inputs
.IP
.EX
\f[B]const\f[R] breakfasts = [\[dq]bacon\[dq], \[dq]eggs\[dq], \[dq]oatmeal\[dq], \[dq]toast\[dq], \[dq]cereal\[dq]];
\f[B]const\f[R] order = \[dq]Let me get some bacon and eggs, please\[dq];

order.match(\f[B]new\f[R] RegExp(\[ga]\[rs]\[rs]b(${breakfasts.join(\[dq]|\[dq])})\[rs]\[rs]b\[ga], \[dq]g\[dq]));
\f[I]// Returns [\[aq]bacon\[aq], \[aq]eggs\[aq]]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-string-and-regexp
Polyfill of many modern \f[CR]RegExp\f[R] features (\f[CR]dotAll\f[R],
\f[CR]sticky\f[R] flags, named capture groups, etc.)
in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Regular expressions guide
.IP \[bu] 2
\f[CR]String.prototype.match()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.replace()\f[R]
