.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "JSON.ISRAWJSON" "3JS" "October 9, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
JSON.isRawJSON \- JSON.isRawJSON()
.SH SYNOPSIS
The \f[B]\f[CB]JSON.isRawJSON()\f[B]\f[R] static method tests whether a
value is an object returned by \f[CR]JSON.rawJSON()\f[R].
.SH SYNTAX
.IP
.EX
JSON.isRawJSON(value)
.EE
.SS Parameters
.TP
\f[B]value\f[R]
The value to test.
.SS Return value
\f[CR]true\f[R] if \f[CR]value\f[R] is created by
\f[CR]JSON.rawJSON()\f[R]; otherwise, \f[CR]false\f[R].
.SH DESCRIPTION
\(lqRaw JSON\(rq objects, when serialized to JSON, are treated as if
they are already a piece of JSON.
Furthermore, because of the way \f[CR]JSON.rawJSON()\f[R] works, the raw
JSON is guaranteed to be syntactically valid JSON.
For more information on the shape and behavior of raw JSON objects, see
\f[CR]JSON.rawJSON()\f[R].
This method exists to allow other serialization libraries to implement
similar behavior to \f[CR]JSON.stringify()\f[R] for raw JSON objects.
.SH EXAMPLES
.SS Using JSON.isRawJSON()
The following example demonstrates how to use
\f[CR]JSON.isRawJSON()\f[R] to test whether an object was returned by
\f[CR]JSON.rawJSON()\f[R].
It implements a custom serializer that serializes data to a YAML\-like
format.
.IP
.EX
\f[B]function\f[R] mySerializer(value, indent = \(dq\(dq) {
  \f[B]if\f[R] (\f[B]typeof\f[R] value !== \(dqobject\(dq || value === \f[B]null\f[R]) {
    \f[B]return\f[R] JSON.stringify(value);
  }
  \f[B]if\f[R] (JSON.isRawJSON(value)) {
    \f[B]return\f[R] value.rawJSON;
  }
  \f[B]const\f[R] subIndent = \(ga${indent}  \(ga;
  \f[B]if\f[R] (Array.isArray(value)) {
    \f[B]return\f[R] \(ga\- ${value.map((v) \f[B]=>\f[R] mySerializer(v, subIndent)).join(\(ga\(rsn${indent}\- \(ga)}\(ga;
  }
  \f[B]return\f[R] Object.entries(value)
    .map(([key, value]) \f[B]=>\f[R] {
      \f[B]const\f[R] subValue = mySerializer(value, subIndent);
      \f[B]if\f[R] (subValue.includes(\(dq\(rsn\(dq)) {
        \f[B]return\f[R] \(ga${key}:\(rsn${subIndent}${subValue}\(ga;
      }
      \f[B]return\f[R] \(ga${key}: ${subValue}\(ga;
    })
    .join(\(ga\(rsn${indent}\(ga);
}

console.log(
  mySerializer({
    name: \(dqJosh\(dq,
    userId: JSON.rawJSON(\(dq12345678901234567890\(dq),
    friends: [
      { name: \(dqAlice\(dq, userId: JSON.rawJSON(\(dq9876543210987654321\(dq) },
      { name: \(dqBob\(dq, userId: JSON.rawJSON(\(dq56789012345678901234\(dq) },
    ],
  }),
);

\f[I]// name: \(dqJosh\(dq\f[R]
\f[I]// userId: 12345678901234567890\f[R]
\f[I]// friends:\f[R]
\f[I]//   \- name: \(dqAlice\(dq\f[R]
\f[I]//     userId: 9876543210987654321\f[R]
\f[I]//   \- name: \(dqBob\(dq\f[R]
\f[I]//     userId: 56789012345678901234\f[R]
.EE
.PP
If in the above example, the \f[CR]userId\f[R] values were not created
by \f[CR]JSON.rawJSON()\f[R], but passed as numbers directly, then we
will get loss of precision upfront because of JS floating point
precision limitations.
.IP
.EX
console.log(
  mySerializer({
    name: \(dqJosh\(dq,
    userId: 12345678901234567890,
    friends: [
      { name: \(dqAlice\(dq, userId: 9876543210987654321 },
      { name: \(dqBob\(dq, userId: 56789012345678901234 },
    ],
  }),
);

\f[I]// name: \(dqJosh\(dq\f[R]
\f[I]// userId: 12345678901234567000\f[R]
\f[I]// friends:\f[R]
\f[I]//   \- name: \(dqAlice\(dq\f[R]
\f[I]//     userId: 9876543210987655000\f[R]
\f[I]//   \- name: \(dqBob\(dq\f[R]
\f[I]//     userId: 56789012345678900000\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#jsonparse-source-text-access
Polyfill of \f[CR]JSON.isRawJSON\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\f[CR]JSON\f[R]
.IP \(bu 2
\f[CR]JSON.stringify()\f[R]
.IP \(bu 2
\f[CR]JSON.rawJSON()\f[R]
