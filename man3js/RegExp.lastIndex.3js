'\" t
.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "RegExp.lastIndex" "JS" "September 25, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RegExp.lastIndex \- RegExp: lastIndex
.SH SYNOPSIS
The \f[B]\f[CB]lastIndex\f[B]\f[R] data property of a \f[CR]RegExp\f[R]
instance specifies the index at which to start the next match.
.SH VALUE
A non\-negative integer.
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
yes
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
no
T}
.TE
.SH DESCRIPTION
This property is set only if the regular expression instance used the
\f[CR]g\f[R] flag to indicate a global search, or the \f[CR]y\f[R] flag
to indicate a sticky search.
The following rules apply when \f[CR]exec()\f[R] is called on a given
input:
.IP \[bu] 2
If \f[CR]lastIndex\f[R] is greater than the length of the input,
\f[CR]exec()\f[R] will not find a match, and \f[CR]lastIndex\f[R] will
be set to 0.
.IP \[bu] 2
If \f[CR]lastIndex\f[R] is equal to or less than the length of the
input, \f[CR]exec()\f[R] will attempt to match the input starting from
\f[CR]lastIndex\f[R].
.RS 2
.IP \[bu] 2
If \f[CR]exec()\f[R] finds a match, then \f[CR]lastIndex\f[R] will be
set to the position of the end of the matched string in the input.
.IP \[bu] 2
If \f[CR]exec()\f[R] does not find a match, then \f[CR]lastIndex\f[R]
will be set to 0.
.RE
.PP
Other regex\-related methods, such as
\f[CR]RegExp.prototype.test()\f[R], \f[CR]String.prototype.match()\f[R],
\f[CR]String.prototype.replace()\f[R], etc., call \f[CR]exec()\f[R]
under the hood, so they have different effects on \f[CR]lastIndex\f[R].
See their respective pages for details.
.SH EXAMPLES
.SS Using lastIndex
Consider the following sequence of statements:
.IP
.EX
const re = /(hi)?/g;
.EE
.PP
Matches the empty string.
.IP
.EX
console.log(re.exec(\[dq]hi\[dq]));
console.log(re.lastIndex);
.EE
.PP
Returns \f[CR][\[dq]hi\[dq], \[dq]hi\[dq]]\f[R] with
\f[CR]lastIndex\f[R] equal to 2.
.IP
.EX
console.log(re.exec(\[dq]hi\[dq]));
console.log(re.lastIndex);
.EE
.PP
Returns \f[CR][\[dq]\[dq], undefined]\f[R], an empty array whose zeroth
element is the match string.
In this case, the empty string because \f[CR]lastIndex\f[R] was 2 (and
still is 2) and \f[CR]hi\f[R] has length 2.
.SS Using lastIndex with sticky regexes
The \f[CR]lastIndex\f[R] property is writable.
You can set it to make the regex start its next search at a given index.
.PP
The \f[CR]y\f[R] flag almost always requires setting
\f[CR]lastIndex\f[R].
It always matches strictly at \f[CR]lastIndex\f[R] and does not attempt
any later positions.
This is usually useful for writing parsers, when you want to match
tokens only at the current position.
.IP
.EX
const stringPattern = /\[dq][\[ha]\[dq]]*\[dq]/y;
const input = \[ga]const message = \[dq]Hello world\[dq];\[ga];

stringPattern.lastIndex = 6;
console.log(stringPattern.exec(input)); // null

stringPattern.lastIndex = 16;
console.log(stringPattern.exec(input)); // [\[aq]\[dq]Hello world\[dq]\[aq]]
.EE
.SS Rewinding lastIndex
The \f[CR]g\f[R] flag also benefits from setting \f[CR]lastIndex\f[R].
One common use case is when the string is modified in the middle of a
global search.
In this case, we may miss a particular match if the string is shortened.
We can avoid this by rewinding \f[CR]lastIndex\f[R].
.IP
.EX
const mdLinkPattern = /\[rs][[\[ha][\[rs]]]+\[rs]]\[rs]((?<link>[\[ha]()\[rs]s]+)\[rs])/dg;

function resolveMDLink(line) {
  let match;
  let modifiedLine = line;
  while ((match = mdLinkPattern.exec(modifiedLine))) {
    const originalLink = match.groups.link;
    const resolvedLink = originalLink.replaceAll(/\[ha]files|\[rs]/index\[rs].md$/g, \[dq]\[dq]);
    modifiedLine =
      modifiedLine.slice(0, match.indices.groups.link[0]) +
      resolvedLink +
      modifiedLine.slice(match.indices.groups.link[1]);
    // Rewind the pattern to the end of the resolved link
    mdLinkPattern.lastIndex += resolvedLink.length \- originalLink.length;
  }
  return modifiedLine;
}

console.log(
  resolveMDLink(
    \[dq][\[ga]lastIndex\[ga]](files/en\-us/web/javascript/reference/global_objects/regexp/lastindex/index.md)\[dq],
  ),
); // [\[ga]lastIndex\[ga]](/en\-us/web/javascript/reference/global_objects/regexp/lastindex)
console.log(
  resolveMDLink(
    \[dq][\[ga]ServiceWorker\[ga]](files/en\-us/web/api/serviceworker/index.md) and [\[ga]SharedWorker\[ga]](files/en\-us/web/api/sharedworker/index.md)\[dq],
  ),
); // [\[ga]ServiceWorker\[ga]](/en\-us/web/api/serviceworker) and [\[ga]SharedWorker\[ga]](/en\-us/web/api/sharedworker)
.EE
.PP
Try deleting the
\f[CR]mdLinkPattern.lastIndex += resolvedLink.length \- originalLink.length\f[R]
line and running the second example.
You will find that the second link is not replaced correctly, because
the \f[CR]lastIndex\f[R] is already past the link\[cq]s index after the
string is shortened.
.RS
.PP
\f[B]Warning:\f[R] This example is for demonstration only.
To deal with Markdown, you should probably use a parsing library instead
of regex.
.RE
.SS Optimizing searching
You can optimize searching by setting \f[CR]lastIndex\f[R] to a point
where previous possible occurrences can be ignored.
For example, instead of this:
.IP
.EX
const stringPattern = /\[dq][\[ha]\[dq]]*\[dq]/g;
const input = \[ga]const message = \[dq]Hello \[dq] + \[dq]world\[dq];\[ga];

// Pretend we\[aq]ve already dealt with the previous parts of the string
let offset = 26;
const remainingInput = input.slice(offset);
const nextString = stringPattern.exec(remainingInput);
console.log(nextString[0]); // \[dq]world\[dq]
offset += nextString.index + nextString.length;
.EE
.PP
Consider this:
.IP
.EX
stringPattern.lastIndex = offset;
const nextString = stringPattern.exec(remainingInput);
console.log(nextString[0]); // \[dq]world\[dq]
offset = stringPattern.lastIndex;
.EE
.PP
This is potentially more performant because we avoid string slicing.
.SS Avoiding side effects
The side effects caused by \f[CR]exec()\f[R] can be confusing,
especially if the input is different for each \f[CR]exec()\f[R].
.IP
.EX
const re = /foo/g;
console.log(re.test(\[dq]foo bar\[dq])); // true
console.log(re.test(\[dq]foo baz\[dq])); // false, because lastIndex is non\-zero
.EE
.PP
This is even more confusing when you are hand\-modifying
\f[CR]lastIndex\f[R].
To contain the side effects, remember to reset \f[CR]lastIndex\f[R]
after each input is completely processed.
.IP
.EX
const re = /foo/g;
console.log(re.test(\[dq]foo bar\[dq])); // true
re.lastIndex = 0;
console.log(re.test(\[dq]foo baz\[dq])); // true
.EE
.PP
With some abstraction, you can require \f[CR]lastIndex\f[R] to be set to
a particular value before each \f[CR]exec()\f[R] call.
.IP
.EX
function createMatcher(pattern) {
  // Create a copy, so that the original regex is never updated
  const regex = new RegExp(pattern, \[dq]g\[dq]);
  return (input, offset) => {
    regex.lastIndex = offset;
    return regex.exec(input);
  };
}

const matchFoo = createMatcher(/foo/);
console.log(matchFoo(\[dq]foo bar\[dq], 0)[0]); // \[dq]foo\[dq]
console.log(matchFoo(\[dq]foo baz\[dq], 0)[0]); // \[dq]foo\[dq]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]RegExp.prototype.dotAll\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.global\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.hasIndices\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.ignoreCase\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.multiline\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.source\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.sticky\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.unicode\f[R]
