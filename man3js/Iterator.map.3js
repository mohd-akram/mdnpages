.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ITERATOR.MAP" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator.map \- Iterator.prototype.map()
.SH SYNOPSIS
The \f[B]\f[CB]map()\f[B]\f[R] method of \f[CR]Iterator\f[R] instances
returns a new iterator helper object that yields elements of the
iterator, each transformed by a mapping function.
.SH SYNTAX
.IP
.EX
map(callbackFn)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element produced by the iterator.
Its return value is yielded by the iterator helper.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed.
.TP
\f[B]index\f[R]
The index of the current element being processed.
.RE
.SS Return value
A new iterator helper object.
Each time the iterator helper\(cqs \f[CR]next()\f[R] method is called,
it gets the next element from the underlying iterator, applies
\f[CR]callbackFn\f[R], and yields the return value.
When the underlying iterator is completed, the iterator helper is also
completed (the \f[CR]next()\f[R] method produces
\f[CR]{ value: undefined, done: true }\f[R]).
.SH DESCRIPTION
The main advantage of iterator helpers over array methods is that they
are lazy, meaning that they only produce the next value when requested.
This avoids unnecessary computation and also allows them to be used with
infinite iterators.
The \f[CR]map()\f[R] method allows you to create a new iterator that,
when iterated, produces transformed elements.
.SH EXAMPLES
.SS Using map()
The following example creates an iterator that yields terms in the
Fibonacci sequence, transforms it into a new sequence with each term
squared, and then reads the first few terms:
.IP
.EX
\f[B]function\f[R]* fibonacci() {
  \f[B]let\f[R] current = 1;
  \f[B]let\f[R] next = 1;
  \f[B]while\f[R] (\f[B]true\f[R]) {
    \f[B]yield\f[R] current;
    [current, next] = [next, current + next];
  }
}

\f[B]const\f[R] seq = fibonacci().map((x) \f[B]=>\f[R] x ** 2);
console.log(seq.next().value); \f[I]// 1\f[R]
console.log(seq.next().value); \f[I]// 1\f[R]
console.log(seq.next().value); \f[I]// 4\f[R]
.EE
.SS Using map() with a for\&...of loop
\f[CR]map()\f[R] is most convenient when you are not hand\-rolling the
iterator.
Because iterators are also iterable, you can iterate the returned helper
with a \f[CR]for...of\f[R] loop:
.IP
.EX
\f[B]for\f[R] (\f[B]const\f[R] n \f[B]of\f[R] fibonacci().map((x) \f[B]=>\f[R] x ** 2)) {
  console.log(n);
  \f[B]if\f[R] (n > 30) {
    \f[B]break\f[R];
  }
}

\f[I]// Logs:\f[R]
\f[I]// 1\f[R]
\f[I]// 1\f[R]
\f[I]// 4\f[R]
\f[I]// 9\f[R]
\f[I]// 25\f[R]
\f[I]// 64\f[R]
.EE
.PP
This is equivalent to:
.IP
.EX
\f[B]for\f[R] (\f[B]const\f[R] n \f[B]of\f[R] fibonacci()) {
  \f[B]const\f[R] n2 = n ** 2;
  console.log(n2);
  \f[B]if\f[R] (n2 > 30) {
    \f[B]break\f[R];
  }
}
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#iterator-helpers
Polyfill of \f[CR]Iterator.prototype.map\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/es-iterator-helpers
es\-shims polyfill of \f[CR]Iterator.prototype.map\f[R]
.UE \c
.IP \(bu 2
\f[CR]Iterator\f[R]
.IP \(bu 2
\f[CR]Iterator.prototype.flatMap()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.reduce()\f[R]
