.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Object.create" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.create \- Object.create()
.SH SYNOPSIS
The \f[B]\f[CB]Object.create()\f[B]\f[R] static method creates a new
object, using an existing object as the prototype of the newly created
object.
.IP
.EX
\f[B]const\f[R] person = {
  isHuman: \f[B]false\f[R],
  printIntroduction: \f[B]function\f[R] () {
    console.log(\[ga]My name is ${\f[B]this\f[R].name}. Am I human? ${\f[B]this\f[R].isHuman}\[ga]);
  },
};

\f[B]const\f[R] me = Object.create(person);

me.name = \[dq]Matthew\[dq]; \f[I]// \[dq]name\[dq] is a property set on \[dq]me\[dq], but not on \[dq]person\[dq]\f[R]
me.isHuman = \f[B]true\f[R]; \f[I]// Inherited properties can be overwritten\f[R]

me.printIntroduction();
\f[I]// Expected output: \[dq]My name is Matthew. Am I human? true\[dq]\f[R]
.EE
.SH SYNTAX
.IP
.EX
Object.create(proto)
Object.create(proto, propertiesObject)
.EE
.SS Parameters
.TP
\f[B]proto\f[R]
The object which should be the prototype of the newly\-created object.
.TP
\f[B]propertiesObject\f[R] \f[I](optional)\f[R]
If specified and not \f[CR]undefined\f[R], an object whose enumerable
own properties specify property descriptors to be added to the
newly\-created object, with the corresponding property names.
These properties correspond to the second argument of
\f[CR]Object.defineProperties()\f[R].
.SS Return value
A new object with the specified prototype object and properties.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if \f[CR]proto\f[R] is neither \f[CR]null\f[R] nor an
\f[CR]Object\f[R].
.SH EXAMPLES
.SS Classical inheritance with Object.create()
Below is an example of how to use \f[CR]Object.create()\f[R] to achieve
classical inheritance.
This is for a single inheritance, which is all that JavaScript supports.
.IP
.EX
\f[I]// Shape \- superclass\f[R]
\f[B]function\f[R] Shape() {
  \f[B]this\f[R].x = 0;
  \f[B]this\f[R].y = 0;
}

\f[I]// superclass method\f[R]
Shape.prototype.move = \f[B]function\f[R] (x, y) {
  \f[B]this\f[R].x += x;
  \f[B]this\f[R].y += y;
  console.info(\[dq]Shape moved.\[dq]);
};

\f[I]// Rectangle \- subclass\f[R]
\f[B]function\f[R] Rectangle() {
  Shape.call(\f[B]this\f[R]); \f[I]// call super constructor.\f[R]
}

\f[I]// subclass extends superclass\f[R]
Rectangle.prototype = Object.create(Shape.prototype, {
  \f[I]// If you don\[aq]t set Rectangle.prototype.constructor to Rectangle,\f[R]
  \f[I]// it will take the prototype.constructor of Shape (parent).\f[R]
  \f[I]// To avoid that, we set the prototype.constructor to Rectangle (child).\f[R]
  constructor: {
    value: Rectangle,
    enumerable: \f[B]false\f[R],
    writable: \f[B]true\f[R],
    configurable: \f[B]true\f[R],
  },
});

\f[B]const\f[R] rect = \f[B]new\f[R] Rectangle();

console.log(\[dq]Is rect an instance of Rectangle?\[dq], rect \f[B]instanceof\f[R] Rectangle); \f[I]// true\f[R]
console.log(\[dq]Is rect an instance of Shape?\[dq], rect \f[B]instanceof\f[R] Shape); \f[I]// true\f[R]
rect.move(1, 1); \f[I]// Logs \[aq]Shape moved.\[aq]\f[R]
.EE
.PP
Note that there are caveats to watch out for using \f[CR]create()\f[R],
such as re\-adding the \f[CR]constructor\f[R] property to ensure proper
semantics.
Although \f[CR]Object.create()\f[R] is believed to have better
performance than mutating the prototype with
\f[CR]Object.setPrototypeOf()\f[R], the difference is in fact negligible
if no instances have been created and property accesses haven\[cq]t been
optimized yet.
In modern code, the class syntax should be preferred in any case.
.SS Using propertiesObject argument with Object.create()
\f[CR]Object.create()\f[R] allows fine\-tuned control over the object
creation process.
The object initializer syntax is, in fact, a syntax sugar of
\f[CR]Object.create()\f[R].
With \f[CR]Object.create()\f[R], we can create objects with a designated
prototype and also some properties.
Note that the second parameter maps keys to \f[I]property
descriptors\f[R] \[em] this means you can control each property\[cq]s
enumerability, configurability, etc.
as well, which you can\[cq]t do in object initializers.
.IP
.EX
o = {};
\f[I]// Is equivalent to:\f[R]
o = Object.create(Object.prototype);

o = Object.create(Object.prototype, {
  \f[I]// foo is a regular data property\f[R]
  foo: {
    writable: \f[B]true\f[R],
    configurable: \f[B]true\f[R],
    value: \[dq]hello\[dq],
  },
  \f[I]// bar is an accessor property\f[R]
  bar: {
    configurable: \f[B]false\f[R],
    \f[B]get\f[R]() {
      \f[B]return\f[R] 10;
    },
    \f[B]set\f[R](value) {
      console.log(\[dq]Setting \[ga]o.bar\[ga] to\[dq], value);
    },
  },
});

\f[I]// Create a new object whose prototype is a new, empty\f[R]
\f[I]// object and add a single property \[aq]p\[aq], with value 42.\f[R]
o = Object.create({}, { p: { value: 42 } });
.EE
.PP
With \f[CR]Object.create()\f[R], we can create an object with
\f[CR]null\f[R] as prototype.
The equivalent syntax in object initializers would be the
\f[CR]__proto__\f[R] key.
.IP
.EX
o = Object.create(\f[B]null\f[R]);
\f[I]// Is equivalent to:\f[R]
o = { __proto__: \f[B]null\f[R] };
.EE
.PP
By default properties are \f[I]not\f[R] writable, enumerable or
configurable.
.IP
.EX
o.p = 24; \f[I]// throws in strict mode\f[R]
o.p; \f[I]// 42\f[R]

o.q = 12;
\f[B]for\f[R] (\f[B]const\f[R] prop \f[B]in\f[R] o) {
  console.log(prop);
}
\f[I]// \[aq]q\[aq]\f[R]

\f[B]delete\f[R] o.p;
\f[I]// false; throws in strict mode\f[R]
.EE
.PP
To specify a property with the same attributes as in an initializer,
explicitly specify \f[CR]writable\f[R], \f[CR]enumerable\f[R] and
\f[CR]configurable\f[R].
.IP
.EX
o2 = Object.create(
  {},
  {
    p: {
      value: 42,
      writable: \f[B]true\f[R],
      enumerable: \f[B]true\f[R],
      configurable: \f[B]true\f[R],
    },
  },
);
\f[I]// This is not equivalent to:\f[R]
\f[I]// o2 = Object.create({ p: 42 })\f[R]
\f[I]// which will create an object with prototype { p: 42 }\f[R]
.EE
.PP
You can use \f[CR]Object.create()\f[R] to mimic the behavior of the
\f[CR]new\f[R] operator.
.IP
.EX
\f[B]function\f[R] Constructor() {}
o = \f[B]new\f[R] Constructor();
\f[I]// Is equivalent to:\f[R]
o = Object.create(Constructor.prototype);
.EE
.PP
Of course, if there is actual initialization code in the
\f[CR]Constructor\f[R] function, the \f[CR]Object.create()\f[R] method
cannot reflect it.
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-object
Polyfill of \f[CR]Object.create\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Object.defineProperty()\f[R]
.IP \[bu] 2
\f[CR]Object.defineProperties()\f[R]
.IP \[bu] 2
\f[CR]Object.prototype.isPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Reflect.construct()\f[R]
.IP \[bu] 2
\c
.UR https://johnresig.com/blog/objectgetprototypeof/
Object.getPrototypeOf
.UE \c
\ by John Resig (2008)
