.\" Automatically generated by Pandoc 3.4
.\"
.TH "Uint8Array.setFromHex" "JS" "November 5, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Uint8Array.setFromHex \- Uint8Array.setFromHex()
.SH SYNOPSIS
The \f[B]\f[CB]setFromHex()\f[B]\f[R] method of \f[CR]Uint8Array\f[R]
instances populates this \f[CR]Uint8Array\f[R] object with bytes from a
hex\-encoded string, returning an object indicating how many bytes were
read and written.
.PP
This method parses the string into a byte array.
To convert the string into a single number, use the
\f[CR]parseInt()\f[R] function with \f[CR]radix\f[R] set to
\f[CR]16\f[R] instead.
.SH SYNTAX
.IP
.EX
setFromHex(string)
.EE
.SS Parameters
.TP
\f[B]string\f[R]
A hexadecimal string encoding bytes to write into a
\f[CR]Uint8Array\f[R].
The string must:
.RS
.IP \[bu] 2
Have an even number of characters because two characters encode one
byte.
.IP \[bu] 2
Only contain characters in the hexadecimal alphabet, which includes
0\[en]9 and A\[en]F (case\-insensitive).
.IP \[bu] 2
Not contain whitespace (unlike
\f[CR]Uint8Array.prototype.setFromBase64()\f[R]).
.PP
Note that the string is only read up to the point where the array is
filled, so any invalid hex syntax after that point is ignored.
.RE
.SS Return value
An object containing the following properties:
.TP
\f[B]read\f[R]
The number of hex characters read from the input string.
If the decoded data fits into the array, it is the length of the input
string: otherwise, it is the number of complete hex characters that fit
into the array.
.TP
\f[B]written\f[R]
The number of bytes written to the \f[CR]Uint8Array\f[R].
Will never be greater than this \f[CR]Uint8Array\f[R]\[cq]s
\f[CR]byteLength\f[R].
.SS Exceptions
.TP
\f[B]SyntaxError\f[R]
Thrown if the input string contains characters outside the hex alphabet,
or its length is odd.
.TP
\f[B]TypeError\f[R]
Thrown if the input string is not a string.
.SH EXAMPLES
.SS Decoding a hexadecimal string
This example decodes a hexadecimal string into an existing
\f[CR]Uint8Array\f[R].
.IP
.EX
\f[B]const\f[R] uint8Array = \f[B]new\f[R] Uint8Array(8);
\f[B]const\f[R] result = uint8Array.setFromHex(\[dq]cafed00d\[dq]);
console.log(result); \f[I]// { read: 8, written: 4 }\f[R]
console.log(uint8Array); \f[I]// Uint8Array(8) [202, 254, 208, 13, 0, 0, 0, 0]\f[R]
.EE
.SS Decoding a big string into a small array
If the string contains more data than the array can hold, the method
will only write as many bytes as the array can hold.
.IP
.EX
\f[B]const\f[R] uint8Array = \f[B]new\f[R] Uint8Array(4);
\f[B]const\f[R] result = uint8Array.setFromHex(\[dq]cafed00d\-some random stuff\[dq]);
console.log(result); \f[I]// { read: 8, written: 4 }\f[R]
console.log(uint8Array); \f[I]// Uint8Array(4) [202, 254, 208, 13]\f[R]
.EE
.PP
Excess characters are ignored, even if they are invalid.
However the total length of the input string must be even.
.SS Setting data at a specific offset
The \f[CR]setFromHex()\f[R] method always starts writing at the
beginning of the \f[CR]Uint8Array\f[R].
If you want to write to the middle of the array, you can write to a
\f[CR]TypedArray.prototype.subarray()\f[R] instead.
.IP
.EX
\f[B]const\f[R] uint8Array = \f[B]new\f[R] Uint8Array(8);
\f[I]// Start writing at offset 2\f[R]
\f[B]const\f[R] result = uint8Array.subarray(2).setFromHex(\[dq]cafed00d\[dq]);
console.log(result); \f[I]// { read: 8, written: 4 }\f[R]
console.log(uint8Array);
\f[I]// Uint8Array(8) [0, 0, 202, 254, 208, 13, 0, 0]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#uint8array-to--from-base64-and-hex
Polyfill of \f[CR]Uint8Array.setFromHex\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Uint8Array\f[R]
.IP \[bu] 2
\f[CR]Uint8Array.fromHex()\f[R]
.IP \[bu] 2
\f[CR]Uint8Array.prototype.toHex()\f[R]
.IP \[bu] 2
\f[CR]parseInt()\f[R]
