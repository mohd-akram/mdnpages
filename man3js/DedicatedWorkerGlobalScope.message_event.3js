.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "DedicatedWorkerGlobalScope.message_event" "JS" "April 22, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
DedicatedWorkerGlobalScope.message_event \- DedicatedWorkerGlobalScope:
message event
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is only available in Dedicated Web Workers.
.PP
The \f[CR]message\f[R] event is fired on a
\f[CR]DedicatedWorkerGlobalScope\f[R] object when the worker receives a
message from its parent (i.e.\ when the parent sends a message using
\f[CR]Worker.postMessage()\f[R]).
.PP
This event is not cancellable and does not bubble.
.SH SYNTAX
Use the event name in methods like \f[CR]addEventListener()\f[R], or set
an event handler property.
.IP
.EX
addEventListener(\[dq]message\[dq], (event) \f[B]=>\f[R] {});

onmessage = (event) \f[B]=>\f[R] {};
.EE
.SH EVENT TYPE
A \f[CR]MessageEvent\f[R].
Inherits from \f[CR]Event\f[R].
.SH EVENT PROPERTIES
\f[I]This interface also inherits properties from its parent,
\f[CI]Event\f[I].\f[R]
.TP
\f[B]MessageEvent.data\f[R] \f[I](read\-only)\f[R]
The data sent by the message emitter.
.TP
\f[B]MessageEvent.origin\f[R] \f[I](read\-only)\f[R]
A string representing the origin of the message emitter.
.TP
\f[B]MessageEvent.lastEventId\f[R] \f[I](read\-only)\f[R]
A string representing a unique ID for the event.
.TP
\f[B]MessageEvent.source\f[R] \f[I](read\-only)\f[R]
A \f[CR]MessageEventSource\f[R] (which can be a \f[CR]Window\f[R],
\f[CR]MessagePort\f[R], or \f[CR]ServiceWorker\f[R] object) representing
the message emitter.
.TP
\f[B]MessageEvent.ports\f[R] \f[I](read\-only)\f[R]
An array of \f[CR]MessagePort\f[R] objects representing the ports
associated with the channel the message is being sent through (where
appropriate, e.g.\ in channel messaging or when sending a message to a
shared worker).
.SH EXAMPLE
The following code snippet shows creation of a \f[CR]Worker\f[R] object
using the \f[CR]Worker()\f[R] constructor.
Messages are passed to the worker when the value inside the form input
\f[CR]first\f[R] changes.
An \f[CR]onmessage\f[R] handler is also present, to deal with messages
are passed back from the worker.
.IP
.EX
\f[I]// main.js\f[R]

\f[B]const\f[R] myWorker = \f[B]new\f[R] Worker(\[dq]worker.js\[dq]);

first.onchange = () \f[B]=>\f[R] {
  myWorker.postMessage([first.value, second.value]);
  console.log(\[dq]Message posted to worker\[dq]);
};

\f[I]// worker.js\f[R]

self.onmessage = (e) \f[B]=>\f[R] {
  console.log(\[dq]Message received from main script\[dq]);
  \f[B]const\f[R] workerResult = \[ga]Result: ${e.data[0] * e.data[1]}\[ga];
  console.log(\[dq]Posting message back to main script\[dq]);
  postMessage(workerResult);
};
.EE
.PP
In the \f[CR]main.js\f[R] script, an \f[CR]onmessage\f[R] handler is
used to handle messages from the worker script:
.IP
.EX
\f[I]// main.js\f[R]

myWorker.onmessage = (e) \f[B]=>\f[R] {
  result.textContent = e.data;
  console.log(\[dq]Message received from worker\[dq]);
};
.EE
.PP
Alternatively, the script can listen for the message using
\f[CR]addEventListener()\f[R]:
.IP
.EX
\f[I]// worker.js\f[R]

self.addEventListener(\[dq]message\[dq], (e) \f[B]=>\f[R] {
  result.textContent = e.data;
  console.log(\[dq]Message received from worker\[dq]);
});
.EE
.PP
Notice how in the main script, \f[CR]onmessage\f[R] has to be called on
\f[CR]myWorker\f[R], whereas inside the worker script you just need
\f[CR]onmessage\f[R] because the worker is effectively the global scope
(\f[CR]DedicatedWorkerGlobalScope\f[R]).
.PP
For a full example, see our \c
.UR https://github.com/mdn/dom-examples/tree/main/web-workers/simple-web-worker
Basic dedicated worker example
.UE \c
\ (\c
.UR https://mdn.github.io/dom-examples/web-workers/simple-web-worker/
run dedicated worker
.UE \c
).
.SH SEE ALSO
.IP \[bu] 2
\f[CR]DedicatedWorkerGlobalScope\f[R]
.IP \[bu] 2
\f[CR]WorkerGlobalScope\f[R]
.IP \[bu] 2
Related events: \f[CR]messageerror\f[R]
.IP \[bu] 2
\f[CR]Worker.postMessage()\f[R]
.IP \[bu] 2
Using channel messaging
