'\" t
.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Document.createNodeIterator" "JS" "July 4, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Document.createNodeIterator \- Document: createNodeIterator() method
.SH SYNOPSIS
The \f[B]\f[CB]Document.createNodeIterator()\f[B]\f[R] method returns a
new \f[CR]NodeIterator\f[R] object.
.SH SYNTAX
.IP
.EX
createNodeIterator(root)
createNodeIterator(root, whatToShow)
createNodeIterator(root, whatToShow, filter)
.EE
.SS Parameters
.TP
\f[B]root\f[R]
The root node at which to begin the \f[CR]NodeIterator\f[R]\[cq]s
traversal.
.TP
\f[B]whatToShow\f[R] \f[I](optional)\f[R]
An optional \f[CR]unsigned long\f[R] representing a bitmask created by
combining the constant properties of \c
.UR https://www.w3.org/TR/DOM-Level-2-Traversal-Range/traversal.html#Traversal-NodeFilter
\f[CR]NodeFilter\f[R]
.UE \c
\&.
It is a convenient way of filtering for certain types of node.
It defaults to \f[CR]0xFFFFFFFF\f[R] representing the
\f[CR]SHOW_ALL\f[R] constant.
.RS
.PP
.TS
tab(@);
lw(7.9n) lw(7.8n) lw(54.3n).
T{
Constant
T}@T{
Numerical value
T}@T{
Description
T}
_
T{
\f[CR]NodeFilter.SHOW_ALL\f[R]
T}@T{
\f[CR]4294967295\f[R] (that is the max value of
\f[CR]unsigned long\f[R])
T}@T{
Shows all nodes.
T}
T{
\f[CR]NodeFilter.SHOW_ATTRIBUTE\f[R] \f[I](deprecated)\f[R]
T}@T{
\f[CR]2\f[R]
T}@T{
Shows attribute \f[CR]Attr\f[R] nodes.
This is meaningful only when creating a \f[CR]TreeWalker\f[R] with an
\f[CR]Attr\f[R] node as its root.
In this case, it means that the attribute node will appear in the first
position of the iteration or traversal.
Since attributes are never children of other nodes, they do not appear
when traversing over the document tree.
T}
T{
\f[CR]NodeFilter.SHOW_CDATA_SECTION\f[R] \f[I](deprecated)\f[R]
T}@T{
\f[CR]8\f[R]
T}@T{
Shows \f[CR]CDATASection\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_COMMENT\f[R]
T}@T{
\f[CR]128\f[R]
T}@T{
Shows \f[CR]Comment\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_DOCUMENT\f[R]
T}@T{
\f[CR]256\f[R]
T}@T{
Shows \f[CR]Document\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_DOCUMENT_FRAGMENT\f[R]
T}@T{
\f[CR]1024\f[R]
T}@T{
Shows \f[CR]DocumentFragment\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_DOCUMENT_TYPE\f[R]
T}@T{
\f[CR]512\f[R]
T}@T{
Shows \f[CR]DocumentType\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_ELEMENT\f[R]
T}@T{
\f[CR]1\f[R]
T}@T{
Shows \f[CR]Element\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_ENTITY\f[R] \f[I](deprecated)\f[R]
T}@T{
\f[CR]32\f[R]
T}@T{
Legacy, no more usable.
T}
T{
\f[CR]NodeFilter.SHOW_ENTITY_REFERENCE\f[R] \f[I](deprecated)\f[R]
T}@T{
\f[CR]16\f[R]
T}@T{
Legacy, no more usable.
T}
T{
\f[CR]NodeFilter.SHOW_NOTATION\f[R] \f[I](deprecated)\f[R]
T}@T{
\f[CR]2048\f[R]
T}@T{
Legacy, no more usable.
T}
T{
\f[CR]NodeFilter.SHOW_PROCESSING_INSTRUCTION\f[R]
T}@T{
\f[CR]64\f[R]
T}@T{
Shows \f[CR]ProcessingInstruction\f[R] nodes.
T}
T{
\f[CR]NodeFilter.SHOW_TEXT\f[R]
T}@T{
\f[CR]4\f[R]
T}@T{
Shows \f[CR]Text\f[R] nodes.
T}
.TE
.RE
.TP
\f[B]filter\f[R] \f[I](optional)\f[R]
A callback function or an object with an \f[CR]acceptNode()\f[R] method.
The function or method will be called for each node in the subtree based
at root which is accepted as included by the whatToShow flag to
determine whether or not to include it in the list of iterable nodes.
The method should return one of \f[CR]NodeFilter.FILTER_ACCEPT\f[R],
\f[CR]NodeFilter.FILTER_REJECT\f[R], or
\f[CR]NodeFilter.FILTER_SKIP\f[R].
See the Example.
.RS
.PP
For \f[CR]createNodeIterator\f[R], the values
\f[CR]NodeFilter.FILTER_REJECT\f[R] and
\f[CR]NodeFilter.FILTER_SKIP\f[R] are equivalent.
This node will not be included in the list of iterable nodes, but its
children will continue to be iterated over.
.RE
.SS Return value
A new \f[CR]NodeIterator\f[R] object.
.SH EXAMPLES
.IP
.EX
\f[B]const\f[R] nodeIterator = document.createNodeIterator(
  document.body,
  NodeFilter.SHOW_ELEMENT,
  (node) \f[B]=>\f[R]
    node.nodeName.toLowerCase() === \[dq]p\[dq]
      ? NodeFilter.FILTER_ACCEPT
      : NodeFilter.FILTER_REJECT,
);
\f[B]const\f[R] pars = [];
\f[B]let\f[R] currentNode;

\f[B]while\f[R] ((currentNode = nodeIterator.nextNode())) {
  pars.push(currentNode);
}
.EE
.PP
The same, but using an object with an \f[CR]acceptNode()\f[R] method:
.IP
.EX
\f[B]const\f[R] nodeIterator = document.createNodeIterator(
  document.body,
  NodeFilter.SHOW_ELEMENT,
  {
    acceptNode(node) {
      \f[B]return\f[R] node.nodeName.toLowerCase() === \[dq]p\[dq]
        ? NodeFilter.FILTER_ACCEPT
        : NodeFilter.FILTER_REJECT;
    },
  },
);
\f[B]const\f[R] pars = [];
\f[B]let\f[R] currentNode;

\f[B]while\f[R] ((currentNode = nodeIterator.nextNode())) {
  pars.push(currentNode);
}
.EE
