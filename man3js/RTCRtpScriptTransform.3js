.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "RTCRtpScriptTransform" "JS" "September 8, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCRtpScriptTransform \- RTCRtpScriptTransform
.SH SYNOPSIS
The \f[B]\f[CB]RTCRtpScriptTransform\f[B]\f[R] interface of the WebRTC
API is used to insert a WebRTC Encoded Transform (a
\f[CR]TransformStream\f[R] running in a worker thread) into the WebRTC
sender and receiver pipelines.
.SH CONSTRUCTOR
.TP
\f[B]RTCRtpScriptTransform()\f[R]
Creates a new instance of the \f[CR]RTCRtpScriptTransform\f[R] object.
.SH INSTANCE PROPERTIES
None.
.SH INSTANCE METHODS
None.
.SH DESCRIPTION
\f[B]\f[CB]RTCRtpScriptTransform\f[B]\f[R] instances are constructed
with a \f[CR]Worker\f[R], in which the transform stream code will run,
along with an (optional) \f[CR]options\f[R] object and array of
transferrable object that will be passed to the worker.
They are then added into incoming and outgoing RTC pipelines by
assigning them to \f[CR]RTCRtpReceiver.transform\f[R] and
\f[CR]RTCRtpSender.transform\f[R], respectively.
.PP
On construction of this object, and whenever an encoded frame arrives,
the \f[CR]rtctransform\f[R] event is fired on the worker global object.
The event\[cq]s \f[CR]transformer\f[R] property is a
\f[CR]RTCRtpScriptTransformer\f[R], the worker\-side counterpart to the
main\-thread \f[CR]RTCRtpScriptTransform\f[R].
This has \f[CR]readable\f[R] (\f[CR]ReadableStream\f[R]) and
\f[CR]writable\f[R] (\f[CR]WritableStream\f[R]) properties that have
been shared from the main thread \f[CR]RTCRtpScriptTransform\f[R] \[em]
where they are not public.
If the corresponding \f[CR]RTCRtpScriptTransform\f[R] is used with an
\f[CR]RTCRtpReceiver\f[R], then the \f[CR]readable\f[R] queues incoming
encoded audio or video frames from the packetizer.
If it is used with \f[CR]RTCRtpSender\f[R] then \f[CR]readable\f[R]
contains frames coming from a codec.
.PP
The worker thread \f[CR]rtctransform\f[R] event handler defines a pipe
chain.
This pipes encoded frames from \f[CR]event.transformer.readable\f[R],
through a \f[CR]TransformStream\f[R] which defines the transformation
function, through to \f[CR]event.transformer.writable\f[R].
The \f[CR]event.transformer\f[R] also has the \f[CR]options\f[R] object
passed from the \f[CR]RTCRtpScriptTransform\f[R] constructor (if
defined) that can be used to determine the source of the event, and
hence the specific \f[CR]TransformStream\f[R] to add to the chain.
.SH EXAMPLES
Note that these examples show how \f[CR]RTCRtpScriptTransform\f[R] is
defined and used.
Worker thread transform code is covered as part of the more complete
example in Using WebRTC Encoded Transforms.
.SS Adding a transform for outgoing frames
This example shows how you might stream video from a user\[cq]s webcam
over WebRTC, adding a WebRTC encoded transform to modify the outgoing
streams.
The code assumes that there is an \f[CR]RTCPeerConnection\f[R] called
\f[CR]peerConnection\f[R] that is already connected to a remote peer.
.PP
First we gets a \f[CR]MediaStreamTrack\f[R], using
\f[CR]getUserMedia()\f[R] to get a video \f[CR]MediaStream\f[R] from a
media device, and then the \f[CR]MediaStream.getTracks()\f[R] method to
get the first \f[CR]MediaStreamTrack\f[R] in the stream.
.PP
The track is added to the peer connection using \f[CR]addTrack()\f[R]
and sent.
The \f[CR]addTrack()\f[R] method returns the \f[CR]RTCRtpSender\f[R]
that is being used to send the track.
.IP
.EX
\f[I]// Get Video stream and MediaTrack\f[R]
\f[B]const\f[R] stream = \f[B]await\f[R] navigator.mediaDevices.getUserMedia({ video: \f[B]true\f[R] });
\f[B]const\f[R] [track] = stream.getTracks();
\f[B]const\f[R] videoSender = peerConnection.addTrack(track, stream);
.EE
.PP
An \f[CR]RTCRtpScriptTransform\f[R] is then constructed taking a worker
script, which defines the transform, and an optional object that can be
used to pass arbitrary messages to the worker (in this case we\[cq]ve
used a \f[CR]name\f[R] property with value \[lq]senderTransform\[rq] to
tell the worker that this transform will be added to the outbound
stream).
We then add the transform to the sender by assigning it to the
\f[CR]RTCRtpSender.transform\f[R] property.
.IP
.EX
\f[I]// Create a worker containing a TransformStream\f[R]
\f[B]const\f[R] worker = \f[B]new\f[R] Worker(\[dq]worker.js\[dq]);
videoSender.transform = \f[B]new\f[R] RTCRtpScriptTransform(worker, {
  name: \[dq]senderTransform\[dq],
});
.EE
.PP
Note that you can add the transform at any time.
However by adding it immediately after calling \f[CR]addTrack()\f[R] the
transform will get the first encoded frame that is sent.
.SS Adding a transform for incoming frames
This example shows how you add a WebRTC encoded transform to modify an
incoming stream.
The code assumes that there is an \f[CR]RTCPeerConnection\f[R] called
\f[CR]peerConnection\f[R] that is already connected to a remote peer.
.PP
First we add an \f[CR]RTCPeerConnection\f[R] \f[CR]track\f[R] event
handler to catch the event when a new track is streamed.
Within the handler we construct an \f[CR]RTCRtpScriptTransform\f[R] and
add it to \f[CR]event.receiver.transform\f[R] (\f[CR]event.receiver\f[R]
is a \f[CR]RTCRtpReceiver\f[R]).
As in the previous example, the constructor takes an object with
\f[CR]name\f[R] property: but here we use \f[CR]receiverTransform\f[R]
as the value to tell the worker that frames are incoming from the
packetizer.
.IP
.EX
peerConnection.ontrack = (event) \f[B]=>\f[R] {
  \f[B]const\f[R] worker = \f[B]new\f[R] Worker(\[dq]worker.js\[dq]);
  event.receiver.transform = \f[B]new\f[R] RTCRtpScriptTransform(worker, {
    name: \[dq]receiverTransform\[dq],
  });
  received_video.srcObject = event.streams[0];
};
.EE
.PP
Note again that you can add the transform stream at any time.
However by adding it in the \f[CR]track\f[R] event handler ensures that
the transform stream will get the first encoded frame for the track.
.SH SEE ALSO
.IP \[bu] 2
Using WebRTC Encoded Transforms
.IP \[bu] 2
\f[CR]TransformStream\f[R]
.IP \[bu] 2
\f[CR]RTCRtpScriptTransformer\f[R]
