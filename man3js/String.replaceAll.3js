.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "String.replaceAll" "JS" "May 11, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.replaceAll - String.prototype.replaceAll()
.SH SYNOPSIS
The \f[B]\f[CB]replaceAll()\f[B]\f[R] method returns a new string with
all matches of a \f[CR]pattern\f[R] replaced by a
\f[CR]replacement\f[R].
The \f[CR]pattern\f[R] can be a string or a \f[CR]RegExp\f[R], and the
\f[CR]replacement\f[R] can be a string or a function to be called for
each match.
The original string is left unchanged.
.SH SYNTAX
.IP
.EX
replaceAll(pattern, replacement)
.EE
.SS Parameters
.TP
\f[B]pattern\f[R]
Can be a string or an object with a \f[CR]Symbol.replace\f[R] method
\[em] the typical example being a regular expression.
Any value that doesn\[cq]t have the \f[CR]Symbol.replace\f[R] method
will be coerced to a string.
.RS
.PP
If \f[CR]pattern\f[R] is a regex, then it must have the global
(\f[CR]g\f[R]) flag set, or a \f[CR]TypeError\f[R] is thrown.
.RE
.TP
\f[B]replacement\f[R]
Can be a string or a function.
The replacement has the same semantics as that of
\f[CR]String.prototype.replace()\f[R].
.SS Return value
A new string, with all matches of a pattern replaced by a replacement.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if the \f[CR]pattern\f[R] is a regex that does not have the
global (\f[CR]g\f[R]) flag set (its \f[CR]flags\f[R] property does not
contain \f[CR]\[dq]g\[dq]\f[R]).
.SH DESCRIPTION
This method does not mutate the string value it\[cq]s called on.
It returns a new string.
.PP
Unlike \f[CR]replace()\f[R], this method would replace all occurrences
of a string, not just the first one.
This is especially useful if the string is not statically known, as
calling the \f[CR]RegExp()\f[R] constructor without escaping special
characters may unintentionally change its semantics.
.IP
.EX
function unsafeRedactName(text, name) {
  return text.replace(new RegExp(name, \[dq]g\[dq]), \[dq][REDACTED]\[dq]);
}
function safeRedactName(text, name) {
  return text.replaceAll(name, \[dq][REDACTED]\[dq]);
}

const report =
  \[dq]A hacker called ha.*er used special characters in their name to breach the system.\[dq];

console.log(unsafeRedactName(report, \[dq]ha.*er\[dq])); // \[dq]A [REDACTED]s in their name to breach the system.\[dq]
console.log(safeRedactName(report, \[dq]ha.*er\[dq])); // \[dq]A hacker called [REDACTED] used special characters in their name to breach the system.\[dq]
.EE
.PP
If \f[CR]pattern\f[R] is an object with a \f[CR]Symbol.replace\f[R]
method (including \f[CR]RegExp\f[R] objects), that method is called with
the target string and \f[CR]replacement\f[R] as arguments.
Its return value becomes the return value of \f[CR]replaceAll()\f[R].
In this case the behavior of \f[CR]replaceAll()\f[R] is entirely encoded
by the \f[CR]\[at]\[at]replace\f[R] method, and therefore will have the
same result as \f[CR]replace()\f[R] (apart from the extra input
validation that the regex is global).
.PP
If the \f[CR]pattern\f[R] is an empty string, the replacement will be
inserted in between every UTF-16 code unit, similar to
\f[CR]split()\f[R] behavior.
.IP
.EX
\[dq]xxx\[dq].replaceAll(\[dq]\[dq], \[dq]_\[dq]); // \[dq]_x_x_x_\[dq]
.EE
.PP
For more information about how regex properties (especially the sticky
flag) interact with \f[CR]replaceAll()\f[R], see
\f[CR]RegExp.prototype[\[at]\[at]replace]()\f[R].
.SH EXAMPLES
.SS Using replaceAll()
.IP
.EX
\[dq]aabbcc\[dq].replaceAll(\[dq]b\[dq], \[dq].\[dq]);
// \[aq]aa..cc\[aq]
.EE
.SS Non-global regex throws
When using a regular expression search value, it must be global.
This won\[cq]t work:
.PP
\f[B]Bad\f[R]
.IP
.EX
\[dq]aabbcc\[dq].replaceAll(/b/, \[dq].\[dq]);
// TypeError: replaceAll must be called with a global RegExp
.EE
.PP
This will work:
.PP
\f[B]Good\f[R]
.IP
.EX
\[dq]aabbcc\[dq].replaceAll(/b/g, \[dq].\[dq]);
(\[dq]aa..cc\[dq]);
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]String.prototype.replaceAll\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
\f[CR]String.prototype.replace()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.match()\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.exec()\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.test()\f[R]
