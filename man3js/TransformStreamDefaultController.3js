.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "TransformStreamDefaultController" "JS" "April 22, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
TransformStreamDefaultController \- TransformStreamDefaultController
.SH SYNOPSIS
This feature is available in Web Workers.
.PP
The \f[B]\f[CB]TransformStreamDefaultController\f[B]\f[R] interface of
the Streams API provides methods to manipulate the associated
\f[CR]ReadableStream\f[R] and \f[CR]WritableStream\f[R].
.PP
When constructing a \f[CR]TransformStream\f[R], the
\f[CR]TransformStreamDefaultController\f[R] is created.
It therefore has no constructor.
The way to get an instance of
\f[CR]TransformStreamDefaultController\f[R] is via the callback methods
of \f[CR]TransformStream()\f[R].
.SH INSTANCE PROPERTIES
.TP
\f[B]TransformStreamDefaultController.desiredSize\f[R] \f[I](read\-only)\f[R]
Returns the desired size to fill the readable side of the stream\[cq]s
internal queue.
.SH INSTANCE METHODS
.TP
\f[B]TransformStreamDefaultController.enqueue()\f[R]
Enqueues a chunk (single piece of data) in the readable side of the
stream.
.TP
\f[B]TransformStreamDefaultController.error()\f[R]
Errors both the readable and writable side of the transform stream.
.TP
\f[B]TransformStreamDefaultController.terminate()\f[R]
Closes the readable side and errors the writable side of the stream.
.SH EXAMPLES
In the following example, a transform stream passes through all chunks
it receives as \f[CR]Uint8Array\f[R] values, using the
\f[CR]error()\f[R] and \f[CR]enqueue()\f[R] methods.
.IP
.EX
\f[B]const\f[R] transformContent = {
  start() {}, \f[I]// required.\f[R]
  \f[B]async\f[R] transform(chunk, controller) {
    chunk = \f[B]await\f[R] chunk;
    \f[B]switch\f[R] (\f[B]typeof\f[R] chunk) {
      \f[B]case\f[R] \[dq]object\[dq]:
        \f[I]// just say the stream is done I guess\f[R]
        \f[B]if\f[R] (chunk === \f[B]null\f[R]) {
          controller.terminate();
        } \f[B]else\f[R] \f[B]if\f[R] (ArrayBuffer.isView(chunk)) {
          controller.enqueue(
            \f[B]new\f[R] Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength),
          );
        } \f[B]else\f[R] \f[B]if\f[R] (
          Array.isArray(chunk) &&
          chunk.every((value) \f[B]=>\f[R] \f[B]typeof\f[R] value === \[dq]number\[dq])
        ) {
          controller.enqueue(\f[B]new\f[R] Uint8Array(chunk));
        } \f[B]else\f[R] \f[B]if\f[R] (
          \f[B]typeof\f[R] chunk.valueOf === \[dq]function\[dq] &&
          chunk.valueOf() !== chunk
        ) {
          \f[B]this\f[R].transform(chunk.valueOf(), controller); \f[I]// hack\f[R]
        } \f[B]else\f[R] \f[B]if\f[R] (\[dq]toJSON\[dq] \f[B]in\f[R] chunk) {
          \f[B]this\f[R].transform(JSON.stringify(chunk), controller);
        }
        \f[B]break\f[R];
      \f[B]case\f[R] \[dq]symbol\[dq]:
        controller.error(\[dq]Cannot send a symbol as a chunk part\[dq]);
        \f[B]break\f[R];
      \f[B]case\f[R] \[dq]undefined\[dq]:
        controller.error(\[dq]Cannot send undefined as a chunk part\[dq]);
        \f[B]break\f[R];
      \f[B]default\f[R]:
        controller.enqueue(\f[B]this\f[R].textencoder.encode(String(chunk)));
        \f[B]break\f[R];
    }
  },
  flush() {
    \f[I]/* do any destructor work here */\f[R]
  },
};

\f[B]class\f[R] AnyToU8Stream \f[B]extends\f[R] TransformStream {
  constructor() {
    \f[B]super\f[R]({ ...transformContent, textencoder: \f[B]new\f[R] TextEncoder() });
  }
}
.EE
