.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "OBJECT.HASOWNPROPERTY" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.hasOwnProperty \- Object.prototype.hasOwnProperty()
.SH SYNOPSIS
The \f[B]\f[CB]hasOwnProperty()\f[B]\f[R] method of \f[CR]Object\f[R]
instances returns a boolean indicating whether this object has the
specified property as its own property (as opposed to inheriting it).
.RS
.PP
\f[B]Note:\f[R] \f[CR]Object.hasOwn()\f[R] is recommended over
\f[CR]hasOwnProperty()\f[R], in browsers where it is supported.
.RE
.IP
.EX
\f[B]const\f[R] object1 = {};
object1.property1 = 42;

console.log(object1.hasOwnProperty(\(dqproperty1\(dq));
\f[I]// Expected output: true\f[R]

console.log(object1.hasOwnProperty(\(dqtoString\(dq));
\f[I]// Expected output: false\f[R]

console.log(object1.hasOwnProperty(\(dqhasOwnProperty\(dq));
\f[I]// Expected output: false\f[R]
.EE
.SH SYNTAX
.IP
.EX
hasOwnProperty(prop)
.EE
.SS Parameters
.TP
\f[B]prop\f[R]
The \f[CR]String\f[R] name or Symbol of the property to test.
.SS Return value
Returns \f[CR]true\f[R] if the object has the specified property as own
property; \f[CR]false\f[R] otherwise.
.SH DESCRIPTION
The \f[B]\f[CB]hasOwnProperty()\f[B]\f[R] method returns \f[CR]true\f[R]
if the specified property is a direct property of the object \(em even
if the value is \f[CR]null\f[R] or \f[CR]undefined\f[R].
The method returns \f[CR]false\f[R] if the property is inherited, or has
not been declared at all.
Unlike the \f[CR]in\f[R] operator, this method does not check for the
specified property in the object\(cqs prototype chain.
.PP
The method can be called on \f[I]most\f[R] JavaScript objects, because
most objects descend from \f[CR]Object\f[R], and hence inherit its
methods.
For example \f[CR]Array\f[R] is an \f[CR]Object\f[R], so you can use
\f[CR]hasOwnProperty()\f[R] method to check whether an index exists:
.IP
.EX
\f[B]const\f[R] fruits = [\(dqApple\(dq, \(dqBanana\(dq, \(dqWatermelon\(dq, \(dqOrange\(dq];
fruits.hasOwnProperty(3); \f[I]// true (\(aqOrange\(aq)\f[R]
fruits.hasOwnProperty(4); \f[I]// false \- not defined\f[R]
.EE
.PP
The method will not be available in objects where it is reimplemented,
or on \f[CR]null\f[R]\-prototype objects (as these don\(cqt inherit from
\f[CR]Object.prototype\f[R]).
Examples for these cases are given below.
.SH EXAMPLES
.SS Using hasOwnProperty to test for an own property\(cqs existence
The following code shows how to determine whether the \f[CR]example\f[R]
object contains a property named \f[CR]prop\f[R].
.IP
.EX
\f[B]const\f[R] example = {};
example.hasOwnProperty(\(dqprop\(dq); \f[I]// false\f[R]

example.prop = \(dqexists\(dq;
example.hasOwnProperty(\(dqprop\(dq); \f[I]// true \- \(aqprop\(aq has been defined\f[R]

example.prop = \f[B]null\f[R];
example.hasOwnProperty(\(dqprop\(dq); \f[I]// true \- own property exists with value of null\f[R]

example.prop = \f[B]undefined\f[R];
example.hasOwnProperty(\(dqprop\(dq); \f[I]// true \- own property exists with value of undefined\f[R]
.EE
.SS Direct vs.\ inherited properties
The following example differentiates between direct properties and
properties inherited through the prototype chain:
.IP
.EX
\f[B]const\f[R] example = {};
example.prop = \(dqexists\(dq;

\f[I]// \(gahasOwnProperty\(ga will only return true for direct properties:\f[R]
example.hasOwnProperty(\(dqprop\(dq); \f[I]// true\f[R]
example.hasOwnProperty(\(dqtoString\(dq); \f[I]// false\f[R]
example.hasOwnProperty(\(dqhasOwnProperty\(dq); \f[I]// false\f[R]

\f[I]// The \(gain\(ga operator will return true for direct or inherited properties:\f[R]
\(dqprop\(dq \f[B]in\f[R] example; \f[I]// true\f[R]
\(dqtoString\(dq \f[B]in\f[R] example; \f[I]// true\f[R]
\(dqhasOwnProperty\(dq \f[B]in\f[R] example; \f[I]// true\f[R]
.EE
.SS Iterating over the properties of an object
The following example shows how to iterate over the enumerable
properties of an object without executing on inherited properties.
.IP
.EX
\f[B]const\f[R] buz = {
  fog: \(dqstack\(dq,
};

\f[B]for\f[R] (\f[B]const\f[R] name \f[B]in\f[R] buz) {
  \f[B]if\f[R] (buz.hasOwnProperty(name)) {
    console.log(\(gathis is fog (${name}) for sure. Value: ${buz[name]}\(ga);
  } \f[B]else\f[R] {
    console.log(name); \f[I]// toString or something else\f[R]
  }
}
.EE
.PP
Note that the \f[CR]for...in\f[R] loop only iterates enumerable items:
the absence of non\-enumerable properties emitted from the loop does not
imply that \f[CR]hasOwnProperty\f[R] itself is confined strictly to
enumerable items.
You can iterate over non\-enumerable properties with
\f[CR]Object.getOwnPropertyNames()\f[R].
.SS Using hasOwnProperty as a property name
JavaScript does not protect the property name \f[CR]hasOwnProperty\f[R];
an object that has a property with this name may return incorrect
results:
.IP
.EX
\f[B]const\f[R] foo = {
  hasOwnProperty() {
    \f[B]return\f[R] \f[B]false\f[R];
  },
  bar: \(dqHere be dragons\(dq,
};

foo.hasOwnProperty(\(dqbar\(dq); \f[I]// re\-implementation always returns false\f[R]
.EE
.PP
The recommended way to overcome this problem is to instead use
\f[CR]Object.hasOwn()\f[R] (in browsers that support it).
Other alternatives include using an \f[I]external\f[R]
\f[CR]hasOwnProperty\f[R]:
.IP
.EX
\f[B]const\f[R] foo = { bar: \(dqHere be dragons\(dq };

\f[I]// Use Object.hasOwn() method \- recommended\f[R]
Object.hasOwn(foo, \(dqbar\(dq); \f[I]// true\f[R]

\f[I]// Use the hasOwnProperty property from the Object prototype\f[R]
Object.prototype.hasOwnProperty.call(foo, \(dqbar\(dq); \f[I]// true\f[R]

\f[I]// Use another Object\(aqs hasOwnProperty\f[R]
\f[I]// and call it with \(aqthis\(aq set to foo\f[R]
({}).hasOwnProperty.call(foo, \(dqbar\(dq); \f[I]// true\f[R]
.EE
.PP
Note that in the first two cases there are no newly created objects.
.SS Objects created with Object.create(null)
\f[CR]null\f[R]\-prototype objects do not inherit from
\f[CR]Object.prototype\f[R], making \f[CR]hasOwnProperty()\f[R]
inaccessible.
.IP
.EX
\f[B]const\f[R] foo = Object.create(\f[B]null\f[R]);
foo.prop = \(dqexists\(dq;
foo.hasOwnProperty(\(dqprop\(dq); \f[I]// Uncaught TypeError: foo.hasOwnProperty is not a function\f[R]
.EE
.PP
The solutions in this case are the same as for the previous section: use
\f[CR]Object.hasOwn()\f[R] by preference, otherwise use an external
object\(cqs \f[CR]hasOwnProperty()\f[R].
.SH SEE ALSO
.IP \(bu 2
\f[CR]Object.hasOwn()\f[R]
.IP \(bu 2
Enumerability and ownership of properties
.IP \(bu 2
\f[CR]Object.getOwnPropertyNames()\f[R]
.IP \(bu 2
\f[CR]for...in\f[R]
.IP \(bu 2
\f[CR]in\f[R]
.IP \(bu 2
Inheritance and the prototype chain
