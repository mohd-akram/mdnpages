.\" Automatically generated by Pandoc 3.4
.\"
.TH "Object.hasOwnProperty" "JS" "January 16, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.hasOwnProperty \- Object.prototype.hasOwnProperty()
.SH SYNOPSIS
The \f[B]\f[CB]hasOwnProperty()\f[B]\f[R] method of \f[CR]Object\f[R]
instances returns a boolean indicating whether this object has the
specified property as its own property (as opposed to inheriting it).
.RS
.PP
\f[B]Note:\f[R] \f[CR]Object.hasOwn()\f[R] is recommended over
\f[CR]hasOwnProperty()\f[R], in browsers where it is supported.
.RE
.SH SYNTAX
.IP
.EX
hasOwnProperty(prop)
.EE
.SS Parameters
.TP
\f[B]prop\f[R]
The \f[CR]String\f[R] name or Symbol of the property to test.
.SS Return value
Returns \f[CR]true\f[R] if the object has the specified property as own
property; \f[CR]false\f[R] otherwise.
.SH DESCRIPTION
The \f[B]\f[CB]hasOwnProperty()\f[B]\f[R] method returns \f[CR]true\f[R]
if the specified property is a direct property of the object \[em] even
if the value is \f[CR]null\f[R] or \f[CR]undefined\f[R].
The method returns \f[CR]false\f[R] if the property is inherited, or has
not been declared at all.
Unlike the \f[CR]in\f[R] operator, this method does not check for the
specified property in the object\[cq]s prototype chain.
.PP
The method can be called on \f[I]most\f[R] JavaScript objects, because
most objects descend from \f[CR]Object\f[R], and hence inherit its
methods.
For example \f[CR]Array\f[R] is an \f[CR]Object\f[R], so you can use
\f[CR]hasOwnProperty()\f[R] method to check whether an index exists:
.IP
.EX
\f[B]const\f[R] fruits = [\[dq]Apple\[dq], \[dq]Banana\[dq], \[dq]Watermelon\[dq], \[dq]Orange\[dq]];
fruits.hasOwnProperty(3); \f[I]// true (\[aq]Orange\[aq])\f[R]
fruits.hasOwnProperty(4); \f[I]// false \- not defined\f[R]
.EE
.PP
The method will not be available in objects where it is reimplemented,
or on \f[CR]null\f[R]\-prototype objects (as these don\[cq]t inherit
from \f[CR]Object.prototype\f[R]).
Examples for these cases are given below.
.SH EXAMPLES
.SS Using hasOwnProperty to test for an own property\[cq]s existence
The following code shows how to determine whether the \f[CR]example\f[R]
object contains a property named \f[CR]prop\f[R].
.IP
.EX
\f[B]const\f[R] example = {};
example.hasOwnProperty(\[dq]prop\[dq]); \f[I]// false\f[R]

example.prop = \[dq]exists\[dq];
example.hasOwnProperty(\[dq]prop\[dq]); \f[I]// true \- \[aq]prop\[aq] has been defined\f[R]

example.prop = \f[B]null\f[R];
example.hasOwnProperty(\[dq]prop\[dq]); \f[I]// true \- own property exists with value of null\f[R]

example.prop = \f[B]undefined\f[R];
example.hasOwnProperty(\[dq]prop\[dq]); \f[I]// true \- own property exists with value of undefined\f[R]
.EE
.SS Direct vs.\ inherited properties
The following example differentiates between direct properties and
properties inherited through the prototype chain:
.IP
.EX
\f[B]const\f[R] example = {};
example.prop = \[dq]exists\[dq];

\f[I]// \[ga]hasOwnProperty\[ga] will only return true for direct properties:\f[R]
example.hasOwnProperty(\[dq]prop\[dq]); \f[I]// true\f[R]
example.hasOwnProperty(\[dq]toString\[dq]); \f[I]// false\f[R]
example.hasOwnProperty(\[dq]hasOwnProperty\[dq]); \f[I]// false\f[R]

\f[I]// The \[ga]in\[ga] operator will return true for direct or inherited properties:\f[R]
\[dq]prop\[dq] \f[B]in\f[R] example; \f[I]// true\f[R]
\[dq]toString\[dq] \f[B]in\f[R] example; \f[I]// true\f[R]
\[dq]hasOwnProperty\[dq] \f[B]in\f[R] example; \f[I]// true\f[R]
.EE
.SS Iterating over the properties of an object
The following example shows how to iterate over the enumerable
properties of an object without executing on inherited properties.
.IP
.EX
\f[B]const\f[R] buz = {
  fog: \[dq]stack\[dq],
};

\f[B]for\f[R] (\f[B]const\f[R] name \f[B]in\f[R] buz) {
  \f[B]if\f[R] (buz.hasOwnProperty(name)) {
    console.log(\[ga]this is fog (${name}) for sure. Value: ${buz[name]}\[ga]);
  } \f[B]else\f[R] {
    console.log(name); \f[I]// toString or something else\f[R]
  }
}
.EE
.PP
Note that the \f[CR]for...in\f[R] loop only iterates enumerable items:
the absence of non\-enumerable properties emitted from the loop does not
imply that \f[CR]hasOwnProperty\f[R] itself is confined strictly to
enumerable items.
You can iterate over non\-enumerable properties with
\f[CR]Object.getOwnPropertyNames()\f[R].
.SS Using hasOwnProperty as a property name
JavaScript does not protect the property name \f[CR]hasOwnProperty\f[R];
an object that has a property with this name may return incorrect
results:
.IP
.EX
\f[B]const\f[R] foo = {
  hasOwnProperty() {
    \f[B]return\f[R] \f[B]false\f[R];
  },
  bar: \[dq]Here be dragons\[dq],
};

foo.hasOwnProperty(\[dq]bar\[dq]); \f[I]// re\-implementation always returns false\f[R]
.EE
.PP
The recommended way to overcome this problem is to instead use
\f[CR]Object.hasOwn()\f[R] (in browsers that support it).
Other alternatives include using an \f[I]external\f[R]
\f[CR]hasOwnProperty\f[R]:
.IP
.EX
\f[B]const\f[R] foo = { bar: \[dq]Here be dragons\[dq] };

\f[I]// Use Object.hasOwn() method \- recommended\f[R]
Object.hasOwn(foo, \[dq]bar\[dq]); \f[I]// true\f[R]

\f[I]// Use the hasOwnProperty property from the Object prototype\f[R]
Object.prototype.hasOwnProperty.call(foo, \[dq]bar\[dq]); \f[I]// true\f[R]

\f[I]// Use another Object\[aq]s hasOwnProperty\f[R]
\f[I]// and call it with \[aq]this\[aq] set to foo\f[R]
({}).hasOwnProperty.call(foo, \[dq]bar\[dq]); \f[I]// true\f[R]
.EE
.PP
Note that in the first two cases there are no newly created objects.
.SS Objects created with Object.create(null)
\f[CR]null\f[R]\-prototype objects do not inherit from
\f[CR]Object.prototype\f[R], making \f[CR]hasOwnProperty()\f[R]
inaccessible.
.IP
.EX
\f[B]const\f[R] foo = Object.create(\f[B]null\f[R]);
foo.prop = \[dq]exists\[dq];
foo.hasOwnProperty(\[dq]prop\[dq]); \f[I]// Uncaught TypeError: foo.hasOwnProperty is not a function\f[R]
.EE
.PP
The solutions in this case are the same as for the previous section: use
\f[CR]Object.hasOwn()\f[R] by preference, otherwise use an external
object\[cq]s \f[CR]hasOwnProperty()\f[R].
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Object.hasOwn()\f[R]
.IP \[bu] 2
Enumerability and ownership of properties
.IP \[bu] 2
\f[CR]Object.getOwnPropertyNames()\f[R]
.IP \[bu] 2
\f[CR]for...in\f[R]
.IP \[bu] 2
\f[CR]in\f[R]
.IP \[bu] 2
Inheritance and the prototype chain
