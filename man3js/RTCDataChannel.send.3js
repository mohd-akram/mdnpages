.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "RTCDATACHANNEL.SEND" "3JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCDataChannel.send \- RTCDataChannel: send() method
.SH SYNOPSIS
The \f[B]\f[CB]send()\f[B]\f[R] method of the \f[CR]RTCDataChannel\f[R]
interface sends data across the data channel to the remote peer.
This can be done any time except during the initial process of creating
the underlying transport channel.
Data sent before connecting is buffered if possible (or an error occurs
if it\(cqs not possible), and is also buffered if sent while the
connection is closing or closed.
.RS
.PP
\f[B]Note:\f[R] Different browsers have different limitations on the
size of the message you can send.
Specifications exist to define how to automatically fragment large
messages, but not all browsers implement them, and those that do have
various additional restrictions.
This will get less complicated over time, but for now, if you have
questions, see Understanding message size limits.
.RE
.SH SYNTAX
.IP
.EX
send(data)
.EE
.SS Parameters
.TP
\f[B]data\f[R]
The data to transmit across the connection.
This may be a string, a \f[CR]Blob\f[R], an \f[CR]ArrayBuffer\f[R], a
\f[CR]TypedArray\f[R] or a \f[CR]DataView\f[R] object.
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.TP
\f[B]InvalidStateError\f[R] \f[B]DOMException\f[R]
Thrown when the data channel has not finished establishing its own
connection (that is, its \f[CR]readyState\f[R] is
\f[CR]connecting\f[R]).
The data channel must establish its own connection because it uses a
transport channel separate from that of the media content.
This error occurs without sending or buffering the \f[CR]data\f[R].
.TP
\f[B]NetworkError\f[R] \f[B]DOMException\f[R]
Thrown when the specified \f[CR]data\f[R] would need to be buffered, and
there isn\(cqt room for it in the buffer.
In this scenario, the underlying transport is immediately closed.
.TP
\f[B]TypeError\f[R]
Thrown if the specified \f[CR]data\f[R] is too large for the other peer
to receive.
Since there are multiple techniques for breaking up large data into
smaller pieces for transfer, it\(cqs possible to encounter scenarios in
which the other peer does not support the same ones.
For example, if one peer is a modern browser that supports using the
\f[CR]EOR\f[R] (End of Record) flag to indicate when a received message
is the last piece of a multi\-part object sent using \f[CR]send()\f[R].
For more information about message size restrictions, see Understanding
message size limits.
.SH EXAMPLES
In this example, a routine called \f[CR]sendMessage()\f[R] is created;
it accepts an object as input and sends to the remote peer, over the
\f[CR]RTCDataChannel\f[R], a JSON string with the specified object and a
timestamp.
.IP
.EX
\f[B]const\f[R] pc = \f[B]new\f[R] RTCPeerConnection();
\f[B]const\f[R] dc = pc.createDataChannel(\(dqBackChannel\(dq);

\f[B]function\f[R] sendMessage(msg) {
  \f[B]const\f[R] obj = {
    message: msg,
    timestamp: \f[B]new\f[R] Date(),
  };
  dc.send(JSON.stringify(obj));
}
.EE
.SH SEE ALSO
.IP \(bu 2
WebRTC
.IP \(bu 2
\f[CR]RTCDataChannel\f[R]
.IP \(bu 2
\f[CR]RTCDataChannel.readyState\f[R]
.IP \(bu 2
\f[CR]close\f[R] event
