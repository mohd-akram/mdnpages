.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "TextEncoder.encodeInto" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
TextEncoder.encodeInto \- TextEncoder: encodeInto() method
.SH SYNOPSIS
The \f[B]\f[CB]TextEncoder.encodeInto()\f[B]\f[R] method takes a string
to encode and a destination \f[CR]Uint8Array\f[R] to put resulting
UTF\-8 encoded text into, and returns a dictionary object indicating the
progress of the encoding.
This is potentially more performant than the older \f[CR]encode()\f[R]
method \[em] especially when the target buffer is a view into a Wasm
heap.
.SH SYNTAX
.IP
.EX
encodeInto(string, uint8Array)
.EE
.SS Parameters
.TP
\f[B]string\f[R]
A string containing the text to encode.
.TP
\f[B]uint8Array\f[R]
A \f[CR]Uint8Array\f[R] object instance to place the resulting UTF\-8
encoded text into.
.SS Return value
An object, which contains two members:
.TP
\f[B]read\f[R]
The number of UTF\-16 units of code from the source that has been
converted over to UTF\-8.
This may be less than \f[CR]string.length\f[R] if \f[CR]uint8Array\f[R]
did not have enough space.
.TP
\f[B]written\f[R]
The number of bytes modified in the destination \f[CR]Uint8Array\f[R].
The bytes written are guaranteed to form complete UTF\-8 byte sequences.
.SH ENCODE INTO A SPECIFIC POSITION
\f[I]encoder\f[R]\f[CR].encodeInto()\f[R] always puts its output at the
start of the array.
However, it is sometimes useful to make the output start at a particular
index.
The solution is \f[CR]TypedArray.prototype.subarray()\f[R]:
.IP
.EX
\f[B]const\f[R] encoder = \f[B]new\f[R] TextEncoder();

\f[B]function\f[R] encodeIntoAtPosition(string, u8array, position) {
  \f[B]return\f[R] encoder.encodeInto(
    string,
    position ? u8array.subarray(position | 0) : u8array,
  );
}

\f[B]const\f[R] u8array = \f[B]new\f[R] Uint8Array(8);
encodeIntoAtPosition(\[dq]hello\[dq], u8array, 2);
console.log(u8array.join()); \f[I]// 0,0,104,101,108,108,111,0\f[R]
.EE
.SH BUFFER SIZING
To convert a JavaScript string \f[CR]s\f[R], the output space needed for
full conversion is never less than \f[CR]s.length\f[R] bytes and never
greater than \f[CR]s.length * 3\f[R] bytes.
If the output allocation (typically within Wasm heap) is expected to be
short\-lived, it makes sense to allocate \f[CR]s.length * 3\f[R] bytes
for the output, in which case the first conversion attempt is guaranteed
to convert the whole string.
Note that the \f[CR]s.length * 3\f[R] is rare because the string would
have to be packed with some of the few characters that expand into 3
bytes.
It is unlikely that long text will exceed \f[CR]s.length * 2\f[R] bytes
in length.
Thus, a more optimistic approach might be to allocate
\f[CR]s.length * 2 + 5\f[R] bytes, and perform reallocation in the rare
circumstance that the optimistic prediction was wrong.
.PP
If the output is expected to be long\-lived, it makes sense to compute
minimum allocation \f[CR]roundUpToBucketSize(s.length)\f[R], the maximum
allocation size \f[CR]s.length * 3\f[R], and to have a chosen (as a
tradeoff between memory usage and speed) threshold \f[CR]t\f[R] such
that if \f[CR]roundUpToBucketSize(s.length) + t >= s.length * 3\f[R],
you allocate for \f[CR]s.length * 3\f[R].
Otherwise, first allocate for \f[CR]roundUpToBucketSize(s.length)\f[R]
and convert.
If the \f[CR]read\f[R] item it the return dictionary is
\f[CR]s.length\f[R], the conversion is done.
If not, reallocate the target buffer to
\f[CR]written + (s.length \- read) * 3\f[R] and then convert the rest by
taking a substring of \f[CR]s\f[R] starting from index \f[CR]read\f[R]
and a subbuffer of the target buffer starting from index
\f[CR]written\f[R].
.PP
Above \f[CR]roundUpToBucketSize()\f[R] is a function that rounds up to
the allocator bucket size.
For example, if your Wasm allocator is known to use power\-of\-two
buckets, \f[CR]roundUpToBucketSize()\f[R] should return the argument if
it is a power\-of\-two or the next power\-of\-two otherwise.
If the behavior of the Wasm allocator is unknown,
\f[CR]roundUpToBucketSize()\f[R] should be an identity function.
.PP
If the behavior of your allocator is unknown, you might want to have up
to two reallocation steps and make the first reallocation step multiply
the \f[I]remaining unconverted\f[R] length by two instead of three.
However, in that case, it makes sense not to implement the usual
multiplying by two of the \f[I]already written\f[R] buffer length,
because in such a case if a second reallocation happened, it would
always over\-allocate compared to the original length times three.
The above advice assumes that you don\[cq]t need to allocate space for a
zero terminator.
That is, on the Wasm side you are working with Rust strings or a
non\-zero\-terminating C++ class.
If you are working with C++ \f[CR]std::string\f[R], even though the
logical length is shown to you, you need to take the extra terminator
byte into account when computing rounding up to allocator bucket size.
See the next section about C strings.
.SH NO ZERO\-TERMINATION
If the input string contains the character U+0000 in the input,
\f[CR]encodeInto()\f[R] will write a 0x00 byte in the output.
\f[CR]encodeInto()\f[R] \f[I]does not\f[R] write a C\-style 0x00
sentinel byte after the logical output.
.PP
If your Wasm program uses C strings, it\[cq]s your responsibility to
write the \f[CR]0x00\f[R] sentinel and you can\[cq]t prevent your Wasm
program from seeing a logically truncated string if the JavaScript
string contained \f[CR]U+0000\f[R].
Observe:
.IP
.EX
\f[B]const\f[R] encoder = \f[B]new\f[R] TextEncoder();

\f[B]function\f[R] encodeIntoWithSentinel(string, u8array, position) {
  \f[B]const\f[R] stats = encoder.encodeInto(
    string,
    position ? u8array.subarray(position | 0) : u8array,
  );
  \f[B]if\f[R] (stats.written < u8array.length) u8array[stats.written] = 0; \f[I]// append null if room\f[R]
  \f[B]return\f[R] stats;
}
.EE
.SH EXAMPLES
.IP
.EX
<\f[B]p\f[R] class=\[dq]source\[dq]>This is a sample paragraph.</\f[B]p\f[R]>
<\f[B]p\f[R] class=\[dq]result\[dq]></\f[B]p\f[R]>
.EE
.IP
.EX
\f[B]const\f[R] sourcePara = document.querySelector(\[dq].source\[dq]);
\f[B]const\f[R] resultPara = document.querySelector(\[dq].result\[dq]);
\f[B]const\f[R] string = sourcePara.textContent;

\f[B]const\f[R] textEncoder = \f[B]new\f[R] TextEncoder();
\f[B]const\f[R] utf8 = \f[B]new\f[R] Uint8Array(string.length);

\f[B]const\f[R] encodedResults = textEncoder.encodeInto(string, utf8);
resultPara.textContent +=
  \[ga]Bytes read: ${encodedResults.read}\[ga] +
  \[ga] | Bytes written: ${encodedResults.written}\[ga] +
  \[ga] | Encoded result: ${utf8}\[ga];
.EE
.SH SEE ALSO
.IP \[bu] 2
The \f[CR]TextEncoder\f[R] interface it belongs to.
.IP \[bu] 2
\f[CR]TextEncoder.encode()\f[R]
