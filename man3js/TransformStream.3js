.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "TransformStream" "JS" "April 22, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
TransformStream \- TransformStream
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]TransformStream\f[B]\f[R] interface of the Streams API
represents a concrete implementation of the pipe chain \f[I]transform
stream\f[R] concept.
.PP
It may be passed to the \f[CR]ReadableStream.pipeThrough()\f[R] method
in order to transform a stream of data from one format into another.
For example, it might be used to decode (or encode) video frames,
decompress data, or convert the stream from XML to JSON.
.PP
A transformation algorithm may be provided as an optional argument to
the object constructor.
If not supplied, data is not modified when piped through the stream.
.PP
\f[CR]TransformStream\f[R] is a transferable object.
.SH CONSTRUCTOR
.TP
\f[B]TransformStream()\f[R]
Creates and returns a transform stream object, optionally specifying a
transformation object and queuing strategies for the streams.
.SH INSTANCE PROPERTIES
.TP
\f[B]TransformStream.readable\f[R] \f[I](read\-only)\f[R]
The \f[CR]readable\f[R] end of a \f[CR]TransformStream\f[R].
.TP
\f[B]TransformStream.writable\f[R] \f[I](read\-only)\f[R]
The \f[CR]writable\f[R] end of a \f[CR]TransformStream\f[R].
.SH INSTANCE METHODS
None
.SH EXAMPLES
.SS Anything\-to\-uint8array stream
In the following example, a transform stream passes through all chunks
it receives as \f[CR]Uint8Array\f[R] values.
.IP
.EX
\f[B]const\f[R] transformContent = {
  start() {}, \f[I]// required.\f[R]
  \f[B]async\f[R] transform(chunk, controller) {
    chunk = \f[B]await\f[R] chunk;
    \f[B]switch\f[R] (\f[B]typeof\f[R] chunk) {
      \f[B]case\f[R] \[dq]object\[dq]:
        \f[I]// just say the stream is done I guess\f[R]
        \f[B]if\f[R] (chunk === \f[B]null\f[R]) {
          controller.terminate();
        } \f[B]else\f[R] \f[B]if\f[R] (ArrayBuffer.isView(chunk)) {
          controller.enqueue(
            \f[B]new\f[R] Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength),
          );
        } \f[B]else\f[R] \f[B]if\f[R] (
          Array.isArray(chunk) &&
          chunk.every((value) \f[B]=>\f[R] \f[B]typeof\f[R] value === \[dq]number\[dq])
        ) {
          controller.enqueue(\f[B]new\f[R] Uint8Array(chunk));
        } \f[B]else\f[R] \f[B]if\f[R] (
          \f[B]typeof\f[R] chunk.valueOf === \[dq]function\[dq] &&
          chunk.valueOf() !== chunk
        ) {
          \f[B]this\f[R].transform(chunk.valueOf(), controller); \f[I]// hack\f[R]
        } \f[B]else\f[R] \f[B]if\f[R] (\[dq]toJSON\[dq] \f[B]in\f[R] chunk) {
          \f[B]this\f[R].transform(JSON.stringify(chunk), controller);
        }
        \f[B]break\f[R];
      \f[B]case\f[R] \[dq]symbol\[dq]:
        controller.error(\[dq]Cannot send a symbol as a chunk part\[dq]);
        \f[B]break\f[R];
      \f[B]case\f[R] \[dq]undefined\[dq]:
        controller.error(\[dq]Cannot send undefined as a chunk part\[dq]);
        \f[B]break\f[R];
      \f[B]default\f[R]:
        controller.enqueue(\f[B]this\f[R].textencoder.encode(String(chunk)));
        \f[B]break\f[R];
    }
  },
  flush() {
    \f[I]/* do any destructor work here */\f[R]
  },
};

\f[B]class\f[R] AnyToU8Stream \f[B]extends\f[R] TransformStream {
  constructor() {
    \f[B]super\f[R]({ ...transformContent, textencoder: \f[B]new\f[R] TextEncoder() });
  }
}
.EE
.SS Polyfilling TextEncoderStream and TextDecoderStream
Note that this is deprecated by the native constructors.
This is intended as a polyfill for unsupported platforms.
.IP
.EX
\f[B]const\f[R] tes = {
  start() {
    \f[B]this\f[R].encoder = \f[B]new\f[R] TextEncoder();
  },
  transform(chunk, controller) {
    controller.enqueue(\f[B]this\f[R].encoder.encode(chunk));
  },
};

\f[B]let\f[R] _jstes_wm = \f[B]new\f[R] WeakMap(); \f[I]/* info holder */\f[R]
\f[B]class\f[R] JSTextEncoderStream \f[B]extends\f[R] TransformStream {
  constructor() {
    \f[B]let\f[R] t = { ...tes };

    \f[B]super\f[R](t);
    _jstes_wm.set(\f[B]this\f[R], t);
  }
  \f[B]get\f[R] encoding() {
    \f[B]return\f[R] _jstes_wm.get(\f[B]this\f[R]).encoder.encoding;
  }
}
.EE
.PP
Similarly, \f[CR]TextDecoderStream\f[R] can be written as such:
.IP
.EX
\f[B]const\f[R] tds = {
  start() {
    \f[B]this\f[R].decoder = \f[B]new\f[R] TextDecoder(\f[B]this\f[R].encoding, \f[B]this\f[R].options);
  },
  transform(chunk, controller) {
    controller.enqueue(\f[B]this\f[R].decoder.decode(chunk, { stream: \f[B]true\f[R] }));
  },
};

\f[B]let\f[R] _jstds_wm = \f[B]new\f[R] WeakMap(); \f[I]/* info holder */\f[R]
\f[B]class\f[R] JSTextDecoderStream \f[B]extends\f[R] TransformStream {
  constructor(encoding = \[dq]utf\-8\[dq], { ...options } = {}) {
    \f[B]let\f[R] t = { ...tds, encoding, options };

    \f[B]super\f[R](t);
    _jstds_wm.set(\f[B]this\f[R], t);
  }
  \f[B]get\f[R] encoding() {
    \f[B]return\f[R] _jstds_wm.get(\f[B]this\f[R]).decoder.encoding;
  }
  \f[B]get\f[R] fatal() {
    \f[B]return\f[R] _jstds_wm.get(\f[B]this\f[R]).decoder.fatal;
  }
  \f[B]get\f[R] ignoreBOM() {
    \f[B]return\f[R] _jstds_wm.get(\f[B]this\f[R]).decoder.ignoreBOM;
  }
}
.EE
.SS Chaining multiple ReadableStreams together
This is a useful one, where multiple streams can be conjoined.
Examples include building a PWA with progressive loading and progressive
streaming.
.IP
.EX
\f[B]let\f[R] responses = [
  \f[I]/* conjoined response tree */\f[R]
];
\f[B]let\f[R] { readable, writable } = \f[B]new\f[R] TransformStream();

responses.reduce(
  (a, res, i, arr) \f[B]=>\f[R]
    a.then(() \f[B]=>\f[R] res.pipeTo(writable, { preventClose: i + 1 !== arr.length })),
  Promise.resolve(),
);
.EE
.PP
Note that this is not resilient to other influences.
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://whatwg-stream-visualizer.glitch.me/
WHATWG Stream Visualizer
.UE \c
, for a basic visualization of readable, writable, and transform
streams.
.IP \[bu] 2
\c
.UR https://web.dev/articles/streams
Streams\[em]The Definitive Guide
.UE \c
