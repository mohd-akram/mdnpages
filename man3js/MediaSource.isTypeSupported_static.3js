.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "MediaSource.isTypeSupported_static" "JS" "June 12, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
MediaSource.isTypeSupported_static \- MediaSource: isTypeSupported()
static method
.SH SYNOPSIS
The \f[B]\f[CB]MediaSource.isTypeSupported()\f[B]\f[R] static method
returns a boolean value which is \f[CR]true\f[R] if the given MIME type
and (optional) codec are \f[I]likely\f[R] to be supported by the current
user agent.
.PP
That is, if it can successfully create \f[CR]SourceBuffer\f[R] objects
for that media type.
If the returned value is \f[CR]false\f[R], then the user agent is
certain that it \f[I]cannot\f[R] access media of the specified format.
.SH SYNTAX
.IP
.EX
MediaSource.isTypeSupported(type)
.EE
.SS Parameters
.TP
\f[B]type\f[R]
A string specifying the MIME type of the media and (optionally) a
\f[CR]codecs\f[R] parameter containing a comma\-separated list of the
supported codecs.
.SS Return value
A value of \f[CR]false\f[R] if the media of the given type will
\f[I]not\f[R] play.
.PP
A value of \f[CR]true\f[R] is returned if the browser can
\f[I]probably\f[R] play media of the specified type.
This is \f[I]not\f[R] a guarantee, and your code must be prepared for
the possibility that the media will not play correctly if at all.
.PP
All web APIs that work with media files use a
\[lq]no/maybe/probably\[rq] approach (or, in this case, \[lq]no or
probably\[rq]) when determining if a media type can be used.
This is because media files are complex, intricate constructs with far
too many subtle variations to be absolutely certain of anything until
you actually use the contents of the media.
.SH EXAMPLES
The following snippet is from an example written by Nick Desaulniers (\c
.UR https://nickdesaulniers.github.io/netfix/demo/bufferAll.html
view the full demo live
.UE \c
, or \c
.UR https://github.com/nickdesaulniers/netfix/blob/gh-pages/demo/bufferAll.html
download the source
.UE \c
\ for further investigation).
The function \f[CR]getMediaSource()\f[R], which is not defined here,
returns a \f[CR]MediaSource\f[R].
.IP
.EX
\f[B]const\f[R] assetURL = \[dq]frag_bunny.mp4\[dq];
\f[I]// Need to be specific for Blink regarding codecs\f[R]
\f[I]// ./mp4info frag_bunny.mp4 | grep Codec\f[R]
\f[B]const\f[R] mimeCodec = \[aq]video/mp4; codecs=\[dq]avc1.42E01E, mp4a.40.2\[dq]\[aq];
\f[B]let\f[R] mediaSource;

\f[B]if\f[R] (\[dq]MediaSource\[dq] \f[B]in\f[R] window && MediaSource.isTypeSupported(mimeCodec)) {
  mediaSource = getMediaSource();
  console.log(mediaSource.readyState); \f[I]// closed\f[R]
  video.src = URL.createObjectURL(mediaSource);
  mediaSource.addEventListener(\[dq]sourceopen\[dq], sourceOpen);
} \f[B]else\f[R] {
  console.error(\[dq]Unsupported MIME type or codec: \[dq], mimeCodec);
}

\f[B]function\f[R] sourceOpen() {
  console.log(\f[B]this\f[R].readyState); \f[I]// open\f[R]
  \f[B]const\f[R] sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
  fetchAB(assetURL, (buf) \f[B]=>\f[R] {
    sourceBuffer.addEventListener(\[dq]updateend\[dq], () \f[B]=>\f[R] {
      mediaSource.endOfStream();
      video.play();
      console.log(mediaSource.readyState); \f[I]// ended\f[R]
    });
    sourceBuffer.appendBuffer(buf);
  });
}
.EE
.SH SEE ALSO
.IP \[bu] 2
Media Source Extensions API
.IP \[bu] 2
Guide to media types and formats on the web
.IP \[bu] 2
Codecs in common media types
.IP \[bu] 2
\f[CR]SourceBuffer\f[R]
.IP \[bu] 2
\f[CR]SourceBufferList\f[R]
