.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Promise.then" "JS" "December 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Promise.then \- Promise.prototype.then()
.SH SYNOPSIS
The \f[B]\f[CB]then()\f[B]\f[R] method of \f[CR]Promise\f[R] instances
takes up to two arguments: callback functions for the fulfilled and
rejected cases of the \f[CR]Promise\f[R].
It immediately returns an equivalent \f[CR]Promise\f[R] object, allowing
you to chain calls to other promise methods.
.SH SYNTAX
.IP
.EX
then(onFulfilled)
then(onFulfilled, onRejected)
.EE
.SS Parameters
.TP
\f[B]onFulfilled\f[R]
A function to asynchronously execute when this promise becomes
fulfilled.
Its return value becomes the fulfillment value of the promise returned
by \f[CR]then()\f[R].
The function is called with the following arguments:
.RS
.TP
\f[B]value\f[R]
The value that the promise was fulfilled with.
.PP
If it is not a function, it is internally replaced with an
\f[I]identity\f[R] function (\f[CR](x) => x\f[R]) which simply passes
the fulfillment value forward.
.RE
.TP
\f[B]onRejected\f[R] \f[I](optional)\f[R]
A function to asynchronously execute when this promise becomes rejected.
Its return value becomes the fulfillment value of the promise returned
by \f[CR]then()\f[R].
The function is called with the following arguments:
.RS
.TP
\f[B]reason\f[R]
The value that the promise was rejected with.
.PP
If it is not a function, it is internally replaced with a
\f[I]thrower\f[R] function (\f[CR](x) => { throw x; }\f[R]) which throws
the rejection reason it received.
.RE
.SS Return value
Returns a new \f[CR]Promise\f[R] immediately.
This new promise is always pending when returned, regardless of the
current promise\[cq]s status.
.PP
One of the \f[CR]onFulfilled\f[R] and \f[CR]onRejected\f[R] handlers
will be executed to handle the current promise\[cq]s fulfillment or
rejection.
The call always happens asynchronously, even when the current promise is
already settled.
The behavior of the returned promise (call it \f[CR]p\f[R]) depends on
the handler\[cq]s execution result, following a specific set of rules.
If the handler function:
.IP \[bu] 2
returns a value: \f[CR]p\f[R] gets fulfilled with the returned value as
its value.
.IP \[bu] 2
doesn\[cq]t return anything: \f[CR]p\f[R] gets fulfilled with
\f[CR]undefined\f[R] as its value.
.IP \[bu] 2
throws an error: \f[CR]p\f[R] gets rejected with the thrown error as its
value.
.IP \[bu] 2
returns an already fulfilled promise: \f[CR]p\f[R] gets fulfilled with
that promise\[cq]s value as its value.
.IP \[bu] 2
returns an already rejected promise: \f[CR]p\f[R] gets rejected with
that promise\[cq]s value as its value.
.IP \[bu] 2
returns another pending promise: \f[CR]p\f[R] is pending and becomes
fulfilled/rejected with that promise\[cq]s value as its value
immediately after that promise becomes fulfilled/rejected.
.SH DESCRIPTION
The \f[CR]then()\f[R] method schedules callback functions for the
eventual completion of a Promise \[em] either fulfillment or rejection.
It is the primitive method of promises: the thenable protocol expects
all promise\-like objects to expose a \f[CR]then()\f[R] method, and the
\f[CR]catch()\f[R] and \f[CR]finally()\f[R] methods both work by
invoking the object\[cq]s \f[CR]then()\f[R] method.
.PP
For more information about the \f[CR]onRejected\f[R] handler, see the
\f[CR]catch()\f[R] reference.
.PP
\f[CR]then()\f[R] returns a new promise object.
If you call the \f[CR]then()\f[R] method twice on the same promise
object (instead of chaining), then this promise object will have two
pairs of settlement handlers.
All handlers attached to the same promise object are always called in
the order they were added.
Moreover, the two promises returned by each call of \f[CR]then()\f[R]
start separate chains and do not wait for each other\[cq]s settlement.
.PP
Thenable objects that arise along the \f[CR]then()\f[R] chain are always
resolved \[em] the \f[CR]onFulfilled\f[R] handler never receives a
thenable object, and any thenable returned by either handler are always
resolved before being passed to the next handler.
This is because when constructing the new promise, the
\f[CR]resolve\f[R] and \f[CR]reject\f[R] functions passed by the
\f[CR]executor\f[R] are saved, and when the current promise settles, the
respective function will be called with the fulfillment value or
rejection reason.
The resolving logic comes from the \f[CR]resolve\f[R] function passed by
the \f[CR]Promise()\f[R] constructor.
.PP
\f[CR]then()\f[R] supports subclassing, which means it can be called on
instances of subclasses of \f[CR]Promise\f[R], and the result will be a
promise of the subclass type.
You can customize the type of the return value through the
\f[CR]\[at]\[at]species\f[R] property.
.SH EXAMPLES
.SS Using the then() method
.IP
.EX
\f[B]const\f[R] p1 = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  resolve(\[dq]Success!\[dq]);
  \f[I]// or\f[R]
  \f[I]// reject(new Error(\[dq]Error!\[dq]));\f[R]
});

p1.then(
  (value) \f[B]=>\f[R] {
    console.log(value); \f[I]// Success!\f[R]
  },
  (reason) \f[B]=>\f[R] {
    console.error(reason); \f[I]// Error!\f[R]
  },
);
.EE
.SS Having a non\-function as either parameter
.IP
.EX
Promise.resolve(1).then(2).then(console.log); \f[I]// 1\f[R]
Promise.reject(1).then(2, 2).then(console.log, console.log); \f[I]// 1\f[R]
.EE
.SS Chaining
The \f[CR]then\f[R] method returns a new \f[CR]Promise\f[R], which
allows for method chaining.
.PP
If the function passed as handler to \f[CR]then\f[R] returns a
\f[CR]Promise\f[R], an equivalent \f[CR]Promise\f[R] will be exposed to
the subsequent \f[CR]then\f[R] in the method chain.
The below snippet simulates asynchronous code with the
\f[CR]setTimeout\f[R] function.
.IP
.EX
Promise.resolve(\[dq]foo\[dq])
  \f[I]// 1. Receive \[dq]foo\[dq], concatenate \[dq]bar\[dq] to it, and resolve that to the next then\f[R]
  .then(
    (string) \f[B]=>\f[R]
      \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
        setTimeout(() \f[B]=>\f[R] {
          string += \[dq]bar\[dq];
          resolve(string);
        }, 1);
      }),
  )
  \f[I]// 2. receive \[dq]foobar\[dq], register a callback function to work on that string\f[R]
  \f[I]// and print it to the console, but not before returning the unworked on\f[R]
  \f[I]// string to the next then\f[R]
  .then((string) \f[B]=>\f[R] {
    setTimeout(() \f[B]=>\f[R] {
      string += \[dq]baz\[dq];
      console.log(string); \f[I]// foobarbaz\f[R]
    }, 1);
    \f[B]return\f[R] string;
  })
  \f[I]// 3. print helpful messages about how the code in this section will be run\f[R]
  \f[I]// before the string is actually processed by the mocked asynchronous code in the\f[R]
  \f[I]// previous then block.\f[R]
  .then((string) \f[B]=>\f[R] {
    console.log(
      \[dq]Last Then: oops... didn\[aq]t bother to instantiate and return a promise in the prior then so the sequence may be a bit surprising\[dq],
    );

    \f[I]// Note that \[ga]string\[ga] will not have the \[aq]baz\[aq] bit of it at this point. This\f[R]
    \f[I]// is because we mocked that to happen asynchronously with a setTimeout function\f[R]
    console.log(string); \f[I]// foobar\f[R]
  });

\f[I]// Logs, in order:\f[R]
\f[I]// Last Then: oops... didn\[aq]t bother to instantiate and return a promise in the prior then so the sequence may be a bit surprising\f[R]
\f[I]// foobar\f[R]
\f[I]// foobarbaz\f[R]
.EE
.PP
The value returned from \f[CR]then()\f[R] is resolved in the same way as
\f[CR]Promise.resolve()\f[R].
This means thenable objects are supported, and if the return value is
not a promise, it\[cq]s implicitly wrapped in a \f[CR]Promise\f[R] and
then resolved.
.IP
.EX
\f[B]const\f[R] p2 = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  resolve(1);
});

p2.then((value) \f[B]=>\f[R] {
  console.log(value); \f[I]// 1\f[R]
  \f[B]return\f[R] value + 1;
}).then((value) \f[B]=>\f[R] {
  console.log(value, \[dq]\- A synchronous value works\[dq]); \f[I]// 2 \- A synchronous value works\f[R]
});

p2.then((value) \f[B]=>\f[R] {
  console.log(value); \f[I]// 1\f[R]
});
.EE
.PP
A \f[CR]then\f[R] call returns a promise that eventually rejects if the
function throws an error or returns a rejected Promise.
.IP
.EX
Promise.resolve()
  .then(() \f[B]=>\f[R] {
    \f[I]// Makes .then() return a rejected promise\f[R]
    \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]Oh no!\[dq]);
  })
  .then(
    () \f[B]=>\f[R] {
      console.log(\[dq]Not called.\[dq]);
    },
    (error) \f[B]=>\f[R] {
      console.error(\[ga]onRejected function called: ${error.message}\[ga]);
    },
  );
.EE
.PP
In practice, it is often desirable to \f[CR]catch()\f[R] rejected
promises rather than \f[CR]then()\f[R]\[cq]s two\-case syntax, as
demonstrated below.
.IP
.EX
Promise.resolve()
  .then(() \f[B]=>\f[R] {
    \f[I]// Makes .then() return a rejected promise\f[R]
    \f[B]throw\f[R] \f[B]new\f[R] Error(\[dq]Oh no!\[dq]);
  })
  .catch((error) \f[B]=>\f[R] {
    console.error(\[ga]onRejected function called: ${error.message}\[ga]);
  })
  .then(() \f[B]=>\f[R] {
    console.log(\[dq]I am always called even if the prior then\[aq]s promise rejects\[dq]);
  });
.EE
.PP
In all other cases, the returned promise eventually fulfills.
In the following example, the first \f[CR]then()\f[R] returns
\f[CR]42\f[R] wrapped in a fulfilled Promise, even though the previous
Promise in the chain was rejected.
.IP
.EX
Promise.reject()
  .then(
    () \f[B]=>\f[R] 99,
    () \f[B]=>\f[R] 42,
  ) \f[I]// onRejected returns 42 which is wrapped in a fulfilled Promise\f[R]
  .then((solution) \f[B]=>\f[R] console.log(\[ga]Resolved with ${solution}\[ga])); \f[I]// Fulfilled with 42\f[R]
.EE
.PP
If \f[CR]onFulfilled\f[R] returns a promise, the return value of
\f[CR]then\f[R] will be fulfilled/rejected based on the eventual state
of that promise.
.IP
.EX
\f[B]function\f[R] resolveLater(resolve, reject) {
  setTimeout(() \f[B]=>\f[R] {
    resolve(10);
  }, 1000);
}
\f[B]function\f[R] rejectLater(resolve, reject) {
  setTimeout(() \f[B]=>\f[R] {
    reject(\f[B]new\f[R] Error(\[dq]Error\[dq]));
  }, 1000);
}

\f[B]const\f[R] p1 = Promise.resolve(\[dq]foo\[dq]);
\f[B]const\f[R] p2 = p1.then(() \f[B]=>\f[R] {
  \f[I]// Return promise here, that will be resolved to 10 after 1 second\f[R]
  \f[B]return\f[R] \f[B]new\f[R] Promise(resolveLater);
});
p2.then(
  (v) \f[B]=>\f[R] {
    console.log(\[dq]resolved\[dq], v); \f[I]// \[dq]resolved\[dq], 10\f[R]
  },
  (e) \f[B]=>\f[R] {
    \f[I]// not called\f[R]
    console.error(\[dq]rejected\[dq], e);
  },
);

\f[B]const\f[R] p3 = p1.then(() \f[B]=>\f[R] {
  \f[I]// Return promise here, that will be rejected with \[aq]Error\[aq] after 1 second\f[R]
  \f[B]return\f[R] \f[B]new\f[R] Promise(rejectLater);
});
p3.then(
  (v) \f[B]=>\f[R] {
    \f[I]// not called\f[R]
    console.log(\[dq]resolved\[dq], v);
  },
  (e) \f[B]=>\f[R] {
    console.error(\[dq]rejected\[dq], e); \f[I]// \[dq]rejected\[dq], \[aq]Error\[aq]\f[R]
  },
);
.EE
.PP
You can use chaining to implement one function with a Promise\-based API
on top of another such function.
.IP
.EX
\f[B]function\f[R] fetchCurrentData() {
  \f[I]// The fetch() API returns a Promise. This function\f[R]
  \f[I]// exposes a similar API, except the fulfillment\f[R]
  \f[I]// value of this function\[aq]s Promise has had more\f[R]
  \f[I]// work done on it.\f[R]
  \f[B]return\f[R] fetch(\[dq]current\-data.json\[dq]).then((response) \f[B]=>\f[R] {
    \f[B]if\f[R] (response.headers.get(\[dq]content\-type\[dq]) !== \[dq]application/json\[dq]) {
      \f[B]throw\f[R] \f[B]new\f[R] TypeError();
    }
    \f[B]const\f[R] j = response.json();
    \f[I]// maybe do something with j\f[R]

    \f[I]// fulfillment value given to user of\f[R]
    \f[I]// fetchCurrentData().then()\f[R]
    \f[B]return\f[R] j;
  });
}
.EE
.SS Asynchronicity of then()
The following is an example to demonstrate the asynchronicity of the
\f[CR]then\f[R] method.
.IP
.EX
\f[I]// Using a resolved promise \[aq]resolvedProm\[aq] for example,\f[R]
\f[I]// the function call \[aq]resolvedProm.then(...)\[aq] returns a new promise immediately,\f[R]
\f[I]// but its handler \[aq](value) => {...}\[aq] will get called asynchronously as demonstrated by the console.logs.\f[R]
\f[I]// the new promise is assigned to \[aq]thenProm\[aq],\f[R]
\f[I]// and thenProm will be resolved with the value returned by handler\f[R]
\f[B]const\f[R] resolvedProm = Promise.resolve(33);
console.log(resolvedProm);

\f[B]const\f[R] thenProm = resolvedProm.then((value) \f[B]=>\f[R] {
  console.log(
    \[ga]this gets called after the end of the main stack. the value received is: ${value}, the value returned is: ${
      value + 1
    }\[ga],
  );
  \f[B]return\f[R] value + 1;
});
console.log(thenProm);

\f[I]// Using setTimeout, we can postpone the execution of a function to the moment the stack is empty\f[R]
setTimeout(() \f[B]=>\f[R] {
  console.log(thenProm);
});

\f[I]// Logs, in order:\f[R]
\f[I]// Promise {[[PromiseStatus]]: \[dq]resolved\[dq], [[PromiseResult]]: 33}\f[R]
\f[I]// Promise {[[PromiseStatus]]: \[dq]pending\[dq], [[PromiseResult]]: undefined}\f[R]
\f[I]// \[dq]this gets called after the end of the main stack. the value received is: 33, the value returned is: 34\[dq]\f[R]
\f[I]// Promise {[[PromiseStatus]]: \[dq]resolved\[dq], [[PromiseResult]]: 34}\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Promise\f[R]
.IP \[bu] 2
\f[CR]Promise.prototype.catch()\f[R]
