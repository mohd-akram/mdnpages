.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "AudioWorkletProcessor" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
AudioWorkletProcessor \- AudioWorkletProcessor
.SH SYNOPSIS
The \f[B]\f[CB]AudioWorkletProcessor\f[B]\f[R] interface of the Web
Audio API represents an audio processing code behind a custom
\f[CR]AudioWorkletNode\f[R].
It lives in the \f[CR]AudioWorkletGlobalScope\f[R] and runs on the Web
Audio rendering thread.
In turn, an \f[CR]AudioWorkletNode\f[R] based on it runs on the main
thread.
.SH CONSTRUCTOR
.RS
.PP
\f[B]Note:\f[R] The \f[CR]AudioWorkletProcessor\f[R] and classes that
derive from it cannot be instantiated directly from a user\-supplied
code.
Instead, they are created only internally by the creation of an
associated \f[CR]AudioWorkletNode\f[R]s.
The constructor of the deriving class is getting called with an options
object, so you can perform a custom initialization procedures \[em] see
constructor page for details.
.RE
.TP
\f[B]AudioWorkletProcessor()\f[R]
Creates a new instance of an \f[CR]AudioWorkletProcessor\f[R] object.
.SH INSTANCE PROPERTIES
.TP
\f[B]port\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]MessagePort\f[R] used for bidirectional communication
between the processor and the \f[CR]AudioWorkletNode\f[R] which it
belongs to.
The other end is available under the \f[CR]port\f[R] property of the
node.
.SH INSTANCE METHODS
\f[I]The \f[CI]AudioWorkletProcessor\f[I] interface does not define any
methods of its own.
However, you must provide a \f[CI]process()\f[I] method, which is called
in order to process the audio stream.\f[R]
.SH EVENTS
\f[I]The \f[CI]AudioWorkletProcessor\f[I] interface doesn\[cq]t respond
to any events.\f[R]
.SH USAGE NOTES
.SS Deriving classes
To define custom audio processing code you have to derive a class from
the \f[CR]AudioWorkletProcessor\f[R] interface.
Although not defined on the interface, the deriving class must have the
\f[CR]process\f[R] method.
This method gets called for each block of 128 sample\-frames and takes
input and output arrays and calculated values of custom
\f[CR]AudioParam\f[R]s (if they are defined) as parameters.
You can use inputs and audio parameter values to fill the outputs array,
which by default holds silence.
.PP
Optionally, if you want custom \f[CR]AudioParam\f[R]s on your node, you
can supply a \f[CR]parameterDescriptors\f[R] property as a \f[I]static
getter\f[R] on the processor.
The array of \f[CR]AudioParamDescriptor\f[R]\-based objects returned is
used internally to create the \f[CR]AudioParam\f[R]s during the
instantiation of the \f[CR]AudioWorkletNode\f[R].
.PP
The resulting \f[CR]AudioParam\f[R]s reside in the \f[CR]parameters\f[R]
property of the node and can be automated using standard methods such as
\f[CR]linearRampToValueAtTime\f[R].
Their calculated values will be passed into the \f[CR]process()\f[R]
method of the processor for you to shape the node output accordingly.
.SS Processing audio
An example algorithm of creating a custom audio processing mechanism is:
.IP "1." 3
Create a separate file;
.IP "2." 3
In the file:
.RS 4
.IP "1." 3
Extend the \f[CR]AudioWorkletProcessor\f[R] class (see \[lq]Deriving
classes\[rq] section) and supply your own \f[CR]process()\f[R] method in
it;
.IP "2." 3
Register the processor using
\f[CR]AudioWorkletGlobalScope.registerProcessor()\f[R] method;
.RE
.IP "3." 3
Load the file using \f[CR]addModule()\f[R] method on your audio
context\[cq]s \f[CR]audioWorklet\f[R] property;
.IP "4." 3
Create an \f[CR]AudioWorkletNode\f[R] based on the processor.
The processor will be instantiated internally by the
\f[CR]AudioWorkletNode\f[R] constructor.
.IP "5." 3
Connect the node to the other nodes.
.SH EXAMPLES
In the example below we create a custom \f[CR]AudioWorkletNode\f[R] that
outputs white noise.
.PP
First, we need to define a custom \f[CR]AudioWorkletProcessor\f[R],
which will output white noise, and register it.
Note that this should be done in a separate file.
.IP
.EX
\f[I]// white\-noise\-processor.js\f[R]
\f[B]class\f[R] WhiteNoiseProcessor \f[B]extends\f[R] AudioWorkletProcessor {
  process(inputs, outputs, parameters) {
    \f[B]const\f[R] output = outputs[0];
    output.forEach((channel) \f[B]=>\f[R] {
      \f[B]for\f[R] (\f[B]let\f[R] i = 0; i < channel.length; i++) {
        channel[i] = Math.random() * 2 \- 1;
      }
    });
    \f[B]return\f[R] \f[B]true\f[R];
  }
}

registerProcessor(\[dq]white\-noise\-processor\[dq], WhiteNoiseProcessor);
.EE
.PP
Next, in our main script file we\[cq]ll load the processor, create an
instance of \f[CR]AudioWorkletNode\f[R], passing it the name of the
processor, then connect the node to an audio graph.
.IP
.EX
\f[B]const\f[R] audioContext = \f[B]new\f[R] AudioContext();
\f[B]await\f[R] audioContext.audioWorklet.addModule(\[dq]white\-noise\-processor.js\[dq]);
\f[B]const\f[R] whiteNoiseNode = \f[B]new\f[R] AudioWorkletNode(
  audioContext,
  \[dq]white\-noise\-processor\[dq],
);
whiteNoiseNode.connect(audioContext.destination);
.EE
.SH SEE ALSO
.IP \[bu] 2
Web Audio API
.IP \[bu] 2
Using the Web Audio API
.IP \[bu] 2
Using AudioWorklet
