'\" t
.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "IDBKeyRange" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
IDBKeyRange \- IDBKeyRange
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]IDBKeyRange\f[B]\f[R] interface of the IndexedDB API
represents a continuous interval over some data type that is used for
keys.
Records can be retrieved from \f[CR]IDBObjectStore\f[R] and
\f[CR]IDBIndex\f[R] objects using keys or a range of keys.
You can limit the range using lower and upper bounds.
For example, you can iterate over all values of a key in the value range
A\[en]Z.
.PP
A key range can be a single value or a range with upper and lower bounds
or endpoints.
If the key range has both upper and lower bounds, then it is
\f[I]bounded\f[R]; if it has no bounds, it is \f[I]unbounded\f[R].
A bounded key range can either be open (the endpoints are excluded) or
closed (the endpoints are included).
To retrieve all keys within a certain range, you can use the following
code constructs:
.PP
.TS
tab(@);
l l.
T{
Range
T}@T{
Code
T}
_
T{
All keys ≥ \f[B]x\f[R]
T}@T{
\f[CR]IDBKeyRange.lowerBound(x)\f[R]
T}
T{
All keys > \f[B]x\f[R]
T}@T{
\f[CR]IDBKeyRange.lowerBound(x, true)\f[R]
T}
T{
All keys ≤ \f[B]y\f[R]
T}@T{
\f[CR]IDBKeyRange.upperBound(y)\f[R]
T}
T{
All keys < \f[B]y\f[R]
T}@T{
\f[CR]IDBKeyRange.upperBound(y, true)\f[R]
T}
T{
All keys ≥ \f[B]x\f[R] && ≤ \f[B]y\f[R]
T}@T{
\f[CR]IDBKeyRange.bound(x, y)\f[R]
T}
T{
All keys > \f[B]x\f[R] &&< \f[B]y\f[R]
T}@T{
\f[CR]IDBKeyRange.bound(x, y, true, true)\f[R]
T}
T{
All keys > \f[B]x\f[R] && ≤ \f[B]y\f[R]
T}@T{
\f[CR]IDBKeyRange.bound(x, y, true, false)\f[R]
T}
T{
All keys ≥ \f[B]x\f[R] &&< \f[B]y\f[R]
T}@T{
\f[CR]IDBKeyRange.bound(x, y, false, true)\f[R]
T}
T{
The key = \f[B]z\f[R]
T}@T{
\f[CR]IDBKeyRange.only(z)\f[R]
T}
.TE
.PP
A key is in a key range if the following conditions are true:
.IP \[bu] 2
The lower value of the key range is one of the following:
.RS 2
.IP \[bu] 2
\f[CR]undefined\f[R]
.IP \[bu] 2
Less than key value
.IP \[bu] 2
Equal to key value if \f[CR]lowerOpen\f[R] is \f[CR]false\f[R].
.RE
.IP \[bu] 2
The upper value of the key range is one of the following:
.RS 2
.IP \[bu] 2
\f[CR]undefined\f[R]
.IP \[bu] 2
Greater than key value
.IP \[bu] 2
Equal to key value if \f[CR]upperOpen\f[R] is \f[CR]false\f[R].
.RE
.SH INSTANCE PROPERTIES
.TP
\f[B]IDBKeyRange.lower\f[R] \f[I](read\-only)\f[R]
Lower bound of the key range.
.TP
\f[B]IDBKeyRange.upper\f[R] \f[I](read\-only)\f[R]
Upper bound of the key range.
.TP
\f[B]IDBKeyRange.lowerOpen\f[R] \f[I](read\-only)\f[R]
Returns false if the lower\-bound value is included in the key range.
.TP
\f[B]IDBKeyRange.upperOpen\f[R] \f[I](read\-only)\f[R]
Returns false if the upper\-bound value is included in the key range.
.SH STATIC METHODS
.TP
\f[B]IDBKeyRange.bound()\f[R]
Creates a new key range with upper and lower bounds.
.TP
\f[B]IDBKeyRange.only()\f[R]
Creates a new key range containing a single value.
.TP
\f[B]IDBKeyRange.lowerBound()\f[R]
Creates a new key range with only a lower bound.
.TP
\f[B]IDBKeyRange.upperBound()\f[R]
Creates a new upper\-bound key range.
.SH INSTANCE METHODS
.TP
\f[B]IDBKeyRange.includes()\f[R]
Returns a boolean indicating whether a specified key is inside the key
range.
.SH EXAMPLES
The following example illustrates how you\[cq]d use a key range.
Here we declare a \f[CR]keyRangeValue\f[R] as a range between values of
\f[CR]\[dq]A\[dq]\f[R] and \f[CR]\[dq]F\[dq]\f[R].
We open a transaction (using \f[CR]IDBTransaction\f[R]) and an object
store, and open a cursor with \f[CR]IDBObjectStore.openCursor\f[R],
declaring \f[CR]keyRangeValue\f[R] as its optional key range value.
This means that the cursor will only retrieve records with keys inside
that range.
This range includes the values \f[CR]\[dq]A\[dq]\f[R] and
\f[CR]\[dq]F\[dq]\f[R], as we haven\[cq]t declared that they should be
open bounds.
If we used
\f[CR]IDBKeyRange.bound(\[dq]A\[dq], \[dq]F\[dq], true, true);\f[R],
then the range would not include \f[CR]\[dq]A\[dq]\f[R] and
\f[CR]\[dq]F\[dq]\f[R], only the values between them.
.RS
.PP
\f[B]Note:\f[R] For a more complete example allowing you to experiment
with key range, have a look at our \c
.UR https://github.com/mdn/dom-examples/tree/main/indexeddb-examples/idbkeyrange
IDBKeyRange\-example
.UE \c
\ repo (\c
.UR https://mdn.github.io/dom-examples/indexeddb-examples/idbkeyrange/
view the example live too
.UE \c
\&.)
.RE
.IP
.EX
\f[B]function\f[R] displayData() {
  \f[B]const\f[R] keyRangeValue = IDBKeyRange.bound(\[dq]A\[dq], \[dq]F\[dq]);

  \f[B]const\f[R] transaction = db.transaction([\[dq]fThings\[dq]], \[dq]readonly\[dq]);
  \f[B]const\f[R] objectStore = transaction.objectStore(\[dq]fThings\[dq]);

  objectStore.openCursor(keyRangeValue).onsuccess = (event) \f[B]=>\f[R] {
    \f[B]const\f[R] cursor = event.target.result;
    \f[B]if\f[R] (cursor) {
      \f[B]const\f[R] listItem = document.createElement(\[dq]li\[dq]);
      listItem.textContent = \[ga]${cursor.value.fThing}, ${cursor.value.fRating}\[ga];
      list.appendChild(listItem);

      cursor.continue();
    } \f[B]else\f[R] {
      console.log(\[dq]Entries all displayed.\[dq]);
    }
  };
}
.EE
.SH SEE ALSO
.IP \[bu] 2
Using IndexedDB
.IP \[bu] 2
Starting transactions: \f[CR]IDBDatabase\f[R]
.IP \[bu] 2
Using transactions: \f[CR]IDBTransaction\f[R]
.IP \[bu] 2
Retrieving and making changes to your data: \f[CR]IDBObjectStore\f[R]
.IP \[bu] 2
Using cursors: \f[CR]IDBCursor\f[R]
.IP \[bu] 2
Reference example: \c
.UR https://github.com/mdn/dom-examples/tree/main/to-do-notifications
To\-do Notifications
.UE \c
\ (\c
.UR https://mdn.github.io/dom-examples/to-do-notifications/
View the example live
.UE \c
).
