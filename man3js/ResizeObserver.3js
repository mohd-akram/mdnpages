.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "RESIZEOBSERVER" "3JS" "December 19, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ResizeObserver \- ResizeObserver
.SH SYNOPSIS
The \f[B]\f[CB]ResizeObserver\f[B]\f[R] interface reports changes to the
dimensions of an \f[CR]Element\f[R]\(cqs content or border box, or the
bounding box of an \f[CR]SVGElement\f[R].
.RS
.PP
\f[B]Note:\f[R] The content box is the box in which content can be
placed, meaning the border box minus the padding and border width.
The border box encompasses the content, padding, and border.
See The box model for further explanation.
.RE
.SH CONSTRUCTOR
.TP
\f[B]ResizeObserver()\f[R]
Creates and returns a new \f[CR]ResizeObserver\f[R] object.
.SH INSTANCE PROPERTIES
None.
.SH INSTANCE METHODS
.TP
\f[B]ResizeObserver.disconnect()\f[R]
Unobserves all observed \f[CR]Element\f[R] targets of a particular
observer.
.TP
\f[B]ResizeObserver.observe()\f[R]
Initiates the observing of a specified \f[CR]Element\f[R].
.TP
\f[B]ResizeObserver.unobserve()\f[R]
Ends the observing of a specified \f[CR]Element\f[R].
.SH EXAMPLES
In the \c
.UR https://mdn.github.io/dom-examples/resize-observer/resize-observer-text.html
resize\-observer\-text.html
.UE \c
\ (\c
.UR https://github.com/mdn/dom-examples/blob/main/resize-observer/resize-observer-text.html
see source
.UE \c
) example, we use the resize observer to change the
\f[CR]font\-size\f[R] of a header and paragraph as a slider\(cqs value
is changed causing the containing \f[CR]<div>\f[R] to change width.
This shows that you can respond to changes in an element\(cqs size, even
if they have nothing to do with the viewport.
.PP
We also provide a checkbox to turn the observer off and on.
If it is turned off, the text will not change in response to the
\f[CR]<div>\f[R]\(cqs width changing.
.PP
The JavaScript looks like so:
.IP
.EX
\f[B]const\f[R] h1Elem = document.querySelector(\(dqh1\(dq);
\f[B]const\f[R] pElem = document.querySelector(\(dqp\(dq);
\f[B]const\f[R] divElem = document.querySelector(\(dqbody > div\(dq);
\f[B]const\f[R] slider = document.querySelector(\(aqinput[type=\(dqrange\(dq]\(aq);
\f[B]const\f[R] checkbox = document.querySelector(\(aqinput[type=\(dqcheckbox\(dq]\(aq);

divElem.style.width = \(dq600px\(dq;

slider.addEventListener(\(dqinput\(dq, () \f[B]=>\f[R] {
  divElem.style.width = \(ga${slider.value}px\(ga;
});

\f[B]const\f[R] resizeObserver = \f[B]new\f[R] ResizeObserver((entries) \f[B]=>\f[R] {
  \f[B]for\f[R] (\f[B]const\f[R] entry \f[B]of\f[R] entries) {
    \f[B]if\f[R] (entry.contentBoxSize) {
      \f[B]const\f[R] contentBoxSize = entry.contentBoxSize[0];
      h1Elem.style.fontSize = \(ga${Math.max(
        1.5,
        contentBoxSize.inlineSize / 200,
      )}rem\(ga;
      pElem.style.fontSize = \(ga${Math.max(
        1,
        contentBoxSize.inlineSize / 600,
      )}rem\(ga;
    } \f[B]else\f[R] {
      h1Elem.style.fontSize = \(ga${Math.max(
        1.5,
        entry.contentRect.width / 200,
      )}rem\(ga;
      pElem.style.fontSize = \(ga${Math.max(1, entry.contentRect.width / 600)}rem\(ga;
    }
  }

  console.log(\(dqSize changed\(dq);
});

resizeObserver.observe(divElem);

checkbox.addEventListener(\(dqchange\(dq, () \f[B]=>\f[R] {
  \f[B]if\f[R] (checkbox.checked) {
    resizeObserver.observe(divElem);
  } \f[B]else\f[R] {
    resizeObserver.unobserve(divElem);
  }
});
.EE
.SH OBSERVATION ERRORS
Implementations following the specification invoke resize events before
paint (that is, before the frame is presented to the user).
If there was any resize event, style and layout are re\-evaluated \(em
which in turn may trigger more resize events.
Infinite loops from cyclic dependencies are addressed by only processing
elements deeper in the DOM during each iteration.
Resize events that don\(cqt meet that condition are deferred to the next
paint, and an error event is fired on the \f[CR]Window\f[R] object, with
the well\-defined message string:
.PP
\f[B]ResizeObserver loop completed with undelivered notifications.\f[R]
.PP
Note that this only prevents user\-agent lockup, not the infinite loop
itself.
For example, the following code will cause the width of
\f[CR]divElem\f[R] to grow indefinitely, with the above error message in
the console repeating every frame:
.IP
.EX
\f[B]const\f[R] divElem = document.querySelector(\(dqbody > div\(dq);

\f[B]const\f[R] resizeObserver = \f[B]new\f[R] ResizeObserver((entries) \f[B]=>\f[R] {
  \f[B]for\f[R] (\f[B]const\f[R] entry \f[B]of\f[R] entries) {
    entry.target.style.width = entry.contentBoxSize[0].inlineSize + 10 + \(dqpx\(dq;
  }
});

resizeObserver.observe(divElem);

window.addEventListener(\(dqerror\(dq, (e) \f[B]=>\f[R] {
  console.error(e.message);
});
.EE
.PP
As long as the error event does not fire indefinitely, resize observer
will settle and produce a stable, likely correct, layout.
However, visitors may see a flash of broken layout, as a sequence of
changes expected to happen in a single frame is instead happening over
multiple frames.
.PP
If you want to prevent these errors, the solution depends on what your
intended effect is.
If you actually intend to have an infinite loop, you just need to defer
the resizing code in your \f[CR]ResizeObserver\f[R] callback to after
the browser repaints.
You can put it into a \f[CR]requestAnimationFrame\f[R] callback.
.IP
.EX
\f[B]const\f[R] divElem = document.querySelector(\(dqbody > div\(dq);

\f[B]const\f[R] resizeObserver = \f[B]new\f[R] ResizeObserver((entries) \f[B]=>\f[R] {
  requestAnimationFrame(() \f[B]=>\f[R] {
    \f[B]for\f[R] (\f[B]const\f[R] entry \f[B]of\f[R] entries) {
      entry.target.style.width = entry.contentBoxSize[0].inlineSize + 10 + \(dqpx\(dq;
    }
  });
});

resizeObserver.observe(divElem);

window.addEventListener(\(dqerror\(dq, (e) \f[B]=>\f[R] {
  console.error(e.message);
});
.EE
.PP
If you don\(cqt intend to have an infinite loop, you should make sure
your resizing code does not trigger the resize observer callback.
There are many ways to do this, such as by setting an \(lqexpected
size\(rq and not resizing if the size is already at that value.
.IP
.EX
\f[B]const\f[R] divElem = document.querySelector(\(dqbody > div\(dq);
\f[B]const\f[R] expectedSizes = \f[B]new\f[R] WeakMap();

\f[B]const\f[R] resizeObserver = \f[B]new\f[R] ResizeObserver((entries) \f[B]=>\f[R] {
  requestAnimationFrame(() \f[B]=>\f[R] {
    \f[B]for\f[R] (\f[B]const\f[R] entry \f[B]of\f[R] entries) {
      \f[B]const\f[R] expectedSize = expectedSizes.get(entry.target);
      \f[B]if\f[R] (entry.contentBoxSize[0].inlineSize === expectedSize) {
        \f[B]continue\f[R];
      }
      \f[B]const\f[R] newSize = entry.contentBoxSize[0].inlineSize + 10;
      entry.target.style.width = \(ga${newSize}px\(ga;
      expectedSizes.set(entry.target, newSize);
    }
  });
});

resizeObserver.observe(divElem);

window.addEventListener(\(dqerror\(dq, (e) \f[B]=>\f[R] {
  console.error(e.message);
});
.EE
.SH SEE ALSO
.IP \(bu 2
Learn: The box model
.IP \(bu 2
\f[CR]PerformanceObserver\f[R]
.IP \(bu 2
\f[CR]IntersectionObserver\f[R] (part of the Intersection Observer API)
.IP \(bu 2
Upcoming container queries may be a viable alternative for implementing
responsive design.
