.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "ResizeObserver" "JS" "February 2, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ResizeObserver \- ResizeObserver
.SH SYNOPSIS
The \f[B]\f[CB]ResizeObserver\f[B]\f[R] interface reports changes to the
dimensions of an \f[CR]Element\f[R]\[cq]s content or border box, or the
bounding box of an \f[CR]SVGElement\f[R].
.RS
.PP
\f[B]Note:\f[R] The content box is the box in which content can be
placed, meaning the border box minus the padding and border width.
The border box encompasses the content, padding, and border.
See The box model for further explanation.
.RE
.SH CONSTRUCTOR
.TP
\f[B]ResizeObserver()\f[R]
Creates and returns a new \f[CR]ResizeObserver\f[R] object.
.SH INSTANCE PROPERTIES
None.
.SH INSTANCE METHODS
.TP
\f[B]ResizeObserver.disconnect()\f[R]
Unobserves all observed \f[CR]Element\f[R] targets of a particular
observer.
.TP
\f[B]ResizeObserver.observe()\f[R]
Initiates the observing of a specified \f[CR]Element\f[R].
.TP
\f[B]ResizeObserver.unobserve()\f[R]
Ends the observing of a specified \f[CR]Element\f[R].
.SH EXAMPLES
In the \c
.UR https://mdn.github.io/dom-examples/resize-observer/resize-observer-text.html
resize\-observer\-text.html
.UE \c
\ (\c
.UR https://github.com/mdn/dom-examples/blob/main/resize-observer/resize-observer-text.html
see source
.UE \c
) example, we use the resize observer to change the
\f[CR]font\-size\f[R] of a header and paragraph as a slider\[cq]s value
is changed causing the containing \f[CR]<div>\f[R] to change width.
This shows that you can respond to changes in an element\[cq]s size,
even if they have nothing to do with the viewport.
.PP
We also provide a checkbox to turn the observer off and on.
If it is turned off, the text will not change in response to the
\f[CR]<div>\f[R]\[cq]s width changing.
.PP
The JavaScript looks like so:
.IP
.EX
\f[B]const\f[R] h1Elem = document.querySelector(\[dq]h1\[dq]);
\f[B]const\f[R] pElem = document.querySelector(\[dq]p\[dq]);
\f[B]const\f[R] divElem = document.querySelector(\[dq]body > div\[dq]);
\f[B]const\f[R] slider = document.querySelector(\[aq]input[type=\[dq]range\[dq]]\[aq]);
\f[B]const\f[R] checkbox = document.querySelector(\[aq]input[type=\[dq]checkbox\[dq]]\[aq]);

divElem.style.width = \[dq]600px\[dq];

slider.addEventListener(\[dq]input\[dq], () \f[B]=>\f[R] {
  divElem.style.width = \[ga]${slider.value}px\[ga];
});

\f[B]const\f[R] resizeObserver = \f[B]new\f[R] ResizeObserver((entries) \f[B]=>\f[R] {
  \f[B]for\f[R] (\f[B]const\f[R] entry \f[B]of\f[R] entries) {
    \f[B]if\f[R] (entry.contentBoxSize) {
      \f[B]const\f[R] contentBoxSize = entry.contentBoxSize[0];
      h1Elem.style.fontSize = \[ga]${Math.max(
        1.5,
        contentBoxSize.inlineSize / 200,
      )}rem\[ga];
      pElem.style.fontSize = \[ga]${Math.max(
        1,
        contentBoxSize.inlineSize / 600,
      )}rem\[ga];
    } \f[B]else\f[R] {
      h1Elem.style.fontSize = \[ga]${Math.max(
        1.5,
        entry.contentRect.width / 200,
      )}rem\[ga];
      pElem.style.fontSize = \[ga]${Math.max(1, entry.contentRect.width / 600)}rem\[ga];
    }
  }

  console.log(\[dq]Size changed\[dq]);
});

resizeObserver.observe(divElem);

checkbox.addEventListener(\[dq]change\[dq], () \f[B]=>\f[R] {
  \f[B]if\f[R] (checkbox.checked) {
    resizeObserver.observe(divElem);
  } \f[B]else\f[R] {
    resizeObserver.unobserve(divElem);
  }
});
.EE
.SH OBSERVATION ERRORS
Implementations following the specification invoke resize events before
paint (that is, before the frame is presented to the user).
If there was any resize event, style and layout are re\-evaluated \[em]
which in turn may trigger more resize events.
Infinite loops from cyclic dependencies are addressed by only processing
elements deeper in the DOM during each iteration.
Resize events that don\[cq]t meet that condition are deferred to the
next paint, and an error event is fired on the \f[CR]Window\f[R] object,
with the well\-defined message string:
.PP
\f[B]ResizeObserver loop completed with undelivered notifications.\f[R]
.PP
Note that this only prevents user\-agent lockup, not the infinite loop
itself.
For example, the following code will cause the width of
\f[CR]divElem\f[R] to grow indefinitely, with the above error message in
the console repeating every frame:
.IP
.EX
\f[B]const\f[R] divElem = document.querySelector(\[dq]body > div\[dq]);

\f[B]const\f[R] resizeObserver = \f[B]new\f[R] ResizeObserver((entries) \f[B]=>\f[R] {
  \f[B]for\f[R] (\f[B]const\f[R] entry \f[B]of\f[R] entries) {
    entry.target.style.width = entry.contentBoxSize[0].inlineSize + 10 + \[dq]px\[dq];
  }
});

window.addEventListener(\[dq]error\[dq], \f[B]function\f[R] (e) {
  console.error(e.message);
});
.EE
.PP
As long as the error event does not fire indefinitely, resize observer
will settle and produce a stable, likely correct, layout.
However, visitors may see a flash of broken layout, as a sequence of
changes expected to happen in a single frame is instead happening over
multiple frames.
.SH SEE ALSO
.IP \[bu] 2
The box model
.IP \[bu] 2
\f[CR]PerformanceObserver\f[R]
.IP \[bu] 2
\f[CR]IntersectionObserver\f[R] (part of the Intersection Observer API)
.IP \[bu] 2
Upcoming container queries may be a viable alternative for implementing
responsive design.
