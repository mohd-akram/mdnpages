.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Promise.reject" "JS" "February 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Promise.reject - Promise.reject()
.SH SYNOPSIS
The \f[B]\f[CB]Promise.reject()\f[B]\f[R] static method returns a
\f[CR]Promise\f[R] object that is rejected with a given reason.
.SH SYNTAX
.IP
.EX
Promise.reject(reason)
.EE
.SS Parameters
.TP
\f[B]reason\f[R]
Reason why this \f[CR]Promise\f[R] rejected.
.SS Return value
A \f[CR]Promise\f[R] that is rejected with the given reason.
.SH DESCRIPTION
The static \f[CR]Promise.reject\f[R] function returns a
\f[CR]Promise\f[R] that is rejected.
For debugging purposes and selective error catching, it is useful to
make \f[CR]reason\f[R] an \f[CR]instanceof\f[R] \f[CR]Error\f[R].
.PP
\f[CR]Promise.reject()\f[R] is generic and supports subclassing, which
means it can be called on subclasses of \f[CR]Promise\f[R], and the
result will be a promise of the subclass type.
To do so, the subclass\[cq]s constructor must implement the same
signature as the \f[CR]Promise()\f[R] constructor \[em] accepting a
single \f[CR]executor\f[R] function that can be called with the
\f[CR]resolve\f[R] and \f[CR]reject\f[R] callbacks as parameters.
\f[CR]Promise.reject()\f[R] is essentially a shorthand for
\f[CR]new Promise((resolve, reject) => reject(reason))\f[R].
.PP
Unlike \f[CR]Promise.resolve()\f[R], \f[CR]Promise.reject()\f[R] always
wraps \f[CR]reason\f[R] in a new \f[CR]Promise\f[R] object, even when
\f[CR]reason\f[R] is already a \f[CR]Promise\f[R].
.SH EXAMPLES
.SS Using the static Promise.reject() method
.IP
.EX
Promise.reject(new Error(\[dq]fail\[dq])).then(
  () => {
    // not called
  },
  (error) => {
    console.error(error); // Stacktrace
  },
);
.EE
.SS Rejecting with a promise
Unlike \f[CR]Promise.resolve\f[R], the \f[CR]Promise.reject\f[R] method
does not reuse existing \f[CR]Promise\f[R] instances.
It always returns a new \f[CR]Promise\f[R] instance that wraps
\f[CR]reason\f[R].
.IP
.EX
const p = Promise.resolve(1);
const rejected = Promise.reject(p);
console.log(rejected === p); // false
rejected.catch((v) => {
  console.log(v === p); // true
});
.EE
.SS Calling reject() on a non-Promise constructor
\f[CR]Promise.reject()\f[R] is a generic method.
It can be called on any constructor that implements the same signature
as the \f[CR]Promise()\f[R] constructor.
For example, we can call it on a constructor that passes it
\f[CR]console.log\f[R] as \f[CR]reject\f[R]:
.IP
.EX
class NotPromise {
  constructor(executor) {
    // The \[dq]resolve\[dq] and \[dq]reject\[dq] functions behave nothing like the
    // native promise\[aq]s, but Promise.reject() calls them in the same way.
    executor(
      (value) => console.log(\[dq]Resolved\[dq], value),
      (reason) => console.log(\[dq]Rejected\[dq], reason),
    );
  }
}

Promise.reject.call(NotPromise, \[dq]foo\[dq]); // Logs \[dq]Rejected foo\[dq]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Promise\f[R]
