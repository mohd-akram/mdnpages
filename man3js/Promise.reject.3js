.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "PROMISE.REJECT" "3JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Promise.reject \- Promise.reject()
.SH SYNOPSIS
The \f[B]\f[CB]Promise.reject()\f[B]\f[R] static method returns a
\f[CR]Promise\f[R] object that is rejected with a given reason.
.IP
.EX
\f[B]function\f[R] resolved(result) {
  console.log(\(dqResolved\(dq);
}

\f[B]function\f[R] rejected(result) {
  console.error(result);
}

Promise.reject(\f[B]new\f[R] Error(\(dqfail\(dq)).then(resolved, rejected);
\f[I]// Expected output: Error: fail\f[R]
.EE
.SH SYNTAX
.IP
.EX
Promise.reject(reason)
.EE
.SS Parameters
.TP
\f[B]reason\f[R]
Reason why this \f[CR]Promise\f[R] rejected.
.SS Return value
A \f[CR]Promise\f[R] that is rejected with the given reason.
.SH DESCRIPTION
The static \f[CR]Promise.reject\f[R] function returns a
\f[CR]Promise\f[R] that is rejected.
For debugging purposes and selective error catching, it is useful to
make \f[CR]reason\f[R] an \f[CR]instanceof\f[R] \f[CR]Error\f[R].
.PP
\f[CR]Promise.reject()\f[R] is generic and supports subclassing, which
means it can be called on subclasses of \f[CR]Promise\f[R], and the
result will be a promise of the subclass type.
To do so, the subclass\(cqs constructor must implement the same
signature as the \f[CR]Promise()\f[R] constructor \(em accepting a
single \f[CR]executor\f[R] function that can be called with the
\f[CR]resolve\f[R] and \f[CR]reject\f[R] callbacks as parameters.
\f[CR]Promise.reject()\f[R] is essentially a shorthand for
\f[CR]new Promise((resolve, reject) => reject(reason))\f[R].
.PP
Unlike \f[CR]Promise.resolve()\f[R], \f[CR]Promise.reject()\f[R] always
wraps \f[CR]reason\f[R] in a new \f[CR]Promise\f[R] object, even when
\f[CR]reason\f[R] is already a \f[CR]Promise\f[R].
.SH EXAMPLES
.SS Using the static Promise.reject() method
.IP
.EX
Promise.reject(\f[B]new\f[R] Error(\(dqfail\(dq)).then(
  () \f[B]=>\f[R] {
    \f[I]// not called\f[R]
  },
  (error) \f[B]=>\f[R] {
    console.error(error); \f[I]// Stacktrace\f[R]
  },
);
.EE
.SS Rejecting with a promise
Unlike \f[CR]Promise.resolve\f[R], the \f[CR]Promise.reject\f[R] method
does not reuse existing \f[CR]Promise\f[R] instances.
It always returns a new \f[CR]Promise\f[R] instance that wraps
\f[CR]reason\f[R].
.IP
.EX
\f[B]const\f[R] p = Promise.resolve(1);
\f[B]const\f[R] rejected = Promise.reject(p);
console.log(rejected === p); \f[I]// false\f[R]
rejected.catch((v) \f[B]=>\f[R] {
  console.log(v === p); \f[I]// true\f[R]
});
.EE
.SS Calling reject() on a non\-Promise constructor
\f[CR]Promise.reject()\f[R] is a generic method.
It can be called on any constructor that implements the same signature
as the \f[CR]Promise()\f[R] constructor.
For example, we can call it on a constructor that passes it
\f[CR]console.log\f[R] as \f[CR]reject\f[R]:
.IP
.EX
\f[B]class\f[R] NotPromise {
  constructor(executor) {
    \f[I]// The \(dqresolve\(dq and \(dqreject\(dq functions behave nothing like the\f[R]
    \f[I]// native promise\(aqs, but Promise.reject() calls them in the same way.\f[R]
    executor(
      (value) \f[B]=>\f[R] console.log(\(dqResolved\(dq, value),
      (reason) \f[B]=>\f[R] console.log(\(dqRejected\(dq, reason),
    );
  }
}

Promise.reject.call(NotPromise, \(dqfoo\(dq); \f[I]// Logs \(dqRejected foo\(dq\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Promise\f[R]
