.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "WeakMap" "JS" "July 25, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
WeakMap \- WeakMap
.SH SYNOPSIS
A \f[B]\f[CB]WeakMap\f[B]\f[R] is a collection of key/value pairs whose
keys must be objects or non\-registered symbols, with values of any
arbitrary JavaScript type, and which does not create strong references
to its keys.
That is, an object\[cq]s presence as a key in a \f[CR]WeakMap\f[R] does
not prevent the object from being garbage collected.
Once an object used as a key has been collected, its corresponding
values in any \f[CR]WeakMap\f[R] become candidates for garbage
collection as well \[em] as long as they aren\[cq]t strongly referred to
elsewhere.
The only primitive type that can be used as a \f[CR]WeakMap\f[R] key is
symbol \[em] more specifically, non\-registered symbols \[em] because
non\-registered symbols are guaranteed to be unique and cannot be
re\-created.
.PP
\f[CR]WeakMap\f[R] allows associating data to objects in a way that
doesn\[cq]t prevent the key objects from being collected, even if the
values reference the keys.
However, a \f[CR]WeakMap\f[R] doesn\[cq]t allow observing the liveness
of its keys, which is why it doesn\[cq]t allow enumeration; if a
\f[CR]WeakMap\f[R] exposed any method to obtain a list of its keys, the
list would depend on the state of garbage collection, introducing
non\-determinism.
If you want to have a list of keys, you should use a \f[CR]Map\f[R]
rather than a \f[CR]WeakMap\f[R].
.PP
You can learn more about \f[CR]WeakMap\f[R] in the WeakMap object
section of the Keyed collections guide.
.SH DESCRIPTION
Keys of WeakMaps must be garbage\-collectable.
Most primitive data types can be arbitrarily created and don\[cq]t have
a lifetime, so they cannot be used as keys.
Objects and non\-registered symbols can be used as keys because they are
garbage\-collectable.
.SS Why WeakMap?
A map API \f[I]could\f[R] be implemented in JavaScript with two arrays
(one for keys, one for values) shared by the four API methods.
Setting elements on this map would involve pushing a key and value onto
the end of each of those arrays simultaneously.
As a result, the indices of the key and value would correspond to both
arrays.
Getting values from the map would involve iterating through all keys to
find a match, then using the index of this match to retrieve the
corresponding value from the array of values.
.PP
Such an implementation would have two main inconveniences:
.IP "1." 3
The first one is an \f[CR]O(n)\f[R] set and search (\f[I]n\f[R] being
the number of keys in the map) since both operations must iterate
through the list of keys to find a matching value.
.IP "2." 3
The second inconvenience is a memory leak because the arrays ensure that
references to each key and each value are maintained indefinitely.
These references prevent the keys from being garbage collected, even if
there are no other references to the object.
This would also prevent the corresponding values from being garbage
collected.
.PP
By contrast, in a \f[CR]WeakMap\f[R], a key object refers strongly to
its contents as long as the key is not garbage collected, but weakly
from then on.
As such, a \f[CR]WeakMap\f[R]:
.IP \[bu] 2
does not prevent garbage collection, which eventually removes references
to the key object
.IP \[bu] 2
allows garbage collection of any values if their key objects are not
referenced from somewhere other than a \f[CR]WeakMap\f[R]
.PP
A \f[CR]WeakMap\f[R] can be a particularly useful construct when mapping
keys to information about the key that is valuable \f[I]only if\f[R] the
key has not been garbage collected.
.PP
But because a \f[CR]WeakMap\f[R] doesn\[cq]t allow observing the
liveness of its keys, its keys are not enumerable.
There is no method to obtain a list of the keys.
If there were, the list would depend on the state of garbage collection,
introducing non\-determinism.
If you want to have a list of keys, you should use a \f[CR]Map\f[R].
.SH CONSTRUCTOR
.TP
\f[B]WeakMap()\f[R]
Creates a new \f[CR]WeakMap\f[R] object.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]WeakMap.prototype\f[R] and shared
by all \f[CR]WeakMap\f[R] instances.
.TP
\f[B]WeakMap.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]WeakMap\f[R] instances, the initial value is the
\f[CR]WeakMap\f[R] constructor.
.TP
\f[B]WeakMap.prototype[Symbol.toStringTag]\f[R]
The initial value of the \f[CR][Symbol.toStringTag]\f[R] property is the
string \f[CR]\[dq]WeakMap\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH INSTANCE METHODS
.TP
\f[B]WeakMap.prototype.delete()\f[R]
Removes any value associated to the \f[CR]key\f[R].
\f[CR]WeakMap.prototype.has(key)\f[R] will return \f[CR]false\f[R]
afterwards.
.TP
\f[B]WeakMap.prototype.get()\f[R]
Returns the value associated to the \f[CR]key\f[R], or
\f[CR]undefined\f[R] if there is none.
.TP
\f[B]WeakMap.prototype.has()\f[R]
Returns a Boolean asserting whether a value has been associated to the
\f[CR]key\f[R] in the \f[CR]WeakMap\f[R] object or not.
.TP
\f[B]WeakMap.prototype.set()\f[R]
Sets the \f[CR]value\f[R] for the \f[CR]key\f[R] in the
\f[CR]WeakMap\f[R] object.
Returns the \f[CR]WeakMap\f[R] object.
.SH EXAMPLES
.SS Using WeakMap
.IP
.EX
\f[B]const\f[R] wm1 = \f[B]new\f[R] WeakMap();
\f[B]const\f[R] wm2 = \f[B]new\f[R] WeakMap();
\f[B]const\f[R] wm3 = \f[B]new\f[R] WeakMap();
\f[B]const\f[R] o1 = {};
\f[B]const\f[R] o2 = \f[B]function\f[R] () {};
\f[B]const\f[R] o3 = window;

wm1.set(o1, 37);
wm1.set(o2, \[dq]azerty\[dq]);
wm2.set(o1, o2); \f[I]// a value can be anything, including an object or a function\f[R]
wm2.set(o2, \f[B]undefined\f[R]);
wm2.set(wm1, wm2); \f[I]// keys and values can be any objects. Even WeakMaps!\f[R]

wm1.get(o2); \f[I]// \[dq]azerty\[dq]\f[R]
wm2.get(o2); \f[I]// undefined, because that is the set value\f[R]
wm2.get(o3); \f[I]// undefined, because there is no key for o3 on wm2\f[R]

wm1.has(o2); \f[I]// true\f[R]
wm2.has(o2); \f[I]// true (even if the value itself is \[aq]undefined\[aq])\f[R]
wm2.has(o3); \f[I]// false\f[R]

wm3.set(o1, 37);
wm3.get(o1); \f[I]// 37\f[R]

wm1.has(o1); \f[I]// true\f[R]
wm1.delete(o1);
wm1.has(o1); \f[I]// false\f[R]
.EE
.SS Implementing a WeakMap\-like class with a .clear() method
.IP
.EX
\f[B]class\f[R] ClearableWeakMap {
  #wm;
  constructor(init) {
    \f[B]this\f[R].#wm = \f[B]new\f[R] WeakMap(init);
  }
  clear() {
    \f[B]this\f[R].#wm = \f[B]new\f[R] WeakMap();
  }
  \f[B]delete\f[R](k) {
    \f[B]return\f[R] \f[B]this\f[R].#wm.delete(k);
  }
  \f[B]get\f[R](k) {
    \f[B]return\f[R] \f[B]this\f[R].#wm.get(k);
  }
  has(k) {
    \f[B]return\f[R] \f[B]this\f[R].#wm.has(k);
  }
  \f[B]set\f[R](k, v) {
    \f[B]this\f[R].#wm.set(k, v);
    \f[B]return\f[R] \f[B]this\f[R];
  }
}
.EE
.SS Emulating private members
Developers can use a \f[CR]WeakMap\f[R] to associate private data to an
object, with the following benefits:
.IP \[bu] 2
Compared to a \f[CR]Map\f[R], a WeakMap does not hold strong references
to the object used as the key, so the metadata shares the same lifetime
as the object itself, avoiding memory leaks.
.IP \[bu] 2
Compared to using non\-enumerable and/or \f[CR]Symbol\f[R] properties, a
WeakMap is external to the object and there is no way for user code to
retrieve the metadata through reflective methods like
\f[CR]Object.getOwnPropertySymbols\f[R].
.IP \[bu] 2
Compared to a closure, the same WeakMap can be reused for all instances
created from a constructor, making it more memory\-efficient, and allows
different instances of the same class to read the private members of
each other.
.IP
.EX
\f[B]let\f[R] Thing;

{
  \f[B]const\f[R] privateScope = \f[B]new\f[R] WeakMap();
  \f[B]let\f[R] counter = 0;

  Thing = \f[B]function\f[R] () {
    \f[B]this\f[R].someProperty = \[dq]foo\[dq];

    privateScope.set(\f[B]this\f[R], {
      hidden: ++counter,
    });
  };

  Thing.prototype.showPublic = \f[B]function\f[R] () {
    \f[B]return\f[R] \f[B]this\f[R].someProperty;
  };

  Thing.prototype.showPrivate = \f[B]function\f[R] () {
    \f[B]return\f[R] privateScope.get(\f[B]this\f[R]).hidden;
  };
}

console.log(\f[B]typeof\f[R] privateScope);
\f[I]// \[dq]undefined\[dq]\f[R]

\f[B]const\f[R] thing = \f[B]new\f[R] Thing();

console.log(thing);
\f[I]// Thing {someProperty: \[dq]foo\[dq]}\f[R]

thing.showPublic();
\f[I]// \[dq]foo\[dq]\f[R]

thing.showPrivate();
\f[I]// 1\f[R]
.EE
.PP
This is roughly equivalent to the following, using private fields:
.IP
.EX
\f[B]class\f[R] Thing {
  \f[B]static\f[R] #counter = 0;
  #hidden;
  constructor() {
    \f[B]this\f[R].someProperty = \[dq]foo\[dq];
    \f[B]this\f[R].#hidden = ++Thing.#counter;
  }
  showPublic() {
    \f[B]return\f[R] \f[B]this\f[R].someProperty;
  }
  showPrivate() {
    \f[B]return\f[R] \f[B]this\f[R].#hidden;
  }
}

console.log(thing);
\f[I]// Thing {someProperty: \[dq]foo\[dq]}\f[R]

thing.showPublic();
\f[I]// \[dq]foo\[dq]\f[R]

thing.showPrivate();
\f[I]// 1\f[R]
.EE
.SS Associating metadata
A \f[CR]WeakMap\f[R] can be used to associate metadata with an object,
without affecting the lifetime of the object itself.
This is very similar to the private members example, since private
members are also modelled as external metadata that doesn\[cq]t
participate in prototypical inheritance.
.PP
This use case can be extended to already\-created objects.
For example, on the web, we may want to associate extra data with a DOM
element, which the DOM element may access later.
A common approach is to attach the data as a property:
.IP
.EX
\f[B]const\f[R] buttons = document.querySelectorAll(\[dq].button\[dq]);
buttons.forEach((button) \f[B]=>\f[R] {
  button.clicked = \f[B]false\f[R];
  button.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
    button.clicked = \f[B]true\f[R];
    \f[B]const\f[R] currentButtons = [...document.querySelectorAll(\[dq].button\[dq])];
    \f[B]if\f[R] (currentButtons.every((button) \f[B]=>\f[R] button.clicked)) {
      console.log(\[dq]All buttons have been clicked!\[dq]);
    }
  });
});
.EE
.PP
This approach works, but it has a few pitfalls:
.IP \[bu] 2
The \f[CR]clicked\f[R] property is enumerable, so it will show up in
\f[CR]Object.keys(button)\f[R], \f[CR]for...in\f[R] loops, etc.
This can be mitigated by using \f[CR]Object.defineProperty()\f[R], but
that makes the code more verbose.
.IP \[bu] 2
The \f[CR]clicked\f[R] property is a normal string property, so it can
be accessed and overwritten by other code.
This can be mitigated by using a \f[CR]Symbol\f[R] key, but the key
would still be accessible via \f[CR]Object.getOwnPropertySymbols()\f[R].
.PP
Using a \f[CR]WeakMap\f[R] fixes these:
.IP
.EX
\f[B]const\f[R] buttons = document.querySelectorAll(\[dq].button\[dq]);
\f[B]const\f[R] clicked = \f[B]new\f[R] WeakMap();
buttons.forEach((button) \f[B]=>\f[R] {
  clicked.set(button, \f[B]false\f[R]);
  button.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
    clicked.set(button, \f[B]true\f[R]);
    \f[B]const\f[R] currentButtons = [...document.querySelectorAll(\[dq].button\[dq])];
    \f[B]if\f[R] (currentButtons.every((button) \f[B]=>\f[R] clicked.get(button))) {
      console.log(\[dq]All buttons have been clicked!\[dq]);
    }
  });
});
.EE
.PP
Here, only code that has access to \f[CR]clicked\f[R] knows the clicked
state of each button, and external code can\[cq]t modify the states.
In addition, if any of the buttons gets removed from the DOM, the
associated metadata will automatically get garbage\-collected.
.SS Caching
You can associate objects passed to a function with the result of the
function, so that if the same object is passed again, the cached result
can be returned without re\-executing the function.
This is useful if the function is pure (i.e.\ it doesn\[cq]t mutate any
outside objects or cause other observable side effects).
.IP
.EX
\f[B]const\f[R] cache = \f[B]new\f[R] WeakMap();
\f[B]function\f[R] handleObjectValues(obj) {
  \f[B]if\f[R] (cache.has(obj)) {
    \f[B]return\f[R] cache.get(obj);
  }
  \f[B]const\f[R] result = Object.values(obj).map(heavyComputation);
  cache.set(obj, result);
  \f[B]return\f[R] result;
}
.EE
.PP
This only works if your function\[cq]s input is an object.
Moreover, even if the input is never passed in again, the result still
remains forever in the cache as long as the key (input) is alive.
A more effective way is to use a \f[CR]Map\f[R] paired with
\f[CR]WeakRef\f[R] objects, which allows you to associate any type of
input value with its respective (potentially large) computation result.
See the WeakRefs and FinalizationRegistry example for more details.
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#weakmap
Polyfill of \f[CR]WeakMap\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Keyed collections
.IP \[bu] 2
\c
.UR https://fitzgeraldnick.com/2014/01/13/hiding-implementation-details-with-e6-weakmaps.html
Hiding Implementation Details with ECMAScript 6 WeakMaps
.UE \c
\ by Nick Fitzgerald (2014)
.IP \[bu] 2
\f[CR]Map\f[R]
.IP \[bu] 2
\f[CR]Set\f[R]
.IP \[bu] 2
\f[CR]WeakSet\f[R]
