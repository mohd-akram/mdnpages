.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Headers" "JS" "March 6, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Headers \- Headers
.SH SYNOPSIS
This feature is available in Web Workers.
.PP
The \f[B]\f[CB]Headers\f[B]\f[R] interface of the Fetch API allows you
to perform various actions on HTTP request and response headers.
These actions include retrieving, setting, adding to, and removing
headers from the list of the request\[cq]s headers.
.PP
A \f[CR]Headers\f[R] object has an associated header list, which is
initially empty and consists of zero or more name and value pairs.
You can add to this using methods like \f[CR]append()\f[R] (see
Examples.)
In all methods of this interface, header names are matched by
case\-insensitive byte sequence.
.PP
For security reasons, some headers can only be controlled by the user
agent.
These headers include the forbidden header names and forbidden response
header names.
.PP
A Headers object also has an associated guard, which takes a value of
\f[CR]immutable\f[R], \f[CR]request\f[R], \f[CR]request\-no\-cors\f[R],
\f[CR]response\f[R], or \f[CR]none\f[R].
This affects whether the \f[CR]set()\f[R], \f[CR]delete()\f[R], and
\f[CR]append()\f[R] methods will mutate the header.
For more information see Guard.
.PP
You can retrieve a \f[CR]Headers\f[R] object via the
\f[CR]Request.headers\f[R] and \f[CR]Response.headers\f[R] properties,
and create a new \f[CR]Headers\f[R] object using the
\f[CR]Headers()\f[R] constructor.
.PP
An object implementing \f[CR]Headers\f[R] can directly be used in a
\f[CR]for...of\f[R] structure, instead of \f[CR]entries()\f[R]:
\f[CR]for (const p of myHeaders)\f[R] is equivalent to
\f[CR]for (const p of myHeaders.entries())\f[R].
.RS
.PP
\f[B]Note:\f[R] you can find out more about the available headers by
reading our HTTP headers reference.
.RE
.SH CONSTRUCTOR
.TP
\f[B]Headers()\f[R]
Creates a new \f[CR]Headers\f[R] object.
.SH INSTANCE METHODS
.TP
\f[B]Headers.append()\f[R]
Appends a new value onto an existing header inside a \f[CR]Headers\f[R]
object, or adds the header if it does not already exist.
.TP
\f[B]Headers.delete()\f[R]
Deletes a header from a \f[CR]Headers\f[R] object.
.TP
\f[B]Headers.entries()\f[R]
Returns an \f[CR]iterator\f[R] allowing to go through all key/value
pairs contained in this object.
.TP
\f[B]Headers.forEach()\f[R]
Executes a provided function once for each key/value pair in this
\f[CR]Headers\f[R] object.
.TP
\f[B]Headers.get()\f[R]
Returns a \f[CR]String\f[R] sequence of all the values of a header
within a \f[CR]Headers\f[R] object with a given name.
.TP
\f[B]Headers.getSetCookie()\f[R]
Returns an array containing the values of all \f[CR]Set\-Cookie\f[R]
headers associated with a response.
.TP
\f[B]Headers.has()\f[R]
Returns a boolean stating whether a \f[CR]Headers\f[R] object contains a
certain header.
.TP
\f[B]Headers.keys()\f[R]
Returns an \f[CR]iterator\f[R] allowing you to go through all keys of
the key/value pairs contained in this object.
.TP
\f[B]Headers.set()\f[R]
Sets a new value for an existing header inside a \f[CR]Headers\f[R]
object, or adds the header if it does not already exist.
.TP
\f[B]Headers.values()\f[R]
Returns an \f[CR]iterator\f[R] allowing you to go through all values of
the key/value pairs contained in this object.
.RS
.PP
\f[B]Note:\f[R] To be clear, the difference between
\f[CR]Headers.set()\f[R] and \f[CR]Headers.append()\f[R] is that if the
specified header does already exist and does accept multiple values,
\f[CR]Headers.set()\f[R] will overwrite the existing value with the new
one, whereas \f[CR]Headers.append()\f[R] will append the new value onto
the end of the set of values.
See their dedicated pages for example code.
.RE
.RS
.PP
\f[B]Note:\f[R] All of the Headers methods will throw a
\f[CR]TypeError\f[R] if you try to pass in a reference to a name that
isn\[cq]t a \c
.UR https://fetch.spec.whatwg.org/#concept-header-name
valid HTTP Header name
.UE \c
\&.
The mutation operations will throw a \f[CR]TypeError\f[R] if the header
has an immutable Guard.
In any other failure case they fail silently.
.RE
.RS
.PP
\f[B]Note:\f[R] When Header values are iterated over, they are
automatically sorted in lexicographical order, and values from duplicate
header names are combined.
.RE
.SH EXAMPLES
In the following snippet, we create a new header using the
\f[CR]Headers()\f[R] constructor, add a new header to it using
\f[CR]append()\f[R], then return that header value using
\f[CR]get()\f[R]:
.IP
.EX
\f[B]const\f[R] myHeaders = \f[B]new\f[R] Headers();

myHeaders.append(\[dq]Content\-Type\[dq], \[dq]text/xml\[dq]);
myHeaders.get(\[dq]Content\-Type\[dq]); \f[I]// should return \[aq]text/xml\[aq]\f[R]
.EE
.PP
The same can be achieved by passing an array of arrays or an object
literal to the constructor:
.IP
.EX
\f[B]let\f[R] myHeaders = \f[B]new\f[R] Headers({
  \[dq]Content\-Type\[dq]: \[dq]text/xml\[dq],
});

\f[I]// or, using an array of arrays:\f[R]
myHeaders = \f[B]new\f[R] Headers([[\[dq]Content\-Type\[dq], \[dq]text/xml\[dq]]]);

myHeaders.get(\[dq]Content\-Type\[dq]); \f[I]// should return \[aq]text/xml\[aq]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
ServiceWorker API
.IP \[bu] 2
HTTP access control (CORS)
.IP \[bu] 2
HTTP
