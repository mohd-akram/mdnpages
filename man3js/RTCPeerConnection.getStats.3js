.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "RTCPeerConnection.getStats" "JS" "March 25, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCPeerConnection.getStats \- RTCPeerConnection: getStats() method
.SH SYNOPSIS
The \f[B]\f[CB]getStats()\f[B]\f[R] method of the
\f[CR]RTCPeerConnection\f[R] interface returns a promise which resolves
with data providing statistics about either the overall connection or
about the specified \f[CR]MediaStreamTrack\f[R].
.SH SYNTAX
.IP
.EX
getStats()
getStats(selector)

getStats(selector, successCallback, failureCallback) // deprecated
.EE
.SS Parameters
.TP
\f[B]selector\f[R] \f[I](optional)\f[R]
A \f[CR]MediaStreamTrack\f[R] for which to gather statistics.
If this is \f[CR]null\f[R] (the default value), statistics will be
gathered for the entire \f[CR]RTCPeerConnection\f[R].
.SS Deprecated parameters
In older code and documentation, you may see a callback\-based version
of this function.
This has been deprecated and its use is \f[B]strongly\f[R] discouraged.
You should update any existing code to use the \f[CR]Promise\f[R]\-based
version of \f[CR]getStats()\f[R] instead.
The parameters for the older form of \f[CR]getStats()\f[R] are described
below, to aid in updating existing code.
.TP
\f[B]successCallback\f[R] \f[I](deprecated)\f[R]
A callback function called once the report has been successfully
generated.
.TP
\f[B]failureCallback\f[R] \f[I](deprecated)\f[R]
A callback function called once the report has failed to be generated.
.SS Return value
A \f[CR]Promise\f[R] which resolves with an \f[CR]RTCStatsReport\f[R]
object providing connection statistics.
The report\[cq]s contents depend on the \f[CR]selector\f[R] and other
details of the connection.
.SS Exceptions
This method does not throw exceptions; instead, it rejects the returned
promise with one of the following errors:
.TP
\f[B]InvalidAccessError\f[R] \f[B]DOMException\f[R]
Thrown when there is no \f[CR]RTCRtpSender\f[R] or
\f[CR]RTCRtpReceiver\f[R] whose \f[CR]track\f[R] matches the specified
\f[CR]selector\f[R], or \f[CR]selector\f[R] matches more than one sender
or receiver.
.SH EXAMPLES
This example creates a periodic function using \f[CR]setInterval()\f[R]
that collects statistics for an \f[CR]RTCPeerConnection\f[R] every
second, generating an HTML\-formatted report and inserting it into a
specific element in the DOM.
.IP
.EX
setInterval(() \f[B]=>\f[R] {
  myPeerConnection.getStats(\f[B]null\f[R]).then((stats) \f[B]=>\f[R] {
    \f[B]let\f[R] statsOutput = \[dq]\[dq];

    stats.forEach((report) \f[B]=>\f[R] {
      statsOutput +=
        \[ga]<h2>Report: ${report.type}</h2>\[rs]n<strong>ID:</strong> ${report.id}<br>\[rs]n\[ga] +
        \[ga]<strong>Timestamp:</strong> ${report.timestamp}<br>\[rs]n\[ga];

      \f[I]// Now the statistics for this report; we intentionally drop the ones we\f[R]
      \f[I]// sorted to the top above\f[R]

      Object.keys(report).forEach((statName) \f[B]=>\f[R] {
        \f[B]if\f[R] (
          statName !== \[dq]id\[dq] &&
          statName !== \[dq]timestamp\[dq] &&
          statName !== \[dq]type\[dq]
        ) {
          statsOutput += \[ga]<strong>${statName}:</strong> ${report[statName]}<br>\[rs]n\[ga];
        }
      });
    });

    document.querySelector(\[dq].stats\-box\[dq]).innerHTML = statsOutput;
  });
}, 1000);
.EE
.PP
This works by calling \f[CR]getStats()\f[R], then, when the promise is
resolved, iterates over the \f[CR]RTCStatsReport\f[R] objects on the
returned \f[CR]RTCStatsReport\f[R].
A section is created for each report with a header and all of the
statistics below, with the type, ID, and timestamp handled specially to
place them at the top of the list.
.PP
Once the HTML for the report is generated, it is injected into the
element whose class is \f[CR]\[dq]stats\-box\[dq]\f[R] by setting its
\f[CR]innerHTML\f[R] property.
