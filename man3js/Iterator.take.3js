.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ITERATOR.TAKE" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator.take \- Iterator.prototype.take()
.SH SYNOPSIS
The \f[B]\f[CB]take()\f[B]\f[R] method of \f[CR]Iterator\f[R] instances
returns a new iterator helper object that yields the given number of
elements in this iterator and then terminates.
.SH SYNTAX
.IP
.EX
take(limit)
.EE
.SS Parameters
.TP
\f[B]limit\f[R]
The number of elements to take from the start of the iteration.
.SS Return value
A new iterator helper object.
The returned iterator helper yields the elements in the original
iterator one\-by\-one, and then completes (the \f[CR]next()\f[R] method
produces \f[CR]{ value: undefined, done: true }\f[R]) once
\f[CR]limit\f[R] elements have been yielded, or when the original
iterator is exhausted, whichever comes first.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]limit\f[R] becomes \f[CR]NaN\f[R] or negative when
converted to an integer.
.SH EXAMPLES
.SS Using take()
The following example creates an iterator that yields terms in the
Fibonacci sequence, and then logs the first three terms:
.IP
.EX
\f[B]function\f[R]* fibonacci() {
  \f[B]let\f[R] current = 1;
  \f[B]let\f[R] next = 1;
  \f[B]while\f[R] (\f[B]true\f[R]) {
    \f[B]yield\f[R] current;
    [current, next] = [next, current + next];
  }
}

\f[B]const\f[R] seq = fibonacci().take(3);
console.log(seq.next().value); \f[I]// 1\f[R]
console.log(seq.next().value); \f[I]// 1\f[R]
console.log(seq.next().value); \f[I]// 2\f[R]
console.log(seq.next().value); \f[I]// undefined\f[R]
.EE
.SS Using take() with a for\&...of loop
\f[CR]take()\f[R] is most convenient when you are not hand\-rolling the
iterator.
Because iterators are also iterable, you can iterate the returned helper
with a \f[CR]for...of\f[R] loop:
.IP
.EX
\f[B]for\f[R] (\f[B]const\f[R] n \f[B]of\f[R] fibonacci().take(5)) {
  console.log(n);
}

\f[I]// Logs:\f[R]
\f[I]// 1\f[R]
\f[I]// 1\f[R]
\f[I]// 2\f[R]
\f[I]// 3\f[R]
\f[I]// 5\f[R]
.EE
.PP
Because \f[CR]fibonacci()\f[R] is an infinite iterator, using a
\f[CR]for\f[R] loop to iterate it without any logic to exit early (such
as a \f[CR]break\f[R] statement) would result in an infinite loop.
.SS Combining drop() with take()
You can combine \f[CR]take()\f[R] with
\f[CR]Iterator.prototype.drop()\f[R] to get a slice of an iterator:
.IP
.EX
\f[B]for\f[R] (\f[B]const\f[R] n \f[B]of\f[R] fibonacci().drop(2).take(5)) {
  \f[I]// Drops the first two elements, then takes the next five\f[R]
  console.log(n);
}
\f[I]// Logs:\f[R]
\f[I]// 2\f[R]
\f[I]// 3\f[R]
\f[I]// 5\f[R]
\f[I]// 8\f[R]
\f[I]// 13\f[R]

\f[B]for\f[R] (\f[B]const\f[R] n \f[B]of\f[R] fibonacci().take(5).drop(2)) {
  \f[I]// Takes the first five elements, then drops the first two\f[R]
  console.log(n);
}
\f[I]// Logs:\f[R]
\f[I]// 2\f[R]
\f[I]// 3\f[R]
\f[I]// 5\f[R]
.EE
.SS Lower and upper bounds of take count
When the \f[CR]limit\f[R] is negative or \f[CR]NaN\f[R], a
\f[CR]RangeError\f[R] is thrown:
.IP
.EX
fibonacci().take(\-1); \f[I]// RangeError: \-1 must be positive\f[R]
fibonacci().take(\f[B]undefined\f[R]); \f[I]// RangeError: undefined must be positive\f[R]
.EE
.PP
When the \f[CR]limit\f[R] is larger than the total number of elements
the iterator can produce (such as \f[CR]Infinity\f[R]), the returned
iterator helper has essentially the same behavior as the original
iterator:
.IP
.EX
\f[B]for\f[R] (\f[B]const\f[R] n \f[B]of\f[R] \f[B]new\f[R] Set([1, 2, 3]).values().take(\f[B]Infinity\f[R])) {
  console.log(n);
}

\f[I]// Logs:\f[R]
\f[I]// 1\f[R]
\f[I]// 2\f[R]
\f[I]// 3\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#iterator-helpers
Polyfill of \f[CR]Iterator.prototype.take\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/es-iterator-helpers
es\-shims polyfill of \f[CR]Iterator.prototype.take\f[R]
.UE \c
.IP \(bu 2
\f[CR]Iterator\f[R]
.IP \(bu 2
\f[CR]Iterator.prototype.drop()\f[R]
