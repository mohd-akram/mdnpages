.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "structuredClone" "JS" "November 9, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
structuredClone \- structuredClone() global function
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The global \f[B]\f[CB]structuredClone()\f[B]\f[R] method creates a deep
clone of a given value using the structured clone algorithm.
.PP
The method also allows transferable objects in the original value to be
\f[I]transferred\f[R] rather than cloned to the new object.
Transferred objects are detached from the original object and attached
to the new object; they are no longer accessible in the original object.
.SH SYNTAX
.IP
.EX
structuredClone(value)
structuredClone(value, options)
.EE
.SS Parameters
.TP
\f[B]value\f[R]
The object to be cloned.
This can be any structured\-cloneable type.
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object with the following properties:
.RS
.TP
\f[B]transfer\f[R]
An array of transferable objects that will be moved rather than cloned
to the returned object.
.RE
.SS Return value
The returned value is a deep copy of the original \f[CR]value\f[R].
.SS Exceptions
.TP
\f[B]DataCloneError\f[R] \f[B]DOMException\f[R]
Thrown if any part of the input value is not serializable.
.SH DESCRIPTION
This function can be used to deep copy JavaScript values.
It also supports circular references, as shown below:
.IP
.EX
\f[I]// Create an object with a value and a circular reference to itself.\f[R]
\f[B]const\f[R] original = { name: \[dq]MDN\[dq] };
original.itself = original;

\f[I]// Clone it\f[R]
\f[B]const\f[R] clone = structuredClone(original);

console.assert(clone !== original); \f[I]// the objects are not the same (not same identity)\f[R]
console.assert(clone.name === \[dq]MDN\[dq]); \f[I]// they do have the same values\f[R]
console.assert(clone.itself === clone); \f[I]// and the circular reference is preserved\f[R]
.EE
.SS Transferring values
Transferable objects (only) can be transferred rather than duplicated in
the cloned object, using the \f[CR]transfer\f[R] property of the
\f[CR]options\f[R] parameter.
Transferring makes the original object unusable.
.RS
.PP
\f[B]Note:\f[R] A scenario where this might be useful is when
asynchronously validating some data in a buffer before saving it.
To avoid the buffer being modified before the data is saved, you can
clone the buffer and validate that data.
If you also \f[I]transfer\f[R] the data, any attempts to modify the
original buffer will fail, preventing its accidental misuse.
.RE
.PP
The following code shows how to clone an array and transfer its
underlying resources to the new object.
On return, the original \f[CR]uInt8Array.buffer\f[R] will be cleared.
.IP
.EX
\f[I]// 16MB = 1024 * 1024 * 16\f[R]
\f[B]const\f[R] uInt8Array = Uint8Array.from({ length: 1024 * 1024 * 16 }, (v, i) \f[B]=>\f[R] i);

\f[B]const\f[R] transferred = structuredClone(uInt8Array, {
  transfer: [uInt8Array.buffer],
});
console.log(uInt8Array.byteLength); \f[I]// 0\f[R]
.EE
.PP
You can clone any number of objects and transfer any subset of those
objects.
For example, the code below would transfer \f[CR]arrayBuffer1\f[R] from
the passed in value, but not \f[CR]arrayBuffer2\f[R].
.IP
.EX
\f[B]const\f[R] transferred = structuredClone(
  { x: { y: { z: arrayBuffer1, w: arrayBuffer2 } } },
  { transfer: [arrayBuffer1] },
);
.EE
.SH EXAMPLES
.SS Cloning an object
In this example, we clone an object with one member, which is an array.
After cloning, changes to each object do not affect the other object.
.IP
.EX
\f[B]const\f[R] mushrooms1 = {
  amanita: [\[dq]muscaria\[dq], \[dq]virosa\[dq]],
};

\f[B]const\f[R] mushrooms2 = structuredClone(mushrooms1);

mushrooms2.amanita.push(\[dq]pantherina\[dq]);
mushrooms1.amanita.pop();

console.log(mushrooms2.amanita); \f[I]// [\[dq]muscaria\[dq], \[dq]virosa\[dq], \[dq]pantherina\[dq]]\f[R]
console.log(mushrooms1.amanita); \f[I]// [\[dq]muscaria\[dq]]\f[R]
.EE
.SS Transferring an object
In this example we create an \f[CR]ArrayBuffer\f[R] and then clone the
object it is a member of, transferring the buffer.
We can use the buffer in the cloned object, but if we try to use the
original buffer we will get an exception.
.IP
.EX
\f[I]// Create an ArrayBuffer with a size in bytes\f[R]
\f[B]const\f[R] buffer1 = \f[B]new\f[R] ArrayBuffer(16);

\f[B]const\f[R] object1 = {
  buffer: buffer1,
};

\f[I]// Clone the object containing the buffer, and transfer it\f[R]
\f[B]const\f[R] object2 = structuredClone(object1, { transfer: [buffer1] });

\f[I]// Create an array from the cloned buffer\f[R]
\f[B]const\f[R] int32View2 = \f[B]new\f[R] Int32Array(object2.buffer);
int32View2[0] = 42;
console.log(int32View2[0]);

\f[I]// Creating an array from the original buffer throws a TypeError\f[R]
\f[B]const\f[R] int32View1 = \f[B]new\f[R] Int32Array(object1.buffer);
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#structuredclone
A polyfill of \f[CR]structuredClone\f[R]
.UE \c
\ is available in \c
.UR https://github.com/zloirock/core-js
\f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Structured clone algorithm
.IP \[bu] 2
\c
.UR https://github.com/ungap/structured-clone
Structured clone polyfill
.UE \c
