.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPURENDERPASSENCODER" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPURenderPassEncoder \- GPURenderPassEncoder
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]GPURenderPassEncoder\f[B]\f[R] interface of the WebGPU
API encodes commands related to controlling the vertex and fragment
shader stages, as issued by a \f[CR]GPURenderPipeline\f[R].
It forms part of the overall encoding activity of a
\f[CR]GPUCommandEncoder\f[R].
.PP
A render pipeline renders graphics to \f[CR]GPUTexture\f[R] attachments,
typically intended for display in a \f[CR]<canvas>\f[R] element, but it
could also render to textures used for other purposes that never appear
onscreen.
It has two main stages:
.IP \(bu 2
A vertex stage, in which a vertex shader takes positioning data fed into
the GPU and uses it to position a series of vertices in 3D space by
applying specified effects like rotation, translation, or perspective.
The vertices are then assembled into primitives such as triangles (the
basic building block of rendered graphics) and rasterized by the GPU to
figure out what pixels each one should cover on the drawing canvas.
.IP \(bu 2
A fragment stage, in which a fragment shader computes the color for each
pixel covered by the primitives produced by the vertex shader.
These computations frequently use inputs such as images (in the form of
textures) that provide surface details and the position and color of
virtual lights.
.PP
A \f[CR]GPURenderPassEncoder\f[R] object instance is created via the
\f[CR]GPUCommandEncoder.beginRenderPass()\f[R] property.
.SH INSTANCE PROPERTIES
.TP
\f[B]label\f[R]
A string providing a label that can be used to identify the object, for
example in \f[CR]GPUError\f[R] messages or console warnings.
.SH INSTANCE METHODS
.TP
\f[B]beginOcclusionQuery()\f[R]
Begins an occlusion query at the specified index of the relevant
\f[CR]GPUQuerySet\f[R] (provided as the value of the
\f[CR]occlusionQuerySet\f[R] descriptor property when invoking
\f[CR]GPUCommandEncoder.beginRenderPass()\f[R] to run the render pass).
.TP
\f[B]draw()\f[R]
Draw primitives based on the vertex buffers provided by
\f[CR]setVertexBuffer()\f[R].
.TP
\f[B]drawIndexed()\f[R]
Draw indexed primitives based on the vertex and index buffers provided
by \f[CR]setVertexBuffer()\f[R] and \f[CR]setIndexBuffer()\f[R]
.TP
\f[B]drawIndirect()\f[R]
Draw primitives using parameters read from a \f[CR]GPUBuffer\f[R].
.TP
\f[B]drawIndexedIndirect()\f[R]
Draw indexed primitives using parameters read from a
\f[CR]GPUBuffer\f[R].
.TP
\f[B]end()\f[R]
Completes recording of the current render pass command sequence.
.TP
\f[B]endOcclusionQuery()\f[R]
Ends an active occlusion query previously started with
\f[CR]beginOcclusionQuery()\f[R].
.TP
\f[B]executeBundles()\f[R]
Executes commands previously recorded into the referenced
\f[CR]GPURenderBundle\f[R]s, as part of this render pass.
.TP
\f[B]insertDebugMarker()\f[R]
Marks a specific point in a series of encoded commands with a label.
.TP
\f[B]popDebugGroup()\f[R]
Ends a debug group, which is begun with a \f[CR]pushDebugGroup()\f[R]
call.
.TP
\f[B]pushDebugGroup()\f[R]
Begins a debug group, which is marked with a specified label, and will
contain all subsequent encoded commands up until a
\f[CR]popDebugGroup()\f[R] method is invoked.
.TP
\f[B]setBindGroup()\f[R]
Sets the \f[CR]GPUBindGroup\f[R] to use for subsequent render commands,
for a given index.
.TP
\f[B]setBlendConstant()\f[R]
Sets the constant blend color and alpha values used with
\f[CR]\(dqconstant\(dq\f[R] and \f[CR]\(dqone\-minus\-constant\(dq\f[R]
blend factors (as set in the descriptor of the
\f[CR]GPUDevice.createRenderPipeline()\f[R] method, in the
\f[CR]blend\f[R] property).
.TP
\f[B]setIndexBuffer()\f[R]
Sets the current \f[CR]GPUBuffer\f[R] that will provide index data for
subsequent drawing commands.
.TP
\f[B]setPipeline()\f[R]
Sets the \f[CR]GPURenderPipeline\f[R] to use for this render pass.
.TP
\f[B]setScissorRect()\f[R]
Sets the scissor rectangle used during the rasterization stage.
After transformation into viewport coordinates any fragments that fall
outside the scissor rectangle will be discarded.
.TP
\f[B]setStencilReference()\f[R]
Sets the stencil reference value using during stencil tests with the
\f[CR]\(dqreplace\(dq\f[R] stencil operation (as set in the descriptor
of the \f[CR]GPUDevice.createRenderPipeline()\f[R] method, in the
properties defining the various stencil operations).
.TP
\f[B]setVertexBuffer()\f[R]
Sets or unsets the current \f[CR]GPUBuffer\f[R] that will provide vertex
data for subsequent drawing commands.
.TP
\f[B]setViewport()\f[R]
Sets the viewport used during the rasterization stage to linearly map
from normalized device coordinates to viewport coordinates.
.SH EXAMPLES
In our \c
.UR https://mdn.github.io/dom-examples/webgpu-render-demo/
basic render demo
.UE \c
, several commands are recorded via a \f[CR]GPUCommandEncoder\f[R].
Most of these commands originate from the
\f[CR]GPURenderPassEncoder\f[R] created via
\f[CR]GPUCommandEncoder.beginRenderPass()\f[R].
.IP
.EX
\f[I]// \&...\f[R]

\f[B]const\f[R] renderPipeline = device.createRenderPipeline(pipelineDescriptor);

\f[I]// Create GPUCommandEncoder to issue commands to the GPU\f[R]
\f[I]// Note: render pass descriptor, command encoder, etc. are destroyed after use, fresh one needed for each frame.\f[R]
\f[B]const\f[R] commandEncoder = device.createCommandEncoder();

\f[I]// Create GPURenderPassDescriptor to tell WebGPU which texture to draw into, then initiate render pass\f[R]
\f[B]const\f[R] renderPassDescriptor = {
  colorAttachments: [
    {
      clearValue: clearColor,
      loadOp: \(dqclear\(dq,
      storeOp: \(dqstore\(dq,
      view: context.getCurrentTexture().createView(),
    },
  ],
};

\f[B]const\f[R] passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);

\f[I]// Draw the triangle\f[R]
passEncoder.setPipeline(renderPipeline);
passEncoder.setVertexBuffer(0, vertexBuffer);
passEncoder.draw(3);

\f[I]// End the render pass\f[R]
passEncoder.end();

\f[I]// End frame by passing array of command buffers to command queue for execution\f[R]
device.queue.submit([commandEncoder.finish()]);

\f[I]// \&...\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
