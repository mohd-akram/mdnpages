.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "HTMLCanvasElement.toBlob" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
HTMLCanvasElement.toBlob \- HTMLCanvasElement: toBlob() method
.SH SYNOPSIS
The \f[B]\f[CB]HTMLCanvasElement.toBlob()\f[B]\f[R] method creates a
\f[CR]Blob\f[R] object representing the image contained in the canvas.
This file may be cached on the disk or stored in memory at the
discretion of the user agent.
.PP
The desired file format and image quality may be specified.
If the file format is not specified, or if the given format is not
supported, then the data will be exported as \f[CR]image/png\f[R].
Browsers are required to support \f[CR]image/png\f[R]; many will support
additional formats including \f[CR]image/jpeg\f[R] and
\f[CR]image/webp\f[R].
.PP
The created image will have a resolution of 96dpi for file formats that
support encoding resolution metadata.
.SH SYNTAX
.IP
.EX
toBlob(callback)
toBlob(callback, type)
toBlob(callback, type, quality)
.EE
.SS Parameters
.TP
\f[B]callback\f[R]
A callback function with the resulting \f[CR]Blob\f[R] object as a
single argument.
\f[CR]null\f[R] may be passed if the image cannot be created for any
reason.
.TP
\f[B]type\f[R] \f[I](optional)\f[R]
A string indicating the image format.
The default type is \f[CR]image/png\f[R]; that type is also used if the
given type isn\[cq]t supported.
.TP
\f[B]quality\f[R] \f[I](optional)\f[R]
A \f[CR]Number\f[R] between \f[CR]0\f[R] and \f[CR]1\f[R] indicating the
image quality to be used when creating images using file formats that
support lossy compression (such as \f[CR]image/jpeg\f[R] or
\f[CR]image/webp\f[R]).
A user agent will use its default quality value if this option is not
specified, or if the number is outside the allowed range.
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.TP
\f[B]SecurityError\f[R]
The canvas\[cq]s bitmap is not origin\-clean; at least some of its
contents have or may have been loaded from a site other than the one
from which the document itself was loaded.
.SH EXAMPLES
.SS Getting a file representing the canvas
Once you have drawn content into a canvas, you can convert it into a
file of any supported image format.
The code snippet below, for example, takes the image in the
\f[CR]<canvas>\f[R] element whose ID is \[lq]canvas\[rq], obtains a copy
of it as a PNG image, then appends a new \f[CR]<img>\f[R] element to the
document, whose source image is the one created using the canvas.
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);

canvas.toBlob((blob) \f[B]=>\f[R] {
  \f[B]const\f[R] newImg = document.createElement(\[dq]img\[dq]);
  \f[B]const\f[R] url = URL.createObjectURL(blob);

  newImg.onload = () \f[B]=>\f[R] {
    \f[I]// no longer need to read the blob so it\[aq]s revoked\f[R]
    URL.revokeObjectURL(url);
  };

  newImg.src = url;
  document.body.appendChild(newImg);
});
.EE
.PP
Note that here we\[cq]re creating a PNG image; if you add a second
parameter to the \f[CR]toBlob()\f[R] call, you can specify another image
type supported by the user agent.
For example, to get the image in JPEG format:
.IP
.EX
canvas.toBlob(
  (blob) \f[B]=>\f[R] {
    \f[I]/* \&... */\f[R]
  },
  \[dq]image/jpeg\[dq],
  0.95,
); \f[I]// JPEG at 95% quality\f[R]
.EE
.SS Convert a canvas to an ico (Mozilla only)
This uses \f[CR]\-moz\-parse\f[R] to convert the canvas to ico, and
hence only works on Firefox.
Windows XP doesn\[cq]t support converting from PNG to ico, so it uses
bmp instead.
A download link is created by setting the download attribute.
The value of the download attribute is the name it will use as the file
name.
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] d = canvas.width;
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);
ctx.beginPath();
ctx.moveTo(d / 2, 0);
ctx.lineTo(d, d);
ctx.lineTo(0, d);
ctx.closePath();
ctx.fillStyle = \[dq]yellow\[dq];
ctx.fill();

\f[B]function\f[R] blobCallback(iconName) {
  \f[B]return\f[R] (b) \f[B]=>\f[R] {
    \f[B]const\f[R] a = document.createElement(\[dq]a\[dq]);
    a.textContent = \[dq]Download\[dq];
    document.body.appendChild(a);
    a.style.display = \[dq]block\[dq];
    a.download = \[ga]${iconName}.ico\[ga];
    a.href = window.URL.createObjectURL(b);
  };
}
canvas.toBlob(
  blobCallback(\[dq]passThisString\[dq]),
  \[dq]image/vnd.microsoft.icon\[dq],
  \[dq]\-moz\-parse\-options:format=bmp;bpp=32\[dq],
);
.EE
.SS Save toBlob to disk with OS.File (Chrome/add\-on context only)
.RS
.PP
\f[B]Note:\f[R] This technique saves it to the desktop and is only
useful in Firefox chrome context or add\-on code, as OS APIs are not
present on websites.
.RE
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] d = canvas.width;
ctx = canvas.getContext(\[dq]2d\[dq]);
ctx.beginPath();
ctx.moveTo(d / 2, 0);
ctx.lineTo(d, d);
ctx.lineTo(0, d);
ctx.closePath();
ctx.fillStyle = \[dq]yellow\[dq];
ctx.fill();

\f[B]function\f[R] blobCallback(iconName) {
  \f[B]return\f[R] (b) \f[B]=>\f[R] {
    \f[B]const\f[R] r = \f[B]new\f[R] FileReader();
    r.onloadend = () \f[B]=>\f[R] {
      \f[I]// r.result contains the ArrayBuffer.\f[R]
      Cu.import(\[dq]resource://gre/modules/osfile.jsm\[dq]);
      \f[B]const\f[R] writePath = OS.Path.join(
        OS.Constants.Path.desktopDir,
        \[ga]${iconName}.ico\[ga],
      );
      \f[B]const\f[R] promise = OS.File.writeAtomic(writePath, \f[B]new\f[R] Uint8Array(r.result), {
        tmpPath: \[ga]${writePath}.tmp\[ga],
      });
      promise.then(
        () \f[B]=>\f[R] {
          console.log(\[dq]successfully wrote file\[dq]);
        },
        () \f[B]=>\f[R] {
          console.log(\[dq]failure writing file\[dq]);
        },
      );
    };
    r.readAsArrayBuffer(b);
  };
}

canvas.toBlob(
  blobCallback(\[dq]passThisString\[dq]),
  \[dq]image/vnd.microsoft.icon\[dq],
  \[dq]\-moz\-parse\-options:format=bmp;bpp=32\[dq],
);
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Blob\f[R]
