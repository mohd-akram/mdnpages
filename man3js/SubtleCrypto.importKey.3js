.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "SubtleCrypto.importKey" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SubtleCrypto.importKey \- SubtleCrypto: importKey() method
.SH SYNOPSIS
\f[B]Secure context\f[R]: This feature is available only in secure
contexts (HTTPS).
.PP
The \f[B]\f[CB]importKey()\f[B]\f[R] method of the
\f[CR]SubtleCrypto\f[R] interface imports a key: that is, it takes as
input a key in an external, portable format and gives you a
\f[CR]CryptoKey\f[R] object that you can use in the Web Crypto API.
.PP
The function accepts several import formats: see Supported formats for
details.
.SH SYNTAX
.IP
.EX
importKey(format, keyData, algorithm, extractable, keyUsages)
.EE
.SS Parameters
.TP
\f[B]format\f[R]
A string describing the data format of the key to import.
It can be one of the following:
.RS
.IP \[bu] 2
\f[CR]raw\f[R]: Raw format.
.IP \[bu] 2
\f[CR]pkcs8\f[R]: PKCS #8 format.
.IP \[bu] 2
\f[CR]spki\f[R]: SubjectPublicKeyInfo format.
.IP \[bu] 2
\f[CR]jwk\f[R]: JSON Web Key format.
.RE
.TP
\f[B]keyData\f[R]
An \f[CR]ArrayBuffer\f[R], a TypedArray, a \f[CR]DataView\f[R], or a
\f[CR]JSONWebKey\f[R] object containing the key in the given format.
.TP
\f[B]algorithm\f[R]
An object defining the type of key to import and providing extra
algorithm\-specific parameters.
.RS
.IP \[bu] 2
For RSASSA\-PKCS1\-v1_5, RSA\-PSS, or RSA\-OAEP: Pass an
\f[CR]RsaHashedImportParams\f[R] object.
.IP \[bu] 2
For ECDSA or ECDH: Pass an \f[CR]EcKeyImportParams\f[R] object.
.IP \[bu] 2
For HMAC: Pass an \f[CR]HmacImportParams\f[R] object.
.IP \[bu] 2
For AES\-CTR, AES\-CBC, AES\-GCM, or AES\-KW: Pass the string
identifying the algorithm or an object of the form
\f[CR]{ \[dq]name\[dq]: ALGORITHM }\f[R], where \f[CR]ALGORITHM\f[R] is
the name of the algorithm.
.IP \[bu] 2
For PBKDF2: Pass the string \f[CR]PBKDF2\f[R].
.IP \[bu] 2
For HKDF: Pass the string \f[CR]HKDF\f[R].
.RE
.TP
\f[B]extractable\f[R]
A boolean value indicating whether it will be possible to export the key
using \f[CR]SubtleCrypto.exportKey()\f[R] or
\f[CR]SubtleCrypto.wrapKey()\f[R].
.TP
\f[B]keyUsages\f[R]
An \f[CR]Array\f[R] indicating what can be done with the key.
Possible array values are:
.RS
.IP \[bu] 2
\f[CR]encrypt\f[R]: The key may be used to \f[CR]encrypt\f[R] messages.
.IP \[bu] 2
\f[CR]decrypt\f[R]: The key may be used to \f[CR]decrypt\f[R] messages.
.IP \[bu] 2
\f[CR]sign\f[R]: The key may be used to \f[CR]sign\f[R] messages.
.IP \[bu] 2
\f[CR]verify\f[R]: The key may be used to \f[CR]verify\f[R] signatures.
.IP \[bu] 2
\f[CR]deriveKey\f[R]: The key may be used in
\f[CR]deriving a new key\f[R].
.IP \[bu] 2
\f[CR]deriveBits\f[R]: The key may be used in \f[CR]deriving bits\f[R].
.IP \[bu] 2
\f[CR]wrapKey\f[R]: The key may be used to \f[CR]wrap a key\f[R].
.IP \[bu] 2
\f[CR]unwrapKey\f[R]: The key may be used to \f[CR]unwrap a key\f[R].
.RE
.SS Return value
A \f[CR]Promise\f[R] that fulfills with the imported key as a
\f[CR]CryptoKey\f[R] object.
.SS Exceptions
The promise is rejected when one of the following exceptions is
encountered:
.TP
\f[B]SyntaxError\f[R] \f[B]DOMException\f[R]
Raised when \f[CR]keyUsages\f[R] is empty but the unwrapped key is of
type \f[CR]secret\f[R] or \f[CR]private\f[R].
.TP
\f[B]TypeError\f[R]
Raised when trying to use an invalid format or if the \f[CR]keyData\f[R]
is not suited for that format.
.SH SUPPORTED FORMATS
This API supports four different key import/export formats: Raw, PKCS
#8, SubjectPublicKeyInfo, and JSON Web Key.
.SS Raw
You can use this format to import or export AES or HMAC secret keys, or
Elliptic Curve public keys.
.PP
In this format the key is supplied as an \f[CR]ArrayBuffer\f[R]
containing the raw bytes for the key.
.SS PKCS #8
You can use this format to import or export RSA or Elliptic Curve
private keys.
.PP
The PKCS #8 format is defined in \c
.UR https://datatracker.ietf.org/doc/html/rfc5208
RFC 5208
.UE \c
, using the \c
.UR https://en.wikipedia.org/wiki/ASN.1
ASN.1 notation
.UE \c
:
.IP
.EX
PrivateKeyInfo ::= SEQUENCE {
    version                   Version,
    privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
    privateKey                PrivateKey,
    attributes           [0]  IMPLICIT Attributes OPTIONAL }
.EE
.PP
The \f[CR]importKey()\f[R] method expects to receive this object as an
\f[CR]ArrayBuffer\f[R] containing the \c
.UR https://luca.ntop.org/Teaching/Appunti/asn1.html
DER\-encoded
.UE \c
\ form of the \f[CR]PrivateKeyInfo\f[R].
DER is a set of rules for encoding ASN.1 structures into a binary form.
.PP
You are most likely to encounter this object in \c
.UR https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail
PEM format
.UE \c
\&.
PEM format is a way to encode binary data in ASCII.
It consists of a header and a footer, and in between, the
base64\-encoded binary data.
A PEM\-encoded \f[CR]PrivateKeyInfo\f[R] looks like this:
.IP
.EX
\-\-\-\-\-BEGIN PRIVATE KEY\-\-\-\-\-
MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDAU9BD0jxDfF5OV380z
9VIEUN2W5kJDZ3hbuaDenCxLiAMsoquKTfFaou71eLdN0TShZANiAARMUhCee/cp
xmjGc1roj0D0k6VlUqtA+JVCWigXcIAukOeTHCngZDKCrD4PkXDBvbciJdZKvO+l
ml2FIkoovZh/8yeTKmjUMb804g6OmjUc9vVojCRV0YdaSmYkkJMJbLg=
\-\-\-\-\-END PRIVATE KEY\-\-\-\-\-
.EE
.PP
To get this into a format you can give to \f[CR]importKey()\f[R] you
need to do two things:
.IP \[bu] 2
base64\-decode the part between header and footer, using
\f[CR]window.atob()\f[R].
.IP \[bu] 2
convert the resulting string into an \f[CR]ArrayBuffer\f[R].
.PP
See the Examples section for more concrete guidance.
.SS SubjectPublicKeyInfo
You can use this format to import or export RSA or Elliptic Curve public
keys.
.PP
\f[CR]SubjectPublicKey\f[R] is defined in \c
.UR https://datatracker.ietf.org/doc/html/rfc5280#section-4.1
RFC 5280, Section 4.1
.UE \c
\ using the \c
.UR https://en.wikipedia.org/wiki/ASN.1
ASN.1 notation
.UE \c
:
.IP
.EX
SubjectPublicKeyInfo  ::=  SEQUENCE  {
    algorithm            AlgorithmIdentifier,
    subjectPublicKey     BIT STRING  }
.EE
.PP
Just like PKCS #8, the \f[CR]importKey()\f[R] method expects to receive
this object as an \f[CR]ArrayBuffer\f[R] containing the \c
.UR https://luca.ntop.org/Teaching/Appunti/asn1.html
DER\-encoded
.UE \c
\ form of the \f[CR]SubjectPublicKeyInfo\f[R].
.PP
Again, you are most likely to encounter this object in \c
.UR https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail
PEM format
.UE \c
\&.
A PEM\-encoded \f[CR]SubjectPublicKeyInfo\f[R] looks like this:
.IP
.EX
\-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3j+HgSHUnc7F6XzvEbD0
r3M5JNy+/kabiJVu8IU1ERAl3Osi38VgiMzjDBDOrFxVzNNzl+SXAHwXIV5BHiXL
CQ6qhwYsDgH6OqgKIwiALra/wNH4UHxj1Or/iyAkjHRR/kGhUtjyVCjzvaQaDpJW
2G+syd1ui0B6kJov2CRUWiPwpff8hBfVWv8q9Yc2yD5hCnykVL0iAiyn+SDAk/rv
8dC5eIlzCI4efUCbyG4c9O88Qz7bS14DxSfaPTy8P/TWoihVVjLaDF743LgM/JLq
CDPUBUA3HLsZUhKm3BbSkd7Q9Ngkjv3+yByo4/fL+fkYRa8j9Ypa2N0Iw53LFb3B
gQIDAQAB
\-\-\-\-\-END PUBLIC KEY\-\-\-\-\-
.EE
.PP
Just as with PKCS #8, to get this into a format you can give to
\f[CR]importKey()\f[R] you need to do two things:
.IP \[bu] 2
base64\-decode the part between header and footer, using
\f[CR]window.atob()\f[R].
.IP \[bu] 2
convert the resulting string into an \f[CR]ArrayBuffer\f[R].
.PP
See the Examples section for more concrete guidance.
.SS JSON Web Key
You can use JSON Web Key format to import or export RSA or Elliptic
Curve public or private keys, as well as AES and HMAC secret keys.
.PP
JSON Web Key format is defined in \c
.UR https://datatracker.ietf.org/doc/html/rfc7517
RFC 7517
.UE \c
\&.
It describes a way to represent public, private, and secret keys as JSON
objects.
.PP
A JSON Web Key looks something like this (this is an EC private key):
.IP
.EX
{
  \[dq]crv\[dq]: \[dq]P\-384\[dq],
  \[dq]d\[dq]: \[dq]wouCtU7Nw4E8_7n5C1\-xBjB4xqSb_liZhYMsy8MGgxUny6Q8NCoH9xSiviwLFfK_\[dq],
  \[dq]ext\[dq]: true,
  \[dq]key_ops\[dq]: [\[dq]sign\[dq]],
  \[dq]kty\[dq]: \[dq]EC\[dq],
  \[dq]x\[dq]: \[dq]SzrRXmyI8VWFJg1dPUNbFcc9jZvjZEfH7ulKI1UkXAltd7RGWrcfFxqyGPcwu6AQ\[dq],
  \[dq]y\[dq]: \[dq]hHUag3OvDzEr0uUQND4PXHQTXP5IDGdYhJhL\-WLKjnGjQAw0rNGy5V29\-aV\-yseW\[dq]
};
.EE
.SH EXAMPLES
.RS
.PP
\f[B]Note:\f[R] You can \c
.UR https://mdn.github.io/dom-examples/web-crypto/import-key/index.html
try the working examples
.UE \c
\ on GitHub.
.RE
.SS Raw import
This example imports an AES key from an \f[CR]ArrayBuffer\f[R]
containing the raw bytes to use.
\c
.UR
https://github.com/mdn/dom-examples/blob/main/web-crypto/import-key/raw.js
See the complete code on GitHub.
.UE \c
.IP
.EX
const rawKey = window.crypto.getRandomValues(new Uint8Array(16));

/*
Import an AES secret key from an ArrayBuffer containing the raw bytes.
Takes an ArrayBuffer string containing the bytes, and returns a Promise
that will resolve to a CryptoKey representing the secret key.
*/
function importSecretKey(rawKey) {
  return window.crypto.subtle.importKey(\[dq]raw\[dq], rawKey, \[dq]AES\-GCM\[dq], true, [
    \[dq]encrypt\[dq],
    \[dq]decrypt\[dq],
  ]);
}
.EE
.SS PKCS #8 import
This example imports an RSA private signing key from a PEM\-encoded PKCS
#8 object.
\c
.UR
https://github.com/mdn/dom-examples/blob/main/web-crypto/import-key/pkcs8.js
See the complete code on GitHub.
.UE \c
.IP
.EX
/*
Convert a string into an ArrayBuffer
from https://developers.google.com/web/updates/2012/06/How\-to\-convert\-ArrayBuffer\-to\-and\-from\-String
*/
function str2ab(str) {
  const buf = new ArrayBuffer(str.length);
  const bufView = new Uint8Array(buf);
  for (let i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}

const pemEncodedKey = \[ga]\-\-\-\-\-BEGIN PRIVATE KEY\-\-\-\-\-
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDD0tPV/du2vftjvXj1t/gXTK39sNBVrOAEb/jKzXae+Xa0H+3LhZaQIQNMfACiBSgIfZUvEGb+7TqXWQpoLoFR/R7MvGWcSk98JyrVtveD8ZmZYyItSY7m2hcasqAFiKyOouV5vzyRe87/lEyzzBpF3bQQ4IDaQu+K9Hj5fKuU6rrOeOhsdnJc+VdDQLScHxvMoLZ9Vtt+oK9J4/tOLwr4CG8khDlBURcBY6gPcLo3dPU09SW+6ctX2cX4mkXx6O/0mmdTmacr/vu50KdRMleFeZYOWPAEhhMfywybTuzBiPVIZVP8WFCSKNMbfi1S9A9PdBqnebwwHhX3/hsEBt2BAgMBAAECggEABEI1P6nf6Zs7mJlyBDv+Pfl5rjL2cOqLy6TovvZVblMkCPpJyFuNIPDK2tK2i897ZaXfhPDBIKmllM2Hq6jZQKB110OAnTPDg0JxzMiIHPs32S1d/KilHjGff4Hjd4NXp1l1Dp8BUPOllorR2TYm2x6dcCGFw9lhTr8O03Qp4hjn84VjGIWADYCk83mgS4nRsnHkdiqYnWx1AjKlY51yEK6RcrDMi0Th2RXrrINoC35sVv+APt2rkoMGi52RwTEseA1KZGFrxjq61ReJif6p2VXEcvHeX6CWLx014LGk43z6Q28P6HgeEVEfIjyqCUea5Du/mYb/QsRSCosXLxBqwQKBgQD1+fdC9ZiMrVI+km7Nx2CKBn8rJrDmUh5SbXn2MYJdrUd8bYNnZkCgKMgxVXsvJrbmVOrby2txOiqudZkk5mD3E5O/QZWPWQLgRu8ueYNpobAX9NRgNfZ7rZD+81vh5MfZiXfuZOuzv29iZhU0oqyZ9y75eHkLdrerNkwYOe5aUQKBgQDLzapDi1NxkBgsj9iiO4KUa7jvD4JjRqFy4Zhj/jbQvlvM0F/uFp7sxVcHGx4r11C+6iCbhX4u+Zuu0HGjT4d+hNXmgGyxR8fIUVxOlOtDkVJa5sOBZK73/9/MBeKusdmJPRhalZQfMUJRWIoEVDMhfg3tW/rBj5RYAtP2dTVUMQKBgDs8yr52dRmT+BWXoFWwaWB0NhYHSFz/c8v4D4Ip5DJ5M5kUqquxJWksySGQa40sbqnD05fBQovPLU48hfgr/zghn9hUjBcsoZOvoZR4sRw0UztBvA+7jzOz1hKAOyWIulR6Vca0yUrNlJ6G5R56+sRNkiOETupi2dLCzcqb0PoxAoGAZyNHvTLvIZN4iGSrjz5qkM4LIwBIThFadxbv1fq6pt0O/BGf2o+cEdq0diYlGK64cEVwBwSBnSg4vzlBqRIAUejLjwEDAJyA4EE8Y5A9l04dzV7nJb5cRak6CrgXxay/mBJRFtaHxVlaZGxYPGSYE6UFS0+3EOmmevvDZQBf4qECgYEA0ZF6Vavz28+8wLO6SP3w8NmpHk7K9tGEvUfQ30SgDx4G7qPIgfPrbB4OP/E0qCfsIImi3sCPpjvUMQdVVZyPOIMuB+rV3ZOxkrzxEUOrpOpR48FZbL7RN90yRQsAsrp9e4iv8QwB3VxLe7X0TDqqnRyqrc/osGzuS2ZcHOKmCU8=
\-\-\-\-\-END PRIVATE KEY\-\-\-\-\-\[ga];

/*
Import a PEM encoded RSA private key, to use for RSA\-PSS signing.
Takes a string containing the PEM encoded key, and returns a Promise
that will resolve to a CryptoKey representing the private key.
*/
function importPrivateKey(pem) {
  // fetch the part of the PEM string between header and footer
  const pemHeader = \[dq]\-\-\-\-\-BEGIN PRIVATE KEY\-\-\-\-\-\[dq];
  const pemFooter = \[dq]\-\-\-\-\-END PRIVATE KEY\-\-\-\-\-\[dq];
  const pemContents = pem.substring(
    pemHeader.length,
    pem.length \- pemFooter.length,
  );
  // base64 decode the string to get the binary data
  const binaryDerString = window.atob(pemContents);
  // convert from a binary string to an ArrayBuffer
  const binaryDer = str2ab(binaryDerString);

  return window.crypto.subtle.importKey(
    \[dq]pkcs8\[dq],
    binaryDer,
    {
      name: \[dq]RSA\-PSS\[dq],
      hash: \[dq]SHA\-256\[dq],
    },
    true,
    [\[dq]sign\[dq]],
  );
}
.EE
.SS SubjectPublicKeyInfo import
This example imports an RSA public encryption key from a PEM\-encoded
SubjectPublicKeyInfo object.
\c
.UR
https://github.com/mdn/dom-examples/blob/main/web-crypto/import-key/spki.js
See the complete code on GitHub.
.UE \c
.IP
.EX
// from https://developers.google.com/web/updates/2012/06/How\-to\-convert\-ArrayBuffer\-to\-and\-from\-String
function str2ab(str) {
  const buf = new ArrayBuffer(str.length);
  const bufView = new Uint8Array(buf);
  for (let i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}

const pemEncodedKey = \[ga]\-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAy3Xo3U13dc+xojwQYWoJLCbOQ5fOVY8LlnqcJm1W1BFtxIhOAJWohiHuIRMctv7dzx47TLlmARSKvTRjd0dF92jx/xY20Lz+DXp8YL5yUWAFgA3XkO3LSJgEOex10NB8jfkmgSb7QIudTVvbbUDfd5fwIBmCtaCwWx7NyeWWDb7A9cFxj7EjRdrDaK3ux/ToMLHFXVLqSL341TkCf4ZQoz96RFPUGPPLOfvN0x66CM1PQCkdhzjE6U5XGE964ZkkYUPPsy6Dcie4obhW4vDjgUmLzv0z7UD010RLIneUgDE2FqBfY/C+uWigNPBPkkQ+Bv/UigS6dHqTCVeD5wgyBQIDAQAB
\-\-\-\-\-END PUBLIC KEY\-\-\-\-\-\[ga];

function importRsaKey(pem) {
  // fetch the part of the PEM string between header and footer
  const pemHeader = \[dq]\-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-\[dq];
  const pemFooter = \[dq]\-\-\-\-\-END PUBLIC KEY\-\-\-\-\-\[dq];
  const pemContents = pem.substring(
    pemHeader.length,
    pem.length \- pemFooter.length \- 1,
  );
  // base64 decode the string to get the binary data
  const binaryDerString = window.atob(pemContents);
  // convert from a binary string to an ArrayBuffer
  const binaryDer = str2ab(binaryDerString);

  return window.crypto.subtle.importKey(
    \[dq]spki\[dq],
    binaryDer,
    {
      name: \[dq]RSA\-OAEP\[dq],
      hash: \[dq]SHA\-256\[dq],
    },
    true,
    [\[dq]encrypt\[dq]],
  );
}
.EE
.SS JSON Web Key import
This code imports an ECDSA private signing key, given a JSON Web Key
object that represents it.
\c
.UR
https://github.com/mdn/dom-examples/blob/main/web-crypto/import-key/jwk.js
See the complete code on GitHub.
.UE \c
.IP
.EX
const jwkEcKey = {
  crv: \[dq]P\-384\[dq],
  d: \[dq]wouCtU7Nw4E8_7n5C1\-xBjB4xqSb_liZhYMsy8MGgxUny6Q8NCoH9xSiviwLFfK_\[dq],
  ext: true,
  key_ops: [\[dq]sign\[dq]],
  kty: \[dq]EC\[dq],
  x: \[dq]SzrRXmyI8VWFJg1dPUNbFcc9jZvjZEfH7ulKI1UkXAltd7RGWrcfFxqyGPcwu6AQ\[dq],
  y: \[dq]hHUag3OvDzEr0uUQND4PXHQTXP5IDGdYhJhL\-WLKjnGjQAw0rNGy5V29\-aV\-yseW\[dq],
};

/*
Import a JSON Web Key format EC private key, to use for ECDSA signing.
Takes an object representing the JSON Web Key, and returns a Promise
that will resolve to a CryptoKey representing the private key.
*/
function importPrivateKey(jwk) {
  return window.crypto.subtle.importKey(
    \[dq]jwk\[dq],
    jwk,
    {
      name: \[dq]ECDSA\[dq],
      namedCurve: \[dq]P\-384\[dq],
    },
    true,
    [\[dq]sign\[dq]],
  );
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]SubtleCrypto.exportKey()\f[R]
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc5208
PKCS #8 format
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc5280#section-4.1
SubjectPublicKeyInfo format
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc7517
JSON Web Key format
.UE \c
\&.
