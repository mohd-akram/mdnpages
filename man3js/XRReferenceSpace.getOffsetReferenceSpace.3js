.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "XRReferenceSpace.getOffsetReferenceSpace" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
XRReferenceSpace.getOffsetReferenceSpace \- XRReferenceSpace:
getOffsetReferenceSpace() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
The \f[CR]XRReferenceSpace\f[R] interface\[cq]s
\f[B]\f[CB]getOffsetReferenceSpace()\f[B]\f[R] method returns a new
reference space object which describes the relative difference in
position between the object on which the method is called and a given
point in 3D space.
The object returned by \f[CR]getOffsetReferenceSpace()\f[R] is an
\f[CR]XRReferenceSpace\f[R] if called on an \f[CR]XRReferenceSpace\f[R],
or an \f[CR]XRBoundedReferenceSpace\f[R] if called on an object of that
type.
.PP
In other words, when you have an object in 3D space and need to position
another object relative to that one, you can call
\f[CR]getOffsetReferenceSpace()\f[R], passing into it the position and
orientation you want the second object to have \f[I]relative to the
position and orientation of the object on which you call
\f[CI]getOffsetReferenceSpace()\f[I]\f[R].
.PP
Then, when drawing the scene, you can use the offset reference space to
not only position objects relative to one another, but to apply the
needed transforms to render objects properly based upon the viewer\[cq]s
position.
This is demonstrated in the example Implementing rotation based on
non\-XR inputs, which demonstrates a way to use this method to let the
user use their mouse to pitch and yaw their viewing angle.
.SH SYNTAX
.IP
.EX
getOffsetReferenceSpace(originOffset)
.EE
.SS Parameters
.TP
\f[B]originOffset\f[R]
An \f[CR]XRRigidTransform\f[R] specifying the offset to the origin of
the new reference space.
These values are added to the position and orientation of the current
reference space and then the result is used as the position and
orientation of the newly created \f[CR]XRReferenceSpace\f[R].
.SS Return value
A new \f[CR]XRReferenceSpace\f[R] object describing a reference space
with the same native origin as the reference space on which the method
was called, but with an origin offset indicating the distance from the
object to the point given by \f[CR]originOffset\f[R].
.PP
If the object on which you call this method is an
\f[CR]XRBoundedReferenceSpace\f[R], the returned object is one as well.
The \f[CR]boundsGeometry\f[R] of the new reference space is set to the
original object\[cq]s \f[CR]boundsGeometry\f[R] with each of its points
multiplied by the inverse of \f[CR]originOffset\f[R].
.SH EXAMPLES
Below are some examples showing how to use
\f[CR]getOffsetReferenceSpace()\f[R].
.SS Teleporting or setting the position of the viewer
Upon first creating a scene, you may need to set the user\[cq]s position
within the 3D world.
You can do that using \f[CR]getOffsetReferenceSpace()\f[R].
.IP
.EX
xrSession.requestReferenceSpace(\[dq]local\[dq]).then((refSpace) \f[B]=>\f[R] {
  xrReferenceSpace = refSpace;
  xrReferenceSpace = xrReferenceSpace.getOffsetReferenceSpace(
    \f[B]new\f[R] XRRigidTransform(startPosition, { x: 0, y: 0, z: 1.0, w: 1.0 }),
  );
  xrSession.requestAnimationFrame(drawFrame);
});
.EE
.PP
In this code, we obtain a local reference space, then use
\f[CR]getOffsetReferenceSpace()\f[R] to create a new space whose origin
is adjusted to a position given by \f[CR]startPosition\f[R] and whose
orientation is looking directly along the Z axis.
Then the first animation frame is requested using
\f[CR]XRSession\f[R]\[cq]s \f[CR]requestAnimationFrame()\f[R].
.SS Implementing rotation based on non\-XR inputs
The input controls supported directly by WebXR are all dedicated VR or
AR input devices.
In order to use mouse, keyboard, or other input devices to move or
otherwise transform objects in the 3D space\[em]or to allow the user to
move through the space\[em]you\[cq]ll need to write some code to read
the inputs and move perform the movements.
.PP
This is another good use case for \f[CR]getOffsetReferenceSpace()\f[R].
In this example, we\[cq]ll show code that lets the user look around by
right\-clicking and moving the mouse to change the viewing angle.
.PP
First, we add an event handler for \f[CR]mousemove\f[R] events, which
calls our code to perform the rotation if the right mouse button is
down.
Note also that we set \f[CR]oncontextmenu\f[R] up to be ignored by
calling \f[CR]preventDefault()\f[R] on those events.
This prevents the right\-clicks from causing the context menu from
appearing in the browser.
.IP
.EX
canvas.oncontextmenu = (event) \f[B]=>\f[R] {
  event.preventDefault();
};
canvas.addEventListener(\[dq]mousemove\[dq], (event) \f[B]=>\f[R] {
  \f[B]if\f[R] (event.buttons & 2) {
    rotateViewBy(event.movementX, event.movementY);
  }
});
.EE
.PP
Next, the \f[CR]rotateViewBy()\f[R] function, which updates the mouse
look direction\[cq]s yaw and pitch based on the mouse delta values from
the \f[CR]mousemove\f[R] event.
The pitch is restricted so that you can\[cq]t look beyond straight up
and straight down.
Each time this is called, the new offsets are used to update the current
values of \f[CR]mousePitch\f[R] and \f[CR]mouseYaw\f[R].
.IP
.EX
\f[B]let\f[R] mouseYaw = 0.0;
\f[B]let\f[R] mousePitch = 0.0;
\f[B]const\f[R] inverseOrientation = quat.create();
\f[B]const\f[R] MOUSE_SPEED = 0.003;

\f[B]function\f[R] rotateViewBy(dx, dy) {
  mouseYaw += dx * MOUSE_SPEED;
  mousePitch += dy * MOUSE_SPEED;

  \f[B]if\f[R] (mousePitch < \-Math.PI * 0.5) {
    mousePitch = \-Math.PI * 0.5;
  } \f[B]else\f[R] \f[B]if\f[R] (mousePitch > Math.PI * 0.5) {
    mousePitch = Math.PI * 0.5;
  }
}
.EE
.PP
Finally, we need code that actually applies the computed yaw and pitch
to the viewer\[cq]s orientation.
This function, \f[CR]applyMouseMovement()\f[R], handles that:
.IP
.EX
\f[B]function\f[R] applyMouseMovement(refSpace) {
  \f[B]if\f[R] (!mouseYaw && !mousePitch) {
    \f[B]return\f[R] refSpace;
  }

  quat.identity(inverseOrientation);
  quat.rotateX(inverseOrientation, inverseOrientation, \-mousePitch);
  quat.rotateY(inverseOrientation, inverseOrientation, \-mouseYaw);

  \f[B]let\f[R] newTransform = \f[B]new\f[R] XRRigidTransform(
    { x: 0, y: 0, z: 0 },
    {
      x: inverseOrientation[0],
      y: inverseOrientation[1],
      z: inverseOrientation[2],
      w: inverseOrientation[3],
    },
  );

  \f[B]return\f[R] refSpace.getOffsetReferenceSpace(newTransform);
}
.EE
.PP
This function creates an inverse orientation matrix\[em]used to orient
the viewer\[em]from the current pitch and yaw values, then uses that
matrix as the source of the orientation when calling
\f[CR]XRRigidTransform()\f[R].
The new \f[CR]XRRigidTransform\f[R]\[cq]s reference space is then
fetched and returned to the caller.
.PP
This new reference space is one in which the viewer\[cq]s position is
unchanged, but their orientation has been altered based on the pitch and
yaw values generated from the accumulated mouse inputs.
\f[CR]applyMouseMovement()\f[R] should be called when drawing a frame,
immediately before fetching the viewer\[cq]s pose using
\f[CR]getViewerPose()\f[R], and the rendering should be performed in
this reference space.
.PP
You can see code similar to this in use in our broader WebXR tutorial
article called Movement, orientation, and motion.
In particular, check out the section called Starting up the WebXR
session.
