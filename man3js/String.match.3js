.\" Automatically generated by Pandoc 3.4
.\"
.TH "String.match" "JS" "November 14, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.match \- String.prototype.match()
.SH SYNOPSIS
The \f[B]\f[CB]match()\f[B]\f[R] method of \f[CR]String\f[R] values
retrieves the result of matching this string against a regular
expression.
.SH SYNTAX
.IP
.EX
match(regexp)
.EE
.SS Parameters
.TP
\f[B]regexp\f[R]
A regular expression object, or any object that has a
\f[CR]Symbol.match\f[R] method.
.RS
.PP
If \f[CR]regexp\f[R] is not a \f[CR]RegExp\f[R] object and does not have
a \f[CR]Symbol.match\f[R] method, it is implicitly converted to a
\f[CR]RegExp\f[R] by using \f[CR]new RegExp(regexp)\f[R].
.PP
If you don\[cq]t give any parameter and use the \f[CR]match()\f[R]
method directly, you will get an \f[CR]Array\f[R] with an empty string:
\f[CR][\[dq]\[dq]]\f[R], because this is equivalent to
\f[CR]match(/(?:)/)\f[R].
.RE
.SS Return value
An \f[CR]Array\f[R] whose contents depend on the presence or absence of
the global (\f[CR]g\f[R]) flag, or \f[CR]null\f[R] if no matches are
found.
.IP \[bu] 2
If the \f[CR]g\f[R] flag is used, all results matching the complete
regular expression will be returned, but capturing groups are not
included.
.IP \[bu] 2
If the \f[CR]g\f[R] flag is not used, only the first complete match and
its related capturing groups are returned.
In this case, \f[CR]match()\f[R] will return the same result as
\f[CR]RegExp.prototype.exec()\f[R] (an array with some extra
properties).
.SH DESCRIPTION
The implementation of \f[CR]String.prototype.match\f[R] doesn\[cq]t do
much other than calling the \f[CR]Symbol.match\f[R] method of the
argument with the string as the first parameter.
The actual implementation comes from
\f[CR]RegExp.prototype[Symbol.match]()\f[R].
.IP \[bu] 2
If you need to know if a string matches a regular expression
\f[CR]RegExp\f[R], use \f[CR]RegExp.prototype.test()\f[R].
.IP \[bu] 2
If you only want the first match found, you might want to use
\f[CR]RegExp.prototype.exec()\f[R] instead.
.IP \[bu] 2
If you want to obtain capture groups and the global flag is set, you
need to use \f[CR]RegExp.prototype.exec()\f[R] or
\f[CR]String.prototype.matchAll()\f[R] instead.
.PP
For more information about the semantics of \f[CR]match()\f[R] when a
regex is passed, see \f[CR]RegExp.prototype[Symbol.match]()\f[R].
.SH EXAMPLES
.SS Using match()
In the following example, \f[CR]match()\f[R] is used to find
\f[CR]\[dq]Chapter\[dq]\f[R] followed by one or more numeric characters
followed by a decimal point and numeric character zero or more times.
.PP
The regular expression includes the \f[CR]i\f[R] flag so that
upper/lower case differences will be ignored.
.IP
.EX
\f[B]const\f[R] str = \[dq]For more information, see Chapter 3.4.5.1\[dq];
\f[B]const\f[R] re = /see (chapter \[rs]d+(\[rs].\[rs]d)*)/i;
\f[B]const\f[R] found = str.match(re);

console.log(found);
\f[I]// [\f[R]
\f[I]//   \[aq]see Chapter 3.4.5.1\[aq],\f[R]
\f[I]//   \[aq]Chapter 3.4.5.1\[aq],\f[R]
\f[I]//   \[aq].1\[aq],\f[R]
\f[I]//   index: 22,\f[R]
\f[I]//   input: \[aq]For more information, see Chapter 3.4.5.1\[aq],\f[R]
\f[I]//   groups: undefined\f[R]
\f[I]// ]\f[R]
.EE
.PP
In the match result above, \f[CR]\[aq]see Chapter 3.4.5.1\[aq]\f[R] is
the whole match.
\f[CR]\[aq]Chapter 3.4.5.1\[aq]\f[R] was captured by
\f[CR](chapter \[rs]d+(\[rs].\[rs]d)*)\f[R].
\f[CR]\[aq].1\[aq]\f[R] was the last value captured by
\f[CR](\[rs].\[rs]d)\f[R].
The \f[CR]index\f[R] property (\f[CR]22\f[R]) is the zero\-based index
of the whole match.
The \f[CR]input\f[R] property is the original string that was parsed.
.SS Using global and ignoreCase flags with match()
The following example demonstrates the use of the global flag and
ignore\-case flag with \f[CR]match()\f[R].
All letters \f[CR]A\f[R] through \f[CR]E\f[R] and \f[CR]a\f[R] through
\f[CR]e\f[R] are returned, each its own element in the array.
.IP
.EX
\f[B]const\f[R] str = \[dq]ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\[dq];
\f[B]const\f[R] regexp = /[A\-E]/gi;
\f[B]const\f[R] matches = str.match(regexp);

console.log(matches);
\f[I]// [\[aq]A\[aq], \[aq]B\[aq], \[aq]C\[aq], \[aq]D\[aq], \[aq]E\[aq], \[aq]a\[aq], \[aq]b\[aq], \[aq]c\[aq], \[aq]d\[aq], \[aq]e\[aq]]\f[R]
.EE
.RS
.PP
\f[B]Note:\f[R] See also \f[CR]String.prototype.matchAll()\f[R] and
Advanced searching with flags.
.RE
.SS Using named capturing groups
In browsers which support named capturing groups, the following code
captures \f[CR]\[dq]fox\[dq]\f[R] or \f[CR]\[dq]cat\[dq]\f[R] into a
group named \f[CR]animal\f[R]:
.IP
.EX
\f[B]const\f[R] paragraph = \[dq]The quick brown fox jumps over the lazy dog. It barked.\[dq];

\f[B]const\f[R] capturingRegex = /(?<animal>fox|cat) jumps over/;
\f[B]const\f[R] found = paragraph.match(capturingRegex);
console.log(found.groups); \f[I]// {animal: \[dq]fox\[dq]}\f[R]
.EE
.SS Using match() with no parameter
.IP
.EX
\f[B]const\f[R] str = \[dq]Nothing will come of nothing.\[dq];

str.match(); \f[I]// returns [\[dq]\[dq]]\f[R]
.EE
.SS Using match() with a non\-RegExp implementing \f[CR][Symbol.match]()\f[R]
If an object has a \f[CR]Symbol.match\f[R] method, it can be used as a
custom matcher.
The return value of \f[CR]Symbol.match\f[R] becomes the return value of
\f[CR]match()\f[R].
.IP
.EX
\f[B]const\f[R] str = \[dq]Hmm, this is interesting.\[dq];

str.match({
  [Symbol.match](str) {
    \f[B]return\f[R] [\[dq]Yes, it\[aq]s interesting.\[dq]];
  },
}); \f[I]// returns [\[dq]Yes, it\[aq]s interesting.\[dq]]\f[R]
.EE
.SS A non\-RegExp as the parameter
When the \f[CR]regexp\f[R] parameter is a string or a number, it is
implicitly converted to a \f[CR]RegExp\f[R] by using
\f[CR]new RegExp(regexp)\f[R].
.IP
.EX
\f[B]const\f[R] str1 =
  \[dq]NaN means not a number. Infinity contains \-Infinity and +Infinity in JavaScript.\[dq];
\f[B]const\f[R] str2 =
  \[dq]My grandfather is 65 years old and My grandmother is 63 years old.\[dq];
\f[B]const\f[R] str3 = \[dq]The contract was declared null and void.\[dq];
str1.match(\[dq]number\[dq]); \f[I]// \[dq]number\[dq] is a string. returns [\[dq]number\[dq]]\f[R]
str1.match(\f[B]NaN\f[R]); \f[I]// the type of NaN is the number. returns [\[dq]NaN\[dq]]\f[R]
str1.match(\f[B]Infinity\f[R]); \f[I]// the type of Infinity is the number. returns [\[dq]Infinity\[dq]]\f[R]
str1.match(+\f[B]Infinity\f[R]); \f[I]// returns [\[dq]Infinity\[dq]]\f[R]
str1.match(\-\f[B]Infinity\f[R]); \f[I]// returns [\[dq]\-Infinity\[dq]]\f[R]
str2.match(65); \f[I]// returns [\[dq]65\[dq]]\f[R]
str2.match(+65); \f[I]// A number with a positive sign. returns [\[dq]65\[dq]]\f[R]
str3.match(\f[B]null\f[R]); \f[I]// returns [\[dq]null\[dq]]\f[R]
.EE
.PP
This may have unexpected results if special characters are not properly
escaped.
.IP
.EX
console.log(\[dq]123\[dq].match(\[dq]1.3\[dq])); \f[I]// [ \[dq]123\[dq] ]\f[R]
.EE
.PP
This is a match because \f[CR].\f[R] in a regex matches any character.
In order to make it only match specifically a dot character, you need to
escape the input.
.IP
.EX
console.log(\[dq]123\[dq].match(\[dq]1\[rs]\[rs].3\[dq])); \f[I]// null\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-string-and-regexp
Polyfill of \f[CR]String.prototype.match\f[R] in \f[CR]core\-js\f[R]
with fixes and implementation of modern behavior like
\f[CR]Symbol.match\f[R] support
.UE \c
.IP \[bu] 2
\f[CR]String.prototype.matchAll()\f[R]
.IP \[bu] 2
\f[CR]RegExp\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.exec()\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.test()\f[R]
