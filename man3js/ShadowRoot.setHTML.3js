.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "SHADOWROOT.SETHTML" "3JS" "June 8, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ShadowRoot.setHTML \- ShadowRoot: setHTML() method
.SH SYNOPSIS
The \f[B]\f[CB]setHTML()\f[B]\f[R] method of the \f[CR]ShadowRoot\f[R]
interface provides an XSS\-safe method to parse and sanitize a string of
HTML into a \f[CR]DocumentFragment\f[R], which then replaces the
existing tree in the Shadow DOM.
.SH SYNTAX
.IP
.EX
setHTML(input)
setHTML(input, options)
.EE
.SS Parameters
.TP
\f[B]input\f[R]
A string defining HTML to be sanitized and injected into the shadow
root.
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An options object with the following optional parameters:
.RS
.TP
\f[B]sanitizer\f[R]
A \f[CR]Sanitizer\f[R] or \f[CR]SanitizerConfig\f[R] object which
defines what elements of the input will be allowed or removed, or the
string \f[CR]\(dqdefault\(dq\f[R] for the default sanitizer
configuration.
Note that generally a \f[CR]\(dqSanitizer\f[R] is expected to be more
efficient than a \f[CR]SanitizerConfig\f[R] if the configuration is to
reused.
If not specified, the default sanitizer configuration is used.
.RE
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.TP
\f[B]TypeError\f[R]
This is thrown if \f[CR]options.sanitizer\f[R] is passed a:
.RS
.IP \(bu 2
non\-normalized \f[CR]SanitizerConfig\f[R] (one that includes both
\(lqallowed\(rq and \(lqremoved\(rq configuration settings).
.IP \(bu 2
string that does not have the value \f[CR]\(dqdefault\(dq\f[R].
.IP \(bu 2
value that is not a \f[CR]Sanitizer\f[R], \f[CR]SanitizerConfig\f[R], or
string.
.RE
.SH DESCRIPTION
The \f[B]\f[CB]setHTML()\f[B]\f[R] method provides an XSS\-safe method
to parse and sanitize a string of HTML and use it to replace the
existing tree in the Shadow DOM.
.PP
\f[CR]setHTML()\f[R] removes any HTML entities that aren\(cqt allowed by
the sanitizer configuration, and further removes any XSS\-unsafe
elements or attributes \(em whether or not they are allowed by the
sanitizer configuration.
.PP
If no sanitizer configuration is specified in the
\f[CR]options.sanitizer\f[R] parameter, \f[CR]setHTML()\f[R] is used
with the default \f[CR]Sanitizer\f[R] configuration.
This configuration allows all elements and attributes that are
considered XSS\-safe, thereby disallowing entities that are considered
unsafe.
A custom sanitizer or sanitizer configuration can be specified to choose
which elements, attributes, and comments are allowed or removed.
Note that even if unsafe options are allowed by the sanitizer
configuration, they will still be removed when using this method (which
implicitly calls \f[CR]Sanitizer.removeUnsafe()\f[R]).
.PP
\f[CR]setHTML()\f[R] should be used instead of
\f[CR]ShadowRoot.innerHTML\f[R] for inserting untrusted strings of HTML
into the shadow DOM.
It should also be used instead of \f[CR]ShadowRoot.setHTMLUnsafe()\f[R],
unless there is a specific need to allow unsafe elements and attributes.
.PP
Note that since this method always sanitizes input strings of
XSS\-unsafe entities, it is not secured or validated using the Trusted
Types API.
.SH EXAMPLES
.SS Basic usage
This example shows some of the ways you can use \f[CR]setHTML()\f[R] to
sanitize and inject a string of HTML.
.PP
First we will create the \f[CR]ShadowRoot\f[R] we want to target.
This could be created programmatically using
\f[CR]Element.attachShadow()\f[R] but for this example we\(cqll create
the root declaratively.
.IP
.EX
<\f[B]div\f[R] id=\(dqhost\(dq>
  <\f[B]template\f[R] shadowrootmode=\(dqopen\(dq>
    <\f[B]span\f[R]>A span element in the shadow DOM</\f[B]span\f[R]>
  </\f[B]template\f[R]>
</\f[B]div\f[R]>
.EE
.PP
We can get a handle to the shadow root from the \f[CR]#host\f[R] element
like this:
.IP
.EX
\f[B]const\f[R] shadow = document.querySelector(\(dq#host\(dq).shadowRoot;
.EE
.PP
The code below shows how we can call \f[CR]setHTML()\f[R] with a string
and different sanitizers in order to filter and inject the HTML into the
shadow root.
.IP
.EX
\f[I]// Define unsanitized string of HTML\f[R]
\f[B]const\f[R] unsanitizedString = \(dqabc <script>alert(1)<\(dq + \(dq/script> def\(dq;

\f[I]// setHTML() with default sanitizer\f[R]
shadow.setHTML(unsanitizedString);

\f[I]// Define custom Sanitizer and use in setHTML()\f[R]
\f[I]// This allows only elements: <div>, <p>, <span> (<script> is unsafe and will be removed)\f[R]
\f[B]const\f[R] sanitizer1 = \f[B]new\f[R] Sanitizer({ elements: [\(dqdiv\(dq, \(dqp\(dq, \(dqspan\(dq, \(dqscript\(dq] });
shadow.setHTML(unsanitizedString, { sanitizer: sanitizer1 });

\f[I]// Define custom SanitizerConfig within setHTML()\f[R]
\f[I]// This removes elements <div>, <p>, <span>, <script>, and any other unsafe elements/attributes\f[R]
shadow.setHTML(unsanitizedString, {
  sanitizer: { removeElements: [\(dqdiv\(dq, \(dqp\(dq, \(dqspan\(dq, \(dqscript\(dq] },
});
.EE
.SS \f[CR]setHTML()\f[R] live example
This example provides a \(lqlive\(rq demonstration of the method when
called with different sanitizers.
The code defines buttons that you can click to sanitize and inject a
string of HTML using a default and a custom sanitizer, respectively.
The original string and sanitized HTML are logged so you can inspect the
results in each case.
.SS HTML
The HTML defines two \f[CR]<button>\f[R] elements for applying different
sanitizers, another button to reset the example, and a \f[CR]<div>\f[R]
that contains the declarative shadow root.
.IP
.EX
<\f[B]button\f[R] id=\(dqbuttonDefault\(dq type=\(dqbutton\(dq>Default</\f[B]button\f[R]>
<\f[B]button\f[R] id=\(dqbuttonAllowScript\(dq type=\(dqbutton\(dq>allowScript</\f[B]button\f[R]>
<\f[B]button\f[R] id=\(dqreload\(dq type=\(dqbutton\(dq>Reload</\f[B]button\f[R]>

<\f[B]div\f[R] id=\(dqhost\(dq>
  <\f[B]template\f[R] shadowrootmode=\(dqopen\(dq>
    <\f[B]span\f[R]>I am in the shadow DOM </\f[B]span\f[R]>
  </\f[B]template\f[R]>
</\f[B]div\f[R]>
.EE
.SS JavaScript
First we define the handler for the reload button.
.IP
.EX
\f[B]const\f[R] reload = document.querySelector(\(dq#reload\(dq);
reload.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] document.location.reload());
.EE
.PP
Then we define the string to sanitize, which will be the same for all
cases.
This contains the \f[CR]<script>\f[R] element and the \f[CR]onclick\f[R]
handler, both of which are considered XSS\-unsafe.
We also get variable \f[CR]shadow\f[R], which is our handle to the
shadow root.
.IP
.EX
\f[I]// Define unsafe string of HTML\f[R]
\f[B]const\f[R] unsanitizedString = \(ga
  <div>
    <p>Paragraph to inject into shadow DOM. <button onclick=\(dqalert(\(aqYou clicked the button!\(aq)\(dq>Click me</button></p>
    <script src=\(dqpath/to/a/module.js\(dq type=\(dqmodule\(dq><script>
  </div>
\(ga;

\f[B]const\f[R] shadow = document.querySelector(\(dq#host\(dq).shadowRoot;
.EE
.PP
Next we define the click handler for the button that sets the shadow
root with the default sanitizer.
This should strip out all unsafe entities before inserting the string of
HTML.
Note that you can see exactly which elements are removed in the
\f[CR]Sanitizer()\f[R] constructor examples.
.IP
.EX
\f[B]const\f[R] defaultSanitizerButton = document.querySelector(\(dq#buttonDefault\(dq);
defaultSanitizerButton.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
  \f[I]// Set the content of the element using the default sanitizer\f[R]
  shadow.setHTML(unsanitizedString);

  \f[I]// Log HTML before sanitization and after being injected\f[R]
  logElement.textContent =
    \(dqDefault sanitizer: remove &lt;script&gt; element and onclick attribute\(rsn\(rsn\(dq;
  log(\(ga\(rsnunsanitized: ${unsanitizedString}\(ga);
  log(\(ga\(rsnsanitized: ${shadow.innerHTML}\(ga);
});
.EE
.PP
The next click handler sets the target HTML using a custom sanitizer
that allows only \f[CR]<div>\f[R], \f[CR]<p>\f[R], and
\f[CR]<script>\f[R] elements.
Note that because we\(cqre using the \f[CR]setHTML\f[R] method,
\f[CR]<script>\f[R] will also be removed!
.IP
.EX
\f[B]const\f[R] allowScriptButton = document.querySelector(\(dq#buttonAllowScript\(dq);
allowScriptButton.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
  \f[I]// Set the content of the element using a custom sanitizer\f[R]
  \f[B]const\f[R] sanitizer1 = \f[B]new\f[R] Sanitizer({
    elements: [\(dqdiv\(dq, \(dqp\(dq, \(dqscript\(dq],
  });
  shadow.setHTML(unsanitizedString, { sanitizer: sanitizer1 });

  \f[I]// Log HTML before sanitization and after being injected\f[R]
  logElement.textContent =
    \(dqSanitizer: {elements: [\(aqdiv\(aq, \(aqp\(aq, \(aqscript\(aq]}\(rsn Script removed even though allowed\(rsn\(dq;
  log(\(ga\(rsnunsanitized: ${unsanitizedString}\(ga);
  log(\(ga\(rsnsanitized: ${shadow.innerHTML}\(ga);
});
.EE
.SS Results
Click the \(lqDefault\(rq and \(lqallowScript\(rq buttons to see the
effects of the default and custom sanitizer, respectively.
Note that because we are using a same sanitization method, in both cases
the \f[CR]<script>\f[R] element and \f[CR]onclick\f[R] handler are
removed, even if explicitly allowed by the sanitizer.
.SH SEE ALSO
.IP \(bu 2
\f[CR]ShadowRoot.setHTMLUnsafe()\f[R]
.IP \(bu 2
\f[CR]Element.setHTML()\f[R] and \f[CR]Element.setHTMLUnsafe()\f[R]
.IP \(bu 2
\f[CR]Document.parseHTML()\f[R] and
\f[CR]Document.parseHTMLUnsafe()\f[R]
.IP \(bu 2
HTML Sanitizer API
