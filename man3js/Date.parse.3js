'\" t
.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Date.parse" "JS" "February 16, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Date.parse \- Date.parse()
.SH SYNOPSIS
The \f[B]\f[CB]Date.parse()\f[B]\f[R] static method parses a string
representation of a date, and returns the date\[cq]s timestamp.
.IP
.EX
\f[I]// Standard date\-time string format\f[R]
\f[B]const\f[R] unixTimeZero = Date.parse(\[dq]1970\-01\-01T00:00:00Z\[dq]);
\f[I]// Non\-standard format resembling toUTCString()\f[R]
\f[B]const\f[R] javaScriptRelease = Date.parse(\[dq]04 Dec 1995 00:12:00 GMT\[dq]);

console.log(unixTimeZero);
\f[I]// Expected output: 0\f[R]

console.log(javaScriptRelease);
\f[I]// Expected output: 818035920000\f[R]
.EE
.SH SYNTAX
.IP
.EX
Date.parse(dateString)
.EE
.SS Parameters
.TP
\f[B]dateString\f[R]
A string in the date time string format.
See the linked reference for caveats on using different formats.
.SS Return value
A number representing the timestamp of the given date.
If \f[CR]dateString\f[R] fails to be parsed as a valid date,
\f[CR]NaN\f[R] is returned.
.SH DESCRIPTION
This function is useful for setting date values based on string values,
for example in conjunction with the \f[CR]setTime()\f[R] method.
.PP
The formats that \f[CR]parse()\f[R] can handle are not explicitly
specified, but there are a few invariants:
.IP \[bu] 2
The date time string format (produced by \f[CR]toISOString()\f[R]) must
be supported.
.IP \[bu] 2
If \f[CR]x\f[R] is any Date whose milliseconds amount is zero, then
\f[CR]x.valueOf()\f[R] should be equal to any of the following:
\f[CR]Date.parse(x.toString())\f[R],
\f[CR]Date.parse(x.toUTCString())\f[R],
\f[CR]Date.parse(x.toISOString())\f[R].
This means the formats produced by \f[CR]toString()\f[R] and
\f[CR]toUTCString()\f[R] should be supported too.
.IP \[bu] 2
The spec does \f[I]not\f[R] require support for the format produced by
\f[CR]toLocaleString()\f[R].
However, major engines all try to support
\f[CR]toLocaleString(\[dq]en\-US\[dq])\f[R] format.
.PP
Other formats are implementation\-defined and may not work across all
browsers.
A library can help if many different formats are to be accommodated.
In fact, the unreliability of \f[CR]Date.parse()\f[R] is one of the
motivations for the \f[CR]Temporal\f[R] API to be introduced.
.PP
Because \f[CR]parse()\f[R] is a static method of \f[CR]Date\f[R], you
always use it as \f[CR]Date.parse()\f[R], rather than as a method of a
\f[CR]Date\f[R] object you created.
.SH EXAMPLES
.SS Using Date.parse()
The following calls all return \f[CR]1546300800000\f[R].
The first will imply UTC time because it\[cq]s date\-only, and the
others explicitly specify the UTC timezone.
.IP
.EX
Date.parse(\[dq]2019\-01\-01\[dq]);
Date.parse(\[dq]2019\-01\-01T00:00:00.000Z\[dq]);
Date.parse(\[dq]2019\-01\-01T00:00:00.000+00:00\[dq]);
.EE
.PP
The following call, which does not specify a time zone will be set to
2019\-01\-01 at 00:00:00 in the local timezone of the system, because it
has both date and time.
.IP
.EX
Date.parse(\[dq]2019\-01\-01T00:00:00\[dq]);
.EE
.SS toString() and toUTCString() formats
Apart from the standard date time string format, the
\f[CR]toString()\f[R] and \f[CR]toUTCString()\f[R] formats are
supported:
.IP
.EX
\f[I]// toString() format\f[R]
Date.parse(\[dq]Thu Jan 01 1970 00:00:00 GMT\-0500 (Eastern Standard Time)\[dq]);
\f[I]// 18000000 in all implementations in all timezones\f[R]

\f[I]// toUTCString() format\f[R]
Date.parse(\[dq]Thu, 01 Jan 1970 00:00:00 GMT\[dq]);
\f[I]// 0 in all implementations in all timezones\f[R]
.EE
.SS Non\-standard date strings
.RS
.PP
\f[B]Note:\f[R] This section contains implementation\-specific behavior
that may be inconsistent across browsers or different versions of
browsers.
It is not meant to be a comprehensive browser compatibility table and
you should always conduct your own tests before using any format in your
code.
.RE
.PP
Implementations usually default to the local time zone when the date
string is non\-standard.
For consistency, we will assume that the runtime uses the UTC timezone,
and unless specified otherwise, the output will vary with the
device\[cq]s time zone.
Daylight Saving Time (DST), of the local time zone, can also have an
effect on this.
.PP
Here are some more examples of non\-standard date strings.
Browsers are very lenient when parsing date strings and may discard any
part of a string that they cannot parse.
For compatibility reasons, browsers often copy each other\[cq]s
behavior, so these handling patterns tend to propagate cross\-browser.
As previously stated, the following examples are for illustration only,
and are not exhaustive by any means:
.PP
.TS
tab(@);
lw(14.0n) lw(14.0n) lw(14.0n) lw(14.0n) lw(14.0n).
T{
Description
T}@T{
Example
T}@T{
Chrome
T}@T{
Firefox
T}@T{
Safari
T}
_
T{
Single number
T}@T{
\f[CR]0\f[R] (single\-digit)
T}@T{
946684800000 (Jan 01 2000); NaN in Firefox ≤122
T}@T{
T}@T{
\-62167219200000 (Jan 01 0000)
T}
T{
T}@T{
\f[CR]31\f[R] (two\-digit)
T}@T{
NaN
T}@T{
T}@T{
\-61188912000000 (Jan 01 0031)
T}
T{
T}@T{
\f[CR]999\f[R] (three\-/four\-digit)
T}@T{
\-30641733102000 (Jan 01 0999)
T}@T{
T}@T{
T}
T{
Date strings that use different separators
T}@T{
\f[CR]1970\-01\-01\f[R] (standard)
T}@T{
0 in all time zones
T}@T{
T}@T{
T}
T{
T}@T{
\f[CR]1970/01/01\f[R]
T}@T{
0
T}@T{
T}@T{
T}
T{
T}@T{
\f[CR]1970,01,01\f[R]
T}@T{
0
T}@T{
T}@T{
NaN
T}
T{
T}@T{
\f[CR]1970 01 01\f[R]
T}@T{
0
T}@T{
T}@T{
NaN
T}
T{
Strings that look like \f[CR]toString()\f[R]
T}@T{
\f[CR]Thu\ Jan\ 01\ 1970\ 00:00:00\f[R]
.PD 0
.P
.PD
\f[CR]Thu Jan 01 1970\f[R]
.PD 0
.P
.PD
\f[CR]Jan 01 1970 00:00:00\f[R]
.PD 0
.P
.PD
\f[CR]Jan 01 1970\f[R]
T}@T{
0
T}@T{
T}@T{
T}
T{
Strings that look like \f[CR]toUTCString()\f[R]
T}@T{
\f[CR]Thu, 01 Jan 1970 00:00:00\f[R]
.PD 0
.P
.PD
\f[CR]Thu, 01 Jan 1970\f[R]
.PD 0
.P
.PD
\f[CR]01 Jan 1970 00:00:00\f[R]
.PD 0
.P
.PD
\f[CR]01 Jan 1970\f[R]
T}@T{
0
T}@T{
T}@T{
T}
T{
First date component is 2\-digit
T}@T{
\f[CR]01\-02\-03\f[R] (first segment can be valid month)
T}@T{
1041465600000 (Jan 02 2003)
T}@T{
T}@T{
\-62132745600000 (Feb 03 0001)
.PD 0
.P
.PD
Note: Safari always assumes YY\-MM\-DD, but MM/DD/YY.
T}
T{
T}@T{
\f[CR]27\-02\-03\f[R] (first segment can be valid day but not month)
T}@T{
NaN
T}@T{
T}@T{
\-61312291200000 (Feb 03 0027)
T}
T{
T}@T{
\f[CR]49\-02\-03\f[R] (first segment cannot be valid day and is <50)
T}@T{
2495923200000 (Feb 03 2049)
T}@T{
T}@T{
\-60617980800000 (Feb 03 0049)
T}
T{
T}@T{
\f[CR]50\-02\-03\f[R] (first segment cannot be valid day and is ≥50)
T}@T{
\-628300800000 (Feb 03 1950)
T}@T{
T}@T{
\-60586444800000 (Feb 03 0050)
T}
T{
Out\-of\-bounds date components
T}@T{
\f[CR]2014\-25\-23\f[R]
.PD 0
.P
.PD
\f[CR]Mar 32, 2014\f[R]
.PD 0
.P
.PD
\f[CR]2014/25/23\f[R]
T}@T{
NaN
T}@T{
T}@T{
T}
T{
T}@T{
\f[CR]2014\-02\-30\f[R]
T}@T{
1393718400000 (Mar 02 2014)
T}@T{
T}@T{
NaN
T}
T{
T}@T{
\f[CR]02/30/2014\f[R]
T}@T{
1393718400000
T}@T{
T}@T{
T}
T{
Extraneous characters after the month name
T}@T{
\f[CR]04 Dec 1995\f[R]
.PD 0
.P
.PD
\f[CR]04 Decem 1995\f[R]
.PD 0
.P
.PD
\f[CR]04 December 1995\f[R]
T}@T{
818031600000
T}@T{
T}@T{
T}
T{
T}@T{
\f[CR]04 DecFoo 1995\f[R]
T}@T{
818031600000
.PD 0
.P
.PD
Only the first three characters are read.
.PD 0
.P
.PD
Firefox ≤121 reads up to the valid month name, thus returning NaN when
it sees \[dq]F\[dq].
T}@T{
T}@T{
T}
T{
T}@T{
\f[CR]04 De 1995\f[R]
T}@T{
NaN
T}@T{
T}@T{
T}
.TE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Date.UTC()\f[R]
