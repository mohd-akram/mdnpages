.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Array.slice" "JS" "August 1, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.slice \- Array.prototype.slice()
.SH SYNOPSIS
The \f[B]\f[CB]slice()\f[B]\f[R] method of \f[CR]Array\f[R] instances
returns a shallow copy of a portion of an array into a new array object
selected from \f[CR]start\f[R] to \f[CR]end\f[R] (\f[CR]end\f[R] not
included) where \f[CR]start\f[R] and \f[CR]end\f[R] represent the index
of items in that array.
The original array will not be modified.
.SH SYNTAX
.IP
.EX
slice()
slice(start)
slice(start, end)
.EE
.SS Parameters
.TP
\f[B]start\f[R] \f[I](optional)\f[R]
Zero\-based index at which to start extraction, converted to an integer.
.RS
.IP \[bu] 2
Negative index counts back from the end of the array \[em] if
\f[CR]\-array.length <= start < 0\f[R], \f[CR]start + array.length\f[R]
is used.
.IP \[bu] 2
If \f[CR]start < \-array.length\f[R] or \f[CR]start\f[R] is omitted,
\f[CR]0\f[R] is used.
.IP \[bu] 2
If \f[CR]start >= array.length\f[R], an empty array is returned.
.RE
.TP
\f[B]end\f[R] \f[I](optional)\f[R]
Zero\-based index at which to end extraction, converted to an integer.
\f[CR]slice()\f[R] extracts up to but not including \f[CR]end\f[R].
.RS
.IP \[bu] 2
Negative index counts back from the end of the array \[em] if
\f[CR]\-array.length <= end < 0\f[R], \f[CR]end + array.length\f[R] is
used.
.IP \[bu] 2
If \f[CR]end < \-array.length\f[R], \f[CR]0\f[R] is used.
.IP \[bu] 2
If \f[CR]end >= array.length\f[R] or \f[CR]end\f[R] is omitted,
\f[CR]array.length\f[R] is used, causing all elements until the end to
be extracted.
.IP \[bu] 2
If \f[CR]end\f[R] implies a position before or at the position that
\f[CR]start\f[R] implies, an empty array is returned.
.RE
.SS Return value
A new array containing the extracted elements.
.SH DESCRIPTION
The \f[CR]slice()\f[R] method is a copying method.
It does not alter \f[CR]this\f[R] but instead returns a shallow copy
that contains some of the same elements as the ones from the original
array.
.PP
The \f[CR]slice()\f[R] method preserves empty slots.
If the sliced portion is sparse, the returned array is sparse as well.
.PP
The \f[CR]slice()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
.SH EXAMPLES
.SS Return a portion of an existing array
.IP
.EX
\f[B]const\f[R] fruits = [\[dq]Banana\[dq], \[dq]Orange\[dq], \[dq]Lemon\[dq], \[dq]Apple\[dq], \[dq]Mango\[dq]];
\f[B]const\f[R] citrus = fruits.slice(1, 3);

\f[I]// fruits contains [\[aq]Banana\[aq], \[aq]Orange\[aq], \[aq]Lemon\[aq], \[aq]Apple\[aq], \[aq]Mango\[aq]]\f[R]
\f[I]// citrus contains [\[aq]Orange\[aq],\[aq]Lemon\[aq]]\f[R]
.EE
.PP
In this example, \f[CR]slice(1, 3)\f[R] extracts elements from index
\f[CR]1\f[R] up to, but not including, index \f[CR]3\f[R], resulting in
a new array \f[CR][\[aq]Orange\[aq], \[aq]Lemon\[aq]]\f[R].
.SS Omitting the end parameter
.IP
.EX
\f[B]const\f[R] fruits = [\[dq]Apple\[dq], \[dq]Banana\[dq], \[dq]Orange\[dq], \[dq]Mango\[dq], \[dq]Pineapple\[dq]];

\f[B]const\f[R] tropical = fruits.slice(2);
console.log(tropical); \f[I]// [\[aq]Orange\[aq], \[aq]Mango\[aq], \[aq]Pineapple\[aq]]\f[R]
.EE
.PP
In this example, \f[CR]slice(2)\f[R] extracts elements from index
\f[CR]2\f[R] to the end of the array.
.SS Using negative indices
.IP
.EX
\f[B]const\f[R] fruits = [\[dq]Apple\[dq], \[dq]Banana\[dq], \[dq]Orange\[dq], \[dq]Mango\[dq], \[dq]Pineapple\[dq]];

\f[B]const\f[R] lastTwo = fruits.slice(\-2);
console.log(lastTwo); \f[I]// [\[aq]Mango\[aq], \[aq]Pineapple\[aq]]\f[R]
.EE
.PP
In this example, \f[CR]slice(\-2)\f[R] extracts the last two elements of
the array.
When using a negative index with the \f[CR]slice\f[R] method, negative
indices are counted from the end of the array, starting at
\f[CR]\-1\f[R] for the last element, \f[CR]\-2\f[R] for the
second\-to\-last element, and so on.
The negative index \f[CR]\-2\f[R] itself is included because it is the
starting point of the extraction.
.IP
.EX
|     |     |     |     |     |
|  S  |  L  |  I  |  C  |  E  |
|     |     |     |     |     |
  \-5    \-4    \-3    \-2    \-1

<\-\-\- read from reverse
.EE
.SS Using a positive start index and a negative end index
.IP
.EX
\f[B]const\f[R] fruits = [\[dq]Apple\[dq], \[dq]Banana\[dq], \[dq]Orange\[dq], \[dq]Mango\[dq], \[dq]Pineapple\[dq]];

\f[I]// Using positive start index and negative end index\f[R]
\f[B]const\f[R] sliceExample = fruits.slice(1, \-1);
console.log(sliceExample); \f[I]// [\[aq]Banana\[aq], \[aq]Orange\[aq], \[aq]Mango\[aq]]\f[R]
.EE
.PP
In this example, \f[CR]slice(1, \-1)\f[R] starts extracting from index
\f[CR]1\f[R] and goes up to, but does not include, the element at index
\f[CR]\-1\f[R] (which is the last element).
This results in a new array with
\f[CR][\[aq]Banana\[aq], \[aq]Orange\[aq], \[aq]Mango\[aq]]\f[R].
The \f[CR]slice\f[R] method always excludes the element at the final
index specified, regardless of whether it is positive or negative.
.IP
.EX
read from start \-\-\->

   0     1     2     3     4
|     |     |     |     |     |
|  S  |  L  |  I  |  C  |  E  |
|     |     |     |     |     |
  \-5    \-4    \-3    \-2    \-1

<\-\-\- read from reverse
.EE
.SS Using slice with arrays of objects
In the following example, \f[CR]slice\f[R] creates a new array,
\f[CR]newCar\f[R], from \f[CR]myCar\f[R].
Both include a reference to the object \f[CR]myHonda\f[R].
When the color of \f[CR]myHonda\f[R] is changed to purple, both arrays
reflect the change.
.IP
.EX
\f[I]// Using slice, create newCar from myCar.\f[R]
\f[B]const\f[R] myHonda = {
  color: \[dq]red\[dq],
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
\f[B]const\f[R] myCar = [myHonda, 2, \[dq]cherry condition\[dq], \[dq]purchased 1997\[dq]];
\f[B]const\f[R] newCar = myCar.slice(0, 2);

console.log(\[dq]myCar =\[dq], myCar);
console.log(\[dq]newCar =\[dq], newCar);
console.log(\[dq]myCar[0].color =\[dq], myCar[0].color);
console.log(\[dq]newCar[0].color =\[dq], newCar[0].color);

\f[I]// Change the color of myHonda.\f[R]
myHonda.color = \[dq]purple\[dq];
console.log(\[dq]The new color of my Honda is\[dq], myHonda.color);

console.log(\[dq]myCar[0].color =\[dq], myCar[0].color);
console.log(\[dq]newCar[0].color =\[dq], newCar[0].color);
.EE
.PP
This script writes:
.IP
.EX
myCar = [
  { color: \[aq]red\[aq], wheels: 4, engine: { cylinders: 4, size: 2.2 } },
  2,
  \[aq]cherry condition\[aq],
  \[aq]purchased 1997\[aq]
]
newCar = [ { color: \[aq]red\[aq], wheels: 4, engine: { cylinders: 4, size: 2.2 } }, 2 ]
myCar[0].color = red
newCar[0].color = red
The new color of my Honda is purple
myCar[0].color = purple
newCar[0].color = purple
.EE
.SS Calling slice() on non\-array objects
The \f[CR]slice()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R].
It then reads the integer\-keyed properties from \f[CR]start\f[R] to
\f[CR]end\f[R] and defines them on a newly created array.
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
  3: 33, \f[I]// ignored by slice() since length is 3\f[R]
};
console.log(Array.prototype.slice.call(arrayLike, 1, 3));
\f[I]// [ 3, 4 ]\f[R]
.EE
.SS Using slice() to convert array\-like objects to arrays
The \f[CR]slice()\f[R] method is often used with \f[CR]bind()\f[R] and
\f[CR]call()\f[R] to create a utility method that converts an
array\-like object into an array.
.IP
.EX
\f[I]// slice() is called with \[ga]this\[ga] passed as the first argument\f[R]
\f[B]const\f[R] slice = Function.prototype.call.bind(Array.prototype.slice);

\f[B]function\f[R] list() {
  \f[B]return\f[R] slice(\f[B]arguments\f[R]);
}

\f[B]const\f[R] list1 = list(1, 2, 3); \f[I]// [1, 2, 3]\f[R]
.EE
.SS Using slice() on sparse arrays
The array returned from \f[CR]slice()\f[R] may be sparse if the source
is sparse.
.IP
.EX
console.log([1, 2, , 4, 5].slice(1, 4)); \f[I]// [2, empty, 4]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype.slice\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Indexed collections guide
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.pop()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.shift()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.concat()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.splice()\f[R]
.IP \[bu] 2
\f[CR]TypedArray.prototype.slice()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.slice()\f[R]
