.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPUDEVICE.CREATEBINDGROUPLAYOUT" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPUDevice.createBindGroupLayout \- GPUDevice: createBindGroupLayout()
method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]createBindGroupLayout()\f[B]\f[R] method of the
\f[CR]GPUDevice\f[R] interface creates a \f[CR]GPUBindGroupLayout\f[R]
that defines the structure and purpose of related GPU resources such as
buffers that will be used in a pipeline, and is used as a template when
creating \f[CR]GPUBindGroup\f[R]s.
.SH SYNTAX
.IP
.EX
createBindGroupLayout(descriptor)
.EE
.SS Parameters
.TP
\f[B]descriptor\f[R]
An object containing the following properties:
.RS
.TP
\f[B]entries\f[R]
An array of entry objects, each one of which describes a single shader
resource binding to be included in the \f[CR]GPUBindGroupLayout\f[R].
Each entry will correspond to an entry defined in a
\f[CR]GPUBindGroup\f[R] (created via a
\f[CR]GPUDevice.createBindGroup()\f[R] call) that uses this
\f[CR]GPUBindGroupLayout\f[R] object as a template.
.TP
\f[B]label\f[R] \f[I](optional)\f[R]
A string providing a label that can be used to identify the object, for
example in \f[CR]GPUError\f[R] messages or console warnings.
.RE
.SS Entry objects
An entry object includes the following properties:
.TP
\f[B]binding\f[R]
A number representing a unique identifier for this particular entry,
which matches the \f[CR]binding\f[R] value of a corresponding
\f[CR]GPUBindGroup\f[R] entry.
In addition, it matches the \f[CR]n\f[R] index value of the
corresponding \c
.UR https://gpuweb.github.io/gpuweb/wgsl/#attribute-binding
\f[CR]\(atbinding(n)\f[R]
.UE \c
\ attribute in the shader (\f[CR]GPUShaderModule\f[R]) used in the
related pipeline.
.TP
\f[B]visibility\f[R]
One or more bitwise flags defining the shader stages that a
\f[CR]GPUBindGroup\f[R] entry corresponding to this entry will be
visible to.
Possible values are:
.RS
.IP \(bu 2
\f[CR]GPUShaderStage.COMPUTE\f[R]: The bind group entry will be
accessible to compute shaders.
.IP \(bu 2
\f[CR]GPUShaderStage.FRAGMENT\f[R]: The bind group entry will be
accessible to fragment shaders.
.IP \(bu 2
\f[CR]GPUShaderStage.VERTEX\f[R]: The bind group entry will be
accessible to vertex shaders.
.PP
Note that multiple stages can be specified by separating values with
bitwise OR, for example:
\f[CR]GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX\f[R].
.RE
.TP
\(lqResource layout object\(rq
An object that defines the required binding resource type and structure
of the \f[CR]GPUBindGroup\f[R] entry corresponding to this entry.
This property can be one of \f[CR]buffer\f[R],
\f[CR]externalTexture\f[R], \f[CR]sampler\f[R],
\f[CR]storageTexture\f[R], or \f[CR]texture\f[R], the object structures
of which are described in the next section.
.SS Resource layout objects
The resource layout object can be one of the following (see also
\f[CR]GPUDevice.createBindGroup()\f[R] for details of how the required
resources for each entry are structured):
.IP \(bu 2
\f[CR]buffer\f[R]: Indicates that the corresponding
\f[CR]GPUBindGroup\f[R] entry will be a \f[CR]GPUBufferBinding\f[R]
object, which contains a \f[CR]GPUBuffer\f[R] plus \f[CR]offset\f[R] and
\f[CR]size\f[R] values.
A \f[CR]buffer\f[R] resource layout object can contain the following
properties:
.RS 2
.TP
\f[B]hasDynamicOffset\f[R] \f[I](optional)\f[R]
A boolean.
If set to \f[CR]true\f[R], it indicates that this binding requires a
dynamic offset, for example as set during a
\f[CR]GPURenderPassEncoder.setBindGroup()\f[R] call.
If omitted, \f[CR]hasDynamicOffset\f[R] defaults to \f[CR]false\f[R].
.TP
\f[B]minBindingSize\f[R] \f[I](optional)\f[R]
A number indicating the minimum allowed size, in bytes, of bound
buffers.
If omitted, \f[CR]minBindingSize\f[R] defaults to 0.
If the value is 0, minimum buffer size is ignored during pipeline
creation and is instead validated by issued draw/dispatch commands.
.TP
\f[B]type\f[R] \f[I](optional)\f[R]
An enumerated value specifying the required type for
\f[CR]GPUBuffer\f[R]s bound to this binding (see
\f[CR]GPUDevice.createBuffer()\f[R] for more information on buffer
types).
Possible values are:
.RS
.IP \(bu 2
\f[CR]\(dqread\-only\-storage\(dq\f[R]: A read\-only buffer created with
a \f[CR]usage\f[R] of \f[CR]GPUBufferUsage.STORAGE\f[R].
.IP \(bu 2
\f[CR]\(dqstorage\(dq\f[R]: A writable buffer created with a
\f[CR]usage\f[R] of \f[CR]GPUBufferUsage.STORAGE\f[R].
.IP \(bu 2
\f[CR]\(dquniform\(dq\f[R]: A buffer created with a \f[CR]usage\f[R] of
\f[CR]GPUBufferUsage.UNIFORM\f[R].
.PP
If omitted, \f[CR]type\f[R] defaults to \f[CR]\(dquniform\(dq\f[R].
.RE
.RE
.IP \(bu 2
\f[CR]externalTexture\f[R]: Indicates that the corresponding
\f[CR]GPUBindGroup\f[R] entry will be a \f[CR]GPUExternalTexture\f[R]
object.
An \f[CR]externalTexture\f[R] resource layout object is empty \(em
\f[CR]{}\f[R].
.IP \(bu 2
\f[CR]sampler\f[R]: Indicates that the corresponding
\f[CR]GPUBindGroup\f[R] entry will be a \f[CR]GPUSampler\f[R] object.
A \f[CR]sampler\f[R] resource layout object can contain the following
properties:
.RS 2
.TP
\f[B]type\f[R] \f[I](optional)\f[R]
An enumerated value specifying the required type for
\f[CR]GPUSampler\f[R]s bound to this binding (see
\f[CR]GPUDevice.createSampler()\f[R] for more information on sampler
types).
Possible values are:
.RS
.IP \(bu 2
\f[CR]\(dqcomparison\(dq\f[R]: A comparison sampler.
.IP \(bu 2
\f[CR]\(dqfiltering\(dq\f[R]: A filtering sampler.
.IP \(bu 2
\f[CR]\(dqnon\-filtering\(dq\f[R]: A non\-filtering sampler.
.PP
If omitted, \f[CR]type\f[R] defaults to \f[CR]\(dqfiltering\(dq\f[R].
.RE
.RE
.IP \(bu 2
\f[CR]storageTexture\f[R]: Indicates that the corresponding
\f[CR]GPUBindGroup\f[R] entry will be a \f[CR]GPUTextureView\f[R]
object.
A \f[CR]storageTexture\f[R] resource layout object can contain the
following properties:
.RS 2
.TP
\f[B]access\f[R] \f[I](optional)\f[R]
An enumerated value specifying whether texture views bound to this
binding will be bound for read and/or write access.
Possible values are:
.RS
.IP \(bu 2
\f[CR]\(dqread\-only\(dq\f[R]: Enables WGSL code to read storage
textures.
.IP \(bu 2
\f[CR]\(dqread\-write\(dq\f[R]: Enables WGSL code to read and write to
storage textures.
.IP \(bu 2
\f[CR]\(dqwrite\-only\(dq\f[R]: The default value; Enables WGSL code to
write to storage textures.
.PP
The \f[CR]\(dqread\-only\(dq\f[R] and \f[CR]\(dqread\-write\(dq\f[R]
values can only be used if the
\f[CR]\(dqreadonly_and_readwrite_storage_textures\(dq\f[R] WGSL language
extension is present in \f[CR]WGSLLanguageFeatures\f[R].
If this is not the case, a \f[CR]GPUValidationError\f[R] is generated.
.RE
.TP
\f[B]format\f[R]
An enumerated value specifying the required format of texture views
bound to this binding.
See the specification\(cqs \c
.UR https://gpuweb.github.io/gpuweb/#enumdef-gputextureformat
Texture Formats
.UE \c
\ section for all the available \f[CR]format\f[R] values.
.TP
\f[B]viewDimension\f[R] \f[I](optional)\f[R]
An enumerated value specifying the required dimension for texture views
bound to this binding.
Possible values are:
.RS
.IP \(bu 2
\f[CR]\(dq1d\(dq\f[R]: The texture is viewed as a one\-dimensional
image.
.IP \(bu 2
\f[CR]\(dq2d\(dq\f[R]: The texture is viewed as a single
two\-dimensional image.
.IP \(bu 2
\f[CR]\(dq2d\-array\(dq\f[R]: The texture is viewed as an array of
two\-dimensional images.
.IP \(bu 2
\f[CR]\(dqcube\(dq\f[R]: The texture is viewed as a cubemap.
The view has 6 array layers, corresponding to the
\f[CR][+X, \-X, +Y, \-Y, +Z, \-Z]\f[R] faces of the cube.
Sampling is done seamlessly across the faces of the cubemap.
.IP \(bu 2
\f[CR]\(dqcube\-array\(dq\f[R]: The texture is viewed as a packed array
of \f[CR]n\f[R] cubemaps, each with 6 array layers corresponding to the
\f[CR][+X, \-X, +Y, \-Y, +Z, \-Z]\f[R] faces of the cube.
Sampling is done seamlessly across the faces of the cubemaps.
.IP \(bu 2
\f[CR]\(dq3d\(dq\f[R]: The texture is viewed as a three\-dimensional
image.
.PP
If omitted, \f[CR]viewDimension\f[R] defaults to \f[CR]\(dq2d\(dq\f[R].
.RE
.RE
.IP \(bu 2
\f[CR]texture\f[R]: Indicates that the corresponding
\f[CR]GPUBindGroup\f[R] entry will be a \f[CR]GPUTextureView\f[R]
object.
A \f[CR]texture\f[R] resource layout object can contain the following
properties:
.RS 2
.TP
\f[B]multisampled\f[R] \f[I](optional)\f[R]
A boolean.
A value of \f[CR]true\f[R] indicates that texture views bound to this
binding must be multi\-sampled.
If omitted, \f[CR]multisampled\f[R] defaults to \f[CR]false\f[R].
.TP
\f[B]sampleType\f[R] \f[I](optional)\f[R]
An enumerated value specifying the sample type required for texture
views bound to this binding (see \f[CR]GPUDevice.createTexture()\f[R]
for more information on texture view types).
Possible values are:
.RS
.IP \(bu 2
\f[CR]\(dqdepth\(dq\f[R]
.IP \(bu 2
\f[CR]\(dqfloat\(dq\f[R]
.IP \(bu 2
\f[CR]\(dqsint\(dq\f[R]
.IP \(bu 2
\f[CR]\(dquint\(dq\f[R]
.IP \(bu 2
\f[CR]\(dqunfilterable\-float\(dq\f[R]
.PP
If omitted, \f[CR]sampleType\f[R] defaults to \f[CR]\(dqfloat\(dq\f[R].
.RE
.TP
\f[B]viewDimension\f[R] \f[I](optional)\f[R]
An enumerated value specifying the required dimension for texture views
bound to this binding.
Possible and default values are the same as for
\f[CR]storageTexture\f[R] resource layout objects \(em see above.
.RE
.SS Return value
A \f[CR]GPUBindGroupLayout\f[R] object instance.
.SS Validation
The following criteria must be met when calling
\f[B]\f[CB]createBindGroupLayout()\f[B]\f[R], otherwise a
\f[CR]GPUValidationError\f[R] is generated and an invalid
\f[CR]GPUBindGroupLayout\f[R] object is returned:
.IP \(bu 2
Each entry\(cqs \f[CR]binding\f[R] value is unique.
.IP \(bu 2
Each entry\(cqs \f[CR]binding\f[R] value is less than the
\f[CR]GPUDevice\f[R]\(cqs \f[CR]maxBindingsPerBindGroup\f[R] limit.
.IP \(bu 2
The number of entries does not exceed the \c
.UR https://gpuweb.github.io/gpuweb/#exceeds-the-binding-slot-limits
binding slot limits
.UE \c
\&.
.IP \(bu 2
Only 1 resource layout object is defined per entry.
.IP \(bu 2
If an entry\(cqs \f[CR]visibility\f[R] includes
\f[CR]GPUShaderStage.VERTEX\f[R]:
.RS 2
.IP \(bu 2
If its resource layout object is a \f[CR]buffer\f[R], its
\f[CR]type\f[R] is not \f[CR]\(dqstorage\(dq\f[R].
.IP \(bu 2
Its resource layout object is not a \f[CR]storageTexture\f[R].
.RE
.IP \(bu 2
If an entry\(cqs resource layout object is a \f[CR]texture\f[R], and its
\f[CR]multisampled\f[R] value is \f[CR]true\f[R]:
.RS 2
.IP \(bu 2
Its \f[CR]viewDimension\f[R] is \f[CR]\(dq2d\(dq\f[R].
.IP \(bu 2
Its \f[CR]sampleType\f[R] is not \f[CR]\(dqfloat\(dq\f[R].
.RE
.IP \(bu 2
If an entry\(cqs resource layout object is a \f[CR]storageTexture\f[R]:
.RS 2
.IP \(bu 2
Its \f[CR]viewDimension\f[R] is not \f[CR]\(dqcube\(dq\f[R] or
\f[CR]\(dqcube\-array\(dq\f[R].
.IP \(bu 2
Its \f[CR]format\f[R] is a format that supports storage usage.
.RE
.SH EXAMPLES
.RS
.PP
\f[B]Note:\f[R] The \c
.UR https://webgpu.github.io/webgpu-samples/
WebGPU samples
.UE \c
\ feature many more examples.
.RE
.SS Basic example
Our \c
.UR https://mdn.github.io/dom-examples/webgpu-compute-demo/
basic compute demo
.UE \c
\ shows an example of creating a bind group layout and then using that
as a template when creating a bind group.
.IP
.EX
\f[I]// \&...\f[R]

\f[B]const\f[R] bindGroupLayout = device.createBindGroupLayout({
  entries: [
    {
      binding: 0,
      visibility: GPUShaderStage.COMPUTE,
      buffer: {
        type: \(dqstorage\(dq,
      },
    },
  ],
});

\f[B]const\f[R] bindGroup = device.createBindGroup({
  layout: bindGroupLayout,
  entries: [
    {
      binding: 0,
      resource: {
        buffer: output,
      },
    },
  ],
});

\f[I]// \&...\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
