.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "RTCCERTIFICATE.GETFINGERPRINTS" "3JS" "April 29, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCCertificate.getFingerprints \- RTCCertificate: getFingerprints()
method
.SH SYNOPSIS
The \f[B]\f[CB]getFingerprints()\f[B]\f[R] method of the
\f[B]\f[CB]RTCCertificate\f[B]\f[R] interface is used to get an array of
certificate fingerprints.
.PP
This can be used in application\-level code to get certificate
fingerprints, which are hashes of the certificate created using the
various algorithms supported by the browser.
.SH SYNTAX
.IP
.EX
getFingerprints()
.EE
.SS Parameters
None.
.SS Return value
An Array of fingerprint values.
Each fingerprint is represented by an object with the following
properties:
.TP
\f[B]algorithm\f[R]
A string indicating the hash function algorithm used to create the
fingerprint in \f[CR]value\f[R].
Allowed values include: \f[CR]\(dqsha\-1\(dq\f[R],
\f[CR]\(dqsha\-224\(dq\f[R], \f[CR]\(dqsha\-256\(dq\f[R],
\f[CR]\(dqsha\-384\(dq\f[R], \f[CR]\(dqsha\-512\(dq\f[R],
\f[CR]\(dqmd5\(dq\f[R], \f[CR]\(dqmd2\(dq\f[R].
.TP
\f[B]value\f[R]
A string containing the certificate fingerprint in lowercase hex string,
as calculated with the \f[CR]algorithm\f[R] hash function.
The format is more precisely defined in \c
.UR https://www.rfc-editor.org/rfc/rfc4572#section-5
RFC4572, Section 5
.UE \c
\&.
.SH DESCRIPTION
The \f[CR]RTCCertificate\f[R] instances used for a particular
\f[CR]RTCPeerConnection\f[R] can created using the
\f[CR]RTCPeerConnection.generateCertificate()\f[R] static method or
fetched from storage in an IndexedDB, and set in the constructor.
If no certificates are passed in the constructor they will be created
automatically, in which case the certificates used can be fetched with
\f[CR]RTCPeerConnection.getConfiguration()\f[R].
.PP
Browsers will automatically exchange certificates and fingerprints
associated with each \f[CR]RTCPeerConnection\f[R] during the SDP offer
phase, and these will be used as part of the DTLS handshake to verify
that the remote party matches the certificate/endpoint send in the SDP.
This provides a low level validation that the WebRTC communication is
being set up with the remote party that initiated the offer, but does
not, for example, provide any validation of the identity of the
communicating users.
.PP
In some cases it can be useful for the application layer to share
certificate fingerprints out\-of\-band:
.IP \(bu 2
If a trust relationship has been established between two web\-browsers
it can be persisted by storing the certificates and reusing them in a
later session (up to a year later).
The trusted certificates are identified by their fingerprints.
.IP \(bu 2
Peers than want to identify a particular user can send fingerprints and
validate the associated user \(lqout of band\(rq (i.e., outside of the
browser\-mediated WebRTC communications flow).
The application can use the fingerprint to identify later sessions with
the specific user.
.IP \(bu 2
In some conferencing server (\(lqmiddlebox\(rq) implementations, the
server may need to known the fingerprints before doing any offer/answer.
.PP
Peers may support different sets of algorithms.
When comparing certificates, all fingerprint values for the set of
algorithms supported by peers should match.
.SH EXAMPLES
.SS Getting certificate fingerprints
This example shows how you might get certificate fingerprints from the
local peer and compare them to fingerprints from the remote peer.
.PP
First we create a connection and get certificates and their
fingerprints.
We get the fingerprints from the remote peer using \(lqsome out of band
mechanism\(rq.
.IP
.EX
\f[I]// Get the certificate fingerprints from the local peer.\f[R]
\f[B]const\f[R] rtcPeerConnection = \f[B]new\f[R] RTCPeerConnection();
\f[B]const\f[R] configuration = rtcPeerConnection.getConfiguration();
\f[B]const\f[R] certificates = configuration.certificates;
\f[B]let\f[R] fingerprintsFromClient;

\f[B]if\f[R] (certificates && certificates.length > 0) {
  certificates.forEach((cert) \f[B]=>\f[R] {
    \f[I]// For purpose of demonstration, just get first certificate\f[R]
    fingerprintsFromClient = cert.getFingerprints();
    \f[B]break\f[R];
  });
}

\f[I]// Get the certificate fingerprints from the remote peer for particular certificate (pseudo code)\f[R]
\f[B]const\f[R] fingerprintsFromServer = [
  \f[I]/* \&... */\f[R]
];
.EE
.PP
There are numerous ways to compare the fingerprint arrays for a
particular certificate.
Here we convert the arrays to dictionary objects where the algorithm
name is the property and then compare them.
This works because only one fingerprint value can exist for each
algorithm.
(There are many other ways to sort and compare the two arrays).
.IP
.EX
\f[B]let\f[R] clientFingerprintDict = Object.fromEntries(
  fingerprintsFromClient.map((x) \f[B]=>\f[R] [x.algorithm, x.value]),
);
\f[B]let\f[R] serverFingerprintDict = Object.fromEntries(
  fingerprintsFromServer.map((x) \f[B]=>\f[R] [x.algorithm, x.value]),
);

\f[I]// Function to compare two objects and return true if there are common properties\f[R]
\f[I]// and all common properties match.\f[R]
\f[B]function\f[R] compareObjects(obj1, obj2) {
  \f[B]const\f[R] commonProperties = Object.keys(obj1).filter((prop) \f[B]=>\f[R]
    obj2.hasOwnProperty(prop),
  );
  \f[I]// Return false if there are no common properties\f[R]
  \f[B]if\f[R] (Object.keys(commonProperties).length === 0) \f[B]return\f[R] \f[B]false\f[R];

  \f[I]// Return false if any common properties don\(aqt match\f[R]
  \f[B]for\f[R] (\f[B]const\f[R] prop \f[B]of\f[R] commonProperties) {
    \f[B]if\f[R] (obj1[prop] !== obj2[prop]) {
      \f[B]return\f[R] \f[B]false\f[R];
    }
  }

  \f[B]return\f[R] \f[B]true\f[R];
}

\f[B]const\f[R] matchingFingerprints = compareObjects(
  clientFingerprintDict,
  serverFingerprintDict,
);
console.log(matchingFingerprints);
.EE
