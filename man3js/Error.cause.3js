'\" t
.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ERROR.CAUSE" "3JS" "April 12, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Error.cause \- Error: cause
.SH SYNOPSIS
The \f[B]\f[CB]cause\f[B]\f[R] data property of an \f[CR]Error\f[R]
instance indicates the specific original cause of the error.
.PP
It is used when catching and re\-throwing an error with a more\-specific
or useful error message in order to still have access to the original
error.
.SH VALUE
The value that was passed to the \f[CR]Error()\f[R] constructor in the
\f[CR]options.cause\f[R] argument.
It may not be present.
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
yes
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
yes
T}
.TE
.SH DESCRIPTION
The value of \f[CR]cause\f[R] can be of any type.
You should not make assumptions that the error you caught has an
\f[CR]Error\f[R] as its \f[CR]cause\f[R], in the same way that you
cannot be sure the variable bound in the \f[CR]catch\f[R] statement is
an \f[CR]Error\f[R] either.
The \(lqProviding structured data as the error cause\(rq example below
shows a case where a non\-error is deliberately provided as the cause.
.SH EXAMPLES
.SS Rethrowing an error with a cause
It is sometimes useful to catch an error and re\-throw it with a new
message.
In this case you should pass the original error into the constructor for
the new \f[CR]Error\f[R], as shown.
.IP
.EX
\f[B]try\f[R] {
  connectToDatabase();
} \f[B]catch\f[R] (err) {
  \f[B]throw\f[R] \f[B]new\f[R] Error(\(dqConnecting to database failed.\(dq, { cause: err });
}
.EE
.PP
For a more detailed example see Error > Differentiate between similar
errors.
.SS Providing structured data as the error cause
Error messages written for human consumption may be inappropriate for
machine parsing \(em since they\(cqre subject to rewording or
punctuation changes that may break any existing parsing written to
consume them.
So when throwing an error from a function, as an alternative to a
human\-readable error message, you can instead provide the cause as
structured data, for machine parsing.
.IP
.EX
\f[B]function\f[R] makeRSA(p, q) {
  \f[B]if\f[R] (!Number.isInteger(p) || !Number.isInteger(q)) {
    \f[B]throw\f[R] \f[B]new\f[R] Error(\(dqRSA key generation requires integer inputs.\(dq, {
      cause: { code: \(dqNonInteger\(dq, values: [p, q] },
    });
  }
  \f[B]if\f[R] (!areCoprime(p, q)) {
    \f[B]throw\f[R] \f[B]new\f[R] Error(\(dqRSA key generation requires two co\-prime integers.\(dq, {
      cause: { code: \(dqNonCoprime\(dq, values: [p, q] },
    });
  }
  \f[I]// rsa algorithm\&...\f[R]
}
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Error.prototype.message\f[R]
.IP \(bu 2
\f[CR]Error.prototype.toString()\f[R]
