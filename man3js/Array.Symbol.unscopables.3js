'\" t
.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ARRAY.SYMBOL.UNSCOPABLES" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.Symbol.unscopables \- Array.prototype[Symbol.unscopables]
.SH SYNOPSIS
The \f[B]\f[CB][Symbol.unscopables]\f[B]\f[R] data property of
\f[CR]Array.prototype\f[R] is shared by all \f[CR]Array\f[R] instances.
It contains property names that were not included in the ECMAScript
standard prior to the ES2015 version and that are ignored for
\f[CR]with\f[R] statement\-binding purposes.
.SH VALUE
A \f[CR]null\f[R]\-prototype object with property names given below and
their values set to \f[CR]true\f[R].
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
no
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
yes
T}
.TE
.SH DESCRIPTION
The default \f[CR]Array\f[R] properties that are ignored for
\f[CR]with\f[R] statement\-binding purposes are:
.IP \(bu 2
\f[CR]at()\f[R]
.IP \(bu 2
\f[CR]copyWithin()\f[R]
.IP \(bu 2
\f[CR]entries()\f[R]
.IP \(bu 2
\f[CR]fill()\f[R]
.IP \(bu 2
\f[CR]find()\f[R]
.IP \(bu 2
\f[CR]findIndex()\f[R]
.IP \(bu 2
\f[CR]findLast()\f[R]
.IP \(bu 2
\f[CR]findLastIndex()\f[R]
.IP \(bu 2
\f[CR]flat()\f[R]
.IP \(bu 2
\f[CR]flatMap()\f[R]
.IP \(bu 2
\f[CR]includes()\f[R]
.IP \(bu 2
\f[CR]keys()\f[R]
.IP \(bu 2
\f[CR]toReversed()\f[R]
.IP \(bu 2
\f[CR]toSorted()\f[R]
.IP \(bu 2
\f[CR]toSpliced()\f[R]
.IP \(bu 2
\f[CR]values()\f[R]
.PP
\f[CR]Array.prototype[Symbol.unscopables]\f[R] is an empty object only
containing all the above property names with the value \f[CR]true\f[R].
Its prototype is \f[CR]null\f[R], so \f[CR]Object.prototype\f[R]
properties like \f[CR]toString\f[R] won\(cqt accidentally be made
unscopable, and a \f[CR]toString()\f[R] within the \f[CR]with\f[R]
statement will continue to be called on the array.
.PP
See \f[CR]Symbol.unscopables\f[R] for how to set unscopable properties
for your own objects.
.SH EXAMPLES
Imagine the \f[CR]values.push(\(aqsomething\(aq)\f[R] call below is in
code that was written prior to ECMAScript 2015.
.IP
.EX
\f[B]var\f[R] values = [];

\f[B]with\f[R] (values) {
  values.push(\(dqsomething\(dq);
}
.EE
.PP
When ECMAScript 2015 introduced the \f[CR]Array.prototype.values()\f[R]
method, the \f[CR]with\f[R] statement in the above code started to
interpret \f[CR]values\f[R] as the \f[CR]values.values\f[R] array method
instead of the external \f[CR]values\f[R] variable.
The \f[CR]values.push(\(aqsomething\(aq)\f[R] call would break because
it\(cqs now accessing \f[CR]push\f[R] on the \f[CR]values.values\f[R]
method.
This caused a bug to be reported to Firefox (\c
.UR https://bugzil.la/883914
Firefox Bug 883914
.UE \c
).
.PP
So the \f[CR][Symbol.unscopables]\f[R] data property for
\f[CR]Array.prototype\f[R] causes the \f[CR]Array\f[R] properties
introduced in ECMAScript 2015 to be ignored for \f[CR]with\f[R]
statement\-binding purposes \(em allowing code that was written prior to
ECMAScript 2015 to continue working as expected, rather than breaking.
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype[Symbol.unscopables]\f[R] in
\f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
Indexed collections guide
.IP \(bu 2
\f[CR]Array\f[R]
.IP \(bu 2
\f[CR]with\f[R]
.IP \(bu 2
\f[CR]Symbol.unscopables\f[R]
