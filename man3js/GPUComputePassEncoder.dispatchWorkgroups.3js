.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPUCOMPUTEPASSENCODER.DISPATCHWORKGROUPS" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPUComputePassEncoder.dispatchWorkgroups \- GPUComputePassEncoder:
dispatchWorkgroups() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]dispatchWorkgroups()\f[B]\f[R] method of the
\f[CR]GPUComputePassEncoder\f[R] interface dispatches a specific grid of
workgroups to perform the work being done by the current
\f[CR]GPUComputePipeline\f[R] (i.e., set via
\f[CR]GPUComputePassEncoder.setPipeline()\f[R]).
.SH SYNTAX
.IP
.EX
dispatchWorkgroups(workgroupCountX)
dispatchWorkgroups(workgroupCountX, workgroupCountY)
dispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ)
.EE
.SS Parameters
.TP
\f[B]workgroupCountX\f[R]
The X dimension of the grid of workgroups to dispatch.
.TP
\f[B]workgroupCountY\f[R] \f[I](optional)\f[R]
The Y dimension of the grid of workgroups to dispatch.
If omitted, \f[CR]workgroupCountY\f[R] defaults to 1.
.TP
\f[B]workgroupCountZ\f[R] \f[I](optional)\f[R]
The Z dimension of the grid of workgroups to dispatch.
If omitted, \f[CR]workgroupCountZ\f[R] defaults to 1.
.RS
.PP
\f[B]Note:\f[R] The X, Y, and Z dimension values passed to
\f[CR]dispatchWorkgroups()\f[R] and
\f[CR]GPUComputePassEncoder.dispatchWorkgroupsIndirect()\f[R] are the
number of workgroups to dispatch for each dimension, not the number of
shader invocations to perform across each dimension.
This matches the behavior of modern native GPU APIs, but differs from
the behavior of OpenCL.
This means that if a \f[CR]GPUShaderModule\f[R] defines an entry point
with \f[CR]\(atworkgroup_size(4, 4)\f[R], and work is dispatched to it
with the call \f[CR]passEncoder.dispatchWorkgroups(8, 8);\f[R], the
entry point will be invoked 1024 times total \(em Dispatching a 4 x 4
workgroup 8 times along both the X and Y axes.
\f[CR]4 * 4 * 8 * 8 = 1024\f[R].
.RE
.SS Return value
None (\f[CR]Undefined\f[R]).
.SS Validation
The following criteria must be met when calling
\f[B]\f[CB]dispatchWorkgroups()\f[B]\f[R], otherwise a
\f[CR]GPUValidationError\f[R] is generated and the
\f[CR]GPUComputePassEncoder\f[R] becomes invalid:
.IP \(bu 2
\f[CR]workgroupCountX\f[R], \f[CR]workgroupCountY\f[R], and
\f[CR]workgroupCountZ\f[R] are all less than or equal to the
\f[CR]GPUDevice\f[R]\(cqs \f[CR]maxComputeWorkgroupsPerDimension\f[R]
limit.
.SH EXAMPLES
In our \c
.UR https://mdn.github.io/dom-examples/webgpu-compute-demo/
basic compute demo
.UE \c
, several commands are recorded via a \f[CR]GPUCommandEncoder\f[R].
Most of these commands originate from the
\f[CR]GPUComputePassEncoder\f[R] created via
\f[CR]beginComputePass()\f[R].
.PP
At the start of the code, we set a global buffer size of 1000.
Also, note that the workgroup size in the shader is set to 64.
.IP
.EX
\f[B]const\f[R] BUFFER_SIZE = 1000;

\f[I]// Compute shader\f[R]
\f[B]const\f[R] shader = \(ga
\(atgroup(0) \(atbinding(0)
var<storage, read_write> output: array<f32>;

\(atcompute \(atworkgroup_size(64)

\&...

\(ga;
.EE
.PP
Later in the code, the \f[CR]dispatchWorkgroups()\f[R]
\f[CR]workgroupCountX\f[R] parameter is set based on the global buffer
size and the shader workgroup count.
.IP
.EX
\f[I]// \&...\f[R]

\f[I]// Create GPUCommandEncoder to encode commands to issue to the GPU\f[R]
\f[B]const\f[R] commandEncoder = device.createCommandEncoder();

\f[I]// Initiate render pass\f[R]
\f[B]const\f[R] passEncoder = commandEncoder.beginComputePass();

\f[I]// Issue commands\f[R]
passEncoder.setPipeline(computePipeline);
passEncoder.setBindGroup(0, bindGroup);
passEncoder.dispatchWorkgroups(Math.ceil(BUFFER_SIZE / 64));

\f[I]// End the render pass\f[R]
passEncoder.end();

\f[I]// Copy output buffer to staging buffer\f[R]
commandEncoder.copyBufferToBuffer(
  output,
  0, \f[I]// Source offset\f[R]
  stagingBuffer,
  0, \f[I]// Destination offset\f[R]
  BUFFER_SIZE,
);

\f[I]// End frame by passing array of command buffers to command queue for execution\f[R]
device.queue.submit([commandEncoder.finish()]);

\f[I]// \&...\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
