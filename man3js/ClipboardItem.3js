.\" Automatically generated by Pandoc 3.4
.\"
.TH "ClipboardItem" "JS" "October 8, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ClipboardItem \- ClipboardItem
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
The \f[B]\f[CB]ClipboardItem\f[B]\f[R] interface of the Clipboard API
represents a single item format, used when reading or writing clipboard
data using \f[CR]clipboard.read()\f[R] and \f[CR]clipboard.write()\f[R]
respectively.
.PP
The benefit of having the \f[B]\f[CB]ClipboardItem\f[B]\f[R] interface
to represent data, is that it enables developers to cope with the
varying scope of file types and data.
.RS
.PP
\f[B]Note:\f[R] To work with text see the
\f[CR]Clipboard.readText()\f[R] and \f[CR]Clipboard.writeText()\f[R]
methods of the \f[CR]Clipboard\f[R] interface.
.RE
.SH CONSTRUCTOR
.TP
\f[B]ClipboardItem()\f[R]
Creates a new \f[B]\f[CB]ClipboardItem\f[B]\f[R] object, with the MIME
type as the key and \f[CR]Blob\f[R] as the value.
.SH INSTANCE PROPERTIES
\f[I]This interface provides the following properties.\f[R]
.TP
\f[B]types\f[R] \f[I](read\-only)\f[R]
Returns an \f[CR]Array\f[R] of MIME types available within the
\f[B]\f[CB]ClipboardItem\f[B]\f[R].
.TP
\f[B]presentationStyle\f[R] \f[I](read\-only)\f[R]
Returns one of the following: \f[CR]\[dq]unspecified\[dq]\f[R],
\f[CR]\[dq]inline\[dq]\f[R] or \f[CR]\[dq]attachment\[dq]\f[R].
.SH STATIC METHODS
\f[I]This interface defines the following methods.\f[R]
.TP
\f[B]ClipboardItem.supports()\f[R]
Checks whether a given MIME type is supported by the clipboard.
This enables a website to detect whether a MIME type is supported by the
clipboard before attempting to write data.
.SH INSTANCE METHODS
\f[I]This interface defines the following methods.\f[R]
.TP
\f[B]getType()\f[R]
Returns a \f[CR]Promise\f[R] that resolves with a \f[CR]Blob\f[R] of the
requested MIME type, or an error if the MIME type is not found.
.SH EXAMPLES
.SS Writing to the clipboard
Here we use \f[CR]supports()\f[R] to check whether the
\f[CR]image/svg+xml\f[R] MIME data type is supported.
If it is, we fetch the image with the \[lq]Fetch API\[rq], and then read
it into a \f[CR]Blob\f[R], which we can use to create a
\f[CR]ClipboardItem\f[R] that is written to the clipboard.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] writeClipImg() {
  \f[B]try\f[R] {
    \f[B]if\f[R] (ClipboardItem.supports(\[dq]image/svg+xml\[dq])) {
      \f[B]const\f[R] imgURL = \[dq]/my\-image.svg\[dq];
      \f[B]const\f[R] data = \f[B]await\f[R] fetch(imgURL);
      \f[B]const\f[R] blob = \f[B]await\f[R] data.blob();
      \f[B]await\f[R] navigator.clipboard.write([
        \f[B]new\f[R] ClipboardItem({
          [blob.type]: blob,
        }),
      ]);
      console.log(\[dq]Fetched image copied.\[dq]);
    } \f[B]else\f[R] {
      console.log(\[dq]SVG images are not supported by the clipboard.\[dq]);
    }
  } \f[B]catch\f[R] (err) {
    console.error(err.name, err.message);
  }
}
.EE
.SS Reading from the clipboard
Here we\[cq]re returning all items on the clipboard via the
\f[CR]clipboard.read()\f[R] method.
Then utilizing the \f[CR]ClipboardItem.types\f[R] property to set the
\f[CR]getType()\f[R] argument and return the corresponding blob object.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] getClipboardContents() {
  \f[B]try\f[R] {
    \f[B]const\f[R] clipboardItems = \f[B]await\f[R] navigator.clipboard.read();

    \f[B]for\f[R] (\f[B]const\f[R] clipboardItem \f[B]of\f[R] clipboardItems) {
      \f[B]for\f[R] (\f[B]const\f[R] type \f[B]of\f[R] clipboardItem.types) {
        \f[B]const\f[R] blob = \f[B]await\f[R] clipboardItem.getType(type);
        \f[I]// we can now use blob here\f[R]
      }
    }
  } \f[B]catch\f[R] (err) {
    console.error(err.name, err.message);
  }
}
.EE
.SH SEE ALSO
.IP \[bu] 2
Clipboard API
.IP \[bu] 2
\c
.UR https://web.dev/articles/async-clipboard
Image support for Async Clipboard article
.UE \c
