.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "RTCRtpSender.replaceTrack" "JS" "July 5, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCRtpSender.replaceTrack \- RTCRtpSender: replaceTrack() method
.SH SYNOPSIS
The \f[CR]RTCRtpSender\f[R] method \f[B]\f[CB]replaceTrack()\f[B]\f[R]
replaces the track currently being used as the sender\[cq]s source with
a new \f[CR]MediaStreamTrack\f[R].
.PP
The new track must be of the same media kind (audio, video, etc.)
and switching the track should not require negotiation.
.PP
Among the use cases for \f[CR]replaceTrack()\f[R] is the common need to
switch between the rear\- and front\-facing cameras on a phone.
With \f[CR]replaceTrack()\f[R], you can have a track object for each
camera and switch between the two as needed.
See the example switching video cameras below.
.SH SYNTAX
.IP
.EX
replaceTrack(newTrack)
.EE
.SS Parameters
.TP
\f[B]newTrack\f[R] \f[I](optional)\f[R]
A \f[CR]MediaStreamTrack\f[R] specifying the track with which to replace
the \f[CR]RTCRtpSender\f[R]\[cq]s current source track.
The new track\[cq]s \f[CR]kind\f[R] must be the same as the current
track\[cq]s, or the replace track request will fail.
.SS Return value
A \f[CR]Promise\f[R] which is fulfilled once the track has been
successfully replaced.
The promise is rejected if the track cannot be replaced for any reason;
this is commonly because the change would require renegotiation of the
codec, which is not allowed (see Things that require negotiation).
.PP
If \f[CR]newTrack\f[R] was omitted or was \f[CR]null\f[R],
\f[CR]replaceTrack()\f[R] stops the sender.
No negotiation is required in this case.
.PP
When the promise is fulfilled, the fulfillment handler receives a value
of \f[CR]undefined\f[R].
.SS Exceptions
If the returned promise is rejected, one of the following exceptions is
provided to the rejection handler:
.TP
\f[B]InvalidModificationError\f[R] \f[B]DOMException\f[R]
Returned if replacing the \f[CR]RTCRtpSender\f[R]\[cq]s current track
with the new one would require negotiation.
.TP
\f[B]InvalidStateError\f[R] \f[B]DOMException\f[R]
Returned if the track on which this method was called is stopped rather
than running.
.TP
\f[B]TypeError\f[R]
Returned if the new track\[cq]s \f[CR]kind\f[R] doesn\[cq]t match the
original track.
.SH USAGE NOTES
.SS Things that require negotiation
Most track replacements can be done without renegotiation.
In fact, even changes that seem huge can be done without requiring
negotiation.
However, some changes may require negotiation and thus fail
\f[CR]replaceTrack()\f[R]:
.IP \[bu] 2
The new track has a resolution which is outside the bounds of the
dimensions negotiated with the peer; however, most browser end points
allow resolution changes.
.IP \[bu] 2
The new track\[cq]s frame rate is high enough to cause the codec\[cq]s
block rate to be exceeded.
.IP \[bu] 2
The new track is a video track and its raw or pre\-encoded state differs
from that of the original track.
.IP \[bu] 2
The new track is an audio track with a different number of channels from
the original.
.IP \[bu] 2
Media sources that have built\-in encoders \[em] such as hardware
encoders \[em] may not be able to provide the negotiated codec.
Software sources may not implement the negotiated codec.
.SH EXAMPLES
.SS Switching video cameras
.IP
.EX
\f[B]const\f[R] localConnection = \f[B]new\f[R] RTCPeerConnection();
\f[B]const\f[R] remoteConnection = \f[B]new\f[R] RTCPeerConnection();
\f[I]// Configuring these to use the WebRTC API can be explored at\f[R]
\f[I]// https://developer.mozilla.org/en\-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample\f[R]
\f[B]const\f[R] connections = [localConnection, remoteConnection];
\f[B]function\f[R] setCamera(selectedCamera) {
  navigator.mediaDevices
    .getUserMedia({
      video: {
        deviceId: {
          exact: selectedCamera,
        },
      },
    })
    .then((stream) \f[B]=>\f[R] {
      \f[B]const\f[R] [videoTrack] = stream.getVideoTracks();
      connections.forEach((pc) \f[B]=>\f[R] {
        \f[B]const\f[R] sender = pc
          .getSenders()
          .find((s) \f[B]=>\f[R] s.track.kind === videoTrack.kind);
        console.log(\[dq]Found sender:\[dq], sender);
        sender.replaceTrack(videoTrack);
      });
    })
    .catch((err) \f[B]=>\f[R] {
      console.error(\[ga]Error happened: ${err}\[ga]);
    });
}
.EE
.SH SEE ALSO
.IP \[bu] 2
WebRTC API
