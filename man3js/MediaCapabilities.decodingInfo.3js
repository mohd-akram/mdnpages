.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "MediaCapabilities.decodingInfo" "JS" "July 29, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
MediaCapabilities.decodingInfo \- MediaCapabilities: decodingInfo()
method
.SH SYNOPSIS
The \f[B]\f[CB]decodingInfo()\f[B]\f[R] method of the
\f[CR]MediaCapabilities\f[R] interface returns a promise that fulfils
with information about how well the user agent can decode/display media
with a given configuration.
.PP
The resolved object contains three boolean properties
\f[CR]supported\f[R], \f[CR]smooth\f[R], and \f[CR]powerefficient\f[R],
which indicate whether decoding the media described would be supported,
and if so, whether decoding would be smooth and power\-efficient.
.PP
The method can also be used to test the user agent capabilities for
decoding media encoded with a key system, but only when called in the
main thread and in a secure context.
If the configuration passed in the
\f[CR]configuration.keySystemConfiguration\f[R] property is supported
for decoding the data, the resolved promise also includes a
\f[CR]MediaKeySystemAccess\f[R] object that can be used to create a
\f[CR]MediaKeys\f[R] object to setup encrypted playback.
.RS
.PP
\f[B]Note:\f[R] Calling \f[CR]decodingInfo()\f[R] with this property may
result in user\-visible effects, such as asking for permission to access
one or more system resources.
As such, this function should only be called when the application is
ready to create and use a \f[CR]MediaKeys\f[R] object with the provided
configuration.
.RE
.SH SYNTAX
.IP
.EX
decodingInfo(configuration)
.EE
.SS Parameters
.TP
\f[B]configuration\f[R]
An object with a property \f[CR]type\f[R], \f[I]either\f[R] a
\f[CR]video\f[R] or \f[CR]audio\f[R] property containing a configuration
of the appropriate type, and optionally a
\f[CR]keySystemConfiguration\f[R] when decoding media encrypted with a
key system:
.RS
.TP
\f[B]type\f[R]
The type of media being tested.
This takes one of three values:
.RS
.TP
\f[B]file\f[R]
Represents a configuration that is meant to be used for a plain file
playback.
.TP
\f[B]media\-source\f[R]
Represents a configuration that is meant to be used for playback of a
\f[CR]MediaSource\f[R].
.TP
\f[B]webrtc\f[R]
Represents a configuration that is meant to be received using
\f[CR]RTCPeerConnection\f[R] (not allowed when
\f[CR]keySystemConfiguration\f[R] is set).
.RE
.TP
\f[B]video\f[R]
Configuration object for a video media source.
This has the following properties:
.RS
.TP
\f[B]contentType\f[R]
String containing a valid video MIME type, and (optionally) a
\f[CR]codecs\f[R] parameter.
.TP
\f[B]width\f[R]
The width of the video.
.TP
\f[B]height\f[R]
The height of the video.
.TP
\f[B]bitrate\f[R]
The number of bits used to encode one second of the video file.
.TP
\f[B]framerate\f[R]
The number of frames making up one second of video playback.
.RE
.TP
\f[B]audio\f[R]
Configuration object for an audio media source.
This has the following properties:
.RS
.TP
\f[B]contentType\f[R]
String containing a valid audio MIME type, and (optionally) a
\f[CR]codecs\f[R] parameter.
.TP
\f[B]channels\f[R]
The number of channels used by the audio track.
.TP
\f[B]bitrate\f[R]
The number of bits used to encode one second of the audio file.
.TP
\f[B]samplerate\f[R]
The number of audio samples making up one second of the audio file.
.RE
.TP
\f[B]keySystemConfiguration\f[R] \f[I](optional)\f[R]
Object specifying the key system configuration for encrypted media.
.RS
.RS
.PP
\f[B]Note:\f[R] \f[CR]Navigator.requestMediaKeySystemAccess()\f[R] takes
arrays some of the same data types in its
\f[CR]supportedConfigurations\f[R] argument.
.RE
.PP
If specified, the \f[CR]type\f[R] must be \f[CR]media\-source\f[R] or
\f[CR]file\f[R] (not \f[CR]webrtc\f[R]).
This has the following properties:
.TP
\f[B]keySystem\f[R]
A string identifying the media key system.
For example \f[CR]org.w3.clearkey\f[R] or \f[CR]com.widevine.alpha\f[R].
.TP
\f[B]initDataType\f[R] \f[I](optional)\f[R]
A string indicating the data type name the initialization data format,
such as \f[CR]\[dq]cenc\[dq]\f[R], \f[CR]\[dq]keyids\[dq]\f[R] and
\f[CR]\[dq]webm\[dq]\f[R].
Allowed names are defined in the \c
.UR https://www.w3.org/TR/eme-initdata-registry/
Encrypted Media Extensions Initialization Data Format Registry
.UE \c
\&.
.TP
\f[B]distinctiveIdentifier\f[R] \f[I](optional)\f[R]
A string indicating whether the implementation may use \[lq]distinctive
identifiers\[rq] (or distinctive permanent identifiers) for any
operations associated with any object created from this configuration.
The allowed values are:
.RS
.TP
\f[B]required\f[R]
The returned object must support this feature.
.TP
\f[B]optional\f[R]
The returned object may support this feature.
This is the default
.TP
\f[B]not\-allowed\f[R]
The returned object must not support or use this feature.
.RE
.TP
\f[B]persistentState\f[R] \f[I](optional)\f[R]
A string indicating whether the returned object must be able to persist
session data or any other type of state.
The allowed values are:
.RS
.TP
\f[B]required\f[R]
The returned object must support this feature.
.TP
\f[B]optional\f[R]
The returned object may support this feature.
This is the default
.TP
\f[B]not\-allowed\f[R]
The returned object must not support or use this feature.
Only \[lq]temporary\[rq] sessions may be created when persistent state
is not allowed.
.RE
.TP
\f[B]sessionTypes\f[R] \f[I](optional)\f[R]
An array of strings indicating the session types that must be supported.
Permitted values include:
.RS
.TP
\f[B]temporary\f[R]
A session for which the license, key(s) and record of or data related to
the session are not persisted.
The application does not need to manage such storage.
Implementations must support this option, and it is the default.
.TP
\f[B]persistent\-license\f[R]
A session for which the license (and potentially other data related to
the session) will be persisted.
A record of the license and associated keys persists even if the license
is destroyed, providing an attestation that the license and key(s) it
contains are no longer usable by the client.
.RE
.TP
\f[B]audio\f[R] \f[I](optional)\f[R]
The audio key system track configuration associated with the
\f[CR]audio\f[R] configuration above.
If set, then the \f[CR]audio\f[R] configuration must also be set.
.RS
.TP
\f[B]encryptionScheme\f[R]
The encryption scheme associated with the content type, such as
\f[CR]cenc\f[R], \f[CR]cbcs\f[R], \f[CR]cbcs\-1\-9\f[R].
This value should be set by an application (it defaults to
\f[CR]null\f[R], indicating that any encryption scheme may be used).
.TP
\f[B]robustness\f[R]
The robustness level associated with the content type.
The empty string indicates that any ability to decrypt and decode the
content type is acceptable.
.RE
.TP
\f[B]video\f[R] \f[I](optional)\f[R]
The video key system track configuration associated with the
\f[CR]video\f[R] configuration above.
If set, then the \f[CR]video\f[R] configuration must also be set.
.RS
.TP
\f[B]encryptionScheme\f[R]
The encryption scheme associated with the content type, such as
\f[CR]cenc\f[R], \f[CR]cbcs\f[R], \f[CR]cbcs\-1\-9\f[R].
This value should be set by an application (it defaults to
\f[CR]null\f[R], indicating that any encryption scheme may be used).
.TP
\f[B]robustness\f[R]
The robustness level associated with the content type.
The empty string indicates that any ability to decrypt and decode the
content type is acceptable.
.RE
.RE
.RE
.SS Return value
A \f[CR]Promise\f[R] fulfilling with an object containing the following
attributes:
.TP
\f[B]supported\f[R]
\f[CR]true\f[R] if the media content can be decoded at all.
Otherwise, it is \f[CR]false\f[R].
.TP
\f[B]smooth\f[R]
\f[CR]true\f[R] if playback of the media can be played at the frame rate
specified by the configuration without needing to drop frames.
Otherwise it is \f[CR]false\f[R].
.TP
\f[B]powerEfficient\f[R]
\f[CR]true\f[R] if playback of the media will be power efficient.
Otherwise, it is \f[CR]false\f[R].
.TP
\f[B]keySystemAccess\f[R]
A \f[CR]MediaKeySystemAccess\f[R] that can be used to create a
\f[CR]MediaKeys\f[R] object to setup encrypted playback, or
\f[CR]null\f[R] if decoding is not supported using the supplied
configuration.
.PP
Browsers will report a supported media configuration as
\f[CR]smooth\f[R] and \f[CR]powerEfficient\f[R] until stats on this
device have been recorded.
All supported audio codecs report \f[CR]powerEfficient\f[R] as true.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if the \f[CR]configuration\f[R] passed to the
\f[CR]decodingInfo()\f[R] method is invalid, either because the type is
not video or audio, the \f[CR]contentType\f[R] is not a valid codec MIME
type, the media decoding configuration is not a valid value for the
\f[CR]type\f[R] (file, media\-source, or webrtc), or any other error in
the media configuration passed to the method, including omitting any
values.
.TP
\f[B]InvalidStateError\f[R] \f[B]DOMException\f[R]
The method is called in a worker when
\f[CR]configuration.keySystemConfiguration\f[R] is defined.
.TP
\f[B]SecurityError\f[R] \f[B]DOMException\f[R]
The method is called outside of a secure context and
\f[CR]configuration.keySystemConfiguration\f[R] is defined.
.SH USAGE NOTES
.SS Comparision with Navigator.requestMediaKeySystemAccess()
\f[CR]decodingInfo()\f[R] and the
\f[CR]Navigator.requestMediaKeySystemAccess()\f[R] method of the
Encrypted Media Extensions API reflect fundamentally different
approaches for selecting a configuration for decoding encrypted media.
.PP
The configuration parameter for
\f[CR]Navigator.requestMediaKeySystemAccess()\f[R] takes an array of
possible configurations and allows the system to choose the one that it
considers appropriate.
.PP
By contrast, \f[CR]decodingInfo()\f[R] takes one configuration at a
time.
The expectation is that the caller will execute
\f[CR]decodingInfo()\f[R] multiple times, starting with the most
preferred configurations and stopping as soon as it finds a
configuration that meets application requirements for being smooth,
power\-efficient, or both.
In other words, the selection decision is devolved to the caller.
.SH EXAMPLES
.SS Getting decoding information for unencrypted media files
This example shows how to create a media configuration for an audio file
and then use it in \f[CR]MediaCapabilities.decodingInfo()\f[R].
.IP
.EX
\f[I]//Create media configuration to be tested\f[R]
\f[B]const\f[R] audioConfig = {
  type: \[dq]file\[dq], \f[I]// or \[aq]media\-source\[aq] or \[aq]webrtc\[aq]\f[R]
  audio: {
    contentType: \[dq]audio/ogg; codecs=vorbis\[dq], \f[I]// valid content type\f[R]
    channels: 2, \f[I]// audio channels used by the track\f[R]
    bitrate: 132700, \f[I]// number of bits used to encode 1s of audio\f[R]
    samplerate: 5200, \f[I]// number of audio samples making up that 1s.\f[R]
  },
};

\f[I]// check support and performance\f[R]
navigator.mediaCapabilities.decodingInfo(audioConfig).then((result) \f[B]=>\f[R] {
  \f[B]if\f[R] (result.supported) {
    log(
      \[ga]The audio configuration is supported${result.smooth ? \[dq], smooth\[dq] : \[dq], not smooth\[dq]}${result.powerEfficient ? \[dq], power efficient\[dq] : \[dq], not power efficient\[dq]}.\[ga],
    );
  } \f[B]else\f[R] {
    log(\[dq]The audio configuration is not supported\[dq]);
  }
});
.EE
.PP
Similarly, the code below shows the configuration for a video file.
.IP
.EX
\f[B]const\f[R] videoConfig = {
  type: \[dq]file\[dq],
  video: {
    contentType: \[dq]video/webm;codecs=vp8\[dq], \f[I]// valid content type\f[R]
    width: 800, \f[I]// width of the video\f[R]
    height: 600, \f[I]// height of the video\f[R]
    bitrate: 10000, \f[I]// number of bits used to encode 1s of video\f[R]
    framerate: 30, \f[I]// number of frames making up that 1s.\f[R]
  },
};

\f[I]// check support and performance\f[R]
navigator.mediaCapabilities.decodingInfo(audioConfig).then((result) \f[B]=>\f[R] {
  \f[B]if\f[R] (result.supported) {
    log(
      \[ga]The video configuration is supported${result.smooth ? \[dq], smooth\[dq] : \[dq], not smooth\[dq]}${result.powerEfficient ? \[dq], power efficient\[dq] : \[dq], not power efficient\[dq]}.\[ga],
    );
  } \f[B]else\f[R] {
    log(\[dq]The video configuration is not supported\[dq]);
  }
});
.EE
.SS Getting decoding information for encrypted media
This example shows how you might use \f[CR]decodingInfo()\f[R] to select
a media configuration for encrypted content.
.PP
As in the previous example we define a media configuration, but this
time we use the \f[CR]type\f[R] of \f[CR]media\-source\f[R] (rather than
\f[CR]file\f[R]), and specify both audio and video content.
We also specify a simple \f[CR]keySystemConfiguration\f[R].
.IP
.EX
\f[B]const\f[R] encryptedMediaConfig = {
  type: \[dq]media\-source\[dq], \f[I]// or \[aq]file\[aq]\f[R]
  audio: {
    contentType: \[dq]audio/webm; codecs=opus\[dq],
    channels: 2, \f[I]// audio channels used by the track\f[R]
    bitrate: 132700, \f[I]// number of bits used to encode 1s of audio\f[R]
    samplerate: 48000, \f[I]// number of audio samples making up that 1s.\f[R]
  },
  video: {
    contentType: \[aq]video/webm; codecs=\[dq]vp09.00.10.08\[dq]\[aq],
    width: 800, \f[I]// width of the video\f[R]
    height: 600, \f[I]// height of the video\f[R]
    bitrate: 10000, \f[I]// number of bits used to encode 1s of video\f[R]
    framerate: 30, \f[I]// number of frames making up that 1s.\f[R]
  },
  keySystemConfiguration: {
    keySystem: \[dq]org.w3.clearkey\[dq],
    initDataType: \[dq]webm\[dq],
    distinctiveIdentifier: \[dq]required\[dq],
  },
};
.EE
.PP
In the previous example we used promise chaining, to wait on the result.
Here we\[cq]ve chosen to use \f[CR]async\f[R] and \f[CR]await\f[R] to
wait on the result, and then log it.
.IP
.EX
getDecodingInfo(encryptedMediaConfig);

\f[B]async\f[R] \f[B]function\f[R] getDecodingInfo(mediaConfig) {
  \f[B]const\f[R] result = \f[B]await\f[R] navigator.mediaCapabilities.decodingInfo(mediaConfig);
  console.log(result);
  \f[B]if\f[R] (!result.supported) {
    log(\[dq]This encrypted media configuration is not supported.\[dq]);
    \f[B]return\f[R];
  }

  \f[I]// keySystemAccess is returned if decoding encrypted media is supported\f[R]
  \f[I]// This can be used to decrypt and playback the media\f[R]
  \f[B]if\f[R] (!result.keySystemAccess) {
    log(\[dq]Encrypted media support is not available.\[dq]);
    \f[B]return\f[R];
  }

  log(
    \[ga]The encrypted media configuration is supported${result.smooth ? \[dq], smooth\[dq] : \[dq], not smooth\[dq]}${result.powerEfficient ? \[dq], power efficient\[dq] : \[dq], not power efficient\[dq]}.\[ga],
  );
}
.EE
.PP
The log output is shown below.
.SS Iterating through decoding information for encrypted media
The previous example showed how you can use \f[CR]decodingInfo()\f[R] to
get information for just one configuration.
In reality the method would normally be called iteratively with a number
of configurations, selecting the first supported configuration that
matches the application\[cq]s criteria for smooth playing or power
efficiency.
The way this works is described below.
.PP
Assuming we already have an \f[CR]Array\f[R] of media configurations
named \f[CR]orderedMediaConfigs\f[R], which we have ordered from most to
least wanted, we can use the \f[CR]Array.prototype.map()\f[R] to call
\f[CR]decodingInfo()\f[R] for each configuration and get an array
containing all the returned \f[CR]Promise\f[R] objects.
.IP
.EX
\f[B]const\f[R] capabilitiesPromises = orderedMediaConfigs.map((mediaConfig) \f[B]=>\f[R]
  navigator.mediaCapabilities.decodingInfo(mediaConfig),
);
.EE
.PP
We then use a \f[CR]for await...of\f[R] loop to iterate the promises as
they resolve.
In the loop we store the last supported configuration to
\f[CR]nonSmoothConfig\f[R], and we exit the loop as soon as we find a
smooth configuration, setting this as our \f[CR]bestConfig\f[R].
.IP
.EX
\f[I]// Assume this app wants a supported && smooth config.\f[R]
\f[B]let\f[R] bestConfig = \f[B]null\f[R];
\f[B]let\f[R] nonSmoothConfig = \f[B]null\f[R];
\f[B]for\f[R] \f[B]await\f[R] (\f[B]const\f[R] mediaCapabilityInfo \f[B]of\f[R] capabilitiesPromises) {
  \f[B]if\f[R] (!mediaCapabilityInfo.supported) \f[B]continue\f[R];

  \f[B]if\f[R] (!mediaCapabilityInfo.smooth) {
    nonSmoothConfig = mediaCapabilityInfo;
    \f[B]continue\f[R];
  }

  bestConfig = mediaCapabilityInfo;
  \f[B]break\f[R];
}
.EE
.PP
If we found a smooth and supported configuration while looping
(\f[CR]bestConfig\f[R]) we use it to create our media keys and decode
the media.
If we didn\[cq]t discover any smooth configurations we might instead use
\f[CR]nonSmoothConfig\f[R] to decode the media.
This will be the supported configuration that was found last, which
because of the way we ordered the original
\f[CR]orderedMediaConfigs\f[R], should be the one with the lowest
framerate.
.IP
.EX
\f[B]let\f[R] keys = \f[B]null\f[R];
\f[B]if\f[R] (bestConfig) {
  keys = \f[B]await\f[R] bestConfig.keySystemAccess.createMediaKeys();
  \f[I]// ... use keys to decode media using best config\f[R]
} \f[B]else\f[R] \f[B]if\f[R] (nonSmoothConfig) {
  console.log(
    \[dq]No smooth configs found. Using lowest resolution configuration!\[dq],
  );
  keys = \f[B]await\f[R] nonSmoothConfig.keySystemAccess.createMediaKeys();
  \f[I]// ... use keys to decode media using lowest framerate config\f[R]
} \f[B]else\f[R] {
  console.log(\[dq]No supported configs!\[dq]);
  \f[I]// Fail!\f[R]
}
.EE
.PP
If there are no supported configuration, we have no choice but to fail
and notify the user.
.SH SEE ALSO
.IP \[bu] 2
\f[CR]MediaCapabilities.encodingInfo()\f[R]
.IP \[bu] 2
\f[CR]HTMLMediaElement.canPlayType()\f[R] for file
.IP \[bu] 2
\f[CR]MediaSource.isTypeSupported()\f[R] for media\-source
.IP \[bu] 2
\f[CR]Navigator.requestMediaKeySystemAccess()\f[R]
