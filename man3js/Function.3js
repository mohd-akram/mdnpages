.\" Automatically generated by Pandoc 3.4
.\"
.TH "Function" "JS" "July 15, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Function \- Function
.SH SYNOPSIS
The \f[B]\f[CB]Function\f[B]\f[R] object provides methods for functions.
In JavaScript, every function is actually a \f[CR]Function\f[R] object.
.SH CONSTRUCTOR
.TP
\f[B]Function()\f[R]
Creates a new \f[CR]Function\f[R] object.
Calling the constructor directly can create functions dynamically but
suffers from security and similar (but far less significant) performance
issues to \f[CR]eval()\f[R].
However, unlike \f[CR]eval()\f[R], the \f[CR]Function\f[R] constructor
creates functions that execute in the global scope only.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]Function.prototype\f[R] and shared
by all \f[CR]Function\f[R] instances.
.TP
\f[B]Function.prototype.arguments\f[R] \f[I](deprecated)\f[R] \f[I](non\-standard)\f[R]
Represents the arguments passed to this function.
For strict, arrow, async, and generator functions, accessing the
\f[CR]arguments\f[R] property throws a \f[CR]TypeError\f[R].
Use the \f[CR]arguments\f[R] object inside function closures instead.
.TP
\f[B]Function.prototype.caller\f[R] \f[I](deprecated)\f[R] \f[I](non\-standard)\f[R]
Represents the function that invoked this function.
For strict, arrow, async, and generator functions, accessing the
\f[CR]caller\f[R] property throws a \f[CR]TypeError\f[R].
.TP
\f[B]Function.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]Function\f[R] instances, the initial value is the
\f[CR]Function\f[R] constructor.
.PP
These properties are own properties of each \f[CR]Function\f[R]
instance.
.TP
\f[B]displayName\f[R] \f[I](non\-standard)\f[R] \f[I](optional)\f[R]
The display name of the function.
.TP
\f[B]length\f[R]
Specifies the number of arguments expected by the function.
.TP
\f[B]name\f[R]
The name of the function.
.TP
\f[B]prototype\f[R]
Used when the function is used as a constructor with the \f[CR]new\f[R]
operator.
It will become the new object\[cq]s prototype.
.SH INSTANCE METHODS
.TP
\f[B]Function.prototype.apply()\f[R]
Calls a function with a given \f[CR]this\f[R] value and optional
arguments provided as an array (or an array\-like object).
.TP
\f[B]Function.prototype.bind()\f[R]
Creates a new function that, when called, has its \f[CR]this\f[R]
keyword set to a provided value, optionally with a given sequence of
arguments preceding any provided when the new function is called.
.TP
\f[B]Function.prototype.call()\f[R]
Calls a function with a given \f[CR]this\f[R] value and optional
arguments.
.TP
\f[B]Function.prototype.toString()\f[R]
Returns a string representing the source code of the function.
Overrides the \f[CR]Object.prototype.toString\f[R] method.
.TP
\f[B]Function.prototype[Symbol.hasInstance]()\f[R]
Specifies the default procedure for determining if a constructor
function recognizes an object as one of the constructor\[cq]s instances.
Called by the \f[CR]instanceof\f[R] operator.
.SH EXAMPLES
.SS Difference between Function constructor and function declaration
Functions created with the \f[CR]Function\f[R] constructor do not create
closures to their creation contexts; they always are created in the
global scope.
When running them, they will only be able to access their own local
variables and global ones, not the ones from the scope in which the
\f[CR]Function\f[R] constructor was created.
This is different from using \f[CR]eval()\f[R] with code for a function
expression.
.IP
.EX
\f[I]// Create a global property with \[ga]var\[ga]\f[R]
\f[B]var\f[R] x = 10;

\f[B]function\f[R] createFunction1() {
  \f[B]const\f[R] x = 20;
  \f[B]return\f[R] \f[B]new\f[R] Function(\[dq]return x;\[dq]); \f[I]// this \[ga]x\[ga] refers to global \[ga]x\[ga]\f[R]
}

\f[B]function\f[R] createFunction2() {
  \f[B]const\f[R] x = 20;
  \f[B]function\f[R] f() {
    \f[B]return\f[R] x; \f[I]// this \[ga]x\[ga] refers to the local \[ga]x\[ga] above\f[R]
  }
  \f[B]return\f[R] f;
}

\f[B]const\f[R] f1 = createFunction1();
console.log(f1()); \f[I]// 10\f[R]
\f[B]const\f[R] f2 = createFunction2();
console.log(f2()); \f[I]// 20\f[R]
.EE
.PP
While this code works in web browsers, \f[CR]f1()\f[R] will produce a
\f[CR]ReferenceError\f[R] in Node.js, as \f[CR]x\f[R] will not be found.
This is because the top\-level scope in Node is not the global scope,
and \f[CR]x\f[R] will be local to the module.
.SH SEE ALSO
.IP \[bu] 2
\f[CR]function\f[R]
.IP \[bu] 2
\f[CR]function\f[R] expression
.IP \[bu] 2
\f[CR]AsyncFunction\f[R]
.IP \[bu] 2
\f[CR]AsyncGeneratorFunction\f[R]
.IP \[bu] 2
\f[CR]GeneratorFunction\f[R]
.IP \[bu] 2
Functions
