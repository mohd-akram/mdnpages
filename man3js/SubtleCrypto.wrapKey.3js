.\" Automatically generated by Pandoc 3.4
.\"
.TH "SubtleCrypto.wrapKey" "JS" "September 25, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SubtleCrypto.wrapKey \- SubtleCrypto: wrapKey() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]wrapKey()\f[B]\f[R] method of the \f[CR]SubtleCrypto\f[R]
interface \[lq]wraps\[rq] a key.
This means that it exports the key in an external, portable format, then
encrypts the exported key.
Wrapping a key helps protect it in untrusted environments, such as
inside an otherwise unprotected data store or in transmission over an
unprotected network.
.PP
As with \f[CR]SubtleCrypto.exportKey()\f[R], you specify an export
format for the key.
To export a key, it must have \f[CR]CryptoKey.extractable\f[R] set to
\f[CR]true\f[R].
.PP
But because \f[CR]wrapKey()\f[R] also encrypts the key to be exported,
you also need to pass in the key that must be used to encrypt it.
This is sometimes called the \[lq]wrapping key\[rq].
.PP
The inverse of \f[CR]wrapKey()\f[R] is
\f[CR]SubtleCrypto.unwrapKey()\f[R]: while \f[CR]wrapKey\f[R] is
composed of export + encrypt, \f[CR]unwrapKey\f[R] is composed of import
+ decrypt.
.SH SYNTAX
.IP
.EX
wrapKey(format, key, wrappingKey, wrapAlgo)
.EE
.SS Parameters
.TP
\f[B]format\f[R]
A string describing the data format in which the key will be exported
before it is encrypted.
It can be one of the following:
.RS
.TP
\f[B]raw\f[R]
Raw format.
.TP
\f[B]pkcs8\f[R]
PKCS #8 format.
.TP
\f[B]spki\f[R]
SubjectPublicKeyInfo format.
.TP
\f[B]jwk\f[R]
JSON Web Key format.
.RE
.TP
\f[B]key\f[R]
The \f[CR]CryptoKey\f[R] to wrap.
.TP
\f[B]wrappingkey\f[R]
The \f[CR]CryptoKey\f[R] used to encrypt the exported key.
The key must have the \f[CR]wrapKey\f[R] usage set.
.TP
\f[B]wrapAlgo\f[R]
An object specifying the algorithm to be used to encrypt the exported
key, and any required extra parameters:
.RS
.IP \[bu] 2
To use RSA\-OAEP, pass an \f[CR]RsaOaepParams\f[R] object.
.IP \[bu] 2
To use AES\-CTR, pass an \f[CR]AesCtrParams\f[R] object.
.IP \[bu] 2
To use AES\-CBC, pass an \f[CR]AesCbcParams\f[R] object.
.IP \[bu] 2
To use AES\-GCM, pass an \f[CR]AesGcmParams\f[R] object.
.IP \[bu] 2
To use AES\-KW, pass the string \f[CR]\[dq]AES\-KW\[dq]\f[R], or an
object of the form \f[CR]{ name: \[dq]AES\-KW\[dq] }\f[R].
.RE
.SS Return value
A \f[CR]Promise\f[R] that fulfills with an \f[CR]ArrayBuffer\f[R]
containing the encrypted exported key.
.SS Exceptions
The promise is rejected when one of the following exceptions is
encountered:
.TP
\f[B]InvalidAccessError\f[R] \f[B]DOMException\f[R]
Raised when the wrapping key is not a key for the requested wrap
algorithm.
.TP
\f[B]NotSupported\f[R] \f[B]DOMException\f[R]
Raised when trying to use an algorithm that is either unknown or
isn\[cq]t suitable for encryption or wrapping.
.TP
\f[B]TypeError\f[R]
Raised when trying to use an invalid format.
.SH SUPPORTED ALGORITHMS
All algorithms that are usable for encryption are also usable for key
wrapping, as long as the key has the \[lq]wrapKey\[rq] usage set.
For key wrapping you have the additional option of AES\-KW.
.SS AES\-KW
AES\-KW is a way to use the AES cipher for key wrapping.
.PP
One advantage of using AES\-KW over another AES mode such as AES\-GCM is
that AES\-KW does not require an initialization vector.
To use AES\-KW, the input must be a multiple of 64 bits.
.PP
AES\-KW is specified in \c
.UR https://datatracker.ietf.org/doc/html/rfc3394
RFC 3394
.UE \c
\&.
.SH EXAMPLES
.RS
.PP
\f[B]Note:\f[R] You can \c
.UR https://mdn.github.io/dom-examples/web-crypto/wrap-key/index.html
try the working examples
.UE \c
\ out on GitHub.
.RE
.SS Raw wrap
This example wraps an AES key.
It uses \[lq]raw\[rq] as the export format and AES\-KW, with a
password\-derived key, to encrypt it.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/wrap-key/raw.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]let\f[R] salt;

\f[I]/*\f[R]
\f[I]Get some key material to use as input to the deriveKey method.\f[R]
\f[I]The key material is a password supplied by the user.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getKeyMaterial() {
  \f[B]const\f[R] password = window.prompt(\[dq]Enter your password\[dq]);
  \f[B]const\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] window.crypto.subtle.importKey(
    \[dq]raw\[dq],
    enc.encode(password),
    { name: \[dq]PBKDF2\[dq] },
    \f[B]false\f[R],
    [\[dq]deriveBits\[dq], \[dq]deriveKey\[dq]],
  );
}

\f[I]/*\f[R]
\f[I]Given some key material and some random salt\f[R]
\f[I]derive an AES\-KW key using PBKDF2.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getKey(keyMaterial, salt) {
  \f[B]return\f[R] window.crypto.subtle.deriveKey(
    {
      name: \[dq]PBKDF2\[dq],
      salt,
      iterations: 100000,
      hash: \[dq]SHA\-256\[dq],
    },
    keyMaterial,
    { name: \[dq]AES\-KW\[dq], length: 256 },
    \f[B]true\f[R],
    [\[dq]wrapKey\[dq], \[dq]unwrapKey\[dq]],
  );
}

\f[I]/*\f[R]
\f[I]Wrap the given key.\f[R]
\f[I]*/\f[R]
\f[B]async\f[R] \f[B]function\f[R] wrapCryptoKey(keyToWrap) {
  \f[I]// get the key encryption key\f[R]
  \f[B]const\f[R] keyMaterial = \f[B]await\f[R] getKeyMaterial();
  salt = window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(16));
  \f[B]const\f[R] wrappingKey = \f[B]await\f[R] getKey(keyMaterial, salt);

  \f[B]return\f[R] window.crypto.subtle.wrapKey(\[dq]raw\[dq], keyToWrap, wrappingKey, \[dq]AES\-KW\[dq]);
}

\f[I]/*\f[R]
\f[I]Generate an encrypt/decrypt secret key,\f[R]
\f[I]then wrap it.\f[R]
\f[I]*/\f[R]
window.crypto.subtle
  .generateKey(
    {
      name: \[dq]AES\-GCM\[dq],
      length: 256,
    },
    \f[B]true\f[R],
    [\[dq]encrypt\[dq], \[dq]decrypt\[dq]],
  )
  .then((secretKey) \f[B]=>\f[R] wrapCryptoKey(secretKey))
  .then((wrappedKey) \f[B]=>\f[R] console.log(wrappedKey));
.EE
.SS PKCS #8 wrap
This example wraps an RSA private signing key.
It uses \[lq]pkcs8\[rq] as the export format and AES\-GCM, with a
password\-derived key, to encrypt it.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/wrap-key/pkcs8.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]let\f[R] salt;
\f[B]let\f[R] iv;

\f[I]/*\f[R]
\f[I]Get some key material to use as input to the deriveKey method.\f[R]
\f[I]The key material is a password supplied by the user.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getKeyMaterial() {
  \f[B]const\f[R] password = window.prompt(\[dq]Enter your password\[dq]);
  \f[B]const\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] window.crypto.subtle.importKey(
    \[dq]raw\[dq],
    enc.encode(password),
    { name: \[dq]PBKDF2\[dq] },
    \f[B]false\f[R],
    [\[dq]deriveBits\[dq], \[dq]deriveKey\[dq]],
  );
}

\f[I]/*\f[R]
\f[I]Given some key material and some random salt\f[R]
\f[I]derive an AES\-GCM key using PBKDF2.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getKey(keyMaterial, salt) {
  \f[B]return\f[R] window.crypto.subtle.deriveKey(
    {
      name: \[dq]PBKDF2\[dq],
      salt,
      iterations: 100000,
      hash: \[dq]SHA\-256\[dq],
    },
    keyMaterial,
    { name: \[dq]AES\-GCM\[dq], length: 256 },
    \f[B]true\f[R],
    [\[dq]wrapKey\[dq], \[dq]unwrapKey\[dq]],
  );
}

\f[I]/*\f[R]
\f[I]Wrap the given key.\f[R]
\f[I]*/\f[R]
\f[B]async\f[R] \f[B]function\f[R] wrapCryptoKey(keyToWrap) {
  \f[I]// get the key encryption key\f[R]
  \f[B]const\f[R] keyMaterial = \f[B]await\f[R] getKeyMaterial();
  salt = window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(16));
  \f[B]const\f[R] wrappingKey = \f[B]await\f[R] getKey(keyMaterial, salt);
  iv = window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(12));

  \f[B]return\f[R] window.crypto.subtle.wrapKey(\[dq]pkcs8\[dq], keyToWrap, wrappingKey, {
    name: \[dq]AES\-GCM\[dq],
    iv,
  });
}

\f[I]/*\f[R]
\f[I]Generate a sign/verify key pair,\f[R]
\f[I]then wrap the private key.\f[R]
\f[I]*/\f[R]
window.crypto.subtle
  .generateKey(
    {
      name: \[dq]RSA\-PSS\[dq],
      \f[I]// Consider using a 4096\-bit key for systems that require long\-term security\f[R]
      modulusLength: 2048,
      publicExponent: \f[B]new\f[R] Uint8Array([1, 0, 1]),
      hash: \[dq]SHA\-256\[dq],
    },
    \f[B]true\f[R],
    [\[dq]sign\[dq], \[dq]verify\[dq]],
  )
  .then((keyPair) \f[B]=>\f[R] wrapCryptoKey(keyPair.privateKey))
  .then((wrappedKey) \f[B]=>\f[R] {
    console.log(wrappedKey);
  });
.EE
.SS SubjectPublicKeyInfo wrap
This example wraps an RSA public encryption key.
It uses \[lq]spki\[rq] as the export format and AES\-CBC, with a
password\-derived key, to encrypt it.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/wrap-key/spki.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]let\f[R] salt;
\f[B]let\f[R] iv;

\f[I]/*\f[R]
\f[I]Get some key material to use as input to the deriveKey method.\f[R]
\f[I]The key material is a password supplied by the user.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getKeyMaterial() {
  \f[B]const\f[R] password = window.prompt(\[dq]Enter your password\[dq]);
  \f[B]const\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] window.crypto.subtle.importKey(
    \[dq]raw\[dq],
    enc.encode(password),
    { name: \[dq]PBKDF2\[dq] },
    \f[B]false\f[R],
    [\[dq]deriveBits\[dq], \[dq]deriveKey\[dq]],
  );
}

\f[I]/*\f[R]
\f[I]Given some key material and some random salt\f[R]
\f[I]derive an AES\-CBC key using PBKDF2.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getKey(keyMaterial, salt) {
  \f[B]return\f[R] window.crypto.subtle.deriveKey(
    {
      name: \[dq]PBKDF2\[dq],
      salt,
      iterations: 100000,
      hash: \[dq]SHA\-256\[dq],
    },
    keyMaterial,
    { name: \[dq]AES\-CBC\[dq], length: 256 },
    \f[B]true\f[R],
    [\[dq]wrapKey\[dq], \[dq]unwrapKey\[dq]],
  );
}

\f[I]/*\f[R]
\f[I]Wrap the given key.\f[R]
\f[I]*/\f[R]
\f[B]async\f[R] \f[B]function\f[R] wrapCryptoKey(keyToWrap) {
  \f[I]// get the key encryption key\f[R]
  \f[B]const\f[R] keyMaterial = \f[B]await\f[R] getKeyMaterial();
  salt = window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(16));
  \f[B]const\f[R] wrappingKey = \f[B]await\f[R] getKey(keyMaterial, salt);
  iv = window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(16));

  \f[B]return\f[R] window.crypto.subtle.wrapKey(\[dq]spki\[dq], keyToWrap, wrappingKey, {
    name: \[dq]AES\-CBC\[dq],
    iv,
  });
}

\f[I]/*\f[R]
\f[I]Generate an encrypt/decrypt key pair,\f[R]
\f[I]then wrap it.\f[R]
\f[I]*/\f[R]
window.crypto.subtle
  .generateKey(
    {
      name: \[dq]RSA\-OAEP\[dq],
      \f[I]// Consider using a 4096\-bit key for systems that require long\-term security\f[R]
      modulusLength: 2048,
      publicExponent: \f[B]new\f[R] Uint8Array([1, 0, 1]),
      hash: \[dq]SHA\-256\[dq],
    },
    \f[B]true\f[R],
    [\[dq]encrypt\[dq], \[dq]decrypt\[dq]],
  )
  .then((keyPair) \f[B]=>\f[R] wrapCryptoKey(keyPair.publicKey))
  .then((wrappedKey) \f[B]=>\f[R] console.log(wrappedKey));
.EE
.SS JSON Web Key wrap
This example wraps an ECDSA private signing key.
It uses \[lq]jwk\[rq] as the export format and AES\-GCM, with a
password\-derived key, to encrypt it.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/wrap-key/jwk.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]let\f[R] salt;
\f[B]let\f[R] iv;

\f[I]/*\f[R]
\f[I]Get some key material to use as input to the deriveKey method.\f[R]
\f[I]The key material is a password supplied by the user.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getKeyMaterial() {
  \f[B]const\f[R] password = window.prompt(\[dq]Enter your password\[dq]);
  \f[B]const\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] window.crypto.subtle.importKey(
    \[dq]raw\[dq],
    enc.encode(password),
    { name: \[dq]PBKDF2\[dq] },
    \f[B]false\f[R],
    [\[dq]deriveBits\[dq], \[dq]deriveKey\[dq]],
  );
}

\f[I]/*\f[R]
\f[I]Given some key material and some random salt\f[R]
\f[I]derive an AES\-GCM key using PBKDF2.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getKey(keyMaterial, salt) {
  \f[B]return\f[R] window.crypto.subtle.deriveKey(
    {
      name: \[dq]PBKDF2\[dq],
      salt,
      iterations: 100000,
      hash: \[dq]SHA\-256\[dq],
    },
    keyMaterial,
    { name: \[dq]AES\-GCM\[dq], length: 256 },
    \f[B]true\f[R],
    [\[dq]wrapKey\[dq], \[dq]unwrapKey\[dq]],
  );
}

\f[I]/*\f[R]
\f[I]Wrap the given key.\f[R]
\f[I]*/\f[R]
\f[B]async\f[R] \f[B]function\f[R] wrapCryptoKey(keyToWrap) {
  \f[I]// get the key encryption key\f[R]
  \f[B]const\f[R] keyMaterial = \f[B]await\f[R] getKeyMaterial();
  salt = window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(16));
  \f[B]const\f[R] wrappingKey = \f[B]await\f[R] getKey(keyMaterial, salt);
  iv = window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(12));

  \f[B]return\f[R] window.crypto.subtle.wrapKey(\[dq]jwk\[dq], keyToWrap, wrappingKey, {
    name: \[dq]AES\-GCM\[dq],
    iv,
  });
}

\f[I]/*\f[R]
\f[I]Generate a sign/verify key pair,\f[R]
\f[I]then wrap the private key\f[R]
\f[I]*/\f[R]
window.crypto.subtle
  .generateKey(
    {
      name: \[dq]ECDSA\[dq],
      namedCurve: \[dq]P\-384\[dq],
    },
    \f[B]true\f[R],
    [\[dq]sign\[dq], \[dq]verify\[dq]],
  )
  .then((keyPair) \f[B]=>\f[R] wrapCryptoKey(keyPair.privateKey))
  .then((wrappedKey) \f[B]=>\f[R] console.log(wrappedKey));
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]SubtleCrypto.exportKey()\f[R]
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc5208
PKCS #8 format
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc5280#section-4.1
SubjectPublicKeyInfo format
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc7517
JSON Web Key format
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc3394
AES\-KW specification
.UE \c
\&.
