.\" Automatically generated by Pandoc 3.4
.\"
.TH "AesCtrParams" "JS" "July 30, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
AesCtrParams \- AesCtrParams
.SH SYNOPSIS
The \f[B]\f[CB]AesCtrParams\f[B]\f[R] dictionary of the Web Crypto API
represents the object that should be passed as the \f[CR]algorithm\f[R]
parameter into \f[CR]SubtleCrypto.encrypt()\f[R],
\f[CR]SubtleCrypto.decrypt()\f[R], \f[CR]SubtleCrypto.wrapKey()\f[R], or
\f[CR]SubtleCrypto.unwrapKey()\f[R], when using the AES\-CTR algorithm.
.PP
AES is a block cipher, meaning that it splits the message into blocks
and encrypts it a block at a time.
In CTR mode, every time a block of the message is encrypted, an extra
block of data is mixed in.
This extra block is called the \[lq]counter block\[rq].
.PP
A given counter block value must never be used more than once with the
same key:
.IP \[bu] 2
Given a message \f[I]n\f[R] blocks long, a different counter block must
be used for every block.
.IP \[bu] 2
If the same key is used to encrypt more than one message, a different
counter block must be used for all blocks across all messages.
.PP
Typically this is achieved by splitting the initial counter block value
into two concatenated parts:
.IP \[bu] 2
A \c
.UR https://en.wikipedia.org/wiki/Cryptographic_nonce
nonce
.UE \c
\ (that is, a number that may only be used once).
The nonce part of the block stays the same for every block in the
message.
Each time a new message is to be encrypted, a new nonce is chosen.
Nonces don\[cq]t have to be secret, but they must not be reused with the
same key.
.IP \[bu] 2
A counter.
This part of the block gets incremented each time a block is encrypted.
.PP
Essentially: the nonce should ensure that counter blocks are not reused
from one message to the next, while the counter should ensure that
counter blocks are not reused within a single message.
.RS
.PP
\f[B]Note:\f[R] See \c
.UR https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf#%5B%7B%22num%22%3A70%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22Fit%22%7D%5D
Appendix B of the NIST SP800\-38A standard
.UE \c
\ for more information.
.RE
.SH INSTANCE PROPERTIES
.TP
\f[B]name\f[R]
A string.
This should be set to \f[CR]AES\-CTR\f[R].
.TP
\f[B]counter\f[R]
An \f[CR]ArrayBuffer\f[R], a \f[CR]TypedArray\f[R], or a
\f[CR]DataView\f[R] \[em] the initial value of the counter block.
This must be 16 bytes long (the AES block size).
The rightmost \f[CR]length\f[R] bits of this block are used for the
counter, and the rest is used for the nonce.
For example, if \f[CR]length\f[R] is set to 64, then the first half of
\f[CR]counter\f[R] is the nonce and the second half is used for the
counter.
.TP
\f[B]length\f[R]
A \f[CR]Number\f[R] \[em] the number of bits in the counter block that
are used for the actual counter.
The counter must be big enough that it doesn\[cq]t wrap: if the message
is \f[CR]n\f[R] blocks and the counter is \f[CR]m\f[R] bits long, then
the following must be true: \f[CR]n <= 2\[ha]m\f[R].
The \c
.UR https://csrc.nist.gov/pubs/sp/800/38/a/final
NIST SP800\-38A
.UE \c
\ standard, which defines CTR, suggests that the counter should occupy
half of the counter block (see \c
.UR https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf#%5B%7B%22num%22%3A73%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22Fit%22%7D%5D
Appendix B.2
.UE \c
), so for AES it would be 64.
.SH EXAMPLES
See the examples for \f[CR]SubtleCrypto.encrypt()\f[R] and
\f[CR]SubtleCrypto.decrypt()\f[R].
