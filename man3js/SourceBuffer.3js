.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "SourceBuffer" "JS" "November 24, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SourceBuffer \- SourceBuffer
.SH SYNOPSIS
The \f[B]\f[CB]SourceBuffer\f[B]\f[R] interface represents a chunk of
media to be passed into an \f[CR]HTMLMediaElement\f[R] and played, via a
\f[CR]MediaSource\f[R] object.
This can be made up of one or several media segments.
.SH INSTANCE PROPERTIES
.TP
\f[B]SourceBuffer.appendWindowEnd\f[R]
Controls the timestamp for the end of the append window.
.TP
\f[B]SourceBuffer.appendWindowStart\f[R]
Controls the timestamp for the start of the \c
.UR https://w3c.github.io/media-source/#append-window
append window
.UE \c
\&.
This is a timestamp range that can be used to filter what media data is
appended to the \f[CR]SourceBuffer\f[R].
Coded media frames with timestamps within this range will be appended,
whereas those outside the range will be filtered out.
.TP
\f[B]SourceBuffer.audioTracks\f[R] \f[I](read\-only)\f[R]
A list of the audio tracks currently contained inside the
\f[CR]SourceBuffer\f[R].
.TP
\f[B]SourceBuffer.buffered\f[R] \f[I](read\-only)\f[R]
Returns the time ranges that are currently buffered in the
\f[CR]SourceBuffer\f[R].
.TP
\f[B]SourceBuffer.mode\f[R]
Controls how the order of media segments in the \f[CR]SourceBuffer\f[R]
is handled, in terms of whether they can be appended in any order, or
they have to be kept in a strict sequence.
.TP
\f[B]SourceBuffer.textTracks\f[R] \f[I](read\-only)\f[R] \f[I](experimental)\f[R]
A list of the text tracks currently contained inside the
\f[CR]SourceBuffer\f[R].
.TP
\f[B]SourceBuffer.timestampOffset\f[R]
Controls the offset applied to timestamps inside media segments that are
subsequently appended to the \f[CR]SourceBuffer\f[R].
.TP
\f[B]SourceBuffer.updating\f[R] \f[I](read\-only)\f[R]
A boolean indicating whether the \f[CR]SourceBuffer\f[R] is currently
being updated \[em] i.e.\ whether an
\f[CR]SourceBuffer.appendBuffer()\f[R] or
\f[CR]SourceBuffer.remove()\f[R] operation is currently in progress.
.TP
\f[B]SourceBuffer.videoTracks\f[R] \f[I](read\-only)\f[R]
A list of the video tracks currently contained inside the
\f[CR]SourceBuffer\f[R].
.SH INSTANCE METHODS
\f[I]Inherits methods from its parent interface,
\f[CI]EventTarget\f[I].\f[R]
.TP
\f[B]SourceBuffer.abort()\f[R]
Aborts the current segment and resets the segment parser.
.TP
\f[B]SourceBuffer.appendBuffer()\f[R]
Appends media segment data from an \f[CR]ArrayBuffer\f[R], a
\f[CR]TypedArray\f[R] or a \f[CR]DataView\f[R] object to the
\f[CR]SourceBuffer\f[R].
.TP
\f[B]SourceBuffer.appendBufferAsync()\f[R] \f[I](non\-standard)\f[R] \f[I](experimental)\f[R]
Starts the process of asynchronously appending the specified buffer to
the \f[CR]SourceBuffer\f[R].
Returns a \f[CR]Promise\f[R] which is fulfilled once the buffer has been
appended.
.TP
\f[B]SourceBuffer.changeType()\f[R]
Changes the MIME type that future calls to \f[CR]appendBuffer()\f[R]
will expect the new data to conform to.
.TP
\f[B]SourceBuffer.remove()\f[R]
Removes media segments within a specific time range from the
\f[CR]SourceBuffer\f[R].
.TP
\f[B]SourceBuffer.removeAsync()\f[R] \f[I](non\-standard)\f[R] \f[I](experimental)\f[R]
Starts the process of asynchronously removing media segments in the
specified range from the \f[CR]SourceBuffer\f[R].
Returns a \f[CR]Promise\f[R] which is fulfilled once all matching
segments have been removed.
.SH EVENTS
.TP
\f[B]abort\f[R]
Fired whenever \f[CR]SourceBuffer.appendBuffer()\f[R] is ended by a call
to \f[CR]SourceBuffer.abort()\f[R].
\f[CR]SourceBuffer.updating\f[R] changes from \f[CR]true\f[R] to
\f[CR]false\f[R].
.TP
\f[B]error\f[R]
Fired whenever an error occurs during
\f[CR]SourceBuffer.appendBuffer()\f[R].
\f[CR]SourceBuffer.updating\f[R] changes from \f[CR]true\f[R] to
\f[CR]false\f[R].
.TP
\f[B]update\f[R]
Fired whenever \f[CR]SourceBuffer.appendBuffer()\f[R] or
\f[CR]SourceBuffer.remove()\f[R] completes.
\f[CR]SourceBuffer.updating\f[R] changes from \f[CR]true\f[R] to
\f[CR]false\f[R].
This event is fired before \f[CR]updateend\f[R].
.TP
\f[B]updateend\f[R]
Fired after \f[CR]SourceBuffer.appendBuffer()\f[R] or
\f[CR]SourceBuffer.remove()\f[R] ends.
This event is fired after \f[CR]update\f[R].
.TP
\f[B]updatestart\f[R]
Fired whenever the value of \f[CR]SourceBuffer.updating\f[R] changes
from \f[CR]false\f[R] to \f[CR]true\f[R].
.SH EXAMPLES
.SS Loading a video chunk by chunk
The following example loads a video chunk by chunk as fast as possible,
playing it as soon as it can.
.PP
You can see the complete code at \c
.UR https://github.com/mdn/dom-examples/tree/main/sourcebuffer
.UE \c
\ and try the demo live at \c
.UR https://mdn.github.io/dom-examples/sourcebuffer/
.UE \c
\&.
.IP
.EX
\f[B]const\f[R] video = document.querySelector(\[dq]video\[dq]);

\f[B]const\f[R] assetURL = \[dq]frag_bunny.mp4\[dq];
\f[I]// Need to be specific for Blink regarding codecs\f[R]
\f[B]const\f[R] mimeCodec = \[aq]video/mp4; codecs=\[dq]avc1.42E01E, mp4a.40.2\[dq]\[aq];

\f[B]function\f[R] loadVideo() {
  \f[B]if\f[R] (MediaSource.isTypeSupported(mimeCodec)) {
    \f[B]const\f[R] mediaSource = \f[B]new\f[R] MediaSource();
    console.log(mediaSource.readyState); \f[I]// closed\f[R]
    video.src = URL.createObjectURL(mediaSource);
    mediaSource.addEventListener(\[dq]sourceopen\[dq], sourceOpen);
  } \f[B]else\f[R] {
    console.error(\[dq]Unsupported MIME type or codec: \[dq], mimeCodec);
  }
}

\f[B]async\f[R] \f[B]function\f[R] sourceOpen() {
  console.log(\f[B]this\f[R].readyState); \f[I]// open\f[R]
  \f[B]const\f[R] mediaSource = \f[B]this\f[R];
  \f[B]const\f[R] sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
  \f[B]const\f[R] response = \f[B]await\f[R] fetch(assetURL);
  \f[B]const\f[R] buffer = \f[B]await\f[R] response.arrayBuffer();
  sourceBuffer.addEventListener(\[dq]updateend\[dq], () \f[B]=>\f[R] {
    mediaSource.endOfStream();
    video.play();
    console.log(mediaSource.readyState); \f[I]// ended\f[R]
  });
  sourceBuffer.appendBuffer(buffer);
}

\f[B]const\f[R] load = document.querySelector(\[dq]#load\[dq]);
load.addEventListener(\[dq]click\[dq], loadVideo);
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]MediaSource\f[R]
.IP \[bu] 2
\f[CR]SourceBufferList\f[R]
