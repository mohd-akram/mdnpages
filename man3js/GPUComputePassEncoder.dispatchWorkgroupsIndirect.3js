.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPUCOMPUTEPASSENCODER.DISPATCHWORKGROUPSINDIRECT" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPUComputePassEncoder.dispatchWorkgroupsIndirect \-
GPUComputePassEncoder: dispatchWorkgroupsIndirect() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]dispatchWorkgroupsIndirect()\f[B]\f[R] method of the
\f[CR]GPUComputePassEncoder\f[R] interface dispatches a grid of
workgroups, defined by the parameters of a \f[CR]GPUBuffer\f[R], to
perform the work being done by the current \f[CR]GPUComputePipeline\f[R]
(i.e., set via \f[CR]GPUComputePassEncoder.setPipeline()\f[R]).
.SH SYNTAX
.IP
.EX
dispatchWorkgroupsIndirect(indirectBuffer, indirectOffset)
.EE
.SS Parameters
.TP
\f[B]indirectBuffer\f[R]
A \f[CR]GPUBuffer\f[R] containing the X, Y, and Z dimensions of the grid
of workgroups to dispatch.
The buffer must contain a tightly packed block of three 32\-bit unsigned
integer values representing the dimensions (12 bytes total), given in
the same order as the arguments for
\f[CR]GPUComputePassEncoder.dispatchWorkgroups()\f[R].
So for example:
.RS
.IP
.EX
\f[B]const\f[R] uint32 = \f[B]new\f[R] Uint32Array(3);
uint32[0] = 25; \f[I]// The X value\f[R]
uint32[1] = 1; \f[I]// The Y value\f[R]
uint32[2] = 1; \f[I]// The Z value\f[R]

\f[I]// Write values into a GPUBuffer\f[R]
device.queue.writeBuffer(buffer, 0, uint32, 0, uint32.length);
.EE
.RE
.TP
\f[B]indirectOffset\f[R]
The offset, in bytes, into \f[CR]indirectBuffer\f[R] where the dimension
data begins.
.RS
.PP
\f[B]Note:\f[R] The X, Y, and Z dimension values passed to
\f[CR]GPUComputePassEncoder.dispatchWorkgroups()\f[R] and
\f[CR]dispatchWorkgroupsIndirect()\f[R] are the number of workgroups to
dispatch for each dimension, not the number of shader invocations to
perform across each dimension.
This matches the behavior of modern native GPU APIs, but differs from
the behavior of OpenCL.
This means that if a \f[CR]GPUShaderModule\f[R] defines an entry point
with \f[CR]\(atworkgroup_size(4, 4)\f[R], and work is dispatched to it
with the call \f[CR]dispatchWorkgroupsIndirect(indirectBuffer);\f[R]
with \f[CR]indirectBuffer\f[R] specifying X and Y dimensions of 8 and 8,
the entry point will be invoked 1024 times total \(em Dispatching a 4 x
4 workgroup 8 times along both the X and Y axes.
\f[CR]4 * 4 * 8 * 8 = 1024\f[R].
.RE
.SS Return value
None (\f[CR]Undefined\f[R]).
.SS Validation
The following criteria must be met when calling
\f[B]\f[CB]dispatchWorkgroupsIndirect()\f[B]\f[R], otherwise a
\f[CR]GPUValidationError\f[R] is generated and the
\f[CR]GPUComputePassEncoder\f[R] becomes invalid:
.IP \(bu 2
\f[CR]indirectBuffer\f[R]\(cqs \f[CR]GPUBuffer.usage\f[R] contains the
\f[CR]GPUBufferUsage.INDIRECT\f[R] flag.
.IP \(bu 2
\f[CR]indirectOffset\f[R] + the total size specified by the
\f[CR]X\f[R], \f[CR]Y\f[R], and \f[CR]Z\f[R] dimensions is less than or
equal to the \f[CR]indirectBuffer\f[R]\(cqs \f[CR]GPUBuffer.size\f[R].
.IP \(bu 2
\f[CR]indirectOffset\f[R] is a multiple of 4.
.SH EXAMPLES
.IP
.EX
\f[I]// Set global buffer size\f[R]
\f[B]const\f[R] BUFFER_SIZE = 1000;

\f[I]// Compute shader; note workgroup size of 64\f[R]
\f[B]const\f[R] shader = \(ga
\(atgroup(0) \(atbinding(0)
var<storage, read_write> output: array<f32>;

\(atcompute \(atworkgroup_size(64)

\&...

\(ga;

\f[I]// \&...\f[R]

\f[I]// Create GPUCommandEncoder to encode commands to issue to the GPU\f[R]
\f[B]const\f[R] commandEncoder = device.createCommandEncoder();

\f[I]// Initiate render pass\f[R]
\f[B]const\f[R] passEncoder = commandEncoder.beginComputePass();

\f[I]// Issue commands\f[R]
passEncoder.setPipeline(computePipeline);
passEncoder.setBindGroup(0, bindGroup);

\f[B]const\f[R] uint32 = \f[B]new\f[R] Uint32Array(3);
\f[I]// Note workgroupCountX is set based on the global buffer size and the shader workgroup count.\f[R]
uint32[0] = Math.ceil(BUFFER_SIZE / 64);
uint32[1] = 1;
uint32[2] = 1;

\f[B]const\f[R] workgroupDimensions = device.createBuffer({
  size: 12,
  usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.INDIRECT,
});
device.queue.writeBuffer(workgroupDimensions, 0, uint32, 0, uint32.length);

passEncoder.dispatchWorkgroupsIndirect(workgroupDimensions, 0);

\f[I]// End the render pass\f[R]
passEncoder.end();

\f[I]// Copy output buffer to staging buffer\f[R]
commandEncoder.copyBufferToBuffer(
  output,
  0, \f[I]// Source offset\f[R]
  stagingBuffer,
  0, \f[I]// Destination offset\f[R]
  BUFFER_SIZE,
);

\f[I]// End frame by passing array of command buffers to command queue for execution\f[R]
device.queue.submit([commandEncoder.finish()]);

\f[I]// \&...\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
