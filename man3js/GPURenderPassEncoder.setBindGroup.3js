.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPURENDERPASSENCODER.SETBINDGROUP" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPURenderPassEncoder.setBindGroup \- GPURenderPassEncoder:
setBindGroup() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]setBindGroup()\f[B]\f[R] method of the
\f[CR]GPURenderPassEncoder\f[R] interface sets the
\f[CR]GPUBindGroup\f[R] to use for subsequent render commands, for a
given index.
.SH SYNTAX
.IP
.EX
setBindGroup(index, bindGroup)
setBindGroup(index, bindGroup, dynamicOffsets)
setBindGroup(index, bindGroup, dynamicOffsets, dynamicOffsetsStart,
             dynamicOffsetsLength)
.EE
.SS Parameters
.TP
\f[B]index\f[R]
The index to set the bind group at.
This matches the \f[CR]n\f[R] index value of the corresponding \c
.UR https://gpuweb.github.io/gpuweb/wgsl/#attribute-group
\f[CR]\(atgroup(n)\f[R]
.UE \c
\ attribute in the shader code (\f[CR]GPUShaderModule\f[R]) used in the
related pipeline.
.TP
\f[B]bindGroup\f[R]
The \f[CR]GPUBindGroup\f[R] to use for subsequent render commands, or
\f[CR]null\f[R], in which case any previously\-set bind group in the
given slot is unset.
.TP
\f[B]dynamicOffsets\f[R] \f[I](optional)\f[R]
A value specifying the offset, in bytes, for each entry in
\f[CR]bindGroup\f[R] with \f[CR]hasDynamicOffset: true\f[R] set (i.e.,
in the descriptor of the \f[CR]GPUDevice.createBindGroupLayout()\f[R]
call that created the \f[CR]GPUBindGroupLayout\f[R] object that the
\f[CR]bindGroup\f[R] is based on).
This value can be:
.RS
.IP \(bu 2
An array of numbers specifying the different offsets.
.IP \(bu 2
A \f[CR]Uint32Array\f[R] containing numbers specifying the offsets.
.RE
.PP
If a \f[CR]Uint32Array\f[R] value is specified for
\f[CR]dynamicOffsets\f[R], both of the following parameters are also
required:
.TP
\f[B]dynamicOffsetsStart\f[R]
A number specifying the offset, in array elements, into
\f[CR]dynamicOffsetsData\f[R], where the dynamic offset data begins.
.TP
\f[B]dynamicOffsetsLength\f[R]
A number specifying the number of dynamic offset values to be read from
in \f[CR]dynamicOffsetsData\f[R].
.SS Return value
None (\f[CR]Undefined\f[R]).
.SS Exceptions
For \f[CR]setBindGroup()\f[R] calls that use a \f[CR]Uint32Array\f[R]
value for \f[CR]dynamicOffsets\f[R], the call will throw with a
\f[CR]RangeError\f[R] \f[CR]DOMException\f[R] if:
.IP \(bu 2
\f[CR]dynamicOffsetsStart\f[R] is less than 0.
.IP \(bu 2
\f[CR]dynamicOffsetsStart\f[R] + \f[CR]dynamicOffsetsLength\f[R] is
greater than \f[CR]dynamicOffsets.length\f[R].
.SS Validation
The following criteria must be met when calling
\f[B]\f[CB]setBindGroup()\f[B]\f[R], otherwise a
\f[CR]GPUValidationError\f[R] is generated and the
\f[CR]GPURenderPassEncoder\f[R] becomes invalid:
.IP \(bu 2
\f[CR]index\f[R] is less than or equal to the \f[CR]GPUDevice\f[R]\(cqs
\f[CR]maxBindGroups\f[R] limit.
.IP \(bu 2
\f[CR]dynamicOffsets.length\f[R] is the same as the number of entries in
\f[CR]bindGroup\f[R] with \f[CR]hasDynamicOffset: true\f[R] set.
.IP \(bu 2
For \f[CR]bindGroup\f[R] entries where the bound \f[CR]buffer\f[R]\(cqs
\f[CR]type\f[R] is \f[CR]\(dquniform\(dq\f[R] (see
\f[CR]GPUDevice.createBindGroupLayout()\f[R]), each number in
\f[CR]dynamicOffsets\f[R] is a multiple of the \f[CR]GPUDevice\f[R]\(cqs
\f[CR]minUniformBufferOffsetAlignment\f[R] limit.
.IP \(bu 2
For \f[CR]bindGroup\f[R] entries where the bound \f[CR]buffer\f[R]\(cqs
\f[CR]type\f[R] is \f[CR]\(dqstorage\(dq\f[R] or
\f[CR]\(dqread\-only\-storage\(dq\f[R] (see
\f[CR]GPUDevice.createBindGroupLayout()\f[R]), each number in
\f[CR]dynamicOffsets\f[R] is a multiple of the \f[CR]GPUDevice\f[R]\(cqs
\f[CR]minStorageBufferOffsetAlignment\f[R] limit.
.IP \(bu 2
For each \f[CR]bindGroup\f[R] entry, the bound \f[CR]buffer\f[R]\(cqs
\f[CR]offset\f[R], plus the corresponding layout entry\(cqs
\f[CR]minBindingSize\f[R], plus the corresponding dynamic offset
specified in \f[CR]dynamicOffsets\f[R], is less than or equal to the
bound \f[CR]buffer\f[R]\(cqs \f[CR]size\f[R].
.SH EXAMPLES
.SS Set bind group
In the WebGPU Samples \c
.UR https://webgpu.github.io/webgpu-samples/samples/texturedCube/
Textured Cube example
.UE \c
, \f[CR]setBindGroup()\f[R] is used to bind the
\f[CR]uniformBindGroup\f[R] to index position 0.
Check out the example for the full context.
.IP
.EX
\f[I]// \&...\f[R]

\f[B]const\f[R] commandEncoder = device.createCommandEncoder();
\f[B]const\f[R] passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
passEncoder.setPipeline(pipeline);
passEncoder.setBindGroup(0, uniformBindGroup);
passEncoder.setVertexBuffer(0, verticesBuffer);
passEncoder.draw(cubeVertexCount, 1, 0, 0);
passEncoder.end();
device.queue.submit([commandEncoder.finish()]);

\f[I]// \&...\f[R]
.EE
.RS
.PP
\f[B]Note:\f[R] Study the other \c
.UR https://webgpu.github.io/webgpu-samples/
WebGPU Samples
.UE \c
\ for more examples of \f[CR]setBindGroup()\f[R] usage.
.RE
.SS Unset bind group
.IP
.EX
\f[I]// Set bind group in slot 0\f[R]
passEncoder.setBindGroup(0, uniformBindGroup);

\f[I]// Later, unset bind group in slot 0\f[R]
passEncoder.setBindGroup(0, \f[B]null\f[R]);
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
