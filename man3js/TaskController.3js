.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "TaskController" "JS" "July 25, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
TaskController \- TaskController
.SH SYNOPSIS
The \f[B]\f[CB]TaskController\f[B]\f[R] interface of the Prioritized
Task Scheduling API represents a controller object that can be used to
both abort and change the priority of one or more prioritized tasks.
If there is no need to change task priorities, then
\f[CR]AbortController\f[R] can be used instead.
.PP
A new \f[CR]TaskController\f[R] instance is created using the
\f[CR]TaskController()\f[R] constructor, optionally specifying a
priority for its associated signal (a \f[CR]TaskSignal\f[R]).
If not specified, the signal will have a priority of
\f[CR]\[dq]user\-visible\[dq]\f[R] by default.
.PP
The controller\[cq]s signal can be passed as an argument to the
\f[CR]Scheduler.postTask()\f[R] method for one or more tasks.
For mutable tasks (only) the task is initialized with the signal
priority, and can later be changed by calling
\f[CR]TaskController.setPriority()\f[R].
For immutable tasks, any priority initialized or set by the controller
is ignored.
.PP
Tasks can be aborted by calling \f[CR]abort()\f[R] on the controller.
.SH CONSTRUCTOR
.TP
\f[B]TaskController()\f[R]
Creates a new \f[CR]TaskController\f[R] object, optionally specifying
the priority of its associated \f[CR]signal\f[R].
.SH INSTANCE METHODS
\f[I]This interface also inherits the methods of its parent,
\f[CI]AbortController\f[I].\f[R]
.TP
\f[B]TaskController.setPriority()\f[R]
Sets the priority of the controller\[cq]s \f[CR]signal\f[R], and hence
the priority of any tasks with which it is associated.
This notifies observers of the priority change by dispatching a
\f[CR]prioritychange\f[R] event.
.SH INSTANCE PROPERTIES
\f[I]This interface also inherits the properties of its parent,
\f[CI]AbortController\f[I].\f[R]
.TP
\f[B]TaskController.signal\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]TaskSignal\f[R] object instance.
The signal is passed to tasks so that they can be aborted or
re\-prioritized by the controller.
The property is inherited from \f[CR]AbortController\f[R].
.SH EXAMPLES
.RS
.PP
\f[B]Note:\f[R] Additional \[lq]live\[rq] examples can be found in:
Prioritized Task Scheduling API Examples.
.RE
.PP
First we create a task controller, setting the priority of its
associated signal to \f[CR]user\-blocking\f[R].
.IP
.EX
\f[I]// Create a TaskController, setting its signal priority to \[aq]user\-blocking\[aq]\f[R]
\f[B]const\f[R] controller = \f[B]new\f[R] TaskController({ priority: \[dq]user\-blocking\[dq] });
.EE
.PP
We then add an event listener for \f[CR]prioritychange\f[R] events (here
\f[CR]addEventListener()\f[R] is called, but we could instead assign a
handler to \f[CR]TaskSignal.onprioritychange\f[R]).
The handler uses previousPolicy on the event to get the original
priority and \f[CR]TaskSignal.priority\f[R] on the event target to get
the new priority.
.IP
.EX
\f[I]// Listen for \[aq]prioritychange\[aq] events on the controller\[aq]s signal.\f[R]
controller.signal.addEventListener(\[dq]prioritychange\[dq], (event) \f[B]=>\f[R] {
  \f[B]const\f[R] previousPriority = event.previousPriority;
  \f[B]const\f[R] newPriority = event.target.priority;
  console.log(\[ga]Priority changed from ${previousPriority} to ${newPriority}.\[ga]);
});
.EE
.PP
We can also listen for \f[CR]abort\f[R] events as shown below.
This same approach would be used if the controller was an
\f[CR]AbortController\f[R].
.IP
.EX
controller.signal.addEventListener(\[dq]abort\[dq], (event) \f[B]=>\f[R] {
  console.log(\[dq]Task aborted\[dq]);
});
.EE
.PP
Next we post the task, passing the controller signal in the optional
argument.
In this case the task is just an arrow function that resolves the
promise by returning some text.
We use \f[CR]then\f[R] and \f[CR]catch\f[R] to handle when the task
resolves or is rejected, logging the return text or the error in each
case.
Note that in a later code block we abort the task, so only the
\f[CR]catch()\f[R] block will actually be run!
.IP
.EX
\f[I]// Post task using the controller\[aq]s signal.\f[R]
\f[I]// The signal priority sets the initial priority of the task\f[R]
scheduler
  .postTask(() \f[B]=>\f[R] \[dq]Task execute\[dq], { signal: controller.signal })
  .then((taskResult) \f[B]=>\f[R] {
    console.log(\[ga]${taskResult}\[ga]);
  }) \f[I]// Aborted (won\[aq]t run)\f[R]
  .catch((error) \f[B]=>\f[R] {
    console.log(\[ga]Catch error: ${error}\[ga]);
  }); \f[I]// Log error\f[R]
.EE
.PP
We can use the controller to manage the task.
Here we can change the priority using
\f[CR]TaskController.setPriority()\f[R].
This will trigger the associated \f[CR]prioritychange\f[R] event.
.IP
.EX
\f[I]// Change the priority to \[aq]background\[aq] using the controller\f[R]
controller.setPriority(\[dq]background\[dq]);
.EE
.PP
Finally, the task can be aborted by calling \f[CR]abort()\f[R] on the
controller.
.IP
.EX
\f[I]// Abort the task\f[R]
controller.abort();
.EE
.PP
The console output of this example would be:
.IP
.EX
The priority changed from user\-blocking to background.
Task aborted
Catch error: AbortError
.EE
