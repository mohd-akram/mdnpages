'\" t
.\" Automatically generated by Pandoc 3.4
.\"
.TH "Symbol.unscopables" "JS" "July 15, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Symbol.unscopables \- Symbol.unscopables
.SH SYNOPSIS
The \f[B]\f[CB]Symbol.unscopables\f[B]\f[R] static data property
represents the well\-known symbol \f[CR]Symbol.unscopables\f[R].
The \f[CR]with\f[R] statement looks up this symbol on the scope object
for a property containing a collection of properties that should not
become bindings within the \f[CR]with\f[R] environment.
.SH VALUE
The well\-known symbol \f[CR]Symbol.unscopables\f[R].
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
no
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
no
T}
.TE
.SH DESCRIPTION
The \f[CR][Symbol.unscopables]\f[R] symbol (accessed via
\f[CR]Symbol.unscopables\f[R]) can be defined on any object to exclude
property names from being exposed as lexical variables in
\f[CR]with\f[R] environment bindings.
Note that when using strict mode, \f[CR]with\f[R] statements are not
available, and this symbol is likely not needed.
.PP
Setting a property of the \f[CR][Symbol.unscopables]\f[R] object to
\f[CR]true\f[R] (or any truthy value) will make the corresponding
property of the \f[CR]with\f[R] scope object \f[I]unscopable\f[R] and
therefore won\[cq]t be introduced to the \f[CR]with\f[R] body scope.
Setting a property to \f[CR]false\f[R] (or any falsy value) will make it
\f[I]scopable\f[R] and thus appear as lexical scope variables.
.PP
When deciding whether \f[CR]x\f[R] is unscopable, the entire prototype
chain of the \f[CR][Symbol.unscopables]\f[R] property is looked up for a
property called \f[CR]x\f[R].
This means if you declared \f[CR][Symbol.unscopables]\f[R] as a plain
object, \f[CR]Object.prototype\f[R] properties like \f[CR]toString\f[R]
would become unscopable as well, which may cause backward
incompatibility for legacy code assuming those properties are normally
scoped (see an example below).
You are advised to make your custom \f[CR][Symbol.unscopables]\f[R]
property have \f[CR]null\f[R] as its prototype, like
\f[CR]Array.prototype[Symbol.unscopables]\f[R] does.
.PP
This protocol is also utilized by DOM APIs, such as
\f[CR]Element.prototype.append()\f[R].
.SH EXAMPLES
.SS Scoping in with statements
The following code works fine in ES5 and below.
However, in ECMAScript 2015, the \f[CR]Array.prototype.values()\f[R]
method was introduced.
That means that inside a \f[CR]with\f[R] environment, \[lq]values\[rq]
would now be the \f[CR]Array.prototype.values()\f[R] method and not the
variable outside the \f[CR]with\f[R] statement.
.IP
.EX
\f[B]var\f[R] values = [];

\f[B]with\f[R] (values) {
  \f[I]// If [Symbol.unscopables] did not exist, values would become\f[R]
  \f[I]// Array.prototype.values starting with ECMAScript 2015.\f[R]
  \f[I]// And an error would have occurred.\f[R]
  values.push(\[dq]something\[dq]);
}
.EE
.PP
The code containing \f[CR]with (values)\f[R] caused some websites to
malfunction in Firefox when \f[CR]Array.prototype.values()\f[R] was
added (\c
.UR https://bugzil.la/883914
Firefox Bug 883914
.UE \c
).
Furthermore, this implies that any future array method addition may be
breaking if it implicitly changes the \f[CR]with\f[R] scope.
Therefore, the \f[CR][Symbol.unscopables]\f[R] symbol was introduced and
implemented on \f[CR]Array\f[R] as
\f[CR]Array.prototype[Symbol.unscopables]\f[R] to prevent some of the
Array methods being scoped into the \f[CR]with\f[R] statement.
.SS Unscopables in objects
You can also set \f[CR][Symbol.unscopables]\f[R] for your own objects.
.IP
.EX
\f[B]const\f[R] obj = {
  foo: 1,
  bar: 2,
  baz: 3,
};

obj[Symbol.unscopables] = {
  \f[I]// Make the object have \[ga]null\[ga] prototype to prevent\f[R]
  \f[I]// \[ga]Object.prototype\[ga] methods from being unscopable\f[R]
  __proto__: \f[B]null\f[R],
  \f[I]// \[ga]foo\[ga] will be scopable\f[R]
  foo: \f[B]false\f[R],
  \f[I]// \[ga]bar\[ga] will be unscopable\f[R]
  bar: \f[B]true\f[R],
  \f[I]// \[ga]baz\[ga] is omitted; because \[ga]undefined\[ga] is falsy, it is also scopable (default)\f[R]
};

\f[B]with\f[R] (obj) {
  console.log(foo); \f[I]// 1\f[R]
  console.log(bar); \f[I]// ReferenceError: bar is not defined\f[R]
  console.log(baz); \f[I]// 3\f[R]
}
.EE
.SS Avoid using a non\-null\-prototype object as \f[CR][Symbol.unscopables]\f[R]
Declaring \f[CR][Symbol.unscopables]\f[R] as a plain object without
eliminating its prototype may cause subtle bugs.
Consider the following code working before
\f[CR][Symbol.unscopables]\f[R]:
.IP
.EX
\f[B]const\f[R] character = {
  name: \[dq]Yoda\[dq],
  toString: \f[B]function\f[R] () {
    \f[B]return\f[R] \[dq]Use with statements, you must not\[dq];
  },
};

\f[B]with\f[R] (character) {
  console.log(name + \[aq] says: \[dq]\[aq] + toString() + \[aq]\[dq]\[aq]); \f[I]// Yoda says: \[dq]Use with statements, you must not\[dq]\f[R]
}
.EE
.PP
To preserve backward compatibility, you decided to add an
\f[CR][Symbol.unscopables]\f[R] property when adding more properties to
\f[CR]character\f[R].
You may na√Øvely do it like:
.PP
\f[B]Bad\f[R]
.IP
.EX
\f[B]const\f[R] character = {
  name: \[dq]Yoda\[dq],
  toString: \f[B]function\f[R] () {
    \f[B]return\f[R] \[dq]Use with statements, you must not\[dq];
  },
  student: \[dq]Luke\[dq],
  [Symbol.unscopables]: {
    \f[I]// Make \[ga]student\[ga] unscopable\f[R]
    student: \f[B]true\f[R],
  },
};
.EE
.PP
However, the code above now breaks:
.IP
.EX
\f[B]with\f[R] (character) {
  console.log(name + \[aq] says: \[dq]\[aq] + toString() + \[aq]\[dq]\[aq]); \f[I]// Yoda says: \[dq][object Undefined]\[dq]\f[R]
}
.EE
.PP
This is because when looking up
\f[CR]character[Symbol.unscopables].toString\f[R], it returns
\f[CR]Object.prototype.toString()\f[R], which is a truthy value, thus
making the \f[CR]toString()\f[R] call in the \f[CR]with()\f[R] statement
reference \f[CR]globalThis.toString()\f[R] instead \[em] and because
it\[cq]s called without a \f[CR]this\f[R], \f[CR]this\f[R] is
\f[CR]undefined\f[R], making it return \f[CR][object Undefined]\f[R].
.PP
Even when the method is not overridden by \f[CR]character\f[R], making
it unscopable will change the value of \f[CR]this\f[R].
.IP
.EX
\f[B]const\f[R] proto = {};
\f[B]const\f[R] obj = { __proto__: proto };

\f[B]with\f[R] (proto) {
  console.log(isPrototypeOf(obj)); \f[I]// true; \[ga]isPrototypeOf\[ga] is scoped and \[ga]this\[ga] is \[ga]proto\[ga]\f[R]
}

proto[Symbol.unscopables] = {};

\f[B]with\f[R] (proto) {
  console.log(isPrototypeOf(obj)); \f[I]// TypeError: Cannot convert undefined or null to object\f[R]
  \f[I]// \[ga]isPrototypeOf\[ga] is unscoped and \[ga]this\[ga] is undefined\f[R]
}
.EE
.PP
To fix this, always make sure \f[CR][Symbol.unscopables]\f[R] only
contains properties you wish to be unscopable, without
\f[CR]Object.prototype\f[R] properties.
.PP
\f[B]Good\f[R]
.IP
.EX
\f[B]const\f[R] character = {
  name: \[dq]Yoda\[dq],
  toString: \f[B]function\f[R] () {
    \f[B]return\f[R] \[dq]Use with statements, you must not\[dq];
  },
  student: \[dq]Luke\[dq],
  [Symbol.unscopables]: {
    \f[I]// Make the object have \[ga]null\[ga] prototype to prevent\f[R]
    \f[I]// \[ga]Object.prototype\[ga] methods from being unscopable\f[R]
    __proto__: \f[B]null\f[R],
    \f[I]// Make \[ga]student\[ga] unscopable\f[R]
    student: \f[B]true\f[R],
  },
};
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Array.prototype[Symbol.unscopables]\f[R]
.IP \[bu] 2
\f[CR]with\f[R]
.IP \[bu] 2
\f[CR]Element.prototype.append()\f[R]
