.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPUBUFFER.MAPSTATE" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPUBuffer.mapState \- GPUBuffer: mapState property
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]mapState\f[B]\f[R] read\-only property of the
\f[CR]GPUBuffer\f[R] interface represents the mapped state of the
\f[CR]GPUBuffer\f[R].
.SH VALUE
An enumerated value.
Possible values are:
.TP
\f[B]unmapped\f[R]
The buffer is not mapped.
\f[CR]GPUBuffer.getMappedRange()\f[R] cannot be used to access the
contents of the \f[CR]GPUBuffer\f[R] in JavaScript.
This could be because:
.RS
.IP \(bu 2
\f[CR]GPUBuffer.mapAsync()\f[R] has not yet been called.
.IP \(bu 2
The \f[CR]GPUBuffer\f[R] was previously mapped, and then unmapped again
with \f[CR]GPUBuffer.unmap()\f[R].
.RE
.TP
\f[B]pending\f[R]
The buffer is not yet mapped.
\f[CR]GPUBuffer.mapAsync()\f[R] has been called, but its
\f[CR]Promise\f[R] is currently pending.
\f[CR]GPUBuffer.getMappedRange()\f[R] cannot currently be used to access
the contents of the \f[CR]GPUBuffer\f[R] in JavaScript.
.TP
\f[B]mapped\f[R]
The buffer is mapped.
The \f[CR]GPUBuffer.mapAsync()\f[R] \f[CR]Promise\f[R] has fulfilled,
and \f[CR]GPUBuffer.getMappedRange()\f[R] can now be used to access the
contents of the \f[CR]GPUBuffer\f[R] in JavaScript.
.SH EXAMPLES
.IP
.EX
\f[B]const\f[R] stagingBuffer = device.createBuffer({
  size: BUFFER_SIZE,
  usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
});

console.log(stagingBuffer.mapState); \f[I]// \(dqunmapped\(dq\f[R]

\f[I]// \&...\f[R]

\f[B]await\f[R] stagingBuffer.mapAsync(
  GPUMapMode.READ,
  0, \f[I]// Offset\f[R]
  BUFFER_SIZE, \f[I]// Length\f[R]
);

console.log(stagingBuffer.mapState); \f[I]// \(dqmapped\(dq\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
