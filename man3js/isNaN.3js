.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "isNaN" "JS" "February 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
isNaN - isNaN()
.SH SYNOPSIS
The \f[B]\f[CB]isNaN()\f[B]\f[R] function determines whether a value is
\f[CR]NaN\f[R] when converted to a number.
Because coercion inside the \f[CR]isNaN()\f[R] function can be
surprising, you may alternatively want to use \f[CR]Number.isNaN()\f[R].
.SH SYNTAX
.IP
.EX
isNaN(value)
.EE
.SS Parameters
.TP
\f[B]value\f[R]
The value to be tested.
.SS Return value
\f[CR]true\f[R] if the given value is \f[CR]NaN\f[R] after being
converted to a number; otherwise, \f[CR]false\f[R].
.SH DESCRIPTION
\f[CR]isNaN()\f[R] is a function property of the global object.
.PP
For number values, \f[CR]isNaN()\f[R] tests if the number is the value
\f[CR]NaN\f[R].
When the argument to the \f[CR]isNaN()\f[R] function is not of type
Number, the value is first coerced to a number, and the resulting value
is then compared against \f[CR]NaN\f[R].
.PP
This behavior of \f[CR]isNaN()\f[R] for non-numeric arguments can be
confusing!
For example, an empty string is coerced to 0, while a boolean is coerced
to 0 or 1; both values are intuitively \[lq]not numbers\[rq], but they
don\[cq]t evaluate to \f[CR]NaN\f[R], so \f[CR]isNaN()\f[R] returns
\f[CR]false\f[R].
Therefore, \f[CR]isNaN()\f[R] answers neither the question \[lq]is the
input the floating point \f[CR]NaN\f[R] value\[rq] nor the question
\[lq]is the input not a number\[rq].
.PP
\f[CR]Number.isNaN()\f[R] is a more reliable way to test whether a value
is the number value \f[CR]NaN\f[R] or not.
Alternatively, the expression \f[CR]x !== x\f[R] can be used, and
neither of the solutions is subject to the false positives that make the
global \f[CR]isNaN()\f[R] unreliable.
To test if a value is a number, use
\f[CR]typeof x === \[dq]number\[dq]\f[R].
.PP
The \f[CR]isNaN()\f[R] function answers the question \[lq]is the input
functionally equivalent to \f[CR]NaN\f[R] when used in a number
context\[rq].
If \f[CR]isNaN(x)\f[R] returns \f[CR]false\f[R], you can use
\f[CR]x\f[R] in an arithmetic expression as if it\[cq]s a valid number
that\[cq]s not \f[CR]NaN\f[R].
If \f[CR]isNaN(x)\f[R] returns \f[CR]true\f[R], \f[CR]x\f[R] will get
coerced to \f[CR]NaN\f[R] and make most arithmetic expressions return
\f[CR]NaN\f[R] (because \f[CR]NaN\f[R] propagates).
You can use this, for example, to test whether an argument to a function
is arithmetically processable (usable \[lq]like\[rq] a number), and
handle values that are not number-like by throwing an error, providing a
default value, etc.
This way, you can have a function that makes use of the full versatility
JavaScript provides by implicitly converting values depending on
context.
.RS
.PP
\f[B]Note:\f[R] The \f[CR]+\f[R] operator performs both number addition
and string concatenation.
Therefore, even if \f[CR]isNaN()\f[R] returns \f[CR]false\f[R] for both
operands, the \f[CR]+\f[R] operator may still return a string, because
it\[cq]s not used as an arithmetic operator.
For example, \f[CR]isNaN(\[dq]1\[dq])\f[R] returns \f[CR]false\f[R], but
\f[CR]\[dq]1\[dq] + 1\f[R] returns \f[CR]\[dq]11\[dq]\f[R].
To be sure that you are working with numbers, coerce the value to a
number and use \f[CR]Number.isNaN()\f[R] to test the result.
.RE
.SH EXAMPLES
Note how \f[CR]isNaN()\f[R] returns \f[CR]true\f[R] for values that are
not the value \f[CR]NaN\f[R] but are not numbers either:
.IP
.EX
isNaN(NaN); // true
isNaN(undefined); // true
isNaN({}); // true

isNaN(true); // false
isNaN(null); // false
isNaN(37); // false

// Strings
isNaN(\[dq]37\[dq]); // false: \[dq]37\[dq] is converted to the number 37 which is not NaN
isNaN(\[dq]37.37\[dq]); // false: \[dq]37.37\[dq] is converted to the number 37.37 which is not NaN
isNaN(\[dq]37,5\[dq]); // true
isNaN(\[dq]123ABC\[dq]); // true: Number(\[dq]123ABC\[dq]) is NaN
isNaN(\[dq]\[dq]); // false: the empty string is converted to 0 which is not NaN
isNaN(\[dq] \[dq]); // false: a string with spaces is converted to 0 which is not NaN

// Dates
isNaN(new Date()); // false; Date objects can be converted to a number (timestamp)
isNaN(new Date().toString()); // true; the string representation of a Date object cannot be parsed as a number
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]NaN\f[R]
.IP \[bu] 2
\f[CR]Number.isNaN()\f[R]
