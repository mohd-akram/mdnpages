.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "isNaN" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
isNaN \- isNaN()
.SH SYNOPSIS
The \f[B]\f[CB]isNaN()\f[B]\f[R] function determines whether a value is
\f[CR]NaN\f[R], first converting the value to a number if necessary.
Because coercion inside the \f[CR]isNaN()\f[R] function can be
surprising, you may prefer to use \f[CR]Number.isNaN()\f[R].
.IP
.EX
\f[B]function\f[R] milliseconds(x) {
  \f[B]if\f[R] (isNaN(x)) {
    \f[B]return\f[R] \[dq]Not a Number!\[dq];
  }
  \f[B]return\f[R] x * 1000;
}

console.log(milliseconds(\[dq]100F\[dq]));
\f[I]// Expected output: \[dq]Not a Number!\[dq]\f[R]

console.log(milliseconds(\[dq]0.0314E+2\[dq]));
\f[I]// Expected output: 3140\f[R]
.EE
.SH SYNTAX
.IP
.EX
isNaN(value)
.EE
.SS Parameters
.TP
\f[B]value\f[R]
The value to be tested.
.SS Return value
\f[CR]true\f[R] if the given value is \f[CR]NaN\f[R] after being
converted to a number; otherwise, \f[CR]false\f[R].
.SH DESCRIPTION
\f[CR]isNaN()\f[R] is a function property of the global object.
.PP
For number values, \f[CR]isNaN()\f[R] tests if the number is the value
\f[CR]NaN\f[R].
When the argument to the \f[CR]isNaN()\f[R] function is not of type
Number, the value is first coerced to a number, and the resulting value
is then compared against \f[CR]NaN\f[R].
.PP
This behavior of \f[CR]isNaN()\f[R] for non\-numeric arguments can be
confusing!
For example, an empty string is coerced to 0, while a boolean is coerced
to 0 or 1; both values are intuitively \[lq]not numbers\[rq], but they
don\[cq]t evaluate to \f[CR]NaN\f[R], so \f[CR]isNaN()\f[R] returns
\f[CR]false\f[R].
Therefore, \f[CR]isNaN()\f[R] answers neither the question \[lq]is the
input the floating point \f[CR]NaN\f[R] value\[rq] nor the question
\[lq]is the input not a number\[rq].
.PP
\f[CR]Number.isNaN()\f[R] is a more reliable way to test whether a value
is the number value \f[CR]NaN\f[R] or not.
Alternatively, the expression \f[CR]x !== x\f[R] can be used, and
neither of the solutions is subject to the false positives that make the
global \f[CR]isNaN()\f[R] unreliable.
To test if a value is a number, use
\f[CR]typeof x === \[dq]number\[dq]\f[R].
.PP
The \f[CR]isNaN()\f[R] function answers the question \[lq]is the input
functionally equivalent to \f[CR]NaN\f[R] when used in a number
context\[rq].
If \f[CR]isNaN(x)\f[R] returns \f[CR]false\f[R], you can use
\f[CR]x\f[R] in an arithmetic expression as if it\[cq]s a valid number
that\[cq]s not \f[CR]NaN\f[R].
If \f[CR]isNaN(x)\f[R] returns \f[CR]true\f[R], \f[CR]x\f[R] will get
coerced to \f[CR]NaN\f[R] and make most arithmetic expressions return
\f[CR]NaN\f[R] (because \f[CR]NaN\f[R] propagates).
You can use this, for example, to test whether an argument to a function
is arithmetically processable (usable \[lq]like\[rq] a number), and
handle values that are not number\-like by throwing an error, providing
a default value, etc.
This way, you can have a function that makes use of the full versatility
JavaScript provides by implicitly converting values depending on
context.
.RS
.PP
\f[B]Note:\f[R] The \f[CR]+\f[R] operator performs both number addition
and string concatenation.
Therefore, even if \f[CR]isNaN()\f[R] returns \f[CR]false\f[R] for both
operands, the \f[CR]+\f[R] operator may still return a string, because
it\[cq]s not used as an arithmetic operator.
For example, \f[CR]isNaN(\[dq]1\[dq])\f[R] returns \f[CR]false\f[R], but
\f[CR]\[dq]1\[dq] + 1\f[R] returns \f[CR]\[dq]11\[dq]\f[R].
To be sure that you are working with numbers, coerce the value to a
number and use \f[CR]Number.isNaN()\f[R] to test the result.
.RE
.SH EXAMPLES
Note how \f[CR]isNaN()\f[R] returns \f[CR]true\f[R] for values that are
not the value \f[CR]NaN\f[R] but are not numbers either:
.IP
.EX
isNaN(\f[B]NaN\f[R]); \f[I]// true\f[R]
isNaN(\f[B]undefined\f[R]); \f[I]// true\f[R]
isNaN({}); \f[I]// true\f[R]

isNaN(\f[B]true\f[R]); \f[I]// false\f[R]
isNaN(\f[B]null\f[R]); \f[I]// false\f[R]
isNaN(37); \f[I]// false\f[R]

\f[I]// Strings\f[R]
isNaN(\[dq]37\[dq]); \f[I]// false: \[dq]37\[dq] is converted to the number 37 which is not NaN\f[R]
isNaN(\[dq]37.37\[dq]); \f[I]// false: \[dq]37.37\[dq] is converted to the number 37.37 which is not NaN\f[R]
isNaN(\[dq]37,5\[dq]); \f[I]// true\f[R]
isNaN(\[dq]123ABC\[dq]); \f[I]// true: Number(\[dq]123ABC\[dq]) is NaN\f[R]
isNaN(\[dq]\[dq]); \f[I]// false: the empty string is converted to 0 which is not NaN\f[R]
isNaN(\[dq] \[dq]); \f[I]// false: a string with spaces is converted to 0 which is not NaN\f[R]

\f[I]// Dates\f[R]
isNaN(\f[B]new\f[R] Date()); \f[I]// false; Date objects can be converted to a number (timestamp)\f[R]
isNaN(\f[B]new\f[R] Date().toString()); \f[I]// true; the string representation of a Date object cannot be parsed as a number\f[R]

\f[I]// Arrays\f[R]
isNaN([]); \f[I]// false; the primitive representation is \[dq]\[dq], which coverts to the number 0\f[R]
isNaN([1]); \f[I]// false; the primitive representation is \[dq]1\[dq]\f[R]
isNaN([1, 2]); \f[I]// true; the primitive representation is \[dq]1,2\[dq], which cannot be parsed as number\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]NaN\f[R]
.IP \[bu] 2
\f[CR]Number.isNaN()\f[R]
