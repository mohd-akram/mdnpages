.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "SUBTLECRYPTO.GENERATEKEY" "3JS" "September 25, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SubtleCrypto.generateKey \- SubtleCrypto: generateKey() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]generateKey()\f[B]\f[R] method of the
\f[CR]SubtleCrypto\f[R] interface is used to generate a new key (for
symmetric algorithms) or key pair (for public\-key algorithms).
.SH SYNTAX
.IP
.EX
generateKey(algorithm, extractable, keyUsages)
.EE
.SS Parameters
.TP
\f[B]algorithm\f[R]
An object defining the type of key to generate and providing extra
algorithm\-specific parameters.
.RS
.IP \(bu 2
For RSASSA\-PKCS1\-v1_5, RSA\-PSS, or RSA\-OAEP: pass an
\f[CR]RsaHashedKeyGenParams\f[R] object.
.IP \(bu 2
For ECDSA or ECDH: pass an \f[CR]EcKeyGenParams\f[R] object.
.IP \(bu 2
For HMAC: pass an \f[CR]HmacKeyGenParams\f[R] object.
.IP \(bu 2
For AES\-CTR, AES\-CBC, AES\-GCM, or AES\-KW: pass an
\f[CR]AesKeyGenParams\f[R] object.
.IP \(bu 2
For Ed25519: pass the string \f[CR]Ed25519\f[R] or an object of the form
\f[CR]{ name: \(dqEd25519\(dq }\f[R].
.IP \(bu 2
For X25519: pass the string \f[CR]X25519\f[R] or an object of the form
\f[CR]{ name: \(dqX25519\(dq }\f[R].
.RE
.TP
\f[B]extractable\f[R]
A boolean value indicating whether it will be possible to export the key
using \f[CR]SubtleCrypto.exportKey()\f[R] or
\f[CR]SubtleCrypto.wrapKey()\f[R].
.TP
\f[B]keyUsages\f[R]
An \f[CR]Array\f[R] of strings indicating what can be done with the
newly generated key.
Possible values for array elements are:
.RS
.TP
\f[B]encrypt\f[R]
The key may be used to encrypt messages.
.TP
\f[B]decrypt\f[R]
The key may be used to decrypt messages.
.TP
\f[B]sign\f[R]
The key may be used to sign messages.
.TP
\f[B]verify\f[R]
The key may be used to verify signatures.
.TP
\f[B]deriveKey\f[R]
The key may be used in deriving a new key.
.TP
\f[B]deriveBits\f[R]
The key may be used in deriving bits.
.TP
\f[B]wrapKey\f[R]
The key may be used to wrap a key.
.TP
\f[B]unwrapKey\f[R]
The key may be used to unwrap a key.
.RE
.SS Return value
A \f[CR]Promise\f[R] that fulfills with a \f[CR]CryptoKey\f[R] (for
symmetric algorithms) or a \f[CR]CryptoKeyPair\f[R] (for public\-key
algorithms).
.SS Exceptions
The promise is rejected when the following exception is encountered:
.TP
\f[B]SyntaxError\f[R] \f[B]DOMException\f[R]
Raised when the result is a \f[CR]CryptoKey\f[R] of type
\f[CR]secret\f[R] or \f[CR]private\f[R] but \f[CR]keyUsages\f[R] is
empty, or invalid for the algorithm type.
.TP
\f[B]SyntaxError\f[R] \f[B]DOMException\f[R]
Raised when the result is a \f[CR]CryptoKeyPair\f[R] and its
\f[CR]privateKey.usages\f[R] attribute is empty, or invalid for the
algorithm type.
.SH EXAMPLES
.RS
.PP
\f[B]Note:\f[R] You can \c
.UR https://mdn.github.io/dom-examples/web-crypto/encrypt-decrypt/index.html
try the working examples
.UE \c
\ on GitHub.
.RE
.SS RSA key pair generation
This code generates an RSA\-OAEP encryption key pair.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/encrypt-decrypt/rsa-oaep.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]let\f[R] keyPair = \f[B]await\f[R] window.crypto.subtle.generateKey(
  {
    name: \(dqRSA\-OAEP\(dq,
    modulusLength: 4096,
    publicExponent: \f[B]new\f[R] Uint8Array([1, 0, 1]),
    hash: \(dqSHA\-256\(dq,
  },
  \f[B]true\f[R],
  [\(dqencrypt\(dq, \(dqdecrypt\(dq],
);
.EE
.SS Elliptic curve key pair generation
This code generates an ECDSA signing key pair.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/sign-verify/ecdsa.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]let\f[R] keyPair = \f[B]await\f[R] window.crypto.subtle.generateKey(
  {
    name: \(dqECDSA\(dq,
    namedCurve: \(dqP\-384\(dq,
  },
  \f[B]true\f[R],
  [\(dqsign\(dq, \(dqverify\(dq],
);
.EE
.SS HMAC key generation
This code generates an HMAC signing key.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/sign-verify/hmac.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]let\f[R] key = \f[B]await\f[R] window.crypto.subtle.generateKey(
  {
    name: \(dqHMAC\(dq,
    hash: { name: \(dqSHA\-512\(dq },
  },
  \f[B]true\f[R],
  [\(dqsign\(dq, \(dqverify\(dq],
);
.EE
.SS AES key generation
This code generates an AES\-GCM encryption key.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/encrypt-decrypt/aes-gcm.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]let\f[R] key = \f[B]await\f[R] window.crypto.subtle.generateKey(
  {
    name: \(dqAES\-GCM\(dq,
    length: 256,
  },
  \f[B]true\f[R],
  [\(dqencrypt\(dq, \(dqdecrypt\(dq],
);
.EE
.SS Ed25519 key generation
This code generates an Ed25519 signing key pair.
It is derived from \c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/sign-verify/ed25519.js
this source code on GitHub
.UE \c
, which you can \c
.UR https://mdn.github.io/dom-examples/web-crypto/sign-verify/
run live here
.UE \c
\&.
.SS JavaScript
Code for generating a key pair using the \f[CR]Ed25519\f[R] algorithm
and logging the information in each key is shown below.
Note that the code is run in a \f[CR]try..catch\f[R] block because not
all browsers support this algorithm.
.PP
The JavaScript first gets the \f[CR]#sign\-button\f[R] and
\f[CR]#message\f[R] \f[CR]<input>\f[R] elements, then adds a listener
for the \f[CR]click\f[R] event on the button.
The event handler clears the log and runs the other operations passing
the content of the \f[CR]<input>\f[R] element.
.IP
.EX
\f[B]const\f[R] button = document.querySelector(\(dq#run\-button\(dq);
\f[B]const\f[R] input = document.querySelector(\(dq#log\(dq);

button.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
  \f[I]// Clear log\f[R]
  logElement.innerText = \(dq\(dq;
  logElement.scrollTop = logElement.scrollHeight;
  \f[I]// Run test\f[R]
  test();
});

\f[B]async\f[R] \f[B]function\f[R] test() {
  \f[B]try\f[R] {
    \f[I]// Create a key pair and use destructuring assignment to assign to variables\f[R]
    \f[B]const\f[R] { publicKey, privateKey } = \f[B]await\f[R] crypto.subtle.generateKey(
      {
        name: \(dqEd25519\(dq,
      },
      \f[B]true\f[R],
      [\(dqsign\(dq, \(dqverify\(dq],
    );

    \f[I]// Log the properties of the keys\f[R]
    log(\(gapublicKey: ${publicKey}\(ga);
    log(\(ga type: ${publicKey.type}\(ga);
    log(\(ga extractable: ${publicKey.extractable}\(ga);
    log(\(ga algorithm: ${JSON.stringify(publicKey.algorithm)}\(ga);
    log(\(ga usages: ${publicKey.usages}\(ga);
    log(\(gaprivateKey: ${privateKey}\(ga);
    log(\(ga type: ${privateKey.type}\(ga);
    log(\(ga extractable: ${privateKey.extractable}\(ga);
    log(\(ga algorithm: ${JSON.stringify(privateKey.algorithm)}\(ga);
    log(\(ga usages: ${privateKey.usages}\(ga);
  } \f[B]catch\f[R] (error) {
    log(error);
  }
}
.EE
.SS Result
The information about the created keys is logged below (or an error
string if the browser does not allow the key to be created).
.SS X25519 key generation
This code generates an X25519 public and private key pair that can be
used in \f[CR]SubtleCrypto.deriveKey()\f[R] to create a shared key, or
in \f[CR]SubtleCrypto.deriveBits()\f[R] to create a shared secret.
.SS JavaScript
Code for generating a key pair using the \f[CR]X25519\f[R] algorithm and
logging the information in each key is shown below.
Note that the code is run in a \f[CR]try..catch\f[R] block because not
all browsers support this algorithm.
.PP
The JavaScript first gets the \f[CR]#run\-button\f[R] and
\f[CR]#log\f[R] \f[CR]<input>\f[R] elements, then adds a listener for
the \f[CR]click\f[R] event on the button.
The event handler clears the log, generates an X25519 key pair, and logs
some of its properties.
.IP
.EX
\f[B]const\f[R] button = document.querySelector(\(dq#run\-button\(dq);
\f[B]const\f[R] input = document.querySelector(\(dq#log\(dq);

button.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
  \f[I]// Clear log\f[R]
  logElement.innerText = \(dq\(dq;
  logElement.scrollTop = logElement.scrollHeight;
  \f[I]// Run test\f[R]
  test();
});

\f[B]async\f[R] \f[B]function\f[R] test() {
  \f[B]try\f[R] {
    \f[I]// Create a key pair and use destructuring assignment to assign to variables\f[R]
    \f[B]const\f[R] { publicKey, privateKey } = \f[B]await\f[R] crypto.subtle.generateKey(
      {
        name: \(dqX25519\(dq,
      },
      \f[B]true\f[R],
      [\(dqderiveKey\(dq, \(dqderiveBits\(dq],
    );

    \f[I]// Log the properties of the keys\f[R]
    log(\(gapublicKey: ${publicKey}\(ga);
    log(\(ga type: ${publicKey.type}\(ga);
    log(\(ga extractable: ${publicKey.extractable}\(ga);
    log(\(ga algorithm: ${JSON.stringify(publicKey.algorithm)}\(ga);
    log(\(ga usages: ${publicKey.usages}\(ga);
    log(\(gaprivateKey: ${privateKey}\(ga);
    log(\(ga type: ${privateKey.type}\(ga);
    log(\(ga extractable: ${privateKey.extractable}\(ga);
    log(\(ga algorithm: ${JSON.stringify(privateKey.algorithm)}\(ga);
    log(\(ga usages: ${privateKey.usages}\(ga);
  } \f[B]catch\f[R] (error) {
    log(error);
  }
}
.EE
.SS Result
The information about the created keys is logged below (or an error
string if the browser does not allow the key to be created).
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://www.keylength.com/
Cryptographic key length recommendations
.UE \c
\&.
.IP \(bu 2
\c
.UR https://csrc.nist.gov/pubs/sp/800/131/a/r2/final
NIST Transitioning the Use of Cryptographic Algorithms and Key Lengths
.UE \c
\&.
