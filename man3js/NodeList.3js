.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "NodeList" "JS" "June 21, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
NodeList \- NodeList
.SH SYNOPSIS
\f[B]\f[CB]NodeList\f[B]\f[R] objects are collections of nodes, usually
returned by properties such as \f[CR]Node.childNodes\f[R] and methods
such as \f[CR]document.querySelectorAll()\f[R].
.PP
This interface was an \c
.UR https://stackoverflow.com/questions/74630989/why-use-domstringlist-rather-than-an-array/74641156#74641156
attempt to create an unmodifiable list
.UE \c
\ and only continues to be supported to not break code that\[cq]s
already using it.
Modern APIs represent list structures using types based on JavaScript
arrays, thus making many array methods available, and at the same time
imposing additional semantics on their usage (such as making their items
read\-only).
.PP
These historical reasons do not mean that you as a developer should
avoid \f[CR]NodeList\f[R].
You don\[cq]t create \f[CR]NodeList\f[R] objects yourself, but you get
them from APIs such as \f[CR]Document.querySelectorAll()\f[R], and these
APIs are not deprecated.
However, be careful of the semantic differences from a real array.
.PP
Although \f[CR]NodeList\f[R] is not an \f[CR]Array\f[R], it is possible
to iterate over it with \f[CR]forEach()\f[R].
It can also be converted to a real \f[CR]Array\f[R] using
\f[CR]Array.from()\f[R].
.SH LIVE VS.\ STATIC NODELISTS
Although they are both considered \f[CR]NodeList\f[R] objects, there are
2 varieties of NodeList: \f[I]live\f[R] and \f[I]static\f[R].
.SS Live NodeLists
In some cases, the \f[CR]NodeList\f[R] is \f[I]live\f[R], which means
that changes in the DOM automatically update the collection.
.PP
For example, \f[CR]Node.childNodes\f[R] is live:
.IP
.EX
\f[B]const\f[R] parent = document.getElementById(\[dq]parent\[dq]);
\f[B]let\f[R] childNodes = parent.childNodes;
console.log(childNodes.length); \f[I]// let\[aq]s assume \[dq]2\[dq]\f[R]
parent.appendChild(document.createElement(\[dq]div\[dq]));
console.log(childNodes.length); \f[I]// outputs \[dq]3\[dq]\f[R]
.EE
.SS Static NodeLists
In other cases, the \f[CR]NodeList\f[R] is \f[I]static,\f[R] where any
changes in the DOM do not affect the content of the collection.
The ubiquitous \f[CR]document.querySelectorAll()\f[R] method returns a
\f[I]static\f[R] \f[CR]NodeList\f[R].
.PP
It\[cq]s good to keep this distinction in mind when you choose how to
iterate over the items in the \f[CR]NodeList\f[R], and whether you
should cache the list\[cq]s \f[CR]length\f[R].
.SH INSTANCE PROPERTIES
.TP
\f[B]NodeList.length\f[R] \f[I](read\-only)\f[R]
The number of nodes in the \f[CR]NodeList\f[R].
.SH INSTANCE METHODS
.TP
\f[B]NodeList.item()\f[R]
Returns an item in the list by its index, or \f[CR]null\f[R] if the
index is out\-of\-bounds.
.RS
.PP
An alternative to accessing \f[CR]nodeList[i]\f[R] (which instead
returns \f[CR]undefined\f[R] when \f[CR]i\f[R] is out\-of\-bounds).
This is mostly useful for non\-JavaScript DOM implementations.
.RE
.TP
\f[B]NodeList.entries()\f[R]
Returns an \f[CR]iterator\f[R], allowing code to go through all
key/value pairs contained in the collection.
(In this case, the keys are integers starting from \f[CR]0\f[R] and the
values are nodes.)
.TP
\f[B]NodeList.forEach()\f[R]
Executes a provided function once per \f[CR]NodeList\f[R] element,
passing the element as an argument to the function.
.TP
\f[B]NodeList.keys()\f[R]
Returns an \f[CR]iterator\f[R], allowing code to go through all the keys
of the key/value pairs contained in the collection.
(In this case, the keys are integers starting from \f[CR]0\f[R].)
.TP
\f[B]NodeList.values()\f[R]
Returns an \f[CR]iterator\f[R] allowing code to go through all values
(nodes) of the key/value pairs contained in the collection.
.SH EXAMPLE
It\[cq]s possible to loop over the items in a \f[CR]NodeList\f[R] using
a for loop:
.IP
.EX
\f[B]for\f[R] (\f[B]let\f[R] i = 0; i < myNodeList.length; i++) {
  \f[B]let\f[R] item = myNodeList[i];
}
.EE
.PP
\f[B]Don\[cq]t use \f[CB]for...in\f[B] to enumerate the items in
\f[CB]NodeList\f[B]s\f[R], since they will \f[I]also\f[R] enumerate its
\f[CR]length\f[R] and \f[CR]item\f[R] properties and cause errors if
your script assumes it only has to deal with \f[CR]element\f[R] objects.
Also, \f[CR]for...in\f[R] is not guaranteed to visit the properties in
any particular order.
.PP
\f[CR]for...of\f[R] loops loop over \f[CR]NodeList\f[R] objects
correctly:
.IP
.EX
\f[B]const\f[R] list = document.querySelectorAll(\[dq]input[type=checkbox]\[dq]);
\f[B]for\f[R] (\f[B]const\f[R] checkbox \f[B]of\f[R] list) {
  checkbox.checked = \f[B]true\f[R];
}
.EE
.PP
Browsers also support the iterator method (\f[CR]forEach()\f[R]) as well
as \f[CR]entries()\f[R], \f[CR]values()\f[R], and \f[CR]keys()\f[R].
