.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "NodeList" "JS" "August 11, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
NodeList \- NodeList
.SH SYNOPSIS
\f[B]\f[CB]NodeList\f[B]\f[R] objects are collections of nodes, usually
returned by properties such as \f[CR]Node.childNodes\f[R] and methods
such as \f[CR]document.querySelectorAll()\f[R].
.RS
.PP
\f[B]Note:\f[R] Although \f[CR]NodeList\f[R] is not an \f[CR]Array\f[R],
it is possible to iterate over it with \f[CR]forEach()\f[R].
It can also be converted to a real \f[CR]Array\f[R] using
\f[CR]Array.from()\f[R].
.RE
.SH LIVE VS.\ STATIC NODELISTS
Although they are both considered \f[CR]NodeList\f[R] objects, there are
2 varieties of NodeList: \f[I]live\f[R] and \f[I]static\f[R].
.SS Live NodeLists
In some cases, the \f[CR]NodeList\f[R] is \f[I]live\f[R], which means
that changes in the DOM automatically update the collection.
.PP
For example, \f[CR]Node.childNodes\f[R] is live:
.IP
.EX
\f[B]const\f[R] parent = document.getElementById(\[dq]parent\[dq]);
\f[B]let\f[R] childNodes = parent.childNodes;
console.log(childNodes.length); \f[I]// let\[aq]s assume \[dq]2\[dq]\f[R]
parent.appendChild(document.createElement(\[dq]div\[dq]));
console.log(childNodes.length); \f[I]// outputs \[dq]3\[dq]\f[R]
.EE
.SS Static NodeLists
In other cases, the \f[CR]NodeList\f[R] is \f[I]static,\f[R] where any
changes in the DOM do not affect the content of the collection.
The ubiquitous \f[CR]document.querySelectorAll()\f[R] method returns a
\f[I]static\f[R] \f[CR]NodeList\f[R].
.PP
It\[cq]s good to keep this distinction in mind when you choose how to
iterate over the items in the \f[CR]NodeList\f[R], and whether you
should cache the list\[cq]s \f[CR]length\f[R].
.SH INSTANCE PROPERTIES
.TP
\f[B]NodeList.length\f[R] \f[I](read\-only)\f[R]
The number of nodes in the \f[CR]NodeList\f[R].
.SH INSTANCE METHODS
.TP
\f[B]NodeList.item()\f[R]
Returns an item in the list by its index, or \f[CR]null\f[R] if the
index is out\-of\-bounds.
.RS
.PP
An alternative to accessing \f[CR]nodeList[i]\f[R] (which instead
returns \f[CR]undefined\f[R] when \f[CR]i\f[R] is out\-of\-bounds).
This is mostly useful for non\-JavaScript DOM implementations.
.RE
.TP
\f[B]NodeList.entries()\f[R]
Returns an \f[CR]iterator\f[R], allowing code to go through all
key/value pairs contained in the collection.
(In this case, the keys are integers starting from \f[CR]0\f[R] and the
values are nodes.)
.TP
\f[B]NodeList.forEach()\f[R]
Executes a provided function once per \f[CR]NodeList\f[R] element,
passing the element as an argument to the function.
.TP
\f[B]NodeList.keys()\f[R]
Returns an \f[CR]iterator\f[R], allowing code to go through all the keys
of the key/value pairs contained in the collection.
(In this case, the keys are integers starting from \f[CR]0\f[R].)
.TP
\f[B]NodeList.values()\f[R]
Returns an \f[CR]iterator\f[R] allowing code to go through all values
(nodes) of the key/value pairs contained in the collection.
.SH EXAMPLE
It\[cq]s possible to loop over the items in a \f[CR]NodeList\f[R] using
a for loop:
.IP
.EX
\f[B]for\f[R] (\f[B]let\f[R] i = 0; i < myNodeList.length; i++) {
  \f[B]let\f[R] item = myNodeList[i];
}
.EE
.PP
\f[B]Don\[cq]t use \f[CB]for...in\f[B] to enumerate the items in
\f[CB]NodeList\f[B]s\f[R], since they will \f[I]also\f[R] enumerate its
\f[CR]length\f[R] and \f[CR]item\f[R] properties and cause errors if
your script assumes it only has to deal with \f[CR]element\f[R] objects.
Also, \f[CR]for...in\f[R] is not guaranteed to visit the properties in
any particular order.
.PP
\f[CR]for...of\f[R] loops loop over \f[CR]NodeList\f[R] objects
correctly:
.IP
.EX
\f[B]const\f[R] list = document.querySelectorAll(\[dq]input[type=checkbox]\[dq]);
\f[B]for\f[R] (\f[B]const\f[R] checkbox \f[B]of\f[R] list) {
  checkbox.checked = \f[B]true\f[R];
}
.EE
.PP
Browsers also support the iterator method (\f[CR]forEach()\f[R]) as well
as \f[CR]entries()\f[R], \f[CR]values()\f[R], and \f[CR]keys()\f[R].
