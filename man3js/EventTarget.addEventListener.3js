.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "EVENTTARGET.ADDEVENTLISTENER" "3JS" "April 28, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
EventTarget.addEventListener \- EventTarget: addEventListener() method
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]addEventListener()\f[B]\f[R] method of the
\f[CR]EventTarget\f[R] interface sets up a function that will be called
whenever the specified event is delivered to the target.
.PP
Common targets are \f[CR]Element\f[R], or its children,
\f[CR]Document\f[R], and \f[CR]Window\f[R], but the target may be any
object that supports events (such as \f[CR]IDBRequest\f[R]).
.RS
.PP
\f[B]Note:\f[R] The \f[CR]addEventListener()\f[R] method is the
\f[I]recommended\f[R] way to register an event listener.
The benefits are as follows:
.IP \(bu 2
It allows adding more than one handler for an event.
This is particularly useful for libraries, JavaScript modules, or any
other kind of code that needs to work well with other libraries or
extensions.
.IP \(bu 2
In contrast to using an \f[CR]onXYZ\f[R] property, it gives you
finer\-grained control of the phase when the listener is activated
(capturing vs.\ bubbling).
.IP \(bu 2
It works on any event target, not just HTML or SVG elements.
.RE
.PP
The method \f[CR]addEventListener()\f[R] works by adding a function, or
an object that implements a \f[CR]handleEvent()\f[R] function, to the
list of event listeners for the specified event type on the
\f[CR]EventTarget\f[R] on which it\(cqs called.
If the function or object is already in the list of event listeners for
this target, the function or object is not added a second time.
.RS
.PP
\f[B]Note:\f[R] If a particular anonymous function is in the list of
event listeners registered for a certain target, and then later in the
code, an identical anonymous function is given in an
\f[CR]addEventListener\f[R] call, the second function will
\f[I]also\f[R] be added to the list of event listeners for that target.
.PP
Indeed, anonymous functions are not identical even if defined using the
\f[I]same\f[R] unchanging source\-code called repeatedly, \f[B]even if
in a loop\f[R].
.PP
Repeatedly defining the same unnamed function in such cases can be
problematic.
(See Memory issues, below.)
.RE
.PP
If an event listener is added to an \f[CR]EventTarget\f[R] from inside
another listener \(em that is, during the processing of the event \(em
that event will not trigger the new listener.
However, the new listener may be triggered during a later stage of event
flow, such as during the bubbling phase.
.SH SYNTAX
.IP
.EX
addEventListener(type, listener)
addEventListener(type, listener, options)
addEventListener(type, listener, useCapture)
.EE
.SS Parameters
.TP
\f[B]type\f[R]
A case\-sensitive string representing the event type to listen for.
.TP
\f[B]listener\f[R]
The object that receives a notification (an object that implements the
\f[CR]Event\f[R] interface) when an event of the specified type occurs.
This must be \f[CR]null\f[R], an object with a \f[CR]handleEvent()\f[R]
method, or a JavaScript function.
See The event listener callback for details on the callback itself.
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object that specifies characteristics about the event listener.
The available options are:
.RS
.TP
\f[B]capture\f[R] \f[I](optional)\f[R]
A boolean value indicating that events of this type will be dispatched
to the registered \f[CR]listener\f[R] before being dispatched to any
\f[CR]EventTarget\f[R] beneath it in the DOM tree.
If not specified, defaults to \f[CR]false\f[R].
.TP
\f[B]once\f[R] \f[I](optional)\f[R]
A boolean value indicating that the \f[CR]listener\f[R] should be
invoked at most once after being added.
If \f[CR]true\f[R], the \f[CR]listener\f[R] would be automatically
removed when invoked.
If not specified, defaults to \f[CR]false\f[R].
.TP
\f[B]passive\f[R] \f[I](optional)\f[R]
A boolean value that, if \f[CR]true\f[R], indicates that the function
specified by \f[CR]listener\f[R] will never call
\f[CR]preventDefault()\f[R].
If a passive listener calls \f[CR]preventDefault()\f[R], nothing will
happen and a console warning may be generated.
.RS
.PP
If this option is not specified it defaults to \f[CR]false\f[R] \(en
except that in browsers other than Safari, it defaults to
\f[CR]true\f[R] for \f[CR]wheel\f[R], \f[CR]mousewheel\f[R],
\f[CR]touchstart\f[R] and \f[CR]touchmove\f[R] events.
See Using passive listeners to learn more.
.RE
.TP
\f[B]signal\f[R] \f[I](optional)\f[R]
An \f[CR]AbortSignal\f[R].
The listener will be removed when the \f[CR]abort()\f[R] method of the
\f[CR]AbortController\f[R] which owns the \f[CR]AbortSignal\f[R] is
called.
If not specified, no \f[CR]AbortSignal\f[R] is associated with the
listener.
.RE
.TP
\f[B]useCapture\f[R] \f[I](optional)\f[R]
A boolean value indicating whether events of this type will be
dispatched to the registered \f[CR]listener\f[R] \f[I]before\f[R] being
dispatched to any \f[CR]EventTarget\f[R] beneath it in the DOM tree.
Events that are bubbling upward through the tree will not trigger a
listener designated to use capture.
Event bubbling and capturing are two ways of propagating events that
occur in an element that is nested within another element, when both
elements have registered a handle for that event.
The event propagation mode determines the order in which elements
receive the event.
See \c
.UR https://www.w3.org/TR/DOM-Level-3-Events/#event-flow
DOM Level 3 Events
.UE \c
\ and \c
.UR https://www.quirksmode.org/js/events_order.html#link4
JavaScript Event order
.UE \c
\ for a detailed explanation.
If not specified, \f[CR]useCapture\f[R] defaults to \f[CR]false\f[R].
.RS
.RS
.PP
\f[B]Note:\f[R] For event listeners attached to the event target, the
event is in the target phase, rather than the capturing and bubbling
phases.
Event listeners in the \f[I]capturing\f[R] phase are called before event
listeners in the target and bubbling phases.
.RE
.RE
.TP
\f[B]wantsUntrusted\f[R] \f[I](optional)\f[R] \f[I](non\-standard)\f[R]
A Firefox (Gecko)\-specific parameter.
If \f[CR]true\f[R], the listener receives synthetic events dispatched by
web content (the default is \f[CR]false\f[R] for browser chrome and
\f[CR]true\f[R] for regular web pages).
This parameter is useful for code found in add\-ons, as well as the
browser itself.
.SS Return value
None (\f[CR]undefined\f[R]).
.SH USAGE NOTES
.SS The event listener callback
The event listener can be specified as either a callback function or an
object whose \f[CR]handleEvent()\f[R] method serves as the callback
function.
.PP
The callback function itself has the same parameters and return value as
the \f[CR]handleEvent()\f[R] method; that is, the callback accepts a
single parameter: an object based on \f[CR]Event\f[R] describing the
event that has occurred, and it returns nothing.
.PP
For example, an event handler callback that can be used to handle both
\f[CR]fullscreenchange\f[R] and \f[CR]fullscreenerror\f[R] might look
like this:
.IP
.EX
\f[B]function\f[R] handleEvent(event) {
  \f[B]if\f[R] (event.type === \(dqfullscreenchange\(dq) {
    \f[I]/* handle a full screen toggle */\f[R]
  } \f[B]else\f[R] {
    \f[I]/* handle a full screen toggle error */\f[R]
  }
}
.EE
.SS The value of \(lqthis\(rq within the handler
It is often desirable to reference the element on which the event
handler was fired, such as when using a generic handler for a set of
similar elements.
.PP
When attaching a handler function to an element using
\f[CR]addEventListener()\f[R], the value of \f[CR]this\f[R] inside the
handler will be a reference to the element.
It will be the same as the value of the \f[CR]currentTarget\f[R]
property of the event argument that is passed to the handler.
.IP
.EX
my_element.addEventListener(\(dqclick\(dq, \f[B]function\f[R] (e) {
  console.log(\f[B]this\f[R].className); \f[I]// logs the className of my_element\f[R]
  console.log(e.currentTarget === \f[B]this\f[R]); \f[I]// logs \(gatrue\(ga\f[R]
});
.EE
.PP
As a reminder, arrow functions do not have their own \f[CR]this\f[R]
context.
.IP
.EX
my_element.addEventListener(\(dqclick\(dq, (e) \f[B]=>\f[R] {
  console.log(\f[B]this\f[R].className); \f[I]// \f[R]\f[B]WARNING\f[R]\f[I]: \(gathis\(ga is not \(gamy_element\(ga\f[R]
  console.log(e.currentTarget === \f[B]this\f[R]); \f[I]// logs \(gafalse\(ga\f[R]
});
.EE
.PP
If an event handler (for example, \f[CR]onclick\f[R]) is specified on an
element in the HTML source, the JavaScript code in the attribute value
is effectively wrapped in a handler function that binds the value of
\f[CR]this\f[R] in a manner consistent with the
\f[CR]addEventListener()\f[R]; an occurrence of \f[CR]this\f[R] within
the code represents a reference to the element.
.IP
.EX
<\f[B]table\f[R] id=\(dqmy_table\(dq onclick=\(dqconsole.log(this.id);\(dq>
  \f[I]<!\-\- \(gathis\(ga refers to the table; logs \(aqmy_table\(aq \-\->\f[R]
  \&...
</\f[B]table\f[R]>
.EE
.PP
Note that the value of \f[CR]this\f[R] inside a function, \f[I]called
by\f[R] the code in the attribute value, behaves as per standard rules.
This is shown in the following example:
.IP
.EX
<\f[B]script\f[R]>
  \f[B]function\f[R] logID() {
    console.log(\f[B]this\f[R].id);
  }
</\f[B]script\f[R]>
<\f[B]table\f[R] id=\(dqmy_table\(dq onclick=\(dqlogID();\(dq>
  \f[I]<!\-\- when called, \(gathis\(ga will refer to the global object \-\->\f[R]
  \&...
</\f[B]table\f[R]>
.EE
.PP
The value of \f[CR]this\f[R] within \f[CR]logID()\f[R] is a reference to
the global object \f[CR]Window\f[R] (or \f[CR]undefined\f[R] in the case
of strict mode.
.SS Specifying \(lqthis\(rq using bind()
The \f[CR]Function.prototype.bind()\f[R] method lets you establish a
fixed \f[CR]this\f[R] context for all subsequent calls \(em bypassing
problems where it\(cqs unclear what \f[CR]this\f[R] will be, depending
on the context from which your function was called.
Note, however, that you\(cqll need to keep a reference to the listener
around so you can remove it later.
.PP
This is an example with and without \f[CR]bind()\f[R]:
.IP
.EX
\f[B]class\f[R] Something {
  name = \(dqSomething Good\(dq;
  constructor(element) {
    \f[I]// bind causes a fixed \(gathis\(ga context to be assigned to \(gaonclick2\(ga\f[R]
    \f[B]this\f[R].onclick2 = \f[B]this\f[R].onclick2.bind(\f[B]this\f[R]);
    element.addEventListener(\(dqclick\(dq, \f[B]this\f[R].onclick1, \f[B]false\f[R]);
    element.addEventListener(\(dqclick\(dq, \f[B]this\f[R].onclick2, \f[B]false\f[R]); \f[I]// Trick\f[R]
  }
  onclick1(event) {
    console.log(\f[B]this\f[R].name); \f[I]// undefined, as \(gathis\(ga is the element\f[R]
  }
  onclick2(event) {
    console.log(\f[B]this\f[R].name); \f[I]// \(aqSomething Good\(aq, as \(gathis\(ga is bound to the Something instance\f[R]
  }
}

\f[B]const\f[R] s = \f[B]new\f[R] Something(document.body);
.EE
.PP
Another solution is using a special function called
\f[CR]handleEvent()\f[R] to catch any events:
.IP
.EX
\f[B]class\f[R] Something {
  name = \(dqSomething Good\(dq;
  constructor(element) {
    \f[I]// Note that the listeners in this case are \(gathis\(ga, not this.handleEvent\f[R]
    element.addEventListener(\(dqclick\(dq, \f[B]this\f[R], \f[B]false\f[R]);
    element.addEventListener(\(dqdblclick\(dq, \f[B]this\f[R], \f[B]false\f[R]);
  }
  handleEvent(event) {
    console.log(\f[B]this\f[R].name); \f[I]// \(aqSomething Good\(aq, as this is bound to newly created object\f[R]
    \f[B]switch\f[R] (event.type) {
      \f[B]case\f[R] \(dqclick\(dq:
        \f[I]// some code here\&...\f[R]
        \f[B]break\f[R];
      \f[B]case\f[R] \(dqdblclick\(dq:
        \f[I]// some code here\&...\f[R]
        \f[B]break\f[R];
    }
  }
}

\f[B]const\f[R] s = \f[B]new\f[R] Something(document.body);
.EE
.PP
Another way of handling the reference to \f[CR]this\f[R] is to use an
arrow function, which doesn\(cqt create a separate \f[CR]this\f[R]
context.
.IP
.EX
\f[B]class\f[R] SomeClass {
  name = \(dqSomething Good\(dq;

  register() {
    window.addEventListener(\(dqkeydown\(dq, (e) \f[B]=>\f[R] {
      \f[B]this\f[R].someMethod(e);
    });
  }

  someMethod(e) {
    console.log(\f[B]this\f[R].name);
    \f[B]switch\f[R] (e.code) {
      \f[B]case\f[R] \(dqArrowUp\(dq:
        \f[I]// some code here\&...\f[R]
        \f[B]break\f[R];
      \f[B]case\f[R] \(dqArrowDown\(dq:
        \f[I]// some code here\&...\f[R]
        \f[B]break\f[R];
    }
  }
}

\f[B]const\f[R] myObject = \f[B]new\f[R] SomeClass();
myObject.register();
.EE
.SS Getting data into and out of an event listener
Event listeners only take one argument, an \f[CR]Event\f[R] or a
subclass of \f[CR]Event\f[R], which is automatically passed to the
listener, and the return value is ignored.
Therefore, to get data into and out of an event listener, instead of
passing the data through parameters and return values, you need to
create closures instead.
.PP
The functions passed as event listeners have access to all variables
declared in the outer scopes that contain the function.
.IP
.EX
\f[B]const\f[R] myButton = document.getElementById(\(dqmy\-button\-id\(dq);
\f[B]let\f[R] someString = \(dqData\(dq;

myButton.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
  console.log(someString);
  \f[I]// \(aqData\(aq on first click,\f[R]
  \f[I]// \(aqData Again\(aq on second click\f[R]

  someString = \(dqData Again\(dq;
});

console.log(someString); \f[I]// Expected Value: \(aqData\(aq (will never output \(aqData Again\(aq)\f[R]
.EE
.PP
Read the function guide for more information about function scopes.
.SS Memory issues
.IP
.EX
\f[B]const\f[R] elems = document.getElementsByTagName(\(dq*\(dq);

\f[I]// Case 1\f[R]
\f[B]for\f[R] (\f[B]const\f[R] elem \f[B]of\f[R] elems) {
  elem.addEventListener(
    \(dqclick\(dq,
    (e) \f[B]=>\f[R] {
      \f[I]// Do something\f[R]
    },
    \f[B]false\f[R],
  );
}

\f[I]// Case 2\f[R]
\f[B]function\f[R] processEvent(e) {
  \f[I]// Do something\f[R]
}

\f[B]for\f[R] (\f[B]const\f[R] elem \f[B]of\f[R] elems) {
  elem.addEventListener(\(dqclick\(dq, processEvent, \f[B]false\f[R]);
}
.EE
.PP
In the first case above, a new (anonymous) handler function is created
with each iteration of the loop.
In the second case, the same previously declared function is used as an
event handler, which results in smaller memory consumption because there
is only one handler function created.
Moreover, in the first case, it is not possible to call
\f[CR]removeEventListener()\f[R] because no reference to the anonymous
function is kept (or here, not kept to any of the multiple anonymous
functions the loop might create.)
In the second case, it\(cqs possible to do
\f[CR]myElement.removeEventListener(\(dqclick\(dq, processEvent, false)\f[R]
because \f[CR]processEvent\f[R] is the function reference.
.PP
Actually, regarding memory consumption, the lack of keeping a function
reference is not the real issue; rather it is the lack of keeping a
\f[I]static\f[R] function reference.
.SS Using passive listeners
If an event has a default action \(em for example, a \f[CR]wheel\f[R]
event that scrolls the container by default \(em the browser is in
general unable to start the default action until the event listener has
finished, because it doesn\(cqt know in advance whether the event
listener might cancel the default action by calling
\f[CR]Event.preventDefault()\f[R].
If the event listener takes too long to execute, this can cause a
noticeable delay, also known as jank, before the default action can be
executed.
.PP
By setting the \f[CR]passive\f[R] option to \f[CR]true\f[R], an event
listener declares that it will not cancel the default action, so the
browser can start the default action immediately, without waiting for
the listener to finish.
If the listener does then call \f[CR]Event.preventDefault()\f[R], this
will have no effect.
.PP
The specification for \f[CR]addEventListener()\f[R] defines the default
value for the \f[CR]passive\f[R] option as always being
\f[CR]false\f[R].
However, to realize the scroll performance benefits of passive listeners
in legacy code, modern browsers have changed the default value of the
\f[CR]passive\f[R] option to \f[CR]true\f[R] for the \f[CR]wheel\f[R],
\f[CR]mousewheel\f[R], \f[CR]touchstart\f[R] and \f[CR]touchmove\f[R]
events on the document\-level nodes \f[CR]Window\f[R],
\f[CR]Document\f[R], and \f[CR]Document.body\f[R].
That prevents the event listener from canceling the event, so it
can\(cqt block page rendering while the user is scrolling.
.PP
Because of that, when you want to override that behavior and ensure the
\f[CR]passive\f[R] option is \f[CR]false\f[R], you must explicitly set
the option to \f[CR]false\f[R] (rather than relying on the default).
.PP
You don\(cqt need to worry about the value of \f[CR]passive\f[R] for the
basic \f[CR]scroll\f[R] event.
Since it can\(cqt be canceled, event listeners can\(cqt block page
rendering anyway.
.PP
See Improving scroll performance using passive listeners for an example
showing the effect of passive listeners.
.SH EXAMPLES
.SS Add a simple listener
This example demonstrates how to use \f[CR]addEventListener()\f[R] to
watch for mouse clicks on an element.
.SS HTML
.IP
.EX
<\f[B]table\f[R] id=\(dqoutside\(dq>
  <\f[B]tr\f[R]>
    <\f[B]td\f[R] id=\(dqt1\(dq>one</\f[B]td\f[R]>
  </\f[B]tr\f[R]>
  <\f[B]tr\f[R]>
    <\f[B]td\f[R] id=\(dqt2\(dq>two</\f[B]td\f[R]>
  </\f[B]tr\f[R]>
</\f[B]table\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[I]// Function to change the content of t2\f[R]
\f[B]function\f[R] modifyText() {
  \f[B]const\f[R] t2 = document.getElementById(\(dqt2\(dq);
  \f[B]const\f[R] isNodeThree = t2.firstChild.nodeValue === \(dqthree\(dq;
  t2.firstChild.nodeValue = isNodeThree ? \(dqtwo\(dq : \(dqthree\(dq;
}

\f[I]// Add event listener to table\f[R]
\f[B]const\f[R] el = document.getElementById(\(dqoutside\(dq);
el.addEventListener(\(dqclick\(dq, modifyText, \f[B]false\f[R]);
.EE
.PP
In this code, \f[CR]modifyText()\f[R] is a listener for \f[CR]click\f[R]
events registered using \f[CR]addEventListener()\f[R].
A click anywhere in the table bubbles up to the handler and runs
\f[CR]modifyText()\f[R].
.SS Result
.SS Add an abortable listener
This example demonstrates how to add an \f[CR]addEventListener()\f[R]
that can be aborted with an \f[CR]AbortSignal\f[R].
.SS HTML
.IP
.EX
<\f[B]table\f[R] id=\(dqoutside\(dq>
  <\f[B]tr\f[R]>
    <\f[B]td\f[R] id=\(dqt1\(dq>one</\f[B]td\f[R]>
  </\f[B]tr\f[R]>
  <\f[B]tr\f[R]>
    <\f[B]td\f[R] id=\(dqt2\(dq>two</\f[B]td\f[R]>
  </\f[B]tr\f[R]>
</\f[B]table\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[I]// Add an abortable event listener to table\f[R]
\f[B]const\f[R] controller = \f[B]new\f[R] AbortController();
\f[B]const\f[R] el = document.getElementById(\(dqoutside\(dq);
el.addEventListener(\(dqclick\(dq, modifyText, { signal: controller.signal });

\f[I]// Function to change the content of t2\f[R]
\f[B]function\f[R] modifyText() {
  \f[B]const\f[R] t2 = document.getElementById(\(dqt2\(dq);
  \f[B]if\f[R] (t2.firstChild.nodeValue === \(dqthree\(dq) {
    t2.firstChild.nodeValue = \(dqtwo\(dq;
  } \f[B]else\f[R] {
    t2.firstChild.nodeValue = \(dqthree\(dq;
    controller.abort(); \f[I]// remove listener after value reaches \(dqthree\(dq\f[R]
  }
}
.EE
.PP
In the example above, we modify the code in the previous example such
that after the second row\(cqs content changes to \(lqthree\(rq, we call
\f[CR]abort()\f[R] from the \f[CR]AbortController\f[R] we passed to the
\f[CR]addEventListener()\f[R] call.
That results in the value remaining as \(lqthree\(rq forever because we
no longer have any code listening for a click event.
.SS Result
.SS Event listener with anonymous function
Here, we\(cqll take a look at how to use an anonymous function to pass
parameters into the event listener.
.SS HTML
.IP
.EX
<\f[B]table\f[R] id=\(dqoutside\(dq>
  <\f[B]tr\f[R]>
    <\f[B]td\f[R] id=\(dqt1\(dq>one</\f[B]td\f[R]>
  </\f[B]tr\f[R]>
  <\f[B]tr\f[R]>
    <\f[B]td\f[R] id=\(dqt2\(dq>two</\f[B]td\f[R]>
  </\f[B]tr\f[R]>
</\f[B]table\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[I]// Function to change the content of t2\f[R]
\f[B]function\f[R] modifyText(new_text) {
  \f[B]const\f[R] t2 = document.getElementById(\(dqt2\(dq);
  t2.firstChild.nodeValue = new_text;
}

\f[I]// Function to add event listener to table\f[R]
\f[B]const\f[R] el = document.getElementById(\(dqoutside\(dq);
el.addEventListener(
  \(dqclick\(dq,
  \f[B]function\f[R] () {
    modifyText(\(dqfour\(dq);
  },
  \f[B]false\f[R],
);
.EE
.PP
Notice that the listener is an anonymous function that encapsulates code
that is then, in turn, able to send parameters to the
\f[CR]modifyText()\f[R] function, which is responsible for actually
responding to the event.
.SS Result
.SS Event listener with an arrow function
This example demonstrates an event listener implemented using arrow
function notation.
.SS HTML
.IP
.EX
<\f[B]table\f[R] id=\(dqoutside\(dq>
  <\f[B]tr\f[R]>
    <\f[B]td\f[R] id=\(dqt1\(dq>one</\f[B]td\f[R]>
  </\f[B]tr\f[R]>
  <\f[B]tr\f[R]>
    <\f[B]td\f[R] id=\(dqt2\(dq>two</\f[B]td\f[R]>
  </\f[B]tr\f[R]>
</\f[B]table\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[I]// Function to change the content of t2\f[R]
\f[B]function\f[R] modifyText(new_text) {
  \f[B]const\f[R] t2 = document.getElementById(\(dqt2\(dq);
  t2.firstChild.nodeValue = new_text;
}

\f[I]// Add event listener to table with an arrow function\f[R]
\f[B]const\f[R] el = document.getElementById(\(dqoutside\(dq);
el.addEventListener(
  \(dqclick\(dq,
  () \f[B]=>\f[R] {
    modifyText(\(dqfour\(dq);
  },
  \f[B]false\f[R],
);
.EE
.SS Result
Please note that while anonymous and arrow functions are similar, they
have different \f[CR]this\f[R] bindings.
While anonymous (and all traditional JavaScript functions) create their
own \f[CR]this\f[R] bindings, arrow functions inherit the
\f[CR]this\f[R] binding of the containing function.
.PP
That means that the variables and constants available to the containing
function are also available to the event handler when using an arrow
function.
.SS Example of options usage
.SS HTML
.IP
.EX
<\f[B]div\f[R] class=\(dqouter\(dq>
  outer, once \f[B]&\f[R] none\-once
  <\f[B]div\f[R] class=\(dqmiddle\(dq target=\(dq_blank\(dq>
    middle, capture \f[B]&\f[R] none\-capture
    <\f[B]a\f[R] class=\(dqinner1\(dq href=\(dqhttps://www.mozilla.org\(dq target=\(dq_blank\(dq>
      inner1, passive \f[B]&\f[R] preventDefault(which is not allowed)
    </\f[B]a\f[R]>
    <\f[B]a\f[R] class=\(dqinner2\(dq href=\(dqhttps://developer.mozilla.org/\(dq target=\(dq_blank\(dq>
      inner2, none\-passive \f[B]&\f[R] preventDefault(not open new page)
    </\f[B]a\f[R]>
  </\f[B]div\f[R]>
</\f[B]div\f[R]>
<\f[B]hr\f[R] />
<\f[B]button\f[R] class=\(dqclear\-button\(dq>Clear logs</\f[B]button\f[R]>
<\f[B]section\f[R] class=\(dqdemo\-logs\(dq></\f[B]section\f[R]>
.EE
.SS CSS
.IP
.EX
\&.outer,
\&.middle,
\&.inner1,
\&.inner2 {
  \f[B]display\f[R]: block;
  \f[B]width\f[R]: 520px;
  \f[B]padding\f[R]: 15px;
  \f[B]margin\f[R]: 15px;
  \f[B]text\-decoration\f[R]: none;
}
\&.outer {
  \f[B]border\f[R]: 1px solid red;
  \f[B]color\f[R]: red;
}
\&.middle {
  \f[B]border\f[R]: 1px solid green;
  \f[B]color\f[R]: green;
  \f[B]width\f[R]: 460px;
}
\&.inner1,
\&.inner2 {
  \f[B]border\f[R]: 1px solid purple;
  \f[B]color\f[R]: purple;
  \f[B]width\f[R]: 400px;
}
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] outer = document.querySelector(\(dq.outer\(dq);
\f[B]const\f[R] middle = document.querySelector(\(dq.middle\(dq);
\f[B]const\f[R] inner1 = document.querySelector(\(dq.inner1\(dq);
\f[B]const\f[R] inner2 = document.querySelector(\(dq.inner2\(dq);

\f[B]const\f[R] capture = {
  capture: \f[B]true\f[R],
};
\f[B]const\f[R] noneCapture = {
  capture: \f[B]false\f[R],
};
\f[B]const\f[R] once = {
  once: \f[B]true\f[R],
};
\f[B]const\f[R] noneOnce = {
  once: \f[B]false\f[R],
};
\f[B]const\f[R] passive = {
  passive: \f[B]true\f[R],
};
\f[B]const\f[R] nonePassive = {
  passive: \f[B]false\f[R],
};

outer.addEventListener(\(dqclick\(dq, onceHandler, once);
outer.addEventListener(\(dqclick\(dq, noneOnceHandler, noneOnce);
middle.addEventListener(\(dqclick\(dq, captureHandler, capture);
middle.addEventListener(\(dqclick\(dq, noneCaptureHandler, noneCapture);
inner1.addEventListener(\(dqclick\(dq, passiveHandler, passive);
inner2.addEventListener(\(dqclick\(dq, nonePassiveHandler, nonePassive);

\f[B]function\f[R] onceHandler(event) {
  log(\(dqouter, once\(dq);
}
\f[B]function\f[R] noneOnceHandler(event) {
  log(\(dqouter, none\-once, default\(rsn\(dq);
}
\f[B]function\f[R] captureHandler(event) {
  \f[I]// event.stopImmediatePropagation();\f[R]
  log(\(dqmiddle, capture\(dq);
}
\f[B]function\f[R] noneCaptureHandler(event) {
  log(\(dqmiddle, none\-capture, default\(dq);
}
\f[B]function\f[R] passiveHandler(event) {
  \f[I]// Unable to preventDefault inside passive event listener invocation.\f[R]
  event.preventDefault();
  log(\(dqinner1, passive, open new page\(dq);
}
\f[B]function\f[R] nonePassiveHandler(event) {
  event.preventDefault();
  \f[I]// event.stopPropagation();\f[R]
  log(\(dqinner2, none\-passive, default, not open new page\(dq);
}
.EE
.SS Result
Click the outer, middle, inner containers respectively to see how the
options work.
.SS Event listener with multiple options
You can set more than one of the options in the \f[CR]options\f[R]
parameter.
In the following example we are setting two options:
.IP \(bu 2
\f[CR]passive\f[R], to assert that the handler will not call
\f[CR]preventDefault()\f[R]
.IP \(bu 2
\f[CR]once\f[R], to ensure that the event handler will only be called
once.
.SS HTML
.IP
.EX
<\f[B]button\f[R] id=\(dqexample\-button\(dq>You have not clicked this button.</\f[B]button\f[R]>
<\f[B]button\f[R] id=\(dqreset\-button\(dq>Click this button to reset the first button.</\f[B]button\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] buttonToBeClicked = document.getElementById(\(dqexample\-button\(dq);

\f[B]const\f[R] resetButton = document.getElementById(\(dqreset\-button\(dq);

\f[I]// the text that the button is initialized with\f[R]
\f[B]const\f[R] initialText = buttonToBeClicked.textContent;

\f[I]// the text that the button contains after being clicked\f[R]
\f[B]const\f[R] clickedText = \(dqYou have clicked this button.\(dq;

\f[I]// we hoist the event listener callback function\f[R]
\f[I]// to prevent having duplicate listeners attached\f[R]
\f[B]function\f[R] eventListener() {
  buttonToBeClicked.textContent = clickedText;
}

\f[B]function\f[R] addListener() {
  buttonToBeClicked.addEventListener(\(dqclick\(dq, eventListener, {
    passive: \f[B]true\f[R],
    once: \f[B]true\f[R],
  });
}

\f[I]// when the reset button is clicked, the example button is reset,\f[R]
\f[I]// and allowed to have its state updated again\f[R]
resetButton.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
  buttonToBeClicked.textContent = initialText;
  addListener();
});

addListener();
.EE
.SS Result
.SS Improving scroll performance using passive listeners
The following example shows the effect of setting \f[CR]passive\f[R].
It includes a \f[CR]<div>\f[R] that contains some text, and a check box.
.SS HTML
.IP
.EX
<\f[B]div\f[R] id=\(dqcontainer\(dq>
  <\f[B]p\f[R]>
    But down there it would be dark now, and not the lovely lighted aquarium she
    imagined it to be during the daylight hours, eddying with schools of tiny,
    delicate animals floating and dancing slowly to their own serene currents
    and creating the look of a living painting. That was wrong, in any case. The
    ocean was different from an aquarium, which was an artificial environment.
    The ocean was a world. And a world is not art. Dorothy thought about the
    living things that moved in that world: large, ruthless and hungry. Like us
    up here.
  </\f[B]p\f[R]>
</\f[B]div\f[R]>

<\f[B]div\f[R]>
  <\f[B]input\f[R] type=\(dqcheckbox\(dq id=\(dqpassive\(dq name=\(dqpassive\(dq checked />
  <\f[B]label\f[R] for=\(dqpassive\(dq>passive</\f[B]label\f[R]>
</\f[B]div\f[R]>
.EE
.SS JavaScript
The code adds a listener to the container\(cqs \f[CR]wheel\f[R] event,
which by default scrolls the container.
The listener runs a long\-running operation.
Initially the listener is added with the \f[CR]passive\f[R] option, and
whenever the checkbox is toggled, the code toggles the
\f[CR]passive\f[R] option.
.IP
.EX
\f[B]const\f[R] passive = document.querySelector(\(dq#passive\(dq);
passive.addEventListener(\(dqchange\(dq, (event) \f[B]=>\f[R] {
  container.removeEventListener(\(dqwheel\(dq, wheelHandler);
  container.addEventListener(\(dqwheel\(dq, wheelHandler, {
    passive: passive.checked,
    once: \f[B]true\f[R],
  });
});

\f[B]const\f[R] container = document.querySelector(\(dq#container\(dq);
container.addEventListener(\(dqwheel\(dq, wheelHandler, {
  passive: \f[B]true\f[R],
  once: \f[B]true\f[R],
});

\f[B]function\f[R] wheelHandler() {
  \f[B]function\f[R] isPrime(n) {
    \f[B]for\f[R] (\f[B]let\f[R] c = 2; c <= Math.sqrt(n); ++c) {
      \f[B]if\f[R] (n % c === 0) {
        \f[B]return\f[R] \f[B]false\f[R];
      }
    }
    \f[B]return\f[R] \f[B]true\f[R];
  }

  \f[B]const\f[R] quota = 1000000;
  \f[B]const\f[R] primes = [];
  \f[B]const\f[R] maximum = 1000000;

  \f[B]while\f[R] (primes.length < quota) {
    \f[B]const\f[R] candidate = Math.floor(Math.random() * (maximum + 1));
    \f[B]if\f[R] (isPrime(candidate)) {
      primes.push(candidate);
    }
  }

  console.log(primes);
}
.EE
.SS Result
The effect is that:
.IP \(bu 2
Initially, the listener is passive, so trying to scroll the container
with the wheel is immediate.
.IP \(bu 2
If you uncheck \(lqpassive\(rq and try to scroll the container using the
wheel, then there is a noticeable delay before the container scrolls,
because the browser has to wait for the long\-running listener to
finish.
.SH SEE ALSO
.IP \(bu 2
\f[CR]EventTarget.removeEventListener()\f[R]
.IP \(bu 2
Creating and triggering custom events
.IP \(bu 2
\c
.UR https://www.quirksmode.org/js/this.html
More details on the use of \f[CR]this\f[R] in event handlers
.UE \c
