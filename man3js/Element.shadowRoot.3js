.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Element.shadowRoot" "JS" "February 13, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Element.shadowRoot \- Element: shadowRoot property
.SH SYNOPSIS
The \f[CR]Element.shadowRoot\f[R] read\-only property represents the
shadow root hosted by the element.
.PP
Use \f[CR]Element.attachShadow()\f[R] to add a shadow root to an
existing element.
.SH VALUE
A \f[CR]ShadowRoot\f[R] object instance, or \f[CR]null\f[R] if the
associated shadow root was attached with its \f[CR]mode\f[R] set to
\f[CR]closed\f[R].
(See \f[CR]Element.attachShadow()\f[R] for further details).
.PP
Some built\-in elements, such as \f[CR]<input>\f[R] and
\f[CR]<img>\f[R], have user\-agent shadow roots that are closed to
script.
Therefore, their \f[CR]shadowRoot\f[R] property is always
\f[CR]null\f[R].
.SH EXAMPLES
The following snippets are taken from our \c
.UR https://github.com/mdn/web-components-examples/tree/main/life-cycle-callbacks
life\-cycle\-callbacks
.UE \c
\ example (\c
.UR https://mdn.github.io/web-components-examples/life-cycle-callbacks/
see it live also
.UE \c
), which creates an element that displays a square of a size and color
specified in the element\[cq]s attributes.
.PP
Inside the \f[CR]<custom\-square>\f[R] element\[cq]s class definition we
include some life cycle callbacks that make a call to an external
function, \f[CR]updateStyle()\f[R], which actually applies the size and
color to the element.
You\[cq]ll see that we are passing it \f[CR]this\f[R] (the custom
element itself) as a parameter.
.IP
.EX
\f[B]class\f[R] Square \f[B]extends\f[R] HTMLElement {
  connectedCallback() {
    console.log(\[dq]Custom square element added to page.\[dq]);
    updateStyle(\f[B]this\f[R]);
  }

  attributeChangedCallback(name, oldValue, newValue) {
    console.log(\[dq]Custom square element attributes changed.\[dq]);
    updateStyle(\f[B]this\f[R]);
  }
}
.EE
.PP
In the \f[CR]updateStyle()\f[R] function itself, we get a reference to
the shadow DOM using \f[CR]Element.shadowRoot\f[R].
From here we use standard DOM traversal techniques to find the
\f[CR]<style>\f[R] element inside the shadow DOM and then update the CSS
found inside it:
.IP
.EX
\f[B]function\f[R] updateStyle(elem) {
  \f[B]const\f[R] shadow = elem.shadowRoot;
  \f[B]const\f[R] childNodes = Array.from(shadow.childNodes);

  childNodes.forEach((childNode) \f[B]=>\f[R] {
    \f[B]if\f[R] (childNode.nodeName === \[dq]STYLE\[dq]) {
      childNode.textContent = \[ga]
        div {
          width: ${elem.getAttribute(\[dq]l\[dq])}px;
          height: ${elem.getAttribute(\[dq]l\[dq])}px;
          background\-color: ${elem.getAttribute(\[dq]c\[dq])};
        }
      \[ga];
    }
  });
}
.EE
