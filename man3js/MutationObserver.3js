.\" Automatically generated by Pandoc 3.4
.\"
.TH "MutationObserver" "JS" "July 25, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
MutationObserver \- MutationObserver
.SH SYNOPSIS
The \f[B]\f[CB]MutationObserver\f[B]\f[R] interface provides the ability
to watch for changes being made to the DOM tree.
It is designed as a replacement for the older Mutation Events feature,
which was part of the DOM3 Events specification.
.SH CONSTRUCTOR
.TP
\f[B]MutationObserver()\f[R]
Creates and returns a new \f[CR]MutationObserver\f[R] which will invoke
a specified callback function when DOM changes occur.
.SH INSTANCE METHODS
.TP
\f[B]disconnect()\f[R]
Stops the \f[CR]MutationObserver\f[R] instance from receiving further
notifications until and unless \f[CR]observe()\f[R] is called again.
.TP
\f[B]observe()\f[R]
Configures the \f[CR]MutationObserver\f[R] to begin receiving
notifications through its callback function when DOM changes matching
the given options occur.
.TP
\f[B]takeRecords()\f[R]
Removes all pending notifications from the
\f[CR]MutationObserver\f[R]\[cq]s notification queue and returns them in
a new \f[CR]Array\f[R] of \f[CR]MutationRecord\f[R] objects.
.SH MUTATION OBSERVER & CUSTOMIZE RESIZE EVENT LISTENER & DEMO
\c
.UR https://codepen.io/milofultz/pen/LYjPXPw
.UE \c
.SH EXAMPLE
The following example was adapted from \c
.UR https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/
this blog post
.UE \c
\&.
.IP
.EX
\f[I]// Select the node that will be observed for mutations\f[R]
\f[B]const\f[R] targetNode = document.getElementById(\[dq]some\-id\[dq]);

\f[I]// Options for the observer (which mutations to observe)\f[R]
\f[B]const\f[R] config = { attributes: \f[B]true\f[R], childList: \f[B]true\f[R], subtree: \f[B]true\f[R] };

\f[I]// Callback function to execute when mutations are observed\f[R]
\f[B]const\f[R] callback = (mutationList, observer) \f[B]=>\f[R] {
  \f[B]for\f[R] (\f[B]const\f[R] mutation \f[B]of\f[R] mutationList) {
    \f[B]if\f[R] (mutation.type === \[dq]childList\[dq]) {
      console.log(\[dq]A child node has been added or removed.\[dq]);
    } \f[B]else\f[R] \f[B]if\f[R] (mutation.type === \[dq]attributes\[dq]) {
      console.log(\[ga]The ${mutation.attributeName} attribute was modified.\[ga]);
    }
  }
};

\f[I]// Create an observer instance linked to the callback function\f[R]
\f[B]const\f[R] observer = \f[B]new\f[R] MutationObserver(callback);

\f[I]// Start observing the target node for configured mutations\f[R]
observer.observe(targetNode, config);

\f[I]// Later, you can stop observing\f[R]
observer.disconnect();
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]PerformanceObserver\f[R]
.IP \[bu] 2
\f[CR]ResizeObserver\f[R]
.IP \[bu] 2
\f[CR]IntersectionObserver\f[R]
.IP \[bu] 2
\c
.UR https://developer.chrome.com/blog/detect-dom-changes-with-mutation-observers/
A brief overview
.UE \c
.IP \[bu] 2
\c
.UR https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/
A more in\-depth discussion
.UE \c
.IP \[bu] 2
\c
.UR https://www.youtube.com/watch?v=eRZ4pO0gVWw
A screencast by Chromium developer Rafael Weinstein
.UE \c
