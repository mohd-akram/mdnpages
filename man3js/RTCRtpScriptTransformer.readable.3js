.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "RTCRtpScriptTransformer.readable" "JS" "September 8, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCRtpScriptTransformer.readable \- RTCRtpScriptTransformer: readable
property
.SH SYNOPSIS
The \f[B]\f[CB]readable\f[B]\f[R] read\-only property of the
\f[CR]RTCRtpScriptTransformer\f[R] interface returns a
\f[CR]ReadableStream\f[R] instance is a source for encoded media frames.
.PP
When the corresponding \f[CR]RTCRtpScriptTransform\f[R] is inserted into
the WebRTC sender and receiver pipelines, this stream may be enqueued
with outgoing or incoming encoded media frames
(\f[CR]RTCEncodedVideoFrame\f[R] or \f[CR]RTCEncodedAudioFrame\f[R]).
A WebRTC encoded transform can read the frames, modify them as needed,
and then send them back into the WebRTC pipeline by writing them to
\f[CR]RTCRtpScriptTransformer.writable\f[R].
A common way to perform this operation is to pipe the frames through a
\f[CR]TransformStream\f[R].
.SH VALUE
A \f[CR]ReadableStream\f[R].
.SH EXAMPLES
The following example shows how \f[CR]readable\f[R] is piped through a
\f[CR]TransformStream\f[R] to
\f[CR]RTCRtpScriptTransformer.writable\f[R].
.IP
.EX
addEventListener(\[dq]rtctransform\[dq], (event) => {
  let transform;
  // Select a transform based on passed options
  if (event.transformer.options.name == \[dq]senderTransform\[dq])
    transform = createSenderTransform(); // A TransformStream
  else if (event.transformer.options.name == \[dq]receiverTransform\[dq])
    transform = createReceiverTransform(); // A TransformStream
  else return;

  // Pipe frames from the readable to writeable through TransformStream
  event.transformer.readable
    .pipeThrough(transform)
    .pipeTo(event.transformer.writable);
});
.EE
.PP
The code implements a handler for the \f[CR]rtctransform\f[R] event,
which is fired at the global worker object on construction of the
corresponding \f[CR]RTCRtpScriptTransform\f[R], and when new frames are
enqueued for processing.
\f[CR]event.transformer\f[R] is the \f[CR]RTCRtpScriptTransformer\f[R]
that has a \f[CR]readable\f[R] and \f[CR]writable\f[R] property.
.PP
An different \f[CR]TransformStream\f[R] is created to process outgoing
and incoming frames, using \f[CR]createSenderTransform()\f[R] or
\f[CR]createReceiverTransform()\f[R], respectively (implementations not
shown).
The event handler chooses the correct transform stream to use based on
options passed through from the \f[CR]RTCRtpScriptTransform\f[R]
constructor and assigns it to \f[CR]transform\f[R].
.PP
The code calls \f[CR]ReadableStream.pipeThrough()\f[R] on the
\f[CR]readable\f[R] to pipe encoded frames through the selected
\f[CR]TransformStream\f[R], and then \f[CR]ReadableStream.pipeTo()\f[R]
to pipe them to the \f[CR]RTCRtpScriptTransformer.writable\f[R].
.SH SEE ALSO
.IP \[bu] 2
Using WebRTC Encoded Transforms
