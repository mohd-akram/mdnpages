.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Number.isSafeInteger" "JS" "August 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Number.isSafeInteger \- Number.isSafeInteger()
.SH SYNOPSIS
The \f[B]\f[CB]Number.isSafeInteger()\f[B]\f[R] static method determines
whether the provided value is a number that is a \f[I]safe integer\f[R].
.SH SYNTAX
.IP
.EX
Number.isSafeInteger(testValue)
.EE
.SS Parameters
.TP
\f[B]testValue\f[R]
The value to be tested for being a safe integer.
.SS Return value
The boolean value \f[CR]true\f[R] if the given value is a number that is
a safe integer.
Otherwise \f[CR]false\f[R].
.SH DESCRIPTION
The safe integers consist of all integers from \-(2\[ha]53 \- 1) to
2\[ha]53 \- 1, inclusive (Â±9,007,199,254,740,991).
A safe integer is an integer that:
.IP \[bu] 2
can be exactly represented as an IEEE\-754 double precision number, and
.IP \[bu] 2
whose IEEE\-754 representation cannot be the result of rounding any
other integer to fit the IEEE\-754 representation.
.PP
For example, 2\[ha]53 \- 1 is a safe integer: it can be exactly
represented, and no other integer rounds to it under any IEEE\-754
rounding mode.
In contrast, 2\[ha]53 is \f[I]not\f[R] a safe integer: it can be exactly
represented in IEEE\-754, but the integer 2\[ha]53 + 1 can\[cq]t be
directly represented in IEEE\-754 but instead rounds to 2\[ha]53 under
round\-to\-nearest and round\-to\-zero rounding.
.PP
Handling values larger or smaller than \[ti]9 quadrillion with full
precision requires using an \c
.UR https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic
arbitrary precision arithmetic library
.UE \c
\&.
See \c
.UR https://floating-point-gui.de/
What Every Programmer Needs to Know about Floating Point Arithmetic
.UE \c
\ for more information on floating point representations of numbers.
.PP
For larger integers, consider using the \f[CR]BigInt\f[R] type.
.SH EXAMPLES
.SS Using isSafeInteger()
.IP
.EX
Number.isSafeInteger(3); \f[I]// true\f[R]
Number.isSafeInteger(2 ** 53); \f[I]// false\f[R]
Number.isSafeInteger(2 ** 53 \- 1); \f[I]// true\f[R]
Number.isSafeInteger(\f[B]NaN\f[R]); \f[I]// false\f[R]
Number.isSafeInteger(\f[B]Infinity\f[R]); \f[I]// false\f[R]
Number.isSafeInteger(\[dq]3\[dq]); \f[I]// false\f[R]
Number.isSafeInteger(3.1); \f[I]// false\f[R]
Number.isSafeInteger(3.0); \f[I]// true\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-number
Polyfill of \f[CR]Number.isSafeInteger\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Number\f[R]
.IP \[bu] 2
\f[CR]Number.MIN_SAFE_INTEGER\f[R]
.IP \[bu] 2
\f[CR]Number.MAX_SAFE_INTEGER\f[R]
.IP \[bu] 2
\f[CR]BigInt\f[R]
