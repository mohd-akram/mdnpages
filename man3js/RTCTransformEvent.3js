.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "RTCTransformEvent" "JS" "January 10, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCTransformEvent \- RTCTransformEvent
.SH SYNOPSIS
The \f[B]\f[CB]RTCTransformEvent\f[B]\f[R] of the WebRTC API represent
an event that is fired in a dedicated worker when an encoded frame has
been queued for processing by a WebRTC Encoded Transform.
.PP
The interface has a \f[CR]transformer\f[R] property that exposes a
readable stream and a writable stream.
A worker should read encoded frames from
\f[CR]transformer.readable\f[R], modify them as needed, and write them
to \f[CR]transformer.writable\f[R] in the same order and without any
duplication.
.PP
At time of writing there is just one event based on
\f[CR]RTCTransformEvent\f[R]: \f[CR]rtctransform\f[R].
.SH INSTANCE PROPERTIES
\f[I]Since \f[CI]RTCTransformEvent\f[I] is based on \f[CI]Event\f[I],
its properties are also available.\f[R]
.TP
\f[B]RTCTransformEvent.transformer\f[R] \f[I](read\-only)\f[R]
Returns the \f[CR]RTCRtpScriptTransformer\f[R] associated with the
event.
.SH TRANSFORM EVENT TYPES
There is only one type of transform event.
.SS \f[CR]rtctransform\f[R]
The \f[CR]rtctransform\f[R] event is fired at the worker global scope on
construction of an associated \f[CR]RTCRtpScriptTransform\f[R], and
whenever a new encoded video or audio frame is enqueued for processing.
.PP
You can add a \f[CR]rtctransform\f[R] event listener to be notified when
the new frame is available using either
\f[CR]DedicatedWorkerGlobalScope.addEventListener()\f[R] or the
\f[CR]onrtctransform\f[R] event handler property.
.SH EXAMPLE
This example creates an event listener for the \f[CR]rtctransform\f[R]
event.
.PP
The example assumes we have a \f[CR]TransformStream\f[R] with an
\f[CR]options\f[R] object passed from a \f[CR]RTCRtpScriptTransform\f[R]
constructor in the main\-thread.
The code at the end shows how the stream is piped through the transform
stream from the \f[CR]readable\f[R] to the \f[CR]writable\f[R].
.IP
.EX
addEventListener(\[dq]rtctransform\[dq], (event) \f[B]=>\f[R] {
  \f[B]let\f[R] transform;
  \f[I]// Select a transform based on passed options\f[R]
  \f[B]if\f[R] (event.transformer.options.name == \[dq]senderTransform\[dq]) {
    transform = createSenderTransform(); \f[I]// A TransformStream (not shown)\f[R]
  } \f[B]else\f[R] \f[B]if\f[R] (event.transformer.options.name == \[dq]receiverTransform\[dq]) {
    transform = createReceiverTransform(); \f[I]// A TransformStream (not shown)\f[R]
  }
  \f[I]// Pipe frames from the readable to writeable through TransformStream\f[R]
  event.transformer.readable
    .pipeThrough(transform)
    .pipeTo(event.transformer.writable);
});
.EE
.PP
Note that this code is part of a more complete example provided in Using
WebRTC Encoded Transforms.
.IP \[bu] 2
Using WebRTC Encoded Transforms
.IP \[bu] 2
\f[CR]TransformStream\f[R]
