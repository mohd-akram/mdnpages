.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "BigInt" "JS" "January 22, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
BigInt \- BigInt
.SH SYNOPSIS
\f[B]\f[CB]BigInt\f[B]\f[R] values represent integer values which are
too high or too low to be represented by the \f[CR]number\f[R]
primitive.
.SH DESCRIPTION
A \f[B]BigInt value\f[R], also sometimes just called a \f[B]BigInt\f[R],
is a \f[CR]bigint\f[R] primitive, created by appending \f[CR]n\f[R] to
the end of an integer literal, or by calling the \f[CR]BigInt()\f[R]
function (without the \f[CR]new\f[R] operator) and giving it an integer
value or string value.
.IP
.EX
\f[B]const\f[R] previouslyMaxSafeInteger = 9007199254740991n;

\f[B]const\f[R] alsoHuge = BigInt(9007199254740991);
\f[I]// 9007199254740991n\f[R]

\f[B]const\f[R] hugeString = BigInt(\[dq]9007199254740991\[dq]);
\f[I]// 9007199254740991n\f[R]

\f[B]const\f[R] hugeHex = BigInt(\[dq]0x1fffffffffffff\[dq]);
\f[I]// 9007199254740991n\f[R]

\f[B]const\f[R] hugeOctal = BigInt(\[dq]0o377777777777777777\[dq]);
\f[I]// 9007199254740991n\f[R]

\f[B]const\f[R] hugeBin = BigInt(
  \[dq]0b11111111111111111111111111111111111111111111111111111\[dq],
);
\f[I]// 9007199254740991n\f[R]
.EE
.PP
BigInt values are similar to Number values in some ways, but also differ
in a few key matters: A BigInt value cannot be used with methods in the
built\-in \f[CR]Math\f[R] object and cannot be mixed with a Number value
in operations; they must be coerced to the same type.
Be careful coercing values back and forth, however, as the precision of
a BigInt value may be lost when it is coerced to a Number value.
.SS Type information
When tested against \f[CR]typeof\f[R], a BigInt value (\f[CR]bigint\f[R]
primitive) will give \f[CR]\[dq]bigint\[dq]\f[R]:
.IP
.EX
\f[B]typeof\f[R] 1n === \[dq]bigint\[dq]; \f[I]// true\f[R]
\f[B]typeof\f[R] BigInt(\[dq]1\[dq]) === \[dq]bigint\[dq]; \f[I]// true\f[R]
.EE
.PP
A BigInt value can also be wrapped in an \f[CR]Object\f[R]:
.IP
.EX
\f[B]typeof\f[R] Object(1n) === \[dq]object\[dq]; \f[I]// true\f[R]
.EE
.SS Operators
Most operators support BigInts, however most do not permit operands to
be of mixed types \[em] both operands must be BigInt or neither:
.IP \[bu] 2
Arithmetic operators: \f[CR]+\f[R], \f[CR]\-\f[R], \f[CR]*\f[R],
\f[CR]/\f[R], \f[CR]%\f[R], \f[CR]**\f[R]
.IP \[bu] 2
Bitwise operators: \f[CR]>>\f[R], \f[CR]<<\f[R], \f[CR]&\f[R],
\f[CR]|\f[R], \f[CR]\[ha]\f[R], \f[CR]\[ti]\f[R]
.IP \[bu] 2
Unary negation (\f[CR]\-\f[R])
.IP \[bu] 2
Increment/decrement: \f[CR]++\f[R], \f[CR]\-\-\f[R]
.PP
The boolean\-returning operators allow mixing numbers and BigInts as
operands:
.IP \[bu] 2
Relational operators and equality operators: \f[CR]>\f[R], \f[CR]<\f[R],
\f[CR]>=\f[R], \f[CR]<=\f[R], \f[CR]==\f[R], \f[CR]!=\f[R],
\f[CR]===\f[R], \f[CR]!==\f[R]
.IP \[bu] 2
Logical operators only rely on the truthiness of operands
.PP
A couple of operators do not support BigInt at all:
.IP \[bu] 2
Unary plus (\f[CR]+\f[R]) cannot be supported due to conflicting usage
in asm.js, so it has been left out \c
.UR https://github.com/tc39/proposal-bigint/blob/master/ADVANCED.md#dont-break-asmjs
in order to not break asm.js
.UE \c
\&.
.IP \[bu] 2
Unsigned right shift (\f[CR]>>>\f[R]) is the only bitwise operator
that\[cq]s unsupported, as every BigInt value is signed.
.PP
Special cases:
.IP \[bu] 2
Addition (\f[CR]+\f[R]) involving a string and a BigInt returns a
string.
.IP \[bu] 2
Division (\f[CR]/\f[R]) truncates fractional components towards zero,
since BigInt is unable to represent fractional quantities.
.IP
.EX
\f[B]const\f[R] previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER); \f[I]// 9007199254740991n\f[R]
\f[B]const\f[R] maxPlusOne = previousMaxSafe + 1n; \f[I]// 9007199254740992n\f[R]
\f[B]const\f[R] theFuture = previousMaxSafe + 2n; \f[I]// 9007199254740993n, this works now!\f[R]
\f[B]const\f[R] prod = previousMaxSafe * 2n; \f[I]// 18014398509481982n\f[R]
\f[B]const\f[R] diff = prod \- 10n; \f[I]// 18014398509481972n\f[R]
\f[B]const\f[R] mod = prod % 10n; \f[I]// 2n\f[R]
\f[B]const\f[R] bigN = 2n ** 54n; \f[I]// 18014398509481984n\f[R]
bigN * \-1n; \f[I]// \-18014398509481984n\f[R]
\f[B]const\f[R] expected = 4n / 2n; \f[I]// 2n\f[R]
\f[B]const\f[R] truncated = 5n / 2n; \f[I]// 2n, not 2.5n\f[R]
.EE
.SS Comparisons
A BigInt value is not strictly equal to a Number value, but it
\f[I]is\f[R] loosely so:
.IP
.EX
0n === 0; \f[I]// false\f[R]
0n == 0; \f[I]// true\f[R]
.EE
.PP
A Number value and a BigInt value may be compared as usual:
.IP
.EX
1n < 2; \f[I]// true\f[R]
2n > 1; \f[I]// true\f[R]
2 > 2; \f[I]// false\f[R]
2n > 2; \f[I]// false\f[R]
2n >= 2; \f[I]// true\f[R]
.EE
.PP
BigInt values and Number values may be mixed in arrays and sorted:
.IP
.EX
\f[B]const\f[R] mixed = [4n, 6, \-12n, 10, 4, 0, 0n];
\f[I]// [4n, 6, \-12n, 10, 4, 0, 0n]\f[R]

mixed.sort(); \f[I]// default sorting behavior\f[R]
\f[I]// [ \-12n, 0, 0n, 10, 4n, 4, 6 ]\f[R]

mixed.sort((a, b) \f[B]=>\f[R] a \- b);
\f[I]// won\[aq]t work since subtraction will not work with mixed types\f[R]
\f[I]// TypeError: can\[aq]t convert BigInt value to Number value\f[R]

\f[I]// sort with an appropriate numeric comparator\f[R]
mixed.sort((a, b) \f[B]=>\f[R] (a < b ? \-1 : a > b ? 1 : 0));
\f[I]// [ \-12n, 0, 0n, 4n, 4, 6, 10 ]\f[R]
.EE
.PP
Note that comparisons with \f[CR]Object\f[R]\-wrapped BigInt values act
as with other objects, only indicating equality when the same object
instance is compared:
.IP
.EX
Object(0n) === 0n; \f[I]// false\f[R]
Object(0n) === Object(0n); \f[I]// false\f[R]

\f[B]const\f[R] o = Object(0n);
o === o; \f[I]// true\f[R]
.EE
.PP
Because coercing between Number values and BigInt values can lead to
loss of precision, the following are recommended:
.IP \[bu] 2
Only use a BigInt value when values greater than 2\[ha]53 are reasonably
expected.
.IP \[bu] 2
Don\[cq]t coerce between BigInt values and Number values.
.SS Conditionals
A BigInt value follows the same conversion rules as Numbers when:
.IP \[bu] 2
it is converted to a \f[CR]Boolean\f[R]: via the \f[CR]Boolean\f[R]
function;
.IP \[bu] 2
when used with logical operators \f[CR]||\f[R], \f[CR]&&\f[R], and
\f[CR]!\f[R]; or
.IP \[bu] 2
within a conditional test like an \f[CR]if\f[R] statement.
.PP
Namely, only \f[CR]0n\f[R] is falsy; everything else is truthy.
.IP
.EX
\f[B]if\f[R] (0n) {
  console.log(\[dq]Hello from the if!\[dq]);
} \f[B]else\f[R] {
  console.log(\[dq]Hello from the else!\[dq]);
}
\f[I]// \[dq]Hello from the else!\[dq]\f[R]

0n || 12n; \f[I]// 12n\f[R]
0n && 12n; \f[I]// 0n\f[R]
Boolean(0n); \f[I]// false\f[R]
Boolean(12n); \f[I]// true\f[R]
!12n; \f[I]// false\f[R]
!0n; \f[I]// true\f[R]
.EE
.SS Cryptography
The operations supported on BigInt values are not constant\-time and are
thus open to \c
.UR https://en.wikipedia.org/wiki/Timing_attack
timing attacks
.UE \c
\&.
JavaScript BigInts therefore could be dangerous for use in cryptography
without mitigating factors.
As a very generic example, an attacker could measure the time difference
between \f[CR]101n ** 65537n\f[R] and \f[CR]17n ** 9999n\f[R], and
deduce the magnitude of secrets, such as private keys, based on the time
elapsed.
If you still have to use BigInts, take a look at the \c
.UR https://timing.attacks.cr.yp.to/programming.html
Timing attack FAQ
.UE \c
\ for general advice regarding the issue.
.SS Use within JSON
Using \f[CR]JSON.stringify()\f[R] with any BigInt value will raise a
\f[CR]TypeError\f[R], as BigInt values aren\[cq]t serialized in JSON by
default.
However, \f[CR]JSON.stringify()\f[R] specifically leaves a backdoor for
BigInt values: it would try to call the BigInt\[cq]s \f[CR]toJSON()\f[R]
method.
(It doesn\[cq]t do so for any other primitive values.)
Therefore, you can implement your own \f[CR]toJSON()\f[R] method (which
is one of the few cases where patching built\-in objects is not
explicitly discouraged):
.IP
.EX
BigInt.prototype.toJSON = \f[B]function\f[R] () {
  \f[B]return\f[R] { $bigint: \f[B]this\f[R].toString() };
};
.EE
.PP
Instead of throwing, \f[CR]JSON.stringify()\f[R] now produces a string
like this:
.IP
.EX
console.log(JSON.stringify({ a: 1n }));
\f[I]// {\[dq]a\[dq]:{\[dq]$bigint\[dq]:\[dq]1\[dq]}}\f[R]
.EE
.PP
If you do not wish to patch \f[CR]BigInt.prototype\f[R], you can use the
\f[CR]replacer\f[R] parameter of \f[CR]JSON.stringify\f[R] to serialize
BigInt values:
.IP
.EX
\f[B]const\f[R] replacer = (key, value) \f[B]=>\f[R]
  \f[B]typeof\f[R] value === \[dq]bigint\[dq] ? { $bigint: value.toString() } : value;

\f[B]const\f[R] data = {
  number: 1,
  big: 18014398509481982n,
};
\f[B]const\f[R] stringified = JSON.stringify(data, replacer);

console.log(stringified);
\f[I]// {\[dq]number\[dq]:1,\[dq]big\[dq]:{\[dq]$bigint\[dq]:\[dq]18014398509481982\[dq]}}\f[R]
.EE
.PP
You can then use the \f[CR]reviver\f[R] parameter of
\f[CR]JSON.parse\f[R] to handle them:
.IP
.EX
\f[B]const\f[R] reviver = (key, value) \f[B]=>\f[R]
  value !== \f[B]null\f[R] &&
  \f[B]typeof\f[R] value === \[dq]object\[dq] &&
  \[dq]$bigint\[dq] \f[B]in\f[R] value &&
  \f[B]typeof\f[R] value.$bigint === \[dq]string\[dq]
    ? BigInt(value.$bigint)
    : value;

\f[B]const\f[R] payload = \[aq]{\[dq]number\[dq]:1,\[dq]big\[dq]:{\[dq]$bigint\[dq]:\[dq]18014398509481982\[dq]}}\[aq];
\f[B]const\f[R] parsed = JSON.parse(payload, reviver);

console.log(parsed);
\f[I]// { number: 1, big: 18014398509481982n }\f[R]
.EE
.RS
.PP
\f[B]Note:\f[R] While it\[cq]s possible to make the replacer of
\f[CR]JSON.stringify()\f[R] generic and properly serialize BigInt values
for all objects as shown above, the reviver of \f[CR]JSON.parse()\f[R]
has to be used with caution, because the serialization is
\f[I]irreversible\f[R]: it\[cq]s not possible to distinguish between an
object that happens to have a property called \f[CR]$bigint\f[R] and an
actual BigInt.
.PP
In addition, the example above creates an entire object during replacing
and reviving, which may have performance or storage implications for
larger objects containing many BigInts.
If you know the shape of the payload, it may be better to just serialize
them as strings and revive them based on the property key\[cq]s name
instead.
.RE
.PP
In fact, JSON allows number literals that are arbitrarily long; they
just cannot be parsed to full precision in JavaScript.
If you are communicating with another program in a language that
supports longer integers (such as 64\-bit integers), and you want to
transmit the BigInt as a JSON number instead of a JSON string, see
Lossless number serialization.
.SS BigInt coercion
Many built\-in operations that expect BigInts first coerce their
arguments to BigInts.
\c
.UR https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tobigint
The operation
.UE \c
\ can be summarized as follows:
.IP \[bu] 2
BigInts are returned as\-is.
.IP \[bu] 2
\f[CR]undefined\f[R] and \f[CR]null\f[R] throw a \f[CR]TypeError\f[R].
.IP \[bu] 2
\f[CR]true\f[R] turns into \f[CR]1n\f[R]; \f[CR]false\f[R] turns into
\f[CR]0n\f[R].
.IP \[bu] 2
Strings are converted by parsing them as if they contain an integer
literal.
Any parsing failure results in a \f[CR]SyntaxError\f[R].
The syntax is a subset of string numeric literals, where decimal points
or exponent indicators are not allowed.
.IP \[bu] 2
Numbers throw a \f[CR]TypeError\f[R] to prevent unintended implicit
coercion causing loss of precision.
.IP \[bu] 2
Symbols throw a \f[CR]TypeError\f[R].
.IP \[bu] 2
Objects are first converted to a primitive by calling their
\f[CR][Symbol.toPrimitive]()\f[R] (with \f[CR]\[dq]number\[dq]\f[R] as
hint), \f[CR]valueOf()\f[R], and \f[CR]toString()\f[R] methods, in that
order.
The resulting primitive is then converted to a BigInt.
.PP
The best way to achieve nearly the same effect in JavaScript is through
the \f[CR]BigInt()\f[R] function: \f[CR]BigInt(x)\f[R] uses the same
algorithm to convert \f[CR]x\f[R], except that Numbers don\[cq]t throw a
\f[CR]TypeError\f[R], but are converted to BigInts if they are integers.
.PP
Note that built\-in operations expecting BigInts often truncate the
BigInt to a fixed width after coercion.
This includes \f[CR]BigInt.asIntN()\f[R], \f[CR]BigInt.asUintN()\f[R],
and methods of \f[CR]BigInt64Array\f[R] and \f[CR]BigUint64Array\f[R].
.SH CONSTRUCTOR
.TP
\f[B]BigInt()\f[R]
Returns primitive values of type BigInt.
Throws an error when called with \f[CR]new\f[R].
.SH STATIC METHODS
.TP
\f[B]BigInt.asIntN()\f[R]
Clamps a BigInt value to a signed integer value, and returns that value.
.TP
\f[B]BigInt.asUintN()\f[R]
Clamps a BigInt value to an unsigned integer value, and returns that
value.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]BigInt.prototype\f[R] and shared
by all \f[CR]BigInt\f[R] instances.
.TP
\f[B]BigInt.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]BigInt\f[R] instances, the initial value is the
\f[CR]BigInt\f[R] constructor.
.TP
\f[B]BigInt.prototype[Symbol.toStringTag]\f[R]
The initial value of the \f[CR][Symbol.toStringTag]\f[R] property is the
string \f[CR]\[dq]BigInt\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
However, because \f[CR]BigInt\f[R] also has its own
\f[CR]toString()\f[R] method, this property is not used unless you call
\f[CR]Object.prototype.toString.call()\f[R] with a BigInt as
\f[CR]thisArg\f[R].
.SH INSTANCE METHODS
.TP
\f[B]BigInt.prototype.toLocaleString()\f[R]
Returns a string with a language\-sensitive representation of this
BigInt value.
Overrides the \f[CR]Object.prototype.toLocaleString()\f[R] method.
.TP
\f[B]BigInt.prototype.toString()\f[R]
Returns a string representing this BigInt value in the specified radix
(base).
Overrides the \f[CR]Object.prototype.toString()\f[R] method.
.TP
\f[B]BigInt.prototype.valueOf()\f[R]
Returns this BigInt value.
Overrides the \f[CR]Object.prototype.valueOf()\f[R] method.
.SH EXAMPLES
.SS Calculating Primes
.IP
.EX
\f[I]// Returns true if the passed BigInt value is a prime number\f[R]
\f[B]function\f[R] isPrime(p) {
  \f[B]for\f[R] (\f[B]let\f[R] i = 2n; i * i <= p; i++) {
    \f[B]if\f[R] (p % i === 0n) \f[B]return\f[R] \f[B]false\f[R];
  }
  \f[B]return\f[R] \f[B]true\f[R];
}

\f[I]// Takes a BigInt value as an argument, returns nth prime number as a BigInt value\f[R]
\f[B]function\f[R] nthPrime(nth) {
  \f[B]let\f[R] maybePrime = 2n;
  \f[B]let\f[R] prime = 0n;

  \f[B]while\f[R] (nth >= 0n) {
    \f[B]if\f[R] (isPrime(maybePrime)) {
      nth\-\-;
      prime = maybePrime;
    }
    maybePrime++;
  }

  \f[B]return\f[R] prime;
}

nthPrime(20n);
\f[I]// 73n\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Number\f[R]
.IP \[bu] 2
\f[CR]Number.MAX_SAFE_INTEGER\f[R]
