.\" Automatically generated by Pandoc 3.4
.\"
.TH "Array.forEach" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.forEach \- Array.prototype.forEach()
.SH SYNOPSIS
The \f[B]\f[CB]forEach()\f[B]\f[R] method of \f[CR]Array\f[R] instances
executes a provided function once for each array element.
.SH SYNTAX
.IP
.EX
forEach(callbackFn)
forEach(callbackFn, thisArg)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element in the array.
Its return value is discarded.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.TP
\f[B]array\f[R]
The array \f[CR]forEach()\f[R] was called upon.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
A value to use as \f[CR]this\f[R] when executing \f[CR]callbackFn\f[R].
See iterative methods.
.SS Return value
None (\f[CR]undefined\f[R]).
.SH DESCRIPTION
The \f[CR]forEach()\f[R] method is an iterative method.
It calls a provided \f[CR]callbackFn\f[R] function once for each element
in an array in ascending\-index order.
Unlike \f[CR]map()\f[R], \f[CR]forEach()\f[R] always returns
\f[CR]undefined\f[R] and is not chainable.
The typical use case is to execute side effects at the end of a chain.
Read the iterative methods section for more information about how these
methods work in general.
.PP
\f[CR]callbackFn\f[R] is invoked only for array indexes which have
assigned values.
It is not invoked for empty slots in sparse arrays.
.PP
The \f[CR]forEach()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
.PP
There is no way to stop or break a \f[CR]forEach()\f[R] loop other than
by throwing an exception.
If you need such behavior, the \f[CR]forEach()\f[R] method is the wrong
tool.
.PP
Early termination may be accomplished with looping statements like
\f[CR]for\f[R], \f[CR]for...of\f[R], and \f[CR]for...in\f[R].
Array methods like \f[CR]every()\f[R], \f[CR]some()\f[R],
\f[CR]find()\f[R], and \f[CR]findIndex()\f[R] also stops iteration
immediately when further iteration is not necessary.
.PP
\f[CR]forEach()\f[R] expects a synchronous function \[em] it does not
wait for promises.
Make sure you are aware of the implications while using promises (or
async functions) as \f[CR]forEach\f[R] callbacks.
.IP
.EX
\f[B]const\f[R] ratings = [5, 4, 5];
\f[B]let\f[R] sum = 0;

\f[B]const\f[R] sumFunction = \f[B]async\f[R] (a, b) \f[B]=>\f[R] a + b;

ratings.forEach(\f[B]async\f[R] (rating) \f[B]=>\f[R] {
  sum = \f[B]await\f[R] sumFunction(sum, rating);
});

console.log(sum);
\f[I]// Naively expected output: 14\f[R]
\f[I]// Actual output: 0\f[R]
.EE
.PP
To run a series of asynchronous operations sequentially or concurrently,
see promise composition.
.SH EXAMPLES
.SS Converting a for loop to forEach
.IP
.EX
\f[B]const\f[R] items = [\[dq]item1\[dq], \[dq]item2\[dq], \[dq]item3\[dq]];
\f[B]const\f[R] copyItems = [];

\f[I]// before\f[R]
\f[B]for\f[R] (\f[B]let\f[R] i = 0; i < items.length; i++) {
  copyItems.push(items[i]);
}

\f[I]// after\f[R]
items.forEach((item) \f[B]=>\f[R] {
  copyItems.push(item);
});
.EE
.SS Printing the contents of an array
.RS
.PP
\f[B]Note:\f[R] In order to display the content of an array in the
console, you can use \f[CR]console.table()\f[R], which prints a
formatted version of the array.
.PP
The following example illustrates an alternative approach, using
\f[CR]forEach()\f[R].
.RE
.PP
The following code logs a line for each element in an array:
.IP
.EX
\f[B]const\f[R] logArrayElements = (element, index \f[I]/*, array */\f[R]) \f[B]=>\f[R] {
  console.log(\[ga]a[${index}] = ${element}\[ga]);
};

\f[I]// Notice that index 2 is skipped, since there is no item at\f[R]
\f[I]// that position in the array.\f[R]
[2, 5, , 9].forEach(logArrayElements);
\f[I]// Logs:\f[R]
\f[I]// a[0] = 2\f[R]
\f[I]// a[1] = 5\f[R]
\f[I]// a[3] = 9\f[R]
.EE
.SS Using thisArg
The following (contrived) example updates an object\[cq]s properties
from each entry in the array:
.IP
.EX
\f[B]class\f[R] Counter {
  constructor() {
    \f[B]this\f[R].sum = 0;
    \f[B]this\f[R].count = 0;
  }
  add(array) {
    \f[I]// Only function expressions have their own this bindings.\f[R]
    array.forEach(\f[B]function\f[R] countEntry(entry) {
      \f[B]this\f[R].sum += entry;
      ++\f[B]this\f[R].count;
    }, \f[B]this\f[R]);
  }
}

\f[B]const\f[R] obj = \f[B]new\f[R] Counter();
obj.add([2, 5, 9]);
console.log(obj.count); \f[I]// 3\f[R]
console.log(obj.sum); \f[I]// 16\f[R]
.EE
.PP
Since the \f[CR]thisArg\f[R] parameter (\f[CR]this\f[R]) is provided to
\f[CR]forEach()\f[R], it is passed to \f[CR]callback\f[R] each time
it\[cq]s invoked.
The callback uses it as its \f[CR]this\f[R] value.
.RS
.PP
\f[B]Note:\f[R] If passing the callback function used an arrow function
expression, the \f[CR]thisArg\f[R] parameter could be omitted, since all
arrow functions lexically bind the \f[CR]this\f[R] value.
.RE
.SS An object copy function
The following code creates a copy of a given object.
.PP
There are different ways to create a copy of an object.
The following is just one way and is presented to explain how
\f[CR]Array.prototype.forEach()\f[R] works by using \f[CR]Object.*\f[R]
utility functions.
.IP
.EX
\f[B]const\f[R] copy = (obj) \f[B]=>\f[R] {
  \f[B]const\f[R] copy = Object.create(Object.getPrototypeOf(obj));
  \f[B]const\f[R] propNames = Object.getOwnPropertyNames(obj);
  propNames.forEach((name) \f[B]=>\f[R] {
    \f[B]const\f[R] desc = Object.getOwnPropertyDescriptor(obj, name);
    Object.defineProperty(copy, name, desc);
  });
  \f[B]return\f[R] copy;
};

\f[B]const\f[R] obj1 = { a: 1, b: 2 };
\f[B]const\f[R] obj2 = copy(obj1); \f[I]// obj2 looks like obj1 now\f[R]
.EE
.SS Flatten an array
The following example is only here for learning purpose.
If you want to flatten an array using built\-in methods, you can use
\f[CR]Array.prototype.flat()\f[R].
.IP
.EX
\f[B]const\f[R] flatten = (arr) \f[B]=>\f[R] {
  \f[B]const\f[R] result = [];
  arr.forEach((item) \f[B]=>\f[R] {
    \f[B]if\f[R] (Array.isArray(item)) {
      result.push(...flatten(item));
    } \f[B]else\f[R] {
      result.push(item);
    }
  });
  \f[B]return\f[R] result;
};

\f[I]// Usage\f[R]
\f[B]const\f[R] nested = [1, 2, 3, [4, 5, [6, 7], 8, 9]];
console.log(flatten(nested)); \f[I]// [1, 2, 3, 4, 5, 6, 7, 8, 9]\f[R]
.EE
.SS Using the third argument of callbackFn
The \f[CR]array\f[R] argument is useful if you want to access another
element in the array, especially when you don\[cq]t have an existing
variable that refers to the array.
The following example first uses \f[CR]filter()\f[R] to extract the
positive values and then uses \f[CR]forEach()\f[R] to log its neighbors.
.IP
.EX
\f[B]const\f[R] numbers = [3, \-1, 1, 4, 1, 5];
numbers
  .filter((num) \f[B]=>\f[R] num > 0)
  .forEach((num, idx, arr) \f[B]=>\f[R] {
    \f[I]// Without the arr argument, there\[aq]s no way to easily access the\f[R]
    \f[I]// intermediate array without saving it to a variable.\f[R]
    console.log(arr[idx \- 1], num, arr[idx + 1]);
  });
\f[I]// undefined 3 1\f[R]
\f[I]// 3 1 4\f[R]
\f[I]// 1 4 1\f[R]
\f[I]// 4 1 5\f[R]
\f[I]// 1 5 undefined\f[R]
.EE
.SS Using forEach() on sparse arrays
.IP
.EX
const arraySparse = [1, 3, /* empty */, 7];
let numCallbackRuns = 0;

arraySparse.forEach((element) => {
  console.log({ element });
  numCallbackRuns++;
});

console.log({ numCallbackRuns });

// { element: 1 }
// { element: 3 }
// { element: 7 }
// { numCallbackRuns: 3 }
.EE
.PP
The callback function is not invoked for the missing value at index 2.
.SS Calling forEach() on non\-array objects
The \f[CR]forEach()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R] and then accesses each property whose key is a
nonnegative integer less than \f[CR]length\f[R].
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
  3: 5, \f[I]// ignored by forEach() since length is 3\f[R]
};
Array.prototype.forEach.call(arrayLike, (x) \f[B]=>\f[R] console.log(x));
\f[I]// 2\f[R]
\f[I]// 3\f[R]
\f[I]// 4\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype.forEach\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Indexed collections guide
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.find()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.map()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.filter()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.every()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.some()\f[R]
.IP \[bu] 2
\f[CR]TypedArray.prototype.forEach()\f[R]
.IP \[bu] 2
\f[CR]Map.prototype.forEach()\f[R]
.IP \[bu] 2
\f[CR]Set.prototype.forEach()\f[R]
