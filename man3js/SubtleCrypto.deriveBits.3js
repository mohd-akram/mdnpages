.\" Automatically generated by Pandoc 3.4
.\"
.TH "SubtleCrypto.deriveBits" "JS" "October 16, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SubtleCrypto.deriveBits \- SubtleCrypto: deriveBits() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]deriveBits()\f[B]\f[R] method of the
\f[CR]SubtleCrypto\f[R] interface can be used to derive an array of bits
from a base key.
.PP
It takes as its arguments the base key, the derivation algorithm to use,
and the length of the bits to derive.
It returns a \f[CR]Promise\f[R] which will be fulfilled with an
\f[CR]ArrayBuffer\f[R] containing the derived bits.
.PP
This method is very similar to \f[CR]SubtleCrypto.deriveKey()\f[R],
except that \f[CR]deriveKey()\f[R] returns a \f[CR]CryptoKey\f[R] object
rather than an \f[CR]ArrayBuffer\f[R].
Essentially \f[CR]deriveKey()\f[R] is composed of
\f[CR]deriveBits()\f[R] followed by \f[CR]importKey()\f[R].
.PP
This function supports the same derivation algorithms as
\f[CR]deriveKey()\f[R]: ECDH, HKDF, PBKDF2, and X25519.
See Supported algorithms for some more detail on these algorithms.
.SH SYNTAX
.IP
.EX
deriveBits(algorithm, baseKey, length)
.EE
.SS Parameters
.TP
\f[B]algorithm\f[R]
An object defining the derivation algorithm to use.
.RS
.IP \[bu] 2
To use ECDH, pass an \f[CR]EcdhKeyDeriveParams\f[R] object, specifying
the string \f[CR]ECDH\f[R] as the \f[CR]name\f[R] property.
.IP \[bu] 2
To use HKDF, pass an \f[CR]HkdfParams\f[R] object.
.IP \[bu] 2
To use PBKDF2, pass a \f[CR]Pbkdf2Params\f[R] object.
.IP \[bu] 2
To use X25519, pass an \f[CR]EcdhKeyDeriveParams\f[R] object, specifying
the string \f[CR]X25519\f[R] as the \f[CR]name\f[R] property.
.RE
.TP
\f[B]baseKey\f[R]
A \f[CR]CryptoKey\f[R] representing the input to the derivation
algorithm.
If \f[CR]algorithm\f[R] is ECDH, this will be the ECDH private key.
Otherwise it will be the initial key material for the derivation
function: for example, for PBKDF2 it might be a password, imported as a
\f[CR]CryptoKey\f[R] using \f[CR]SubtleCrypto.importKey()\f[R].
.TP
\f[B]length\f[R]
A number representing the number of bits to derive.
To be compatible with all browsers, the number should be a multiple of
8.
.SS Return value
A \f[CR]Promise\f[R] that fulfills with an \f[CR]ArrayBuffer\f[R]
containing the derived bits.
.SS Exceptions
The promise is rejected when one of the following exceptions are
encountered:
.TP
\f[B]OperationError\f[R] \f[B]DOMException\f[R]
Raised if the \f[I]length\f[R] parameter of the \f[CR]deriveBits()\f[R]
call is null, and also in some cases if the \f[I]length\f[R] parameter
is not a multiple of 8.
.TP
\f[B]InvalidAccessError\f[R] \f[B]DOMException\f[R]
Raised when the base key is not a key for the requested derivation
algorithm or if the \f[CR]CryptoKey.usages\f[R] value of that key
doesn\[cq]t contain \f[CR]deriveBits\f[R].
.TP
\f[B]NotSupported\f[R] \f[B]DOMException\f[R]
Raised when trying to use an algorithm that is either unknown or
isn\[cq]t suitable for derivation.
.SH SUPPORTED ALGORITHMS
See the Supported algorithms section of the \f[CR]deriveKey()\f[R]
documentation.
.SH EXAMPLES
.RS
.PP
\f[B]Note:\f[R] You can \c
.UR https://mdn.github.io/dom-examples/web-crypto/derive-bits/index.html
try the working examples
.UE \c
\ on GitHub.
.RE
.SS ECDH
In this example Alice and Bob each generate an ECDH key pair.
.PP
We then use Alice\[cq]s private key and Bob\[cq]s public key to derive a
shared secret.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/derive-bits/ecdh.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] deriveSharedSecret(privateKey, publicKey) {
  \f[B]const\f[R] sharedSecret = \f[B]await\f[R] window.crypto.subtle.deriveBits(
    {
      name: \[dq]ECDH\[dq],
      namedCurve: \[dq]P\-384\[dq],
      public: publicKey,
    },
    privateKey,
    128,
  );

  \f[B]const\f[R] buffer = \f[B]new\f[R] Uint8Array(sharedSecret, 0, 5);
  \f[B]const\f[R] sharedSecretValue = document.querySelector(\[dq].ecdh .derived\-bits\-value\[dq]);
  sharedSecretValue.classList.add(\[dq]fade\-in\[dq]);
  sharedSecretValue.addEventListener(\[dq]animationend\[dq], () \f[B]=>\f[R] {
    sharedSecretValue.classList.remove(\[dq]fade\-in\[dq]);
  });
  sharedSecretValue.textContent = \[ga]${buffer}\&...[${sharedSecret.byteLength} bytes total]\[ga];
}

\f[I]// Generate 2 ECDH key pairs: one for Alice and one for Bob\f[R]
\f[I]// In more normal usage, they would generate their key pairs\f[R]
\f[I]// separately and exchange public keys securely\f[R]
\f[B]const\f[R] generateAliceKeyPair = window.crypto.subtle.generateKey(
  {
    name: \[dq]ECDH\[dq],
    namedCurve: \[dq]P\-384\[dq],
  },
  \f[B]false\f[R],
  [\[dq]deriveBits\[dq]],
);

\f[B]const\f[R] generateBobKeyPair = window.crypto.subtle.generateKey(
  {
    name: \[dq]ECDH\[dq],
    namedCurve: \[dq]P\-384\[dq],
  },
  \f[B]false\f[R],
  [\[dq]deriveBits\[dq]],
);

Promise.all([generateAliceKeyPair, generateBobKeyPair]).then((values) \f[B]=>\f[R] {
  \f[B]const\f[R] aliceKeyPair = values[0];
  \f[B]const\f[R] bobKeyPair = values[1];

  \f[B]const\f[R] deriveBitsButton = document.querySelector(\[dq].ecdh .derive\-bits\-button\[dq]);
  deriveBitsButton.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
    \f[I]// Alice then generates a secret using her private key and Bob\[aq]s public key.\f[R]
    \f[I]// Bob could generate the same secret using his private key and Alice\[aq]s public key.\f[R]
    deriveSharedSecret(aliceKeyPair.privateKey, bobKeyPair.publicKey);
  });
});
.EE
.SS X25519
In this example Alice and Bob each generate an X25519 key pair.
We then use Alice\[cq]s private key and Bob\[cq]s public key to derive a
secret, and compare that with the secret generated using Bob\[cq]s
private key and Alice\[cq]s public key to show that they are
shared/identical.
.SS HTML
The HTML is defines two buttons.
The \[lq]Change keys\[rq] button is pressed to generate new key pairs
for Alice and Bob.
The \[lq]Derive bits\[rq] button is pressed to derive a shared secret
with the current set of key pairs.
.IP
.EX
<\f[B]input\f[R] id=\[dq]buttonDeriveKeys\[dq] type=\[dq]button\[dq] value=\[dq]Derive bits\[dq] />
<\f[B]input\f[R] id=\[dq]buttonChangeKeys\[dq] type=\[dq]button\[dq] value=\[dq]Change keys\[dq] />
.EE
.SS JavaScript
The function to generate a shared secret using the X25519 algorithm is
shown below.
This takes a private key from one party and the public key from another.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] deriveSharedSecret(privateKey, publicKey) {
  \f[B]return\f[R] \f[B]await\f[R] window.crypto.subtle.deriveBits(
    {
      name: \[dq]X25519\[dq],
      public: publicKey,
    },
    privateKey,
    128,
  );
}
.EE
.PP
The code below adds a function to generate new keys for Alice and Bob.
This is done the first time the JavaScript is loaded, and repeated
whenever the \[lq]Change keys\[rq] button is pressed (this allows us to
see the effect of changing the keys on the shared secret).
.IP
.EX
\f[B]let\f[R] aliceKeyPair;
\f[B]let\f[R] bobKeyPair;

\f[B]async\f[R] \f[B]function\f[R] changeKeys() {
  \f[B]try\f[R] {
    aliceKeyPair = \f[B]await\f[R] window.crypto.subtle.generateKey(
      {
        name: \[dq]X25519\[dq],
      },
      \f[B]false\f[R],
      [\[dq]deriveBits\[dq]],
    );

    bobKeyPair = \f[B]await\f[R] window.crypto.subtle.generateKey(
      {
        name: \[dq]X25519\[dq],
      },
      \f[B]false\f[R],
      [\[dq]deriveBits\[dq]],
    );

    log(\[dq]Keys changed\[dq]);
  } \f[B]catch\f[R] (e) {
    log(e);
  }
}

changeKeys();

\f[B]const\f[R] changeKeysButton = document.querySelector(\[dq]#buttonChangeKeys\[dq]);

\f[I]// Generate 2 X25519 key pairs: one for Alice and one for Bob\f[R]
\f[I]// In more normal usage, they would generate their key pairs\f[R]
\f[I]// separately and exchange public keys securely\f[R]
changeKeysButton.addEventListener(\[dq]click\[dq], changeKeys);
.EE
.PP
The code below adds a handler function that is invoked every time the
\[lq]Derive bits\[rq] button is pressed.
The handler generates the shared secrets for Alice and Bob using the
\f[CR]deriveSharedSecret()\f[R] method defined above, and logs them for
easy comparison.
.IP
.EX
\f[B]const\f[R] deriveBitsButton = document.querySelector(\[dq]#buttonDeriveKeys\[dq]);

deriveBitsButton.addEventListener(\[dq]click\[dq], \f[B]async\f[R] () \f[B]=>\f[R] {
  \f[I]// Generate 2 X25519 key pairs: one for Alice and one for Bob\f[R]
  \f[I]// In more normal usage, they would generate their key pairs\f[R]
  \f[I]// separately and exchange public keys securely\f[R]

  \f[I]// Alice then generates a secret using her private key and Bob\[aq]s public key.\f[R]
  \f[I]// Bob could generate the same secret using his private key and Alice\[aq]s public key.\f[R]

  \f[B]const\f[R] sharedSecretAlice = \f[B]await\f[R] deriveSharedSecret(
    aliceKeyPair.privateKey,
    bobKeyPair.publicKey,
  );

  \f[B]let\f[R] buffer = \f[B]new\f[R] Uint8Array(sharedSecretAlice, 0, 10);
  log(\[ga]${buffer}\&...[${sharedSecretAlice.byteLength} bytes total] (Alice secret)\[ga]);

  \f[B]const\f[R] sharedSecretBob = \f[B]await\f[R] deriveSharedSecret(
    bobKeyPair.privateKey,
    aliceKeyPair.publicKey,
  );

  buffer = \f[B]new\f[R] Uint8Array(sharedSecretBob, 0, 10);
  log(\[ga]${buffer}\&...[${sharedSecretAlice.byteLength} bytes total] (Bob secret)\[ga]);
});
.EE
.SS Result
Press the \[lq]Derive bits\[rq] button to generate and log a shared
secret from Bob and Alice\[cq]s keys.
Press the \[lq]Change keys\[rq] button to change the X25519 keys used by
both parties.
.SS PBKDF2
In this example we ask the user for a password, then use it to derive
some bits using PBKDF2.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/derive-bits/pbkdf2.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[B]let\f[R] salt;

\f[I]/*\f[R]
\f[I]Get some key material to use as input to the deriveBits method.\f[R]
\f[I]The key material is a password supplied by the user.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getKeyMaterial() {
  \f[B]const\f[R] password = window.prompt(\[dq]Enter your password\[dq]);
  \f[B]const\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] window.crypto.subtle.importKey(
    \[dq]raw\[dq],
    enc.encode(password),
    { name: \[dq]PBKDF2\[dq] },
    \f[B]false\f[R],
    [\[dq]deriveBits\[dq], \[dq]deriveKey\[dq]],
  );
}

\f[I]/*\f[R]
\f[I]Derive some bits from a password supplied by the user.\f[R]
\f[I]*/\f[R]
\f[B]async\f[R] \f[B]function\f[R] getDerivedBits() {
  \f[B]const\f[R] keyMaterial = \f[B]await\f[R] getKeyMaterial();
  salt = window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(16));
  \f[B]const\f[R] derivedBits = \f[B]await\f[R] window.crypto.subtle.deriveBits(
    {
      name: \[dq]PBKDF2\[dq],
      salt,
      iterations: 100000,
      hash: \[dq]SHA\-256\[dq],
    },
    keyMaterial,
    256,
  );

  \f[B]const\f[R] buffer = \f[B]new\f[R] Uint8Array(derivedBits, 0, 5);
  \f[B]const\f[R] derivedBitsValue = document.querySelector(
    \[dq].pbkdf2 .derived\-bits\-value\[dq],
  );
  derivedBitsValue.classList.add(\[dq]fade\-in\[dq]);
  derivedBitsValue.addEventListener(\[dq]animationend\[dq], () \f[B]=>\f[R] {
    derivedBitsValue.classList.remove(\[dq]fade\-in\[dq]);
  });
  derivedBitsValue.textContent = \[ga]${buffer}\&...[${derivedBits.byteLength} bytes total]\[ga];
}

\f[B]const\f[R] deriveBitsButton = document.querySelector(\[dq].pbkdf2 .derive\-bits\-button\[dq]);
deriveBitsButton.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
  getDerivedBits();
});
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc5869
HKDF specification
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://csrc.nist.gov/pubs/sp/800/132/final
NIST guidelines for password\-based key derivation
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html
Password storage cheat sheet
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pbkdf2-sha256/3993#3993
Advice on choosing an iteration count for PBKDF2
.UE \c
\&.
