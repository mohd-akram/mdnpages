.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "BIGINT.ASINTN" "3JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
BigInt.asIntN \- BigInt.asIntN()
.SH SYNOPSIS
The \f[B]\f[CB]BigInt.asIntN()\f[B]\f[R] static method truncates a
\f[CR]BigInt\f[R] value to the given number of least significant bits
and returns that value as a signed integer.
.IP
.EX
\f[B]const\f[R] I64_CEIL = 2n ** 63n;

console.log(BigInt.asIntN(64, I64_CEIL \- 1n));
\f[I]// 9223372036854775807n (2n ** 64n \- 1n, the maximum non\-wrapping value)\f[R]
console.log(BigInt.asIntN(64, I64_CEIL));
\f[I]// \-9223372036854775808n (wraps to min value)\f[R]
console.log(BigInt.asIntN(64, I64_CEIL + 1n));
\f[I]// \-9223372036854775807n (min value + 1n)\f[R]
console.log(BigInt.asIntN(64, I64_CEIL * 2n));
\f[I]// 0n (wrapped around to zero)\f[R]
console.log(BigInt.asIntN(64, \-I64_CEIL * \-42n));
\f[I]// 0n (also wraps on negative multiples)\f[R]
.EE
.SH SYNTAX
.IP
.EX
BigInt.asIntN(bits, bigint)
.EE
.SS Parameters
.TP
\f[B]bits\f[R]
The amount of bits available for the returned BigInt.
Should be an integer between 0 and 2\(ha53 \- 1, inclusive.
.TP
\f[B]bigint\f[R]
The BigInt value to truncate to fit into the supplied bits.
.SS Return value
The value of \f[CR]bigint\f[R] modulo 2\(ha\f[CR]bits\f[R], as a signed
integer.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]bits\f[R] is negative or greater than 2\(ha53 \- 1.
.SH DESCRIPTION
The \f[CR]BigInt.asIntN\f[R] method truncates a \f[CR]BigInt\f[R] value
to the given number of bits, and interprets the result as a signed
integer.
For example, for \f[CR]BigInt.asIntN(3, 25n)\f[R], the value
\f[CR]25n\f[R] is truncated to \f[CR]1n\f[R]:
.IP
.EX
25n = 00011001 (base 2)
          \(ha=== Use only the three remaining bits
===>       001 (base 2) = 1n
.EE
.PP
If the leading bit of the remaining number is \f[CR]1\f[R], the result
is negative.
For example, \f[CR]BigInt.asIntN(4, 25n)\f[R] yields \f[CR]\-7n\f[R],
because \f[CR]1001\f[R] is the encoding of \f[CR]\-7\f[R] under two\(cqs
complement:
.IP
.EX
25n = 00011001 (base 2)
         \(ha==== Use only the four remaining bits
===>      1001 (base 2) = \-7n
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]BigInt\f[R] values are always encoded as two\(cqs
complement in binary.
.RE
.PP
Unlike similar language APIs such as
\f[CR]Number.prototype.toExponential()\f[R], \f[CR]asIntN\f[R] is a
static property of \f[CR]BigInt\f[R], so you always use it as
\f[CR]BigInt.asIntN()\f[R], rather than as a method of a BigInt value.
Exposing \f[CR]asIntN()\f[R] as a \(lqstandard library function\(rq
allows \c
.UR https://github.com/tc39/proposal-bigint/blob/master/ADVANCED.md#dont-break-asmjs
interop with asm.js
.UE \c
\&.
.SH EXAMPLES
.SS Staying in 64\-bit ranges
The \f[CR]BigInt.asIntN()\f[R] method can be useful to stay in the range
of 64\-bit arithmetic.
.IP
.EX
\f[B]const\f[R] max = 2n ** (64n \- 1n) \- 1n;

BigInt.asIntN(64, max); \f[I]// 9223372036854775807n\f[R]

BigInt.asIntN(64, max + 1n); \f[I]// \-9223372036854775808n\f[R]
\f[I]// negative because the 64th bit of 2\(ha63 is 1\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]BigInt\f[R]
.IP \(bu 2
\f[CR]BigInt.asUintN()\f[R]
