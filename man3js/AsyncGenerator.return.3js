.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ASYNCGENERATOR.RETURN" "3JS" "November 14, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
AsyncGenerator.return \- AsyncGenerator.prototype.return()
.SH SYNOPSIS
The \f[B]\f[CB]return()\f[B]\f[R] method of \f[CR]AsyncGenerator\f[R]
instances acts as if a \f[CR]return\f[R] statement is inserted in the
generator\(cqs body at the current suspended position, which finishes
the generator and allows the generator to perform any cleanup tasks when
combined with a \f[CR]try...finally\f[R] block.
.SH SYNTAX
.IP
.EX
asyncGeneratorInstance.return()
asyncGeneratorInstance.return(value)
.EE
.SS Parameters
.TP
\f[B]value\f[R] \f[I](optional)\f[R]
The value to return.
.SS Return value
A \f[CR]Promise\f[R] which resolves with an \f[CR]Object\f[R] with two
properties:
.TP
\f[B]done\f[R]
A boolean value:
.RS
.IP \(bu 2
\f[CR]true\f[R] if the generator function\(cqs control flow has reached
the end.
.IP \(bu 2
\f[CR]false\f[R] if the generator function\(cqs control flow hasn\(cqt
reached the end and can produce more values.
This can only happen if the \f[CR]return\f[R] is captured in a
\f[CR]try...finally\f[R] and there are more \f[CR]yield\f[R] expressions
in the \f[CR]finally\f[R] block.
.RE
.TP
\f[B]value\f[R]
The value that is given as an argument, or, if the \f[CR]yield\f[R]
expression is wrapped in a \f[CR]try...finally\f[R], the value
yielded/returned from the \f[CR]finally\f[R] block.
.SH DESCRIPTION
The \f[CR]return()\f[R] method, when called, can be seen as if a
\f[CR]return value;\f[R] statement is inserted in the generator\(cqs
body at the current suspended position, where \f[CR]value\f[R] is the
value passed to the \f[CR]return()\f[R] method.
Therefore, in a typical flow, calling \f[CR]return(value)\f[R] will
return \f[CR]{ done: true, value: value }\f[R].
However, if the \f[CR]yield\f[R] expression is wrapped in a
\f[CR]try...finally\f[R] block, the control flow doesn\(cqt exit the
function body, but proceeds to the \f[CR]finally\f[R] block instead.
In this case, the value returned may be different, and \f[CR]done\f[R]
may even be \f[CR]false\f[R], if there are more \f[CR]yield\f[R]
expressions within the \f[CR]finally\f[R] block.
.SH EXAMPLES
.SS Using return()
The following example shows an async generator and the \f[CR]return\f[R]
method.
.IP
.EX
\f[I]// An async task. Pretend it\(aqs doing something more useful\f[R]
\f[I]// in practice.\f[R]
\f[B]function\f[R] delayedValue(time, value) {
  \f[B]return\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
    setTimeout(() \f[B]=>\f[R] resolve(value), time);
  });
}

\f[B]async\f[R] \f[B]function\f[R]* createAsyncGenerator() {
  \f[B]yield\f[R] delayedValue(500, 1);
  \f[B]yield\f[R] delayedValue(500, 2);
  \f[B]yield\f[R] delayedValue(500, 3);
}

\f[B]const\f[R] asyncGen = createAsyncGenerator();
asyncGen.next().then((res) \f[B]=>\f[R] console.log(res)); \f[I]// { value: 1, done: false }\f[R]
asyncGen.return(\(dqfoo\(dq).then((res) \f[B]=>\f[R] console.log(res)); \f[I]// { value: \(dqfoo\(dq, done: true }\f[R]
asyncGen.next().then((res) \f[B]=>\f[R] console.log(res)); \f[I]// { value: undefined, done: true }\f[R]
.EE
.SS Using return() once a generator is complete
If no \f[CR]value\f[R] argument is passed into the \f[CR]return()\f[R]
method, the promise will resolve as if the next() method has been
called.
In this example the generator has completed, so the value returned is
\f[CR]undefined\f[R].
.PP
\f[CR]return()\f[R] can still be called after the generator is in a
\(lqcompleted\(rq state, however the generator will stay in this state.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R]* createAsyncGenerator() {
  \f[B]yield\f[R] Promise.resolve(1);
  \f[B]yield\f[R] \f[B]await\f[R] Promise.resolve(2);
  \f[B]yield\f[R] 3;
}
\f[B]const\f[R] asyncGen = createAsyncGenerator();
asyncGen.next().then((res) \f[B]=>\f[R] console.log(res)); \f[I]// { value: 1, done: false }\f[R]
asyncGen.next().then((res) \f[B]=>\f[R] console.log(res)); \f[I]// { value: 2, done: false }\f[R]
asyncGen.next().then((res) \f[B]=>\f[R] console.log(res)); \f[I]// { value: 3, done: false }\f[R]
\f[I]// value is returned undefined, as no value is passed and generator is \(aqdone\(aq\f[R]
asyncGen.return().then((res) \f[B]=>\f[R] console.log(res)); \f[I]// { value: undefined, done: true }\f[R]
\f[I]// we can still return a value once the generator is complete\f[R]
asyncGen.return(1).then((res) \f[B]=>\f[R] console.log(res)); \f[I]// { value: 1, done: true }\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]async function*\f[R]
.IP \(bu 2
Iterators and generators guide
