.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "CanvasRenderingContext2D.clip" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
CanvasRenderingContext2D.clip \- CanvasRenderingContext2D: clip() method
.SH SYNOPSIS
The \f[B]\f[CB]CanvasRenderingContext2D.clip()\f[B]\f[R] method of the
Canvas 2D API turns the current or given path into the current clipping
region.
The previous clipping region, if any, is intersected with the current or
given path to create the new clipping region.
.PP
In the image below, the red outline represents a clipping region shaped
like a star.
Only those parts of the checkerboard pattern that are within the
clipping region get drawn.
[IMAGE: Star\-shaped clipping region]
Star\-shaped clipping region
.RS
.PP
\f[B]Note:\f[R] Be aware that the clipping region is only constructed
from shapes added to the path.
It doesn\[cq]t work with shape primitives drawn directly to the canvas,
such as \f[CR]fillRect()\f[R].
Instead, you\[cq]d have to use \f[CR]rect()\f[R] to add a rectangular
shape to the path before calling \f[CR]clip()\f[R].
.RE
.RS
.PP
\f[B]Note:\f[R] Clip paths cannot be reverted directly.
You must save your canvas state using \f[CR]save()\f[R] before calling
\f[CR]clip()\f[R], and restore it once you have finished drawing in the
clipped area using \f[CR]restore()\f[R].
.RE
.SH SYNTAX
.IP
.EX
clip()
clip(path)
clip(fillRule)
clip(path, fillRule)
.EE
.SS Parameters
.TP
\f[B]fillRule\f[R]
The algorithm by which to determine if a point is inside or outside the
clipping region.
Possible values:
.RS
.TP
\f[B]nonzero\f[R]
The \c
.UR https://en.wikipedia.org/wiki/Nonzero-rule
non\-zero winding rule
.UE \c
\&.
Default rule.
.TP
\f[B]evenodd\f[R]
The \c
.UR https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
even\-odd winding rule
.UE \c
\&.
.RE
.TP
\f[B]path\f[R]
A \f[CR]Path2D\f[R] path to use as the clipping region.
.SS Return value
None (\f[CR]undefined\f[R]).
.SH EXAMPLES
.SS A simple clipping region
This example uses the \f[CR]clip()\f[R] method to create a clipping
region according to the shape of a circular arc.
Two rectangles are then drawn; only those parts within the clipping
region are rendered.
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]canvas\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
The clipping region is a full circle, with its center at (100, 75), and
a radius of 50.
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);

\f[I]// Create circular clipping region\f[R]
ctx.beginPath();
ctx.arc(100, 75, 50, 0, Math.PI * 2);
ctx.clip();

\f[I]// Draw stuff that gets clipped\f[R]
ctx.fillStyle = \[dq]blue\[dq];
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = \[dq]orange\[dq];
ctx.fillRect(0, 0, 100, 100);
.EE
.SS Result
.SS Specifying a path and a fillRule
This example saves two rectangles to a Path2D object, which is then made
the current clipping region using the \f[CR]clip()\f[R] method.
The \f[CR]\[dq]evenodd\[dq]\f[R] rule creates a hole where the clipping
rectangles intersect; by default (with the \f[CR]\[dq]nonzero\[dq]\f[R]
rule), there would be no hole.
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]canvas\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);

\f[I]// Create clipping path\f[R]
\f[B]let\f[R] region = \f[B]new\f[R] Path2D();
region.rect(80, 10, 20, 130);
region.rect(40, 50, 100, 50);
ctx.clip(region, \[dq]evenodd\[dq]);

\f[I]// Draw stuff that gets clipped\f[R]
ctx.fillStyle = \[dq]blue\[dq];
ctx.fillRect(0, 0, canvas.width, canvas.height);
.EE
.SS Result
.SS Creating a complex clipping region
This example uses two paths, a rectangle and a square to create a
complex clipping region.
The \f[CR]clip()\f[R] method is called twice, first to set the current
clipping region to the circle using a \f[CR]Path2D\f[R] object, then
again to intersect the circle clipping region with a square.
The final clipping region is a shape representing the intersection of
the circle and the square.
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]canvas\[dq]></\f[B]canvas\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] ctx = canvas.getContext(\[dq]2d\[dq]);

\f[I]// Create two clipping paths\f[R]
\f[B]let\f[R] circlePath = \f[B]new\f[R] Path2D();
circlePath.arc(150, 75, 75, 0, 2 * Math.PI);
\f[B]let\f[R] squarePath = \f[B]new\f[R] Path2D();
squarePath.rect(85, 10, 130, 130);

\f[I]// Set the clip to the circle\f[R]
ctx.clip(circlePath);
\f[I]// Set the clip to be the intersection of the circle and the square\f[R]
ctx.clip(squarePath);

\f[I]// Draw stuff that gets clipped\f[R]
ctx.fillStyle = \[dq]blue\[dq];
ctx.fillRect(0, 0, canvas.width, canvas.height);
.EE
.SS Result
.SH SEE ALSO
.IP \[bu] 2
The interface defining this method: \f[CR]CanvasRenderingContext2D\f[R]
