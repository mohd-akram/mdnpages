.\" Automatically generated by Pandoc 3.4
.\"
.TH "JSON" "JS" "October 9, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
JSON \- JSON
.SH SYNOPSIS
The \f[B]\f[CB]JSON\f[B]\f[R] namespace object contains static methods
for parsing values from and converting values to \c
.UR https://json.org/
JavaScript Object Notation
.UE \c
\ (JSON).
.SH DESCRIPTION
Unlike most global objects, \f[CR]JSON\f[R] is not a constructor.
You cannot use it with the \f[CR]new\f[R] operator or invoke the
\f[CR]JSON\f[R] object as a function.
All properties and methods of \f[CR]JSON\f[R] are static (just like the
\f[CR]Math\f[R] object).
.SS JavaScript and JSON differences
JSON is a syntax for serializing objects, arrays, numbers, strings,
booleans, and \f[CR]null\f[R].
It is based upon JavaScript syntax, but is distinct from JavaScript:
most of JavaScript is \f[I]not\f[R] JSON.
For example:
.TP
Objects and Arrays
Property names must be double\-quoted strings; trailing commas are
forbidden.
.TP
Numbers
Leading zeros are prohibited.
A decimal point must be followed by at least one digit.
\f[CR]NaN\f[R] and \f[CR]Infinity\f[R] are unsupported.
.PP
Any JSON text is a valid JavaScript expression, but only after the \c
.UR https://github.com/tc39/proposal-json-superset
JSON superset
.UE \c
\ revision.
Before the revision, U+2028 LINE SEPARATOR and U+2029 PARAGRAPH
SEPARATOR are allowed in string literals and property keys in JSON; but
the same use in JavaScript string literals is a \f[CR]SyntaxError\f[R].
.PP
Other differences include allowing only double\-quoted strings and no
support for \f[CR]undefined\f[R] or comments.
For those who wish to use a more human\-friendly configuration format
based on JSON, there is \c
.UR https://json5.org/
JSON5
.UE \c
, used by the Babel compiler, and the more commonly used \c
.UR https://en.wikipedia.org/wiki/YAML
YAML
.UE \c
\&.
.PP
The same text may represent different values in JavaScript object
literals vs.\ JSON as well.
For more information, see Object literal syntax vs.\ JSON.
.SS Full JSON grammar
Valid JSON syntax is formally defined by the following grammar,
expressed in \c
.UR https://en.wikipedia.org/wiki/Augmented_Backus%E2%80%93Naur_form
ABNF
.UE \c
, and copied from \c
.UR https://datatracker.ietf.org/doc/html/rfc8259
IETF JSON standard (RFC)
.UE \c
:
.IP
.EX
JSON\-text = object / array
begin\-array     = ws %x5B ws  ; [ left square bracket
begin\-object    = ws %x7B ws  ; { left curly bracket
end\-array       = ws %x5D ws  ; ] right square bracket
end\-object      = ws %x7D ws  ; } right curly bracket
name\-separator  = ws %x3A ws  ; : colon
value\-separator = ws %x2C ws  ; , comma
ws = *(
     %x20 /              ; Space
     %x09 /              ; Horizontal tab
     %x0A /              ; Line feed or New line
     %x0D                ; Carriage return
     )
value = false / null / true / object / array / number / string
false = %x66.61.6c.73.65   ; false
null  = %x6e.75.6c.6c      ; null
true  = %x74.72.75.65      ; true
object = begin\-object [ member *( value\-separator member ) ]
         end\-object
member = string name\-separator value
array = begin\-array [ value *( value\-separator value ) ] end\-array
number = [ minus ] int [ frac ] [ exp ]
decimal\-point = %x2E       ; .
digit1\-9 = %x31\-39         ; 1\-9
e = %x65 / %x45            ; e E
exp = e [ minus / plus ] 1*DIGIT
frac = decimal\-point 1*DIGIT
int = zero / ( digit1\-9 *DIGIT )
minus = %x2D               ; \-
plus = %x2B                ; +
zero = %x30                ; 0
string = quotation\-mark *char quotation\-mark
char = unescaped /
    escape (
        %x22 /          ; \[dq]    quotation mark  U+0022
        %x5C /          ; \[rs]    reverse solidus U+005C
        %x2F /          ; /    solidus         U+002F
        %x62 /          ; b    backspace       U+0008
        %x66 /          ; f    form feed       U+000C
        %x6E /          ; n    line feed       U+000A
        %x72 /          ; r    carriage return U+000D
        %x74 /          ; t    tab             U+0009
        %x75 4HEXDIG )  ; uXXXX                U+XXXX
escape = %x5C              ; \[rs]
quotation\-mark = %x22      ; \[dq]
unescaped = %x20\-21 / %x23\-5B / %x5D\-10FFFF
HEXDIG = DIGIT / %x41\-46 / %x61\-66   ; 0\-9, A\-F, or a\-f
       ; HEXDIG equivalent to HEXDIG rule in [RFC5234]
DIGIT = %x30\-39            ; 0\-9
      ; DIGIT equivalent to DIGIT rule in [RFC5234]
.EE
.PP
Insignificant whitespace may be present anywhere except within a
\f[CR]JSONNumber\f[R] (numbers must contain no whitespace) or
\f[CR]JSONString\f[R] (where it is interpreted as the corresponding
character in the string, or would cause an error).
The tab (U+0009), carriage return (U+000D), line feed (U+000A), and
space (U+0020) characters are the only valid whitespace characters.
.SH STATIC PROPERTIES
.TP
\f[B]JSON[Symbol.toStringTag]\f[R]
The initial value of the \f[CR][Symbol.toStringTag]\f[R] property is the
string \f[CR]\[dq]JSON\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH STATIC METHODS
.TP
\f[B]JSON.isRawJSON()\f[R]
Tests whether a value is an object returned by
\f[CR]JSON.rawJSON()\f[R].
.TP
\f[B]JSON.parse()\f[R]
Parse a piece of string text as JSON, optionally transforming the
produced value and its properties, and return the value.
.TP
\f[B]JSON.rawJSON()\f[R]
Creates a \[lq]raw JSON\[rq] object containing a piece of JSON text.
When serialized to JSON, the raw JSON object is treated as if it is
already a piece of JSON.
This text is required to be valid JSON.
.TP
\f[B]JSON.stringify()\f[R]
Return a JSON string corresponding to the specified value, optionally
including only certain properties or replacing property values in a
user\-defined manner.
.SH EXAMPLES
.SS Example JSON
.IP
.EX
{
  \[dq]browsers\[dq]: {
    \[dq]firefox\[dq]: {
      \[dq]name\[dq]: \[dq]Firefox\[dq],
      \[dq]pref_url\[dq]: \[dq]about:config\[dq],
      \[dq]releases\[dq]: {
        \[dq]1\[dq]: {
          \[dq]release_date\[dq]: \[dq]2004\-11\-09\[dq],
          \[dq]status\[dq]: \[dq]retired\[dq],
          \[dq]engine\[dq]: \[dq]Gecko\[dq],
          \[dq]engine_version\[dq]: \[dq]1.7\[dq]
        }
      }
    }
  }
}
.EE
.PP
You can use the \f[CR]JSON.parse()\f[R] method to convert the above JSON
string into a JavaScript object:
.IP
.EX
\f[B]const\f[R] jsonText = \[ga]{
  \[dq]browsers\[dq]: {
    \[dq]firefox\[dq]: {
      \[dq]name\[dq]: \[dq]Firefox\[dq],
      \[dq]pref_url\[dq]: \[dq]about:config\[dq],
      \[dq]releases\[dq]: {
        \[dq]1\[dq]: {
          \[dq]release_date\[dq]: \[dq]2004\-11\-09\[dq],
          \[dq]status\[dq]: \[dq]retired\[dq],
          \[dq]engine\[dq]: \[dq]Gecko\[dq],
          \[dq]engine_version\[dq]: \[dq]1.7\[dq]
        }
      }
    }
  }
}\[ga];

console.log(JSON.parse(jsonText));
.EE
.SS Lossless number serialization
JSON can contain number literals of arbitrary precision.
However, it is not possible to represent all JSON numbers exactly in
JavaScript, because JavaScript uses floating point representation which
has a fixed precision.
For example, \f[CR]12345678901234567890 === 12345678901234567000\f[R] in
JavaScript because they have the same floating point representation.
This means there is no JavaScript number that corresponds precisely to
the \f[CR]12345678901234567890\f[R] JSON number.
.PP
Let\[cq]s assume you have a exact representation of some number (either
via \f[CR]BigInt\f[R] or a custom library):
.IP
.EX
\f[B]const\f[R] data = {
  \f[I]// Using a BigInt here to store the exact value,\f[R]
  \f[I]// but it can also be a custom high\-precision number library,\f[R]
  \f[I]// if the number might not be an integer.\f[R]
  gross_gdp: 12345678901234567890n,
};
.EE
.PP
You want to serialize it and then parse to the same exact number.
There are several difficulties:
.IP \[bu] 2
On the serialization side, in order to obtain a number in JSON, you have
to pass a number to \f[CR]JSON.stringify\f[R], either via the
\f[CR]replacer\f[R] function or via the \f[CR]toJSON\f[R] method.
But, in either case, you have already lost precision during number
conversion.
If you pass a string to \f[CR]JSON.stringify\f[R], it will be serialized
as a string, not a number.
.IP \[bu] 2
On the parsing side, not all numbers can be represented exactly.
For example, \f[CR]JSON.parse(\[dq]12345678901234567890\[dq])\f[R]
returns \f[CR]12345678901234568000\f[R] because the number is rounded to
the nearest representable number.
Even if you use a \f[CR]reviver\f[R] function, the number will already
be rounded before the \f[CR]reviver\f[R] function is called.
.PP
There are, in general, two ways to ensure that numbers are losslessly
converted to JSON and parsed back: one involves a JSON number, another
involves a JSON string.
JSON is a \f[I]communication format\f[R], so if you use JSON, you are
likely communicating with another system (HTTP request, storing in
database, etc.).
The best solution to choose depends on the recipient system.
.SS Using JSON strings
If the recipient system does not have same JSON\-handling capabilities
as JavaScript, and does not support high precision numbers, you may want
to serialize the number as a string, and then handle it as a string on
the recipient side.
This is also the only option in older JavaScript.
.PP
To specify how custom data types (including \f[CR]BigInt\f[R]) should be
serialized to JSON, either add a \f[CR]toJSON\f[R] method to your data
type, or use the \f[CR]replacer\f[R] function of
\f[CR]JSON.stringify()\f[R].
.IP
.EX
\f[I]// Using toJSON() method\f[R]
BigInt.prototype.toJSON = \f[B]function\f[R] () {
  \f[B]return\f[R] \f[B]this\f[R].toString();
};
\f[B]const\f[R] str1 = JSON.stringify(data);

\f[I]// Using JSON.stringify() with replacer\f[R]
\f[B]const\f[R] str2 = JSON.stringify(data, (key, value) \f[B]=>\f[R] {
  \f[B]if\f[R] (key === \[dq]gross_gdp\[dq]) {
    \f[B]return\f[R] value.toString();
  }
  \f[B]return\f[R] value;
});
.EE
.PP
In either case, the JSON text will look like
\f[CR]{\[dq]gross_gdp\[dq]:\[dq]12345678901234567890\[dq]}\f[R], where
the value is a string, not a number.
Then, on the recipient side, you can parse the JSON and handle the
string.
.SS Using JSON numbers
If the recipient of this message natively supports high precision
numbers (such as Python integers), passing numbers as JSON numbers is
obviously better, because they can directly parse to the high precision
type instead of parsing a string from JSON, and then parsing a number
from the string.
In JavaScript, you can serialize arbitrary data types to JSON numbers
without producing a number value first (resulting in loss of precision)
by using \f[CR]JSON.rawJSON()\f[R] to precisely specify what the JSON
source text should be.
.IP
.EX
\f[I]// Using toJSON() method\f[R]
BigInt.prototype.toJSON = \f[B]function\f[R] () {
  \f[B]return\f[R] JSON.rawJSON(\f[B]this\f[R].toString());
};
\f[B]const\f[R] str1 = JSON.stringify(data);

\f[I]// Using JSON.stringify() with replacer\f[R]
\f[B]const\f[R] str2 = JSON.stringify(data, (key, value) \f[B]=>\f[R] {
  \f[B]if\f[R] (key === \[dq]gross_gdp\[dq]) {
    \f[B]return\f[R] JSON.rawJSON(value.toString());
  }
  \f[B]return\f[R] value;
});
.EE
.PP
The text passed to \f[CR]JSON.rawJSON\f[R] is treated as if it is
already a piece of JSON, so it won\[cq]t be serialized again as a
string.
Therefore, the JSON text will look like
\f[CR]{\[dq]gross_gdp\[dq]:12345678901234567890}\f[R], where the value
is a number.
This JSON can then be parsed by the recipient without any extra
processing, provided that the recipient system does not have the same
precision limitations as JavaScript.
.PP
When parsing JSON containing high\-precision numbers in JavaScript, take
extra care because when \f[CR]JSON.parse()\f[R] invokes the
\f[CR]reviver\f[R] function, the value you receive is already parsed
(and has lost precision).
You can use the \f[CR]context.source\f[R] parameter of the
\f[CR]JSON.parse()\f[R] \f[CR]reviver\f[R] function to re\-parse the
number yourself.
.IP
.EX
\f[B]const\f[R] parsedData = JSON.parse(str, (key, value, context) \f[B]=>\f[R] {
  \f[B]if\f[R] (key === \[dq]gross_gdp\[dq]) {
    \f[I]// Or use the constructor of your custom high\-precision number library\f[R]
    \f[B]return\f[R] BigInt(context.source);
  }
  \f[B]return\f[R] value;
});
\f[I]// { gross_gdp: 12345678901234567890n }\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Date.prototype.toJSON()\f[R]
.IP \[bu] 2
\c
.UR https://json-diff.com/
JSON Diff
.UE \c
.IP \[bu] 2
\c
.UR https://jsonbeautifier.org/
JSON Beautifier/editor
.UE \c
.IP \[bu] 2
\c
.UR https://jsonparser.org/
JSON Parser
.UE \c
.IP \[bu] 2
\c
.UR https://tools.learningcontainer.com/json-validator/
JSON Validator
.UE \c
