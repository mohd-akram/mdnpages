.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Window.getComputedStyle" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Window.getComputedStyle \- Window: getComputedStyle() method
.SH SYNOPSIS
The \f[B]\f[CB]Window.getComputedStyle()\f[B]\f[R] method returns an
object containing the values of all CSS properties of an element, after
applying active stylesheets and resolving any basic computation those
values may contain.
.PP
Individual CSS property values are accessed through APIs provided by the
object, or by indexing with CSS property names.
.SH SYNTAX
.IP
.EX
getComputedStyle(element)
getComputedStyle(element, pseudoElt)
.EE
.SS Parameters
.TP
\f[B]element\f[R]
The \f[CR]Element\f[R] for which to get the computed style.
.TP
\f[B]pseudoElt\f[R] \f[I](optional)\f[R]
A string specifying the pseudo\-element to match.
Omitted (or \f[CR]null\f[R]) for real elements.
.SS Return value
A \f[I]live\f[R] \f[CR]CSSStyleDeclaration\f[R] object, which updates
automatically when the element\[cq]s styles are changed.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
If the passed object is not an \f[CR]Element\f[R] or the
\f[CR]pseudoElt\f[R] is not a valid pseudo\-element selector or is
\f[CR]::part()\f[R] or \f[CR]::slotted()\f[R].
.RS
.RS
.PP
\f[B]Note:\f[R] Valid pseudo\-element selector refers to syntactic
validity, e.g.\ \f[CR]::unsupported\f[R] is considered valid, even
though the pseudo\-element itself is not supported.
Additionally, the latest W3 standard \c
.UR https://www.w3.org/TR/cssom-1/#dom-window-getcomputedstyle
explicitly supports
.UE \c
\ only \f[CR]::before\f[R] and \f[CR]::after\f[R], while the CSS WG
draft \c
.UR https://drafts.csswg.org/cssom/#dom-window-getcomputedstyle
does not restrict this value
.UE \c
\&.
Browser compatibility may vary.
.RE
.RE
.SH EXAMPLES
In this example we style a \f[CR]<p>\f[R] element, then retrieve those
styles using \f[CR]getComputedStyle()\f[R], and print them into the text
content of the \f[CR]<p>\f[R].
.SS HTML
.IP
.EX
<\f[B]p\f[R]>Hello</\f[B]p\f[R]>
.EE
.SS CSS
.IP
.EX
p {
  \f[B]width\f[R]: 400px;
  \f[B]margin\f[R]: 0 auto;
  \f[B]padding\f[R]: 20px;
  \f[B]font\f[R]: 2rem/2 sans\-serif;
  \f[B]text\-align\f[R]: center;
  \f[B]background\f[R]: purple;
  \f[B]color\f[R]: white;
}
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] para = document.querySelector(\[dq]p\[dq]);
\f[B]const\f[R] compStyles = window.getComputedStyle(para);
para.textContent =
  \[ga]My computed font\-size is ${compStyles.getPropertyValue(\[dq]font\-size\[dq])},\[rs]n\[ga] +
  \[ga]and my computed line\-height is ${compStyles.getPropertyValue(
    \[dq]line\-height\[dq],
  )}.\[ga];
.EE
.SS Result
.SH DESCRIPTION
The returned object is the same \f[CR]CSSStyleDeclaration\f[R] type as
the object returned from the element\[cq]s \f[CR]style\f[R] property.
However, the two objects have different purposes:
.IP \[bu] 2
The object from \f[CR]getComputedStyle\f[R] is read\-only, and should be
used to inspect the element\[cq]s style \[em] including those set by a
\f[CR]<style>\f[R] element or an external stylesheet.
.IP \[bu] 2
The \f[CR]element.style\f[R] object should be used to \f[B]set\f[R]
styles on that element, or inspect styles directly added to it from
JavaScript manipulation or the global \f[CR]style\f[R] attribute.
.PP
The first argument must be an \f[CR]Element\f[R].
Non\-elements, like a \f[CR]Text\f[R] node, will throw an error.
.SH DEFAULTVIEW
In many code samples, \f[CR]getComputedStyle\f[R] is used from the
\f[CR]document.defaultView\f[R] object.
In nearly all cases, this is needless, as \f[CR]getComputedStyle\f[R]
exists on the \f[CR]window\f[R] object as well.
It\[cq]s likely the \f[CR]defaultView\f[R] pattern was a combination of
folks not wanting to write a testing spec for \f[CR]window\f[R] and
making an API that was also usable in Java.
.SH USE WITH PSEUDO\-ELEMENTS
\f[CR]getComputedStyle\f[R] can pull style info from pseudo\-elements
(such as \f[CR]::after\f[R], \f[CR]::before\f[R], \f[CR]::marker\f[R],
\f[CR]::line\-marker\f[R] \[em] see \c
.UR https://www.w3.org/TR/css-pseudo-4/
the pseudo\-element spec
.UE \c
).
.IP
.EX
<\f[B]style\f[R]>
  h3\f[BI]::after\f[R] {
    \f[B]content\f[R]: \[dq] rocks!\[dq];
  }
</\f[B]style\f[R]>

<\f[B]h3\f[R]>Generated content</\f[B]h3\f[R]>

<\f[B]script\f[R]>
  \f[B]const\f[R] h3 = document.querySelector(\[dq]h3\[dq]);
  \f[B]const\f[R] result = getComputedStyle(h3, \[dq]:after\[dq]).content;

  console.log(\[dq]the generated content is: \[dq], result); \f[I]// returns \[aq] rocks!\[aq]\f[R]
</\f[B]script\f[R]>
.EE
.SH NOTES
.IP \[bu] 2
The returned \f[CR]CSSStyleDeclaration\f[R] object contains active
values for CSS property \f[B]\f[BI]longhand\f[B]\f[R] names as well as
shorthand names.
For example, the returned object contains entries for
\f[CR]border\-bottom\-width\f[R] in addition to the
\f[CR]border\-width\f[R] and \f[CR]border\f[R] shorthand property names.
You can query values with longhand names like \f[CR]font\-size\f[R] as
well as shorthand names like \f[CR]font\f[R].
.IP \[bu] 2
CSS property values may be accessed using the
\f[CR]getPropertyValue(propName)\f[R] method or by indexing directly
into the object using array or dot notation such as
\f[CR]obj[\[aq]z\-index\[aq]]\f[R] or \f[CR]obj.zIndex\f[R].
.IP \[bu] 2
The values returned by \f[CR]getComputedStyle\f[R] are resolved values.
These are usually the same as CSS 2.1\[cq]s computed values, but for
some older properties like \f[CR]width\f[R], \f[CR]height\f[R], or
\f[CR]padding\f[R], they are instead the same as used values.
Originally, CSS 2.0 defined the \f[I]computed values\f[R] as the
\[lq]ready to be used\[rq] final values of properties after cascading
and inheritance, but CSS 2.1 redefined them as pre\-layout, and
\f[I]used values\f[R] as post\-layout.
For CSS 2.0 properties, \f[CR]getComputedStyle\f[R] returns the old
meaning of computed values, now called \f[B]used values\f[R].
An example difference between pre\- and post\-layout values includes the
resolution of percentages for \f[CR]width\f[R] or \f[CR]height\f[R], as
those will be replaced by their pixel equivalent only for \f[I]used
values\f[R].
.IP \[bu] 2
Returned values are sometimes deliberately inaccurate.
To avoid the \[lq]CSS History Leak\[rq] security issue, browsers may lie
about the computed styles for a visited link, returning values as if the
user never visited the linked URL.
See \c
.UR https://blog.mozilla.org/security/2010/03/31/plugging-the-css-history-leak/
Plugging the CSS history leak
.UE \c
\ and \c
.UR https://hacks.mozilla.org/2010/03/privacy-related-changes-coming-to-css-vistited/
Privacy\-related changes coming to CSS \f[CR]:visited\f[R]
.UE \c
\ for examples of how this is implemented.
.IP \[bu] 2
During CSS transitions, \f[CR]getComputedStyle\f[R] returns the original
property value in Firefox, but the final property value in WebKit.
.IP \[bu] 2
In Firefox, properties with the value \f[CR]auto\f[R] return the used
value, not the value \f[CR]auto\f[R].
So if you apply \f[CR]top:auto\f[R] and \f[CR]bottom:0\f[R] on an
element with \f[CR]height:30px\f[R] and a containing block of
\f[CR]height:100px\f[R], Firefox\[cq]s computed style for \f[CR]top\f[R]
returns \f[CR]70px\f[R], as 100 âˆ’ 30 = 70.
.SH SEE ALSO
.IP \[bu] 2
\f[CR]window.getDefaultComputedStyle()\f[R]
.IP \[bu] 2
\f[CR]getPropertyValue()\f[R]
.IP \[bu] 2
Resolved value
