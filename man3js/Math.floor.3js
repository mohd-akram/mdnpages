.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "MATH.FLOOR" "3JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Math.floor \- Math.floor()
.SH SYNOPSIS
The \f[B]\f[CB]Math.floor()\f[B]\f[R] static method always rounds down
and returns the largest integer less than or equal to a given number.
.IP
.EX
console.log(Math.floor(5.95));
\f[I]// Expected output: 5\f[R]

console.log(Math.floor(5.05));
\f[I]// Expected output: 5\f[R]

console.log(Math.floor(5));
\f[I]// Expected output: 5\f[R]

console.log(Math.floor(\-5.05));
\f[I]// Expected output: \-6\f[R]
.EE
.SH SYNTAX
.IP
.EX
Math.floor(x)
.EE
.SS Parameters
.TP
\f[B]x\f[R]
A number.
.SS Return value
The largest integer smaller than or equal to \f[CR]x\f[R].
It\(cqs the same value as \f[CR]\-Math.ceil(\-x)\f[R].
.SH DESCRIPTION
Because \f[CR]floor()\f[R] is a static method of \f[CR]Math\f[R], you
always use it as \f[CR]Math.floor()\f[R], rather than as a method of a
\f[CR]Math\f[R] object you created (\f[CR]Math\f[R] is not a
constructor).
.SH EXAMPLES
.SS Using Math.floor()
.IP
.EX
Math.floor(\-\f[B]Infinity\f[R]); \f[I]// \-Infinity\f[R]
Math.floor(\-45.95); \f[I]// \-46\f[R]
Math.floor(\-45.05); \f[I]// \-46\f[R]
Math.floor(\-0); \f[I]// \-0\f[R]
Math.floor(0); \f[I]// 0\f[R]
Math.floor(4); \f[I]// 4\f[R]
Math.floor(45.05); \f[I]// 45\f[R]
Math.floor(45.95); \f[I]// 45\f[R]
Math.floor(\f[B]Infinity\f[R]); \f[I]// Infinity\f[R]
.EE
.SS Decimal adjustment
In this example, we implement a method called \f[CR]decimalAdjust()\f[R]
that is an enhancement method of \f[CR]Math.floor()\f[R],
\f[CR]Math.ceil()\f[R], and \f[CR]Math.round()\f[R].
While the three \f[CR]Math\f[R] functions always adjust the input to the
units digit, \f[CR]decimalAdjust\f[R] accepts an \f[CR]exp\f[R]
parameter that specifies the number of digits to the left of the decimal
point to which the number should be adjusted.
For example, \f[CR]\-1\f[R] means it would leave one digit after the
decimal point (as in \(lqÃ— 10\(ha\-1\(rq).
In addition, it allows you to select the means of adjustment \(em
\f[CR]round\f[R], \f[CR]floor\f[R], or \f[CR]ceil\f[R] \(em through the
\f[CR]type\f[R] parameter.
.PP
It does so by multiplying the number by a power of 10, then rounding the
result to the nearest integer, then dividing by the power of 10.
To better preserve precision, it takes advantage of Number\(cqs
\f[CR]toString()\f[R] method, which represents large or small numbers in
scientific notation (like \f[CR]6.02e23\f[R]).
.IP
.EX
\f[I]/**\f[R]
\f[I] * Adjusts a number to the specified digit.\f[R]
\f[I] *\f[R]
\f[I] * \f[R]\f[BI]\(atparam\f[R]\f[I] \f[R]\f[BI]{\(dqround\(dq\f[R]\f[I] | \(dqfloor\(dq | \(dqceil\(dq} type The type of adjustment.\f[R]
\f[I] * \f[R]\f[BI]\(atparam\f[R]\f[I] \f[R]\f[BI]{number}\f[R]\f[I] value The number.\f[R]
\f[I] * \f[R]\f[BI]\(atparam\f[R]\f[I] \f[R]\f[BI]{number}\f[R]\f[I] exp The exponent (the 10 logarithm of the adjustment base).\f[R]
\f[I] * \f[R]\f[BI]\(atreturns\f[R]\f[I] {number} The adjusted value.\f[R]
\f[I] */\f[R]
\f[B]function\f[R] decimalAdjust(type, value, exp) {
  type = String(type);
  \f[B]if\f[R] (![\(dqround\(dq, \(dqfloor\(dq, \(dqceil\(dq].includes(type)) {
    \f[B]throw\f[R] \f[B]new\f[R] TypeError(
      \(dqThe type of decimal adjustment must be one of \(aqround\(aq, \(aqfloor\(aq, or \(aqceil\(aq.\(dq,
    );
  }
  exp = Number(exp);
  value = Number(value);
  \f[B]if\f[R] (exp % 1 !== 0 || Number.isNaN(value)) {
    \f[B]return\f[R] \f[B]NaN\f[R];
  } \f[B]else\f[R] \f[B]if\f[R] (exp === 0) {
    \f[B]return\f[R] Math[type](value);
  }
  \f[B]const\f[R] [magnitude, exponent = 0] = value.toString().split(\(dqe\(dq);
  \f[B]const\f[R] adjustedValue = Math[type](\(ga${magnitude}e${exponent \- exp}\(ga);
  \f[I]// Shift back\f[R]
  \f[B]const\f[R] [newMagnitude, newExponent = 0] = adjustedValue.toString().split(\(dqe\(dq);
  \f[B]return\f[R] Number(\(ga${newMagnitude}e${+newExponent + exp}\(ga);
}

\f[I]// Decimal round\f[R]
\f[B]const\f[R] round10 = (value, exp) \f[B]=>\f[R] decimalAdjust(\(dqround\(dq, value, exp);
\f[I]// Decimal floor\f[R]
\f[B]const\f[R] floor10 = (value, exp) \f[B]=>\f[R] decimalAdjust(\(dqfloor\(dq, value, exp);
\f[I]// Decimal ceil\f[R]
\f[B]const\f[R] ceil10 = (value, exp) \f[B]=>\f[R] decimalAdjust(\(dqceil\(dq, value, exp);

\f[I]// Round\f[R]
round10(55.55, \-1); \f[I]// 55.6\f[R]
round10(55.549, \-1); \f[I]// 55.5\f[R]
round10(55, 1); \f[I]// 60\f[R]
round10(54.9, 1); \f[I]// 50\f[R]
round10(\-55.55, \-1); \f[I]// \-55.5\f[R]
round10(\-55.551, \-1); \f[I]// \-55.6\f[R]
round10(\-55, 1); \f[I]// \-50\f[R]
round10(\-55.1, 1); \f[I]// \-60\f[R]
\f[I]// Floor\f[R]
floor10(55.59, \-1); \f[I]// 55.5\f[R]
floor10(59, 1); \f[I]// 50\f[R]
floor10(\-55.51, \-1); \f[I]// \-55.6\f[R]
floor10(\-51, 1); \f[I]// \-60\f[R]
\f[I]// Ceil\f[R]
ceil10(55.51, \-1); \f[I]// 55.6\f[R]
ceil10(51, 1); \f[I]// 60\f[R]
ceil10(\-55.59, \-1); \f[I]// \-55.5\f[R]
ceil10(\-59, 1); \f[I]// \-50\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Math.abs()\f[R]
.IP \(bu 2
\f[CR]Math.ceil()\f[R]
.IP \(bu 2
\f[CR]Math.round()\f[R]
.IP \(bu 2
\f[CR]Math.sign()\f[R]
.IP \(bu 2
\f[CR]Math.trunc()\f[R]
