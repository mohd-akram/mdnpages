.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Promise" "JS" "June 9, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Promise \- Promise
.SH SYNOPSIS
The \f[B]\f[CB]Promise\f[B]\f[R] object represents the eventual
completion (or failure) of an asynchronous operation and its resulting
value.
.PP
To learn about the way promises work and how you can use them, we advise
you to read Using promises first.
.SH DESCRIPTION
A \f[CR]Promise\f[R] is a proxy for a value not necessarily known when
the promise is created.
It allows you to associate handlers with an asynchronous action\[cq]s
eventual success value or failure reason.
This lets asynchronous methods return values like synchronous methods:
instead of immediately returning the final value, the asynchronous
method returns a \f[I]promise\f[R] to supply the value at some point in
the future.
.PP
A \f[CR]Promise\f[R] is in one of these states:
.IP \[bu] 2
\f[I]pending\f[R]: initial state, neither fulfilled nor rejected.
.IP \[bu] 2
\f[I]fulfilled\f[R]: meaning that the operation was completed
successfully.
.IP \[bu] 2
\f[I]rejected\f[R]: meaning that the operation failed.
.PP
The \f[I]eventual state\f[R] of a pending promise can either be
\f[I]fulfilled\f[R] with a value or \f[I]rejected\f[R] with a reason
(error).
When either of these options occur, the associated handlers queued up by
a promise\[cq]s \f[CR]then\f[R] method are called.
If the promise has already been fulfilled or rejected when a
corresponding handler is attached, the handler will be called, so there
is no race condition between an asynchronous operation completing and
its handlers being attached.
.PP
A promise is said to be \f[I]settled\f[R] if it is either fulfilled or
rejected, but not pending.
[IMAGE: Flowchart showing how the Promise state transitions between
pending, fulfilled, and rejected via then/catch handlers.
A pending promise can become either fulfilled or rejected.
If fulfilled, the \[lq]on fulfillment\[rq] handler, or first parameter
of the then() method, is executed and carries out further asynchronous
actions.
If rejected, the error handler, either passed as the second parameter of
the then() method or as the sole parameter of the catch() method, gets
executed.]
Flowchart showing how the Promise state transitions between pending,
fulfilled, and rejected via then/catch handlers.
A pending promise can become either fulfilled or rejected.
If fulfilled, the \[lq]on fulfillment\[rq] handler, or first parameter
of the then() method, is executed and carries out further asynchronous
actions.
If rejected, the error handler, either passed as the second parameter of
the then() method or as the sole parameter of the catch() method, gets
executed.
.PP
You will also hear the term \f[I]resolved\f[R] used with promises \[em]
this means that the promise is settled or \[lq]locked\-in\[rq] to match
the eventual state of another promise, and further resolving or
rejecting it has no effect.
The \c
.UR https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md
States and fates
.UE \c
\ document from the original Promise proposal contains more details
about promise terminology.
Colloquially, \[lq]resolved\[rq] promises are often equivalent to
\[lq]fulfilled\[rq] promises, but as illustrated in \[lq]States and
fates\[rq], resolved promises can be pending or rejected as well.
For example:
.IP
.EX
\f[B]new\f[R] Promise((resolveOuter) \f[B]=>\f[R] {
  resolveOuter(
    \f[B]new\f[R] Promise((resolveInner) \f[B]=>\f[R] {
      setTimeout(resolveInner, 1000);
    }),
  );
});
.EE
.PP
This promise is already \f[I]resolved\f[R] at the time when it\[cq]s
created (because the \f[CR]resolveOuter\f[R] is called synchronously),
but it is resolved with another promise, and therefore won\[cq]t be
\f[I]fulfilled\f[R] until 1 second later, when the inner promise
fulfills.
In practice, the \[lq]resolution\[rq] is often done behind the scenes
and not observable, and only its fulfillment or rejection are.
.RS
.PP
\f[B]Note:\f[R] Several other languages have mechanisms for lazy
evaluation and deferring a computation, which they also call
\[lq]promises\[rq], e.g.\ Scheme.
Promises in JavaScript represent processes that are already happening,
which can be chained with callback functions.
If you are looking to lazily evaluate an expression, consider using a
function with no arguments e.g.\ \f[CR]f = () => expression\f[R] to
create the lazily\-evaluated expression, and \f[CR]f()\f[R] to evaluate
the expression immediately.
.RE
.PP
\f[CR]Promise\f[R] itself has no first\-class protocol for cancellation,
but you may be able to directly cancel the underlying asynchronous
operation, typically using \f[CR]AbortController\f[R].
.SS Chained Promises
The promise methods \f[CR]then()\f[R], \f[CR]catch()\f[R], and
\f[CR]finally()\f[R] are used to associate further action with a promise
that becomes settled.
The \f[CR]then()\f[R] method takes up to two arguments; the first
argument is a callback function for the fulfilled case of the promise,
and the second argument is a callback function for the rejected case.
The \f[CR]catch()\f[R] and \f[CR]finally()\f[R] methods call
\f[CR]then()\f[R] internally and make error handling less verbose.
For example, a \f[CR]catch()\f[R] is really just a \f[CR]then()\f[R]
without passing the fulfillment handler.
As these methods return promises, they can be chained.
For example:
.IP
.EX
\f[B]const\f[R] myPromise = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  setTimeout(() \f[B]=>\f[R] {
    resolve(\[dq]foo\[dq]);
  }, 300);
});

myPromise
  .then(handleFulfilledA, handleRejectedA)
  .then(handleFulfilledB, handleRejectedB)
  .then(handleFulfilledC, handleRejectedC);
.EE
.PP
We will use the following terminology: \f[I]initial promise\f[R] is the
promise on which \f[CR]then\f[R] is called; \f[I]new promise\f[R] is the
promise returned by \f[CR]then\f[R].
The two callbacks passed to \f[CR]then\f[R] are called \f[I]fulfillment
handler\f[R] and \f[I]rejection handler\f[R], respectively.
.PP
The settled state of the initial promise determines which handler to
execute.
.IP \[bu] 2
If the initial promise is fulfilled, the fulfillment handler is called
with the fulfillment value.
.IP \[bu] 2
If the initial promise is rejected, the rejection handler is called with
the rejection reason.
.PP
The completion of the handler function determines the settled state of
the new promise.
.IP \[bu] 2
If the handler function returns a thenable value, the new promise
settles in the same state as the returned promise.
.IP \[bu] 2
If the handler function returns a non\-thenable value, the new promise
is fulfilled with the returned value.
.IP \[bu] 2
If the handler function throws an error, the new promise is rejected
with the thrown error.
.IP \[bu] 2
If the initial promise has no corresponding handler attached, the new
promise will settle to the same state as the initial promise \[em] that
is, without a rejection handler, a rejected promise stays rejected with
the same reason.
.PP
For example, in the code above, if \f[CR]myPromise\f[R] rejects,
\f[CR]handleRejectedA\f[R] will be called, and if
\f[CR]handleRejectedA\f[R] completes normally (without throwing or
returning a rejected promise), the promise returned by the first
\f[CR]then\f[R] will be fulfilled instead of staying rejected.
Therefore, if an error must be handled immediately, but we want to
maintain the error state down the chain, we must throw an error of some
type in the rejection handler.
On the other hand, in the absence of an immediate need, it is simpler to
leave out error handling until the final \f[CR]catch()\f[R] handler.
.IP
.EX
myPromise
  .then(handleFulfilledA)
  .then(handleFulfilledB)
  .then(handleFulfilledC)
  .catch(handleRejectedAny);
.EE
.PP
Using arrow functions for the callback functions, implementation of the
promise chain might look something like this:
.IP
.EX
myPromise
  .then((value) \f[B]=>\f[R] \[ga]${value} and bar\[ga])
  .then((value) \f[B]=>\f[R] \[ga]${value} and bar again\[ga])
  .then((value) \f[B]=>\f[R] \[ga]${value} and again\[ga])
  .then((value) \f[B]=>\f[R] \[ga]${value} and again\[ga])
  .then((value) \f[B]=>\f[R] {
    console.log(value);
  })
  .catch((err) \f[B]=>\f[R] {
    console.error(err);
  });
.EE
.RS
.PP
\f[B]Note:\f[R] For faster execution, all synchronous actions should
preferably be done within one handler, otherwise it would take several
ticks to execute all handlers in sequence.
.RE
.PP
JavaScript maintains a job queue.
Each time, JavaScript picks a job from the queue and executes it to
completion.
The jobs are defined by the executor of the \f[CR]Promise()\f[R]
constructor, the handlers passed to \f[CR]then\f[R], or any platform API
that returns a promise.
The promises in a chain represent the dependency relationship between
these jobs.
When a promise settles, the respective handlers associated with it are
added to the back of the job queue.
.PP
A promise can participate in more than one chain.
For the following code, the fulfillment of \f[CR]promiseA\f[R] will
cause both \f[CR]handleFulfilled1\f[R] and \f[CR]handleFulfilled2\f[R]
to be added to the job queue.
Because \f[CR]handleFulfilled1\f[R] is registered first, it will be
invoked first.
.IP
.EX
\f[B]const\f[R] promiseA = \f[B]new\f[R] Promise(myExecutorFunc);
\f[B]const\f[R] promiseB = promiseA.then(handleFulfilled1, handleRejected1);
\f[B]const\f[R] promiseC = promiseA.then(handleFulfilled2, handleRejected2);
.EE
.PP
An action can be assigned to an already settled promise.
In this case, the action is added immediately to the back of the job
queue and will be performed when all existing jobs are completed.
Therefore, an action for an already \[lq]settled\[rq] promise will occur
only after the current synchronous code completes and at least one
loop\-tick has passed.
This guarantees that promise actions are asynchronous.
.IP
.EX
\f[B]const\f[R] promiseA = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  resolve(777);
});
\f[I]// At this point, \[dq]promiseA\[dq] is already settled.\f[R]
promiseA.then((val) \f[B]=>\f[R] console.log(\[dq]asynchronous logging has val:\[dq], val));
console.log(\[dq]immediate logging\[dq]);

\f[I]// produces output in this order:\f[R]
\f[I]// immediate logging\f[R]
\f[I]// asynchronous logging has val: 777\f[R]
.EE
.SS Thenables
The JavaScript ecosystem had made multiple Promise implementations long
before it became part of the language.
Despite being represented differently internally, at the minimum, all
Promise\-like objects implement the \f[I]Thenable\f[R] interface.
A thenable implements the \f[CR].then()\f[R] method, which is called
with two callbacks: one for when the promise is fulfilled, one for when
it\[cq]s rejected.
Promises are thenables as well.
.PP
To interoperate with the existing Promise implementations, the language
allows using thenables in place of promises.
For example, \f[CR]Promise.resolve\f[R] will not only resolve promises,
but also trace thenables.
.IP
.EX
\f[B]const\f[R] aThenable = {
  then(onFulfilled, onRejected) {
    onFulfilled({
      \f[I]// The thenable is fulfilled with another thenable\f[R]
      then(onFulfilled, onRejected) {
        onFulfilled(42);
      },
    });
  },
};

Promise.resolve(aThenable); \f[I]// A promise fulfilled with 42\f[R]
.EE
.SS Promise concurrency
The \f[CR]Promise\f[R] class offers four static methods to facilitate
async task \c
.UR https://en.wikipedia.org/wiki/Concurrent_computing
concurrency
.UE \c
:
.TP
\f[B]Promise.all()\f[R]
Fulfills when \f[B]all\f[R] of the promises fulfill; rejects when
\f[B]any\f[R] of the promises rejects.
.TP
\f[B]Promise.allSettled()\f[R]
Fulfills when \f[B]all\f[R] promises settle.
.TP
\f[B]Promise.any()\f[R]
Fulfills when \f[B]any\f[R] of the promises fulfills; rejects when
\f[B]all\f[R] of the promises reject.
.TP
\f[B]Promise.race()\f[R]
Settles when \f[B]any\f[R] of the promises settles.
In other words, fulfills when any of the promises fulfills; rejects when
any of the promises rejects.
.PP
All these methods take an iterable of promises (thenables, to be exact)
and return a new promise.
They all support subclassing, which means they can be called on
subclasses of \f[CR]Promise\f[R], and the result will be a promise of
the subclass type.
To do so, the subclass\[cq]s constructor must implement the same
signature as the \f[CR]Promise()\f[R] constructor \[em] accepting a
single \f[CR]executor\f[R] function that can be called with the
\f[CR]resolve\f[R] and \f[CR]reject\f[R] callbacks as parameters.
The subclass must also have a \f[CR]resolve\f[R] static method that can
be called like \f[CR]Promise.resolve()\f[R] to resolve values to
promises.
.PP
Note that JavaScript is single\-threaded by nature, so at a given
instant, only one task will be executing, although control can shift
between different promises, making execution of the promises appear
concurrent.
\c
.UR https://en.wikipedia.org/wiki/Parallel_computing
Parallel execution
.UE \c
\ in JavaScript can only be achieved through worker threads.
.SH CONSTRUCTOR
.TP
\f[B]Promise()\f[R]
Creates a new \f[CR]Promise\f[R] object.
The constructor is primarily used to wrap functions that do not already
support promises.
.SH STATIC PROPERTIES
.TP
\f[B]Promise[\[at]\[at]species]\f[R]
Returns the constructor used to construct return values from promise
methods.
.SH STATIC METHODS
.TP
\f[B]Promise.all()\f[R]
Takes an iterable of promises as input and returns a single
\f[CR]Promise\f[R].
This returned promise fulfills when all of the input\[cq]s promises
fulfill (including when an empty iterable is passed), with an array of
the fulfillment values.
It rejects when any of the input\[cq]s promises reject, with this first
rejection reason.
.TP
\f[B]Promise.allSettled()\f[R]
Takes an iterable of promises as input and returns a single
\f[CR]Promise\f[R].
This returned promise fulfills when all of the input\[cq]s promises
settle (including when an empty iterable is passed), with an array of
objects that describe the outcome of each promise.
.TP
\f[B]Promise.any()\f[R]
Takes an iterable of promises as input and returns a single
\f[CR]Promise\f[R].
This returned promise fulfills when any of the input\[cq]s promises
fulfill, with this first fulfillment value.
It rejects when all of the input\[cq]s promises reject (including when
an empty iterable is passed), with an \f[CR]AggregateError\f[R]
containing an array of rejection reasons.
.TP
\f[B]Promise.race()\f[R]
Takes an iterable of promises as input and returns a single
\f[CR]Promise\f[R].
This returned promise settles with the eventual state of the first
promise that settles.
.TP
\f[B]Promise.reject()\f[R]
Returns a new \f[CR]Promise\f[R] object that is rejected with the given
reason.
.TP
\f[B]Promise.resolve()\f[R]
Returns a \f[CR]Promise\f[R] object that is resolved with the given
value.
If the value is a thenable (i.e.\ has a \f[CR]then\f[R] method), the
returned promise will \[lq]follow\[rq] that thenable, adopting its
eventual state; otherwise, the returned promise will be fulfilled with
the value.
.TP
\f[B]Promise.withResolvers()\f[R]
Returns an object containing a new \f[CR]Promise\f[R] object and two
functions to resolve or reject it, corresponding to the two parameters
passed to the executor of the \f[CR]Promise()\f[R] constructor.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]Promise.prototype\f[R] and shared
by all \f[CR]Promise\f[R] instances.
.TP
\f[B]Promise.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]Promise\f[R] instances, the initial value is the
\f[CR]Promise\f[R] constructor.
.TP
\f[B]Promise.prototype[\[at]\[at]toStringTag]\f[R]
The initial value of the \f[CR]\[at]\[at]toStringTag\f[R] property is
the string \f[CR]\[dq]Promise\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH INSTANCE METHODS
.TP
\f[B]Promise.prototype.catch()\f[R]
Appends a rejection handler callback to the promise, and returns a new
promise resolving to the return value of the callback if it is called,
or to its original fulfillment value if the promise is instead
fulfilled.
.TP
\f[B]Promise.prototype.finally()\f[R]
Appends a handler to the promise, and returns a new promise that is
resolved when the original promise is resolved.
The handler is called when the promise is settled, whether fulfilled or
rejected.
.TP
\f[B]Promise.prototype.then()\f[R]
Appends fulfillment and rejection handlers to the promise, and returns a
new promise resolving to the return value of the called handler, or to
its original settled value if the promise was not handled (i.e.\ if the
relevant handler \f[CR]onFulfilled\f[R] or \f[CR]onRejected\f[R] is not
a function).
.SH EXAMPLES
.SS Basic Example
.IP
.EX
\f[B]const\f[R] myFirstPromise = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  \f[I]// We call resolve(...) when what we were doing asynchronously was successful, and reject(...) when it failed.\f[R]
  \f[I]// In this example, we use setTimeout(...) to simulate async code.\f[R]
  \f[I]// In reality, you will probably be using something like XHR or an HTML API.\f[R]
  setTimeout(() \f[B]=>\f[R] {
    resolve(\[dq]Success!\[dq]); \f[I]// Yay! Everything went well!\f[R]
  }, 250);
});

myFirstPromise.then((successMessage) \f[B]=>\f[R] {
  \f[I]// successMessage is whatever we passed in the resolve(...) function above.\f[R]
  \f[I]// It doesn\[aq]t have to be a string, but if it is only a succeed message, it probably will be.\f[R]
  console.log(\[ga]Yay! ${successMessage}\[ga]);
});
.EE
.SS Example with diverse situations
This example shows diverse techniques for using Promise capabilities and
diverse situations that can occur.
To understand this, start by scrolling to the bottom of the code block,
and examine the promise chain.
Upon provision of an initial promise, a chain of promises can follow.
The chain is composed of \f[CR].then()\f[R] calls, and typically (but
not necessarily) has a single \f[CR].catch()\f[R] at the end, optionally
followed by \f[CR].finally()\f[R].
In this example, the promise chain is initiated by a custom\-written
\f[CR]new Promise()\f[R] construct; but in actual practice, promise
chains more typically start with an API function (written by someone
else) that returns a promise.
.PP
The example function \f[CR]tetheredGetNumber()\f[R] shows that a promise
generator will utilize \f[CR]reject()\f[R] while setting up an
asynchronous call, or within the call\-back, or both.
The function \f[CR]promiseGetWord()\f[R] illustrates how an API function
might generate and return a promise in a self\-contained manner.
.PP
Note that the function \f[CR]troubleWithGetNumber()\f[R] ends with a
\f[CR]throw\f[R].
That is forced because a promise chain goes through all the
\f[CR].then()\f[R] promises, even after an error, and without the
\f[CR]throw\f[R], the error would seem \[lq]fixed\[rq].
This is a hassle, and for this reason, it is common to omit
\f[CR]onRejected\f[R] throughout the chain of \f[CR].then()\f[R]
promises, and just have a single \f[CR]onRejected\f[R] in the final
\f[CR]catch()\f[R].
.PP
This code can be run under NodeJS.
Comprehension is enhanced by seeing the errors actually occur.
To force more errors, change the \f[CR]threshold\f[R] values.
.IP
.EX
\f[I]// To experiment with error handling, \[dq]threshold\[dq] values cause errors randomly\f[R]
\f[B]const\f[R] THRESHOLD_A = 8; \f[I]// can use zero 0 to guarantee error\f[R]

\f[B]function\f[R] tetheredGetNumber(resolve, reject) {
  setTimeout(() \f[B]=>\f[R] {
    \f[B]const\f[R] randomInt = Date.now();
    \f[B]const\f[R] value = randomInt % 10;
    \f[B]if\f[R] (value < THRESHOLD_A) {
      resolve(value);
    } \f[B]else\f[R] {
      reject(\[ga]Too large: ${value}\[ga]);
    }
  }, 500);
}

\f[B]function\f[R] determineParity(value) {
  \f[B]const\f[R] isOdd = value % 2 === 1;
  \f[B]return\f[R] { value, isOdd };
}

\f[B]function\f[R] troubleWithGetNumber(reason) {
  \f[B]const\f[R] err = \f[B]new\f[R] Error(\[dq]Trouble getting number\[dq], { cause: reason });
  console.error(err);
  \f[B]throw\f[R] err;
}

\f[B]function\f[R] promiseGetWord(parityInfo) {
  \f[B]return\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
    \f[B]const\f[R] { value, isOdd } = parityInfo;
    \f[B]if\f[R] (value >= THRESHOLD_A \- 1) {
      reject(\[ga]Still too large: ${value}\[ga]);
    } \f[B]else\f[R] {
      parityInfo.wordEvenOdd = isOdd ? \[dq]odd\[dq] : \[dq]even\[dq];
      resolve(parityInfo);
    }
  });
}

\f[B]new\f[R] Promise(tetheredGetNumber)
  .then(determineParity, troubleWithGetNumber)
  .then(promiseGetWord)
  .then((info) \f[B]=>\f[R] {
    console.log(\[ga]Got: ${info.value}, ${info.wordEvenOdd}\[ga]);
    \f[B]return\f[R] info;
  })
  .catch((reason) \f[B]=>\f[R] {
    \f[B]if\f[R] (reason.cause) {
      console.error(\[dq]Had previously handled error\[dq]);
    } \f[B]else\f[R] {
      console.error(\[ga]Trouble with promiseGetWord(): ${reason}\[ga]);
    }
  })
  .finally((info) \f[B]=>\f[R] console.log(\[dq]All done\[dq]));
.EE
.SS Advanced Example
This small example shows the mechanism of a \f[CR]Promise\f[R].
The \f[CR]testPromise()\f[R] method is called each time the
\f[CR]<button>\f[R] is clicked.
It creates a promise that will be fulfilled, using
\f[CR]setTimeout()\f[R], to the promise count (number starting from 1)
every 1\-3 seconds, at random.
The \f[CR]Promise()\f[R] constructor is used to create the promise.
.PP
The fulfillment of the promise is logged, via a fulfill callback set
using \f[CR]p1.then()\f[R].
A few logs show how the synchronous part of the method is decoupled from
the asynchronous completion of the promise.
.PP
By clicking the button several times in a short amount of time,
you\[cq]ll even see the different promises being fulfilled one after
another.
.SS HTML
.IP
.EX
<\f[B]button\f[R] id=\[dq]make\-promise\[dq]>Make a promise!</\f[B]button\f[R]>
<\f[B]div\f[R] id=\[dq]log\[dq]></\f[B]div\f[R]>
.EE
.SS JavaScript
.IP
.EX
\[dq]use strict\[dq];

\f[B]let\f[R] promiseCount = 0;

\f[B]function\f[R] testPromise() {
  \f[B]const\f[R] thisPromiseCount = ++promiseCount;
  \f[B]const\f[R] log = document.getElementById(\[dq]log\[dq]);
  \f[I]// begin\f[R]
  log.insertAdjacentHTML(\[dq]beforeend\[dq], \[ga]${thisPromiseCount}) Started<br>\[ga]);
  \f[I]// We make a new promise: we promise a numeric count of this promise,\f[R]
  \f[I]// starting from 1 (after waiting 3s)\f[R]
  \f[B]const\f[R] p1 = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
    \f[I]// The executor function is called with the ability\f[R]
    \f[I]// to resolve or reject the promise\f[R]
    log.insertAdjacentHTML(
      \[dq]beforeend\[dq],
      \[ga]${thisPromiseCount}) Promise constructor<br>\[ga],
    );
    \f[I]// This is only an example to create asynchronism\f[R]
    setTimeout(
      () \f[B]=>\f[R] {
        \f[I]// We fulfill the promise\f[R]
        resolve(thisPromiseCount);
      },
      Math.random() * 2000 + 1000,
    );
  });

  \f[I]// We define what to do when the promise is resolved with the then() call,\f[R]
  \f[I]// and what to do when the promise is rejected with the catch() call\f[R]
  p1.then((val) \f[B]=>\f[R] {
    \f[I]// Log the fulfillment value\f[R]
    log.insertAdjacentHTML(\[dq]beforeend\[dq], \[ga]${val}) Promise fulfilled<br>\[ga]);
  }).catch((reason) \f[B]=>\f[R] {
    \f[I]// Log the rejection reason\f[R]
    console.log(\[ga]Handle rejected promise (${reason}) here.\[ga]);
  });
  \f[I]// end\f[R]
  log.insertAdjacentHTML(\[dq]beforeend\[dq], \[ga]${thisPromiseCount}) Promise made<br>\[ga]);
}

\f[B]const\f[R] btn = document.getElementById(\[dq]make\-promise\[dq]);
btn.addEventListener(\[dq]click\[dq], testPromise);
.EE
.SS Result
.SS Loading an image with XHR
Another simple example using \f[CR]Promise\f[R] and
\f[CR]XMLHttpRequest\f[R] to load an image is available at the MDN
GitHub \c
.UR https://github.com/mdn/js-examples/tree/main/promises-test
js\-examples
.UE \c
\ repository.
You can also \c
.UR https://mdn.github.io/js-examples/promises-test/
see it in action
.UE \c
\&.
Each step is commented on and allows you to follow the Promise and XHR
architecture closely.
.SS Incumbent settings object tracking
A settings object is an \c
.UR https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object
environment
.UE \c
\ that provides additional information when JavaScript code is running.
This includes the realm and module map, as well as HTML specific
information such as the origin.
The incumbent settings object is tracked in order to ensure that the
browser knows which one to use for a given piece of user code.
.PP
To better picture this, we can take a closer look at how the realm might
be an issue.
A \f[B]realm\f[R] can be roughly thought of as the global object.
What is unique about realms is that they hold all of the necessary
information to run JavaScript code.
This includes objects like \f[CR]Array\f[R] and \f[CR]Error\f[R].
Each settings object has its own \[lq]copy\[rq] of these and they are
not shared.
That can cause some unexpected behavior in relation to promises.
In order to get around this, we track something called the
\f[B]incumbent settings object\f[R].
This represents information specific to the context of the user code
responsible for a certain function call.
.PP
To illustrate this a bit further we can take a look at how an
\f[CR]<iframe>\f[R] embedded in a document communicates with its host.
Since all web APIs are aware of the incumbent settings object, the
following will work in all browsers:
.IP
.EX
<!doctype html> <\f[B]iframe\f[R]></\f[B]iframe\f[R]>
\f[I]<!\-\- we have a realm here \-\->\f[R]
<\f[B]script\f[R]>
  \f[I]// we have a realm here as well\f[R]
  \f[B]const\f[R] bound = frames[0].postMessage.bind(frames[0], \[dq]some data\[dq], \[dq]*\[dq]);
  \f[I]// bound is a built\-in function \[em] there is no user\f[R]
  \f[I]// code on the stack, so which realm do we use?\f[R]
  setTimeout(bound);
  \f[I]// this still works, because we use the youngest\f[R]
  \f[I]// realm (the incumbent) on the stack\f[R]
</\f[B]script\f[R]>
.EE
.PP
The same concept applies to promises.
If we modify the above example a little bit, we get this:
.IP
.EX
<!doctype html> <\f[B]iframe\f[R]></\f[B]iframe\f[R]>
\f[I]<!\-\- we have a realm here \-\->\f[R]
<\f[B]script\f[R]>
  \f[I]// we have a realm here as well\f[R]
  \f[B]const\f[R] bound = frames[0].postMessage.bind(frames[0], \[dq]some data\[dq], \[dq]*\[dq]);
  \f[I]// bound is a built in function \[em] there is no user\f[R]
  \f[I]// code on the stack \[em] which realm do we use?\f[R]
  Promise.resolve(\f[B]undefined\f[R]).then(bound);
  \f[I]// this still works, because we use the youngest\f[R]
  \f[I]// realm (the incumbent) on the stack\f[R]
</\f[B]script\f[R]>
.EE
.PP
If we change this so that the \f[CR]<iframe>\f[R] in the document is
listening to post messages, we can observe the effect of the incumbent
settings object:
.IP
.EX
\f[I]<!\-\- y.html \-\->\f[R]
<!doctype html>
<\f[B]iframe\f[R] src=\[dq]x.html\[dq]></\f[B]iframe\f[R]>
<\f[B]script\f[R]>
  \f[B]const\f[R] bound = frames[0].postMessage.bind(frames[0], \[dq]some data\[dq], \[dq]*\[dq]);
  Promise.resolve(\f[B]undefined\f[R]).then(bound);
</\f[B]script\f[R]>
.EE
.IP
.EX
\f[I]<!\-\- x.html \-\->\f[R]
<!doctype html>
<\f[B]script\f[R]>
  window.addEventListener(
    \[dq]message\[dq],
    (event) \f[B]=>\f[R] {
      document.querySelector(\[dq]#text\[dq]).textContent = \[dq]hello\[dq];
      \f[I]// this code will only run in browsers that track the incumbent settings object\f[R]
      console.log(event);
    },
    \f[B]false\f[R],
  );
</\f[B]script\f[R]>
.EE
.PP
In the above example, the inner text of the \f[CR]<iframe>\f[R] will be
updated only if the incumbent settings object is tracked.
This is because without tracking the incumbent, we may end up using the
wrong environment to send the message.
.RS
.PP
\f[B]Note:\f[R] Currently, incumbent realm tracking is fully implemented
in Firefox, and has partial implementations in Chrome and Safari.
.RE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-promise
Polyfill of \f[CR]Promise\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Using promises guide
.IP \[bu] 2
\c
.UR https://promisesaplus.com/
Promises/A+ specification
.UE \c
.IP \[bu] 2
\c
.UR https://web.dev/articles/promises
JavaScript Promises: an introduction
.UE \c
\ on web.dev (2013)
.IP \[bu] 2
\c
.UR https://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript
Callbacks, Promises, and Coroutines: Asynchronous Programming Patterns
in JavaScript
.UE \c
\ slide show by Domenic Denicola (2011)
