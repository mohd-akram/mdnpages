.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "RegExp.\[at]\[at]matchAll" "JS" "September 12, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RegExp.\[at]\[at]matchAll - RegExp.prototype\[at]\[at]matchAll
.SH SYNOPSIS
The \f[B]\f[CB][\[at]\[at]matchAll]()\f[B]\f[R] method of
\f[CR]RegExp\f[R] instances specifies how
\f[CR]String.prototype.matchAll\f[R] should behave.
.SH SYNTAX
.IP
.EX
regexp[Symbol.matchAll](str)
.EE
.SS Parameters
.TP
\f[B]str\f[R]
A \f[CR]String\f[R] that is a target of the match.
.SS Return value
An iterable iterator object (which is not restartable) of matches.
Each match is an array with the same shape as the return value of
\f[CR]RegExp.prototype.exec()\f[R].
.SH DESCRIPTION
This method is called internally in
\f[CR]String.prototype.matchAll()\f[R].
For example, the following two examples return the same result.
.IP
.EX
\[dq]abc\[dq].matchAll(/a/g);

/a/g[Symbol.matchAll](\[dq]abc\[dq]);
.EE
.PP
Like \f[CR]\[at]\[at]split\f[R], \f[CR]\[at]\[at]matchAll\f[R] starts by
using \f[CR]\[at]\[at]species\f[R] to construct a new regex, thus
avoiding mutating the original regexp in any way.
\f[CR]lastIndex\f[R] starts as the original regex\[cq]s value.
.IP
.EX
const regexp = /[a-c]/g;
regexp.lastIndex = 1;
const str = \[dq]abc\[dq];
Array.from(str.matchAll(regexp), (m) => \[ga]${regexp.lastIndex} ${m[0]}\[ga]);
// [ \[dq]1 b\[dq], \[dq]1 c\[dq] ]
.EE
.PP
The validation that the input is a global regex happens in
\f[CR]String.prototype.matchAll()\f[R].
\f[CR]\[at]\[at]matchAll\f[R] does not validate the input.
If the regex is not global, the returned iterator yields the
\f[CR]exec()\f[R] result once and then returns \f[CR]undefined\f[R].
If the regexp is global, each time the returned iterator\[cq]s
\f[CR]next()\f[R] method is called, the regex\[cq]s \f[CR]exec()\f[R] is
called and the result is yielded.
.PP
When the regex is sticky and global, it will still perform sticky
matches \[em] i.e.\ it will not match any occurrences beyond the
\f[CR]lastIndex\f[R].
.IP
.EX
console.log(Array.from(\[dq]ab-c\[dq].matchAll(/[abc]/gy)));
// [ [ \[dq]a\[dq] ], [ \[dq]b\[dq] ] ]
.EE
.PP
If the current match is an empty string, the \f[CR]lastIndex\f[R] will
still be advanced.
If the regex has the \f[CR]u\f[R] flag, it advances by one Unicode code
point; otherwise, it advances by one UTF-16 code point.
.IP
.EX
console.log(Array.from(\[dq]ðŸ˜„\[dq].matchAll(/(?:)/g)));
// [ [ \[dq]\[dq] ], [ \[dq]\[dq] ], [ \[dq]\[dq] ] ]

console.log(Array.from(\[dq]ðŸ˜„\[dq].matchAll(/(?:)/gu)));
// [ [ \[dq]\[dq] ], [ \[dq]\[dq] ] ]
.EE
.PP
This method exists for customizing the behavior of \f[CR]matchAll()\f[R]
in \f[CR]RegExp\f[R] subclasses.
.SH EXAMPLES
.SS Direct call
This method can be used in almost the same way as
\f[CR]String.prototype.matchAll()\f[R], except for the different value
of \f[CR]this\f[R] and the different order of arguments.
.IP
.EX
const re = /[0-9]+/g;
const str = \[dq]2016-01-02\[dq];
const result = re[Symbol.matchAll](str);

console.log(Array.from(result, (x) => x[0]));
// [ \[dq]2016\[dq], \[dq]01\[dq], \[dq]02\[dq] ]
.EE
.SS Using \[at]\[at]matchAll in subclasses
Subclasses of \f[CR]RegExp\f[R] can override the
\f[CR][\[at]\[at]matchAll]()\f[R] method to modify the default behavior.
.PP
For example, to return an \f[CR]Array\f[R] instead of an iterator:
.IP
.EX
class MyRegExp extends RegExp {
  [Symbol.matchAll](str) {
    const result = RegExp.prototype[Symbol.matchAll].call(this, str);
    return result ? Array.from(result) : null;
  }
}

const re = new MyRegExp(\[dq]([0-9]+)-([0-9]+)-([0-9]+)\[dq], \[dq]g\[dq]);
const str = \[dq]2016-01-02|2019-03-07\[dq];
const result = str.matchAll(re);

console.log(result[0]);
// [ \[dq]2016-01-02\[dq], \[dq]2016\[dq], \[dq]01\[dq], \[dq]02\[dq] ]

console.log(result[1]);
// [ \[dq]2019-03-07\[dq], \[dq]2019\[dq], \[dq]03\[dq], \[dq]07\[dq] ]
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]RegExp.prototype[\[at]\[at]matchAll]\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
\f[CR]String.prototype.matchAll()\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype[\[at]\[at]match]()\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype[\[at]\[at]replace]()\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype[\[at]\[at]search]()\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype[\[at]\[at]split]()\f[R]
.IP \[bu] 2
\f[CR]Symbol.matchAll\f[R]
