.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "SubtleCrypto.deriveKey" "JS" "October 9, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SubtleCrypto.deriveKey \- SubtleCrypto: deriveKey() method
.SH SYNOPSIS
\f[B]Secure context\f[R]: This feature is available only in secure
contexts (HTTPS).
.PP
The \f[B]\f[CB]deriveKey()\f[B]\f[R] method of the
\f[CR]SubtleCrypto\f[R] interface can be used to derive a secret key
from a master key.
.PP
It takes as arguments some initial key material, the derivation
algorithm to use, and the desired properties for the key to derive.
It returns a \f[CR]Promise\f[R] which will be fulfilled with a
\f[CR]CryptoKey\f[R] object representing the new key.
.PP
It\[cq]s worth noting that the three key derivation algorithms you can
use have quite different characteristics and are appropriate in quite
different situations.
See Supported algorithms for some more detail on this.
.SH SYNTAX
.IP
.EX
deriveKey(algorithm, baseKey, derivedKeyAlgorithm, extractable, keyUsages)
.EE
.SS Parameters
.TP
\f[B]algorithm\f[R]
An object defining the derivation algorithm to use.
.RS
.IP \[bu] 2
To use ECDH, pass an \f[CR]EcdhKeyDeriveParams\f[R] object.
.IP \[bu] 2
To use HKDF, pass an \f[CR]HkdfParams\f[R] object.
.IP \[bu] 2
To use PBKDF2, pass a \f[CR]Pbkdf2Params\f[R] object.
.RE
.TP
\f[B]baseKey\f[R]
A \f[CR]CryptoKey\f[R] representing the input to the derivation
algorithm.
If \f[CR]algorithm\f[R] is ECDH, then this will be the ECDH private key.
Otherwise it will be the initial key material for the derivation
function: for example, for PBKDF2 it might be a password, imported as a
\f[CR]CryptoKey\f[R] using \f[CR]SubtleCrypto.importKey()\f[R].
.TP
\f[B]derivedKeyAlgorithm\f[R]
An object defining the algorithm the derived key will be used for:
.RS
.IP \[bu] 2
For HMAC pass an \f[CR]HmacKeyGenParams\f[R] object.
.IP \[bu] 2
For AES\-CTR, AES\-CBC, AES\-GCM, or AES\-KW, pass an
\f[CR]AesKeyGenParams\f[R] object.
.IP \[bu] 2
For HKDF, pass an \f[CR]HkdfParams\f[R] object.
.IP \[bu] 2
For PBKDF2, pass a \f[CR]Pbkdf2Params\f[R] object.
.RE
.TP
\f[B]extractable\f[R]
A boolean value indicating whether it will be possible to export the key
using \f[CR]SubtleCrypto.exportKey()\f[R] or
\f[CR]SubtleCrypto.wrapKey()\f[R].
.TP
\f[B]keyUsages\f[R]
An \f[CR]Array\f[R] indicating what can be done with the derived key.
Note that the key usages must be allowed by the algorithm set in
\f[CR]derivedKeyAlgorithm\f[R].
Possible values of the array are:
.RS
.IP \[bu] 2
\f[CR]encrypt\f[R]: The key may be used to \f[CR]encrypt\f[R] messages.
.IP \[bu] 2
\f[CR]decrypt\f[R]: The key may be used to \f[CR]decrypt\f[R] messages.
.IP \[bu] 2
\f[CR]sign\f[R]: The key may be used to \f[CR]sign\f[R] messages.
.IP \[bu] 2
\f[CR]verify\f[R]: The key may be used to \f[CR]verify\f[R] signatures.
.IP \[bu] 2
\f[CR]deriveKey\f[R]: The key may be used in
\f[CR]deriving a new key\f[R].
.IP \[bu] 2
\f[CR]deriveBits\f[R]: The key may be used in \f[CR]deriving bits\f[R].
.IP \[bu] 2
\f[CR]wrapKey\f[R]: The key may be used to \f[CR]wrap a key\f[R].
.IP \[bu] 2
\f[CR]unwrapKey\f[R]: The key may be used to \f[CR]unwrap a key\f[R].
.RE
.SS Return value
A \f[CR]Promise\f[R] that fulfills with a \f[CR]CryptoKey\f[R].
.SS Exceptions
The promise is rejected when one of the following exceptions are
encountered:
.TP
\f[B]InvalidAccessError\f[R] \f[B]DOMException\f[R]
Raised when the master key is not a key for the requested derivation
algorithm or if the \f[CR]keyUsages\f[R] value of that key doesn\[cq]t
contain \f[CR]deriveKey\f[R].
.TP
\f[B]NotSupported\f[R] \f[B]DOMException\f[R]
Raised when trying to use an algorithm that is either unknown or
isn\[cq]t suitable for derivation, or if the algorithm requested for the
derived key doesn\[cq]t define a key length.
.TP
\f[B]SyntaxError\f[R] \f[B]DOMException\f[R]
Raised when \f[CR]keyUsages\f[R] is empty but the unwrapped key is of
type \f[CR]secret\f[R] or \f[CR]private\f[R].
.SH SUPPORTED ALGORITHMS
The three algorithms supported by \f[CR]deriveKey()\f[R] have quite
different characteristics and are appropriate in different situations.
.SS ECDH
ECDH (Elliptic Curve Diffie\-Hellman) is a \f[I]key\-agreement
algorithm\f[R].
It enables two people who each have an ECDH public/private key pair to
generate a shared secret: that is, a secret that they \[em] and no one
else \[em] share.
They can then use this shared secret as a symmetric key to secure their
communication, or can use the secret as an input to derive such a key
(for example, using the HKDF algorithm).
.PP
ECDH is specified in \c
.UR https://datatracker.ietf.org/doc/html/rfc6090
RFC 6090
.UE \c
\&.
.SS HKDF
HKDF is a \f[I]key derivation function\f[R].
It\[cq]s designed to derive key material from some high\-entropy input,
such as the output of an ECDH key agreement operation.
.PP
It\[cq]s \f[I]not\f[R] designed to derive keys from relatively
low\-entropy inputs such as passwords.
For that, use PBKDF2.
.PP
HKDF is specified in \c
.UR https://datatracker.ietf.org/doc/html/rfc5869
RFC 5869
.UE \c
\&.
.SS PBKDF2
PBKDF2 is also a \f[I]key derivation function\f[R].
It\[cq]s designed to derive key material from some relatively
low\-entropy input, such as a password.
It derives key material by applying a function such as HMAC to the input
password along with some salt, and repeating this process many times.
The more times the process is repeated, the more computationally
expensive key derivation is: this makes it harder for an attacker to use
brute\-force to discover the key using a dictionary attack.
.PP
PBKDF2 is specified in \c
.UR https://datatracker.ietf.org/doc/html/rfc2898
RFC 2898
.UE \c
\&.
.SH EXAMPLES
.RS
.PP
\f[B]Note:\f[R] You can \c
.UR https://mdn.github.io/dom-examples/web-crypto/derive-key/index.html
try the working examples
.UE \c
\ on GitHub.
.RE
.SS ECDH
In this example Alice and Bob each generate an ECDH key pair, then
exchange public keys.
They then use \f[CR]deriveKey()\f[R] to derive a shared AES key, that
they could use to encrypt messages.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/derive-key/ecdh.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[I]/*\f[R]
\f[I]Derive an AES key, given:\f[R]
\f[I]\- our ECDH private key\f[R]
\f[I]\- their ECDH public key\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] deriveSecretKey(privateKey, publicKey) {
  \f[B]return\f[R] window.crypto.subtle.deriveKey(
    {
      name: \[dq]ECDH\[dq],
      public: publicKey,
    },
    privateKey,
    {
      name: \[dq]AES\-GCM\[dq],
      length: 256,
    },
    \f[B]false\f[R],
    [\[dq]encrypt\[dq], \[dq]decrypt\[dq]],
  );
}

\f[B]async\f[R] \f[B]function\f[R] agreeSharedSecretKey() {
  \f[I]// Generate 2 ECDH key pairs: one for Alice and one for Bob\f[R]
  \f[I]// In more normal usage, they would generate their key pairs\f[R]
  \f[I]// separately and exchange public keys securely\f[R]
  \f[B]let\f[R] alicesKeyPair = \f[B]await\f[R] window.crypto.subtle.generateKey(
    {
      name: \[dq]ECDH\[dq],
      namedCurve: \[dq]P\-384\[dq],
    },
    \f[B]false\f[R],
    [\[dq]deriveKey\[dq]],
  );

  \f[B]let\f[R] bobsKeyPair = \f[B]await\f[R] window.crypto.subtle.generateKey(
    {
      name: \[dq]ECDH\[dq],
      namedCurve: \[dq]P\-384\[dq],
    },
    \f[B]false\f[R],
    [\[dq]deriveKey\[dq]],
  );

  \f[I]// Alice then generates a secret key using her private key and Bob\[aq]s public key.\f[R]
  \f[B]let\f[R] alicesSecretKey = \f[B]await\f[R] deriveSecretKey(
    alicesKeyPair.privateKey,
    bobsKeyPair.publicKey,
  );

  \f[I]// Bob generates the same secret key using his private key and Alice\[aq]s public key.\f[R]
  \f[B]let\f[R] bobsSecretKey = \f[B]await\f[R] deriveSecretKey(
    bobsKeyPair.privateKey,
    alicesKeyPair.publicKey,
  );

  \f[I]// Alice can then use her copy of the secret key to encrypt a message to Bob.\f[R]
  \f[B]let\f[R] encryptButton = document.querySelector(\[dq].ecdh .encrypt\-button\[dq]);
  encryptButton.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
    encrypt(alicesSecretKey);
  });

  \f[I]// Bob can use his copy to decrypt the message.\f[R]
  \f[B]let\f[R] decryptButton = document.querySelector(\[dq].ecdh .decrypt\-button\[dq]);
  decryptButton.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
    decrypt(bobsSecretKey);
  });
}
.EE
.SS PBKDF2
In this example we ask the user for a password, then use it to derive an
AES key using PBKDF2, then use the AES key to encrypt a message.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/derive-key/pbkdf2.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[I]/*\f[R]
\f[I]Get some key material to use as input to the deriveKey method.\f[R]
\f[I]The key material is a password supplied by the user.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getKeyMaterial() {
  \f[B]const\f[R] password = window.prompt(\[dq]Enter your password\[dq]);
  \f[B]const\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] window.crypto.subtle.importKey(
    \[dq]raw\[dq],
    enc.encode(password),
    \[dq]PBKDF2\[dq],
    \f[B]false\f[R],
    [\[dq]deriveBits\[dq], \[dq]deriveKey\[dq]],
  );
}

\f[B]async\f[R] \f[B]function\f[R] encrypt(plaintext, salt, iv) {
  \f[B]const\f[R] keyMaterial = \f[B]await\f[R] getKeyMaterial();
  \f[B]const\f[R] key = \f[B]await\f[R] window.crypto.subtle.deriveKey(
    {
      name: \[dq]PBKDF2\[dq],
      salt,
      iterations: 100000,
      hash: \[dq]SHA\-256\[dq],
    },
    keyMaterial,
    { name: \[dq]AES\-GCM\[dq], length: 256 },
    \f[B]true\f[R],
    [\[dq]encrypt\[dq], \[dq]decrypt\[dq]],
  );

  \f[B]return\f[R] window.crypto.subtle.encrypt({ name: \[dq]AES\-GCM\[dq], iv }, key, plaintext);
}
.EE
.SS HKDF
In this example, we encrypt a message \f[CR]plainText\f[R] given a
shared secret \f[CR]secret\f[R], which might itself have been derived
using an algorithm such as ECDH.
Instead of using the shared secret directly, we use it as key material
for the HKDF function, to derive an AES\-GCM encryption key, which we
then use to encrypt the message.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/derive-key/hkdf.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[I]/*\f[R]
\f[I]  Given some key material and some random salt,\f[R]
\f[I]  derive an AES\-GCM key using HKDF.\f[R]
\f[I]  */\f[R]
\f[B]function\f[R] getKey(keyMaterial, salt) {
  \f[B]return\f[R] window.crypto.subtle.deriveKey(
    {
      name: \[dq]HKDF\[dq],
      salt: salt,
      info: \f[B]new\f[R] Uint8Array(\[dq]Encryption example\[dq]),
      hash: \[dq]SHA\-256\[dq],
    },
    keyMaterial,
    { name: \[dq]AES\-GCM\[dq], length: 256 },
    \f[B]true\f[R],
    [\[dq]encrypt\[dq], \[dq]decrypt\[dq]],
  );
}

\f[B]async\f[R] \f[B]function\f[R] encrypt(secret, plainText) {
  \f[B]const\f[R] message = {
    salt: window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(16)),
    iv: window.crypto.getRandomValues(\f[B]new\f[R] Uint8Array(12)),
  };

  \f[B]const\f[R] key = \f[B]await\f[R] getKey(secret, message.salt);

  message.ciphertext = \f[B]await\f[R] window.crypto.subtle.encrypt(
    {
      name: \[dq]AES\-GCM\[dq],
      iv: message.iv,
    },
    key,
    plainText,
  );

  \f[B]return\f[R] message;
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc5869
HKDF specification
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://csrc.nist.gov/publications/detail/sp/800-132/final
NIST guidelines for password\-based key derivation
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html
Password storage cheat sheet
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pbkdf2-sha256/3993#3993
Advice on choosing an iteration count for PBKDF2
.UE \c
\&.
