.\" Automatically generated by Pandoc 3.4
.\"
.TH "IIRFilterNode.getFrequencyResponse" "JS" "November 28, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
IIRFilterNode.getFrequencyResponse \- IIRFilterNode:
getFrequencyResponse() method
.SH SYNOPSIS
The \f[CR]getFrequencyResponse()\f[R] method of the
\f[CR]IIRFilterNode\f[R] interface takes the current filtering
algorithm\[cq]s settings and calculates the frequency response for
frequencies specified in a specified array of frequencies.
.PP
The two output arrays, \f[CR]magResponseOutput\f[R] and
\f[CR]phaseResponseOutput\f[R], must be created before calling this
method; they must be the same size as the array of input frequency
values (\f[CR]frequencyArray\f[R]).
.SH SYNTAX
.IP
.EX
getFrequencyResponse(frequencyArray, magResponseOutput, phaseResponseOutput)
.EE
.SS Parameters
.TP
\f[B]frequencyArray\f[R]
A \f[CR]Float32Array\f[R] containing an array of frequencies, specified
in Hertz, which you want to filter.
.TP
\f[B]magResponseOutput\f[R]
A \f[CR]Float32Array\f[R] to receive the computed magnitudes of the
frequency response for each frequency value in the
\f[CR]frequencyArray\f[R].
.TP
\f[B]phaseResponseOutput\f[R]
A \f[CR]Float32Array\f[R] to receive the computed phase response values
in radians for each frequency value in the input
\f[CR]frequencyArray\f[R].
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.TP
\f[B]NotSupportedError\f[R] \f[B]DOMException\f[R]
Thrown if the three arrays provided are not all of the same length.
.SH EXAMPLES
In the following example we are using an IIR filter on a media stream
(for a complete full demo, see our \c
.UR https://mdn.github.io/webaudio-examples/stream-source-buffer/
stream\-source\-buffer demo
.UE \c
\ live, or \c
.UR https://github.com/mdn/webaudio-examples/blob/main/stream-source-buffer/index.html
read its source
.UE \c
).
As part of this demo, we get the frequency responses for this IIR
filter, for five sample frequencies.
We first create the \f[CR]Float32Array\f[R] objects we need, one
containing the input frequencies, and two to receive the output
magnitude and phase values:
.IP
.EX
\f[B]const\f[R] myFrequencyArray = \f[B]new\f[R] Float32Array(5);
myFrequencyArray[0] = 1000;
myFrequencyArray[1] = 2000;
myFrequencyArray[2] = 3000;
myFrequencyArray[3] = 4000;
myFrequencyArray[4] = 5000;

\f[B]const\f[R] magResponseOutput = \f[B]new\f[R] Float32Array(5);
\f[B]const\f[R] phaseResponseOutput = \f[B]new\f[R] Float32Array(5);
.EE
.PP
Next we create a \f[CR]<ul>\f[R] element in our HTML to contain our
results, and grab a reference to it in our JavaScript:
.IP
.EX
<\f[B]p\f[R]>IIR filter frequency response for:</\f[B]p\f[R]>
<\f[B]ul\f[R] class=\[dq]freq\-response\-output\[dq]></\f[B]ul\f[R]>
.EE
.IP
.EX
\f[B]const\f[R] freqResponseOutput = document.querySelector(\[dq].freq\-response\-output\[dq]);
.EE
.PP
Finally, after creating our filter, we use
\f[CR]getFrequencyResponse()\f[R] to generate the response data and put
it in our arrays, then loop through each data set and output them in a
human\-readable list at the bottom of the page:
.IP
.EX
\f[B]const\f[R] feedforwardCoefficients = [0.1, 0.2, 0.3, 0.4, 0.5];
\f[B]const\f[R] feedbackCoefficients = [0.5, 0.4, 0.3, 0.2, 0.1];

\f[B]const\f[R] iirFilter = audioCtx.createIIRFilter(
  feedforwardCoefficients,
  feedbackCoefficients,
);

\f[I]// \&...\f[R]

\f[B]function\f[R] calcFrequencyResponse() {
  iirFilter.getFrequencyResponse(
    myFrequencyArray,
    magResponseOutput,
    phaseResponseOutput,
  );

  \f[B]for\f[R] (\f[B]let\f[R] i = 0; i < myFrequencyArray.length; i++) {
    \f[B]const\f[R] listItem = document.createElement(\[dq]li\[dq]);
    listItem.textContent = \[ga]${myFrequencyArray[i]}Hz: Magnitude ${magResponseOutput[i]}, Phase ${phaseResponseOutput[i]} radians.\[ga];
    freqResponseOutput.appendChild(listItem);
  }
}

calcFrequencyResponse();
.EE
.SH SEE ALSO
.IP \[bu] 2
Using the Web Audio API
.IP \[bu] 2
\f[CR]IIRFilterNode\f[R]
.IP \[bu] 2
\f[CR]AudioNode\f[R]
