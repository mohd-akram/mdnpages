'\" t
.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Atomics.xor" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Atomics.xor \- Atomics.xor()
.SH SYNOPSIS
The \f[B]\f[CB]Atomics.xor()\f[B]\f[R] static method computes a bitwise
XOR with a given value at a given position in the array, and returns the
old value at that position.
This atomic operation guarantees that no other write happens until the
modified value is written back.
.IP
.EX
\f[I]// Create a SharedArrayBuffer with a size in bytes\f[R]
\f[B]const\f[R] buffer = \f[B]new\f[R] SharedArrayBuffer(16);
\f[B]const\f[R] uint8 = \f[B]new\f[R] Uint8Array(buffer);
uint8[0] = 7;

\f[I]// 7 (0111) XOR 2 (0010) = 5 (0101)\f[R]
console.log(Atomics.xor(uint8, 0, 2));
\f[I]// Expected output: 7\f[R]

console.log(Atomics.load(uint8, 0));
\f[I]// Expected output: 5\f[R]
.EE
.SH SYNTAX
.IP
.EX
Atomics.xor(typedArray, index, value)
.EE
.SS Parameters
.TP
\f[B]typedArray\f[R]
An integer typed array.
One of \f[CR]Int8Array\f[R], \f[CR]Uint8Array\f[R],
\f[CR]Int16Array\f[R], \f[CR]Uint16Array\f[R], \f[CR]Int32Array\f[R],
\f[CR]Uint32Array\f[R], \f[CR]BigInt64Array\f[R], or
\f[CR]BigUint64Array\f[R].
.TP
\f[B]index\f[R]
The position in the \f[CR]typedArray\f[R] to compute the bitwise XOR.
.TP
\f[B]value\f[R]
The number to compute the bitwise XOR with.
.SS Return value
The old value at the given position (\f[CR]typedArray[index]\f[R]).
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if \f[CR]typedArray\f[R] is not one of the allowed integer types.
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]index\f[R] is out of bounds in the
\f[CR]typedArray\f[R].
.SH DESCRIPTION
The bitwise XOR operation yields 1, if \f[CR]a\f[R] and \f[CR]b\f[R] are
different.
The truth table for the XOR operation is:
.PP
.TS
tab(@);
l l l.
T{
\f[CR]a\f[R]
T}@T{
\f[CR]b\f[R]
T}@T{
\f[CR]a \[ha] b\f[R]
T}
_
T{
0
T}@T{
0
T}@T{
0
T}
T{
0
T}@T{
1
T}@T{
1
T}
T{
1
T}@T{
0
T}@T{
1
T}
T{
1
T}@T{
1
T}@T{
0
T}
.TE
.PP
For example, a bitwise XOR of \f[CR]5 \[ha] 1\f[R] results in
\f[CR]0100\f[R] which is 4 in decimal.
.IP
.EX
5  0101
1  0001
   \-\-\-\-
4  0100
.EE
.SH EXAMPLES
.SS Using xor
.IP
.EX
\f[B]const\f[R] sab = \f[B]new\f[R] SharedArrayBuffer(1024);
\f[B]const\f[R] ta = \f[B]new\f[R] Uint8Array(sab);
ta[0] = 5;

Atomics.xor(ta, 0, 1); \f[I]// returns 5, the old value\f[R]
Atomics.load(ta, 0); \f[I]// 4\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Atomics\f[R]
.IP \[bu] 2
\f[CR]Atomics.and()\f[R]
.IP \[bu] 2
\f[CR]Atomics.or()\f[R]
