.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "HTMLVIDEOELEMENT.REQUESTVIDEOFRAMECALLBACK" "3JS" "February 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
HTMLVideoElement.requestVideoFrameCallback \- HTMLVideoElement:
requestVideoFrameCallback() method
.SH SYNOPSIS
The \f[B]\f[CB]requestVideoFrameCallback()\f[B]\f[R] method of the
\f[CR]HTMLVideoElement\f[R] interface registers a callback function that
runs when a new video frame is sent to the compositor.
This enables developers to perform efficient operations on each video
frame.
.SH SYNTAX
.IP
.EX
requestVideoFrameCallback(callback)
.EE
.SS Parameters
.TP
\f[B]callback\f[R]
The callback function that runs when a new video frame is sent to the
compositor.
This contains two parameters:
.RS
.TP
\f[B]now\f[R]
A \f[CR]DOMHighResTimeStamp\f[R] representing the time when the callback
was called.
.TP
\f[B]metadata\f[R]
An object containing the following properties:
.RS
.TP
\f[B]expectedDisplayTime\f[R]
A \f[CR]DOMHighResTimeStamp\f[R] representing the time when the browser
expects the frame to be visible.
.TP
\f[B]height\f[R]
A number, in media pixels, representing the height of the video frame
(the visible decoded pixels, without aspect ratio adjustments).
.TP
\f[B]mediaTime\f[R]
A number, in seconds, representing the media presentation timestamp of
the presented frame.
This is equal to the frame\(cqs timestamp on the
\f[CR]HTMLMediaElement.currentTime\f[R] timeline.
.TP
\f[B]presentationTime\f[R]
A \f[CR]DOMHighResTimeStamp\f[R] representing the time when the browser
submitted the frame for composition.
.TP
\f[B]presentedFrames\f[R]
A number representing the number of frames submitted for composition so
far alongside the current callback.
This can be used to detect whether frames were missed between callback
instances.
.TP
\f[B]processingDuration\f[R]
A number, in seconds, representing the duration between the submission
of the encoded packet with the same presentation timestamp as this frame
to the decoder (i.e., the \f[CR]mediaTime\f[R]) and the decoded frame
being ready for presentation.
.TP
\f[B]width\f[R]
A number, in media pixels, representing the width of the video frame
(the visible decoded pixels, without aspect ratio adjustments).
.PP
Additional metadata properties may be available within
\f[CR]requestVideoFrameCallback()\f[R] callbacks used in WebRTC
applications:
.TP
\f[B]captureTime\f[R]
A \f[CR]DOMHighResTimeStamp\f[R] representing the time when the frame
was captured.
This applies to video frames coming from a local or remote source.
For a remote source, the capture time is estimated using clock
synchronization and RTCP sender reports to convert RTP timestamps to
capture time.
.TP
\f[B]receiveTime\f[R]
A \f[CR]DOMHighResTimeStamp\f[R] representing the time when the encoded
frame was received by the platform.
This applies to video frames coming from a remote source.
Specifically, this corresponds to the time when the last packet
belonging to this frame was received over the network.
.TP
\f[B]rtpTimestamp\f[R]
A number representing the RTP timestamp associated with this video
frame.
.RE
.RE
.RS
.PP
\f[B]Note:\f[R] \f[CR]width\f[R] and \f[CR]height\f[R] may differ from
\f[CR]HTMLVideoElement.videoWidth\f[R] and
\f[CR]HTMLVideoElement.videoHeight\f[R] in certain cases (for example,
an anamorphic video may have rectangular pixels).
.RE
.SS Return value
A number representing a unique callback ID.
.PP
This can be passed to
\f[CR]HTMLVideoElement.cancelVideoFrameCallback()\f[R] to cancel the
callback registration.
.SH DESCRIPTION
Typical use cases for \f[CR]requestVideoFrameCallback()\f[R] include
video processing and painting to a canvas, video analysis, and
synchronization with external audio sources.
Per\-frame processing used to be done in a less efficient or accurate
fashion by running operations on the current video display whenever the
\f[CR]timeupdate\f[R] event fired.
This technique did not provide access to the actual video frames.
.PP
\f[CR]requestVideoFrameCallback()\f[R] is used in the same way as
\f[CR]Window.requestAnimationFrame()\f[R].
You use it to run a callback function that performs some operation when
the next video frame is sent to the compositor.
The callback finishes by calling \f[CR]requestVideoFrameCallback()\f[R]
again to run the callback when the next video frame is composited, and
so on.
However, \f[CR]requestVideoFrameCallback()\f[R] is tailored for video
operations in several ways:
.IP \(bu 2
\f[CR]requestVideoFrameCallback()\f[R] provides reliable access to each
individual video frame.
.IP \(bu 2
\f[CR]requestAnimationFrame()\f[R] tries to match the display refresh
rate, which is typically 60Hz.
\f[CR]requestVideoFrameCallback()\f[R], on the other hand, tries to
match the video frame rate.
More specifically, the callback will run at the lower of the video frame
rate and the browser paint refresh rate.
For example, a video with a frame rate of 25fps playing in a browser
that paints at 60Hz would fire callbacks at a rate of 25Hz.
A video with a frame rate of 120fps running in the same 60Hz browser
would fire callbacks at 60Hz.
.IP \(bu 2
\f[CR]requestVideoFrameCallback()\f[R] makes useful video metadata
available in the callback function.
.PP
One thing to bear in mind is that \f[CR]requestVideoFrameCallback()\f[R]
does not offer any strict guarantees that the output from your callback
will remain in sync with the video frame rate.
It may end up being fired one vertical synchronization (v\-sync) later
than when the new video frame was presented.
(V\-sync is a graphics technology that synchronizes the frame rate of a
video with the refresh rate of a monitor.)
.PP
The API runs on the main thread, while video compositing likely happens
on a separate compositing thread.
You\(cqve got to factor in the time taken for these operations to
complete, as well as the time it takes for the video itself and the
result of your \f[CR]requestVideoFrameCallback()\f[R] operation to
display on the screen.
.PP
You can compare the \f[CR]now\f[R] callback parameter and the
\f[CR]expectedDisplayTime\f[R] metadata property to determine whether
your callback is a v\-sync late.
If \f[CR]expectedDisplayTime\f[R] is within about five to ten
microseconds of \f[CR]now\f[R], the frame is already rendered.
If the \f[CR]expectedDisplayTime\f[R] is approximately sixteen
milliseconds in the future (assuming your browser/screen is refreshing
at 60Hz), then the callback is a v\-sync out.
.SH EXAMPLES
.SS Drawing video frames on a canvas
This example shows how to use \f[CR]requestVideoFrameCallback()\f[R] to
draw the frames of a video onto a \f[CR]<canvas>\f[R] element at exactly
the same frame rate as the video.
It also logs the frame metadata to the DOM for debugging purposes.
.IP
.EX
\f[B]if\f[R] (\(dqrequestVideoFrameCallback\(dq \f[B]in\f[R] HTMLVideoElement.prototype) {
  \f[B]const\f[R] video = document.createElement(\(dqvideo\(dq);
  \f[B]const\f[R] fpsInfo = document.createElement(\(dqdiv\(dq);
  \f[B]const\f[R] metadataInfo = document.createElement(\(dqdiv\(dq);
  \f[B]const\f[R] canvas = document.createElement(\(dqcanvas\(dq);
  \f[B]const\f[R] ctx = canvas.getContext(\(dq2d\(dq);

  \f[I]// \(aqBig Buck Bunny\(aq licensed under CC 3.0 by the Blender foundation. Hosted by archive.org\f[R]
  \f[I]// Poster from peach.blender.org\f[R]
  video.src =
    \(dqhttps://archive.org/download/BigBuckBunny_124/Content/big_buck_bunny_720p_surround.mp4\(dq;
  video.poster =
    \(dqhttps://peach.blender.org/wp\-content/uploads/title_anouncement.jpg?x11217\(dq;
  video.width = 640;
  video.controls = \f[B]true\f[R];

  document.body.append(video, fpsInfo, metadataInfo, canvas);

  \f[B]let\f[R] paintCount = 0;
  \f[B]let\f[R] startTime = 0.0;

  \f[B]const\f[R] updateCanvas = (now, metadata) \f[B]=>\f[R] {
    \f[B]if\f[R] (startTime === 0.0) {
      startTime = now;
    }

    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    \f[B]const\f[R] elapsed = (now \- startTime) / 1000.0;
    \f[B]const\f[R] fps = (++paintCount / elapsed).toFixed(3);
    fpsInfo.innerText = \(gavideo fps: ${fps}\(ga;
    metadataInfo.innerText = JSON.stringify(metadata, \f[B]null\f[R], 2);

    \f[I]// Re\-register the callback to run on the next frame\f[R]
    video.requestVideoFrameCallback(updateCanvas);
  };

  \f[I]// Initial registration of the callback to run on the first frame\f[R]
  video.requestVideoFrameCallback(updateCanvas);
} \f[B]else\f[R] {
  alert(\(dqYour browser does not support requestVideoFrameCallback().\(dq);
}
.EE
.PP
See \c
.UR https://requestvideoframecallback.glitch.me/
requestVideoFrameCallback Demo
.UE \c
\ for a working implementation of the above code.
.SH SEE ALSO
.IP \(bu 2
The \f[CR]<video>\f[R] element
.IP \(bu 2
\f[CR]HTMLVideoElement.cancelVideoFrameCallback()\f[R]
.IP \(bu 2
\c
.UR https://web.dev/articles/requestvideoframecallback-rvfc
Perform efficient per\-video\-frame operations on video with
\f[CR]requestVideoFrameCallback()\f[R]
.UE \c
\ on developer.chrome.com (2023)
