.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "OBJECT.PROPERTYISENUMERABLE" "3JS" "March 6, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.propertyIsEnumerable \- Object.prototype.propertyIsEnumerable()
.SH SYNOPSIS
The \f[B]\f[CB]propertyIsEnumerable()\f[B]\f[R] method of
\f[CR]Object\f[R] instances returns a boolean indicating whether the
specified property is this object\(cqs enumerable own property.
.IP
.EX
\f[B]const\f[R] object1 = {};
\f[B]const\f[R] array1 = [];
object1.property1 = 42;
array1[0] = 42;

console.log(object1.propertyIsEnumerable(\(dqproperty1\(dq));
\f[I]// Expected output: true\f[R]

console.log(array1.propertyIsEnumerable(0));
\f[I]// Expected output: true\f[R]

console.log(array1.propertyIsEnumerable(\(dqlength\(dq));
\f[I]// Expected output: false\f[R]
.EE
.SH SYNTAX
.IP
.EX
propertyIsEnumerable(prop)
.EE
.SS Parameters
.TP
\f[B]prop\f[R]
The name of the property to test.
Can be a string or a \f[CR]Symbol\f[R].
.SS Return value
A boolean value indicating whether the specified property is enumerable
and is the object\(cqs own property.
.SH DESCRIPTION
All objects that inherit from \f[CR]Object.prototype\f[R] (that is, all
except \f[CR]null\f[R]\-prototype objects) inherit the
\f[CR]propertyIsEnumerable()\f[R] method.
This method determines if the specified property, string or symbol, is
an enumerable own property of the object.
If the object does not have the specified property, this method returns
\f[CR]false\f[R].
.PP
This method is equivalent to
\f[CR]Object.getOwnPropertyDescriptor(obj, prop)?.enumerable ?? false\f[R].
.SH EXAMPLES
.SS Using propertyIsEnumerable()
The following example shows the use of \f[CR]propertyIsEnumerable()\f[R]
on objects and arrays.
.IP
.EX
\f[B]const\f[R] o = {};
\f[B]const\f[R] a = [];
o.prop = \(dqis enumerable\(dq;
a[0] = \(dqis enumerable\(dq;

o.propertyIsEnumerable(\(dqprop\(dq); \f[I]// true\f[R]
a.propertyIsEnumerable(0); \f[I]// true\f[R]
.EE
.SS User\-defined vs.\ built\-in objects
Most built\-in properties are non\-enumerable by default, while
user\-created object properties are often enumerable, unless explicitly
designated otherwise.
.IP
.EX
\f[B]const\f[R] a = [\(dqis enumerable\(dq];

a.propertyIsEnumerable(0); \f[I]// true\f[R]
a.propertyIsEnumerable(\(dqlength\(dq); \f[I]// false\f[R]

Math.propertyIsEnumerable(\(dqrandom\(dq); \f[I]// false\f[R]
globalThis.propertyIsEnumerable(\(dqMath\(dq); \f[I]// false\f[R]
.EE
.SS Direct vs.\ inherited properties
Only enumerable own properties cause \f[CR]propertyIsEnumerable()\f[R]
to return \f[CR]true\f[R], although all enumerable properties, including
inherited ones, are visited by the \f[CR]for...in\f[R] loop.
.IP
.EX
\f[B]const\f[R] o1 = {
  enumerableInherited: \(dqis enumerable\(dq,
};
Object.defineProperty(o1, \(dqnonEnumerableInherited\(dq, {
  value: \(dqis non\-enumerable\(dq,
  enumerable: \f[B]false\f[R],
});
\f[B]const\f[R] o2 = {
  \f[I]// o1 is the prototype of o2\f[R]
  __proto__: o1,
  enumerableOwn: \(dqis enumerable\(dq,
};
Object.defineProperty(o2, \(dqnonEnumerableOwn\(dq, {
  value: \(dqis non\-enumerable\(dq,
  enumerable: \f[B]false\f[R],
});

o2.propertyIsEnumerable(\(dqenumerableInherited\(dq); \f[I]// false\f[R]
o2.propertyIsEnumerable(\(dqnonEnumerableInherited\(dq); \f[I]// false\f[R]
o2.propertyIsEnumerable(\(dqenumerableOwn\(dq); \f[I]// true\f[R]
o2.propertyIsEnumerable(\(dqnonEnumerableOwn\(dq); \f[I]// false\f[R]
.EE
.SS Testing symbol properties
\f[CR]Symbol\f[R] properties are also supported by
\f[CR]propertyIsEnumerable()\f[R].
Note that most enumeration methods only visit string properties;
enumerability of symbol properties is only useful when using
\f[CR]Object.assign()\f[R] or spread syntax.
For more information, see Enumerability and ownership of properties.
.IP
.EX
\f[B]const\f[R] sym = Symbol(\(dqenumerable\(dq);
\f[B]const\f[R] sym2 = Symbol(\(dqnon\-enumerable\(dq);
\f[B]const\f[R] o = {
  [sym]: \(dqis enumerable\(dq,
};
Object.defineProperty(o, sym2, {
  value: \(dqis non\-enumerable\(dq,
  enumerable: \f[B]false\f[R],
});

o.propertyIsEnumerable(sym); \f[I]// true\f[R]
o.propertyIsEnumerable(sym2); \f[I]// false\f[R]
.EE
.SS Usage with null\-prototype objects
Because \f[CR]null\f[R]\-prototype objects do not inherit from
\f[CR]Object.prototype\f[R], they do not inherit the
\f[CR]propertyIsEnumerable()\f[R] method.
You must call \f[CR]Object.prototype.propertyIsEnumerable\f[R] with the
object as \f[CR]this\f[R] instead.
.IP
.EX
\f[B]const\f[R] o = {
  __proto__: \f[B]null\f[R],
  enumerableOwn: \(dqis enumerable\(dq,
};

o.propertyIsEnumerable(\(dqenumerableOwn\(dq); \f[I]// TypeError: o.propertyIsEnumerable is not a function\f[R]
Object.prototype.propertyIsEnumerable.call(o, \(dqenumerableOwn\(dq); \f[I]// true\f[R]
.EE
.PP
Alternatively, you may use \f[CR]Object.getOwnPropertyDescriptor()\f[R]
instead, which also helps to distinguish between non\-existent
properties and actually non\-enumerable properties.
.IP
.EX
\f[B]const\f[R] o = {
  __proto__: \f[B]null\f[R],
  enumerableOwn: \(dqis enumerable\(dq,
};

Object.getOwnPropertyDescriptor(o, \(dqenumerableOwn\(dq)?.enumerable; \f[I]// true\f[R]
Object.getOwnPropertyDescriptor(o, \(dqnonExistent\(dq)?.enumerable; \f[I]// undefined\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
Enumerability and ownership of properties
.IP \(bu 2
\f[CR]for...in\f[R]
.IP \(bu 2
\f[CR]Object.keys()\f[R]
.IP \(bu 2
\f[CR]Object.defineProperty()\f[R]
