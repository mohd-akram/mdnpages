.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Object.propertyIsEnumerable" "JS" "August 9, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.propertyIsEnumerable \- Object.prototype.propertyIsEnumerable()
.SH SYNOPSIS
The \f[B]\f[CB]propertyIsEnumerable()\f[B]\f[R] method of
\f[CR]Object\f[R] instances returns a boolean indicating whether the
specified property is this object\[cq]s enumerable own property.
.SH SYNTAX
.IP
.EX
propertyIsEnumerable(prop)
.EE
.SS Parameters
.TP
\f[B]prop\f[R]
The name of the property to test.
Can be a string or a \f[CR]Symbol\f[R].
.SS Return value
A boolean value indicating whether the specified property is enumerable
and is the object\[cq]s own property.
.SH DESCRIPTION
All objects that inherit from \f[CR]Object.prototype\f[R] (that is, all
except \f[CR]null\f[R]\-prototype objects) inherit the
\f[CR]propertyIsEnumerable()\f[R] method.
This method determines if the specified property, string or symbol, is
an enumerable own property of the object.
If the object does not have the specified property, this method returns
\f[CR]false\f[R].
.PP
This method is equivalent to
\f[CR]Object.getOwnPropertyDescriptor(obj, prop)?.enumerable ?? false\f[R].
.SH EXAMPLES
.SS Using propertyIsEnumerable()
The following example shows the use of \f[CR]propertyIsEnumerable()\f[R]
on objects and arrays.
.IP
.EX
\f[B]const\f[R] o = {};
\f[B]const\f[R] a = [];
o.prop = \[dq]is enumerable\[dq];
a[0] = \[dq]is enumerable\[dq];

o.propertyIsEnumerable(\[dq]prop\[dq]); \f[I]// true\f[R]
a.propertyIsEnumerable(0); \f[I]// true\f[R]
.EE
.SS User\-defined vs.\ built\-in objects
Most built\-in properties are non\-enumerable by default, while
user\-created object properties are often enumerable, unless explicitly
designated otherwise.
.IP
.EX
\f[B]const\f[R] a = [\[dq]is enumerable\[dq]];

a.propertyIsEnumerable(0); \f[I]// true\f[R]
a.propertyIsEnumerable(\[dq]length\[dq]); \f[I]// false\f[R]

Math.propertyIsEnumerable(\[dq]random\[dq]); \f[I]// false\f[R]
globalThis.propertyIsEnumerable(\[dq]Math\[dq]); \f[I]// false\f[R]
.EE
.SS Direct vs.\ inherited properties
Only enumerable own properties cause \f[CR]propertyIsEnumerable()\f[R]
to return \f[CR]true\f[R], although all enumerable properties, including
inherited ones, are visited by the \f[CR]for...in\f[R] loop.
.IP
.EX
\f[B]const\f[R] o1 = {
  enumerableInherited: \[dq]is enumerable\[dq],
};
Object.defineProperty(o1, \[dq]nonEnumerableInherited\[dq], {
  value: \[dq]is non\-enumerable\[dq],
  enumerable: \f[B]false\f[R],
});
\f[B]const\f[R] o2 = {
  \f[I]// o1 is the prototype of o2\f[R]
  __proto__: o1,
  enumerableOwn: \[dq]is enumerable\[dq],
};
Object.defineProperty(o2, \[dq]nonEnumerableOwn\[dq], {
  value: \[dq]is non\-enumerable\[dq],
  enumerable: \f[B]false\f[R],
});

o2.propertyIsEnumerable(\[dq]enumerableInherited\[dq]); \f[I]// false\f[R]
o2.propertyIsEnumerable(\[dq]nonEnumerableInherited\[dq]); \f[I]// false\f[R]
o2.propertyIsEnumerable(\[dq]enumerableOwn\[dq]); \f[I]// true\f[R]
o2.propertyIsEnumerable(\[dq]nonEnumerableOwn\[dq]); \f[I]// false\f[R]
.EE
.SS Testing symbol properties
\f[CR]Symbol\f[R] properties are also supported by
\f[CR]propertyIsEnumerable()\f[R].
Note that most enumeration methods only visit string properties;
enumerability of symbol properties is only useful when using
\f[CR]Object.assign()\f[R] or spread syntax.
For more information, see Enumerability and ownership of properties.
.IP
.EX
\f[B]const\f[R] sym = Symbol(\[dq]enumerable\[dq]);
\f[B]const\f[R] sym2 = Symbol(\[dq]non\-enumerable\[dq]);
\f[B]const\f[R] o = {
  [sym]: \[dq]is enumerable\[dq],
};
Object.defineProperty(o, sym2, {
  value: \[dq]is non\-enumerable\[dq],
  enumerable: \f[B]false\f[R],
});

o.propertyIsEnumerable(sym); \f[I]// true\f[R]
o.propertyIsEnumerable(sym2); \f[I]// false\f[R]
.EE
.SS Usage with null\-prototype objects
Because \f[CR]null\f[R]\-prototype objects do not inherit from
\f[CR]Object.prototype\f[R], they do not inherit the
\f[CR]propertyIsEnumerable()\f[R] method.
You must call \f[CR]Object.prototype.propertyIsEnumerable\f[R] with the
object as \f[CR]this\f[R] instead.
.IP
.EX
\f[B]const\f[R] o = {
  __proto__: \f[B]null\f[R],
  enumerableOwn: \[dq]is enumerable\[dq],
};

o.propertyIsEnumerable(\[dq]enumerableOwn\[dq]); \f[I]// TypeError: o.propertyIsEnumerable is not a function\f[R]
Object.prototype.propertyIsEnumerable.call(o, \[dq]enumerableOwn\[dq]); \f[I]// true\f[R]
.EE
.PP
Alternatively, you may use \f[CR]Object.getOwnPropertyDescriptor()\f[R]
instead, which also helps to distinguish between non\-existent
properties and actually non\-enumerable properties.
.IP
.EX
\f[B]const\f[R] o = {
  __proto__: \f[B]null\f[R],
  enumerableOwn: \[dq]is enumerable\[dq],
};

Object.getOwnPropertyDescriptor(o, \[dq]enumerableOwn\[dq])?.enumerable; \f[I]// true\f[R]
Object.getOwnPropertyDescriptor(o, \[dq]nonExistent\[dq])?.enumerable; \f[I]// undefined\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
Enumerability and ownership of properties
.IP \[bu] 2
\f[CR]for...in\f[R]
.IP \[bu] 2
\f[CR]Object.keys()\f[R]
.IP \[bu] 2
\f[CR]Object.defineProperty()\f[R]
