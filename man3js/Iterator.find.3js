.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ITERATOR.FIND" "3JS" "March 5, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator.find \- Iterator.prototype.find()
.SH SYNOPSIS
The \f[B]\f[CB]find()\f[B]\f[R] method of \f[CR]Iterator\f[R] instances
is similar to \f[CR]Array.prototype.find()\f[R]: it returns the first
element produced by the iterator that satisfies the provided testing
function.
If no values satisfy the testing function, \f[CR]undefined\f[R] is
returned.
.SH SYNTAX
.IP
.EX
find(callbackFn)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element produced by the iterator.
It should return a truthy value to indicate a matching element has been
found, and a falsy value otherwise.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed.
.TP
\f[B]index\f[R]
The index of the current element being processed.
.RE
.SS Return value
The first element produced by the iterator that satisfies the provided
testing function.
Otherwise, \f[CR]undefined\f[R] is returned.
.SH DESCRIPTION
\f[CR]find()\f[R] iterates the iterator and invokes the
\f[CR]callbackFn\f[R] function once for each element.
It returns the element immediately if the callback function returns a
truthy value.
Otherwise, it iterates until the end of the iterator and returns
\f[CR]undefined\f[R].
If \f[CR]find()\f[R] returns an element, the underlying iterator is
closed by calling its \f[CR]return()\f[R] method.
.PP
The main advantage of iterator helpers over array methods is that they
are lazy, meaning that they only produce the next value when requested.
This avoids unnecessary computation and also allows them to be used with
infinite iterators.
With infinite iterators, \f[CR]find()\f[R] returns the first satisfying
element as soon as it is found.
If the \f[CR]callbackFn\f[R] always returns a falsy value, the method
never returns.
.SH EXAMPLES
.SS Using find()
.IP
.EX
\f[B]function\f[R]* fibonacci() {
  \f[B]let\f[R] current = 1;
  \f[B]let\f[R] next = 1;
  \f[B]while\f[R] (\f[B]true\f[R]) {
    \f[B]yield\f[R] current;
    [current, next] = [next, current + next];
  }
}

\f[B]const\f[R] isEven = (x) \f[B]=>\f[R] x % 2 === 0;
console.log(fibonacci().find(isEven)); \f[I]// 2\f[R]

\f[B]const\f[R] isNegative = (x) \f[B]=>\f[R] x < 0;
console.log(fibonacci().take(10).find(isNegative)); \f[I]// undefined\f[R]
console.log(fibonacci().find(isNegative)); \f[I]// Never completes\f[R]
.EE
.PP
Calling \f[CR]find()\f[R] always closes the underlying iterator, even if
the method early\-returns.
The iterator is never left in a half\-way state.
.IP
.EX
\f[B]const\f[R] seq = fibonacci();
console.log(seq.find(isEven)); \f[I]// 2\f[R]
console.log(seq.next()); \f[I]// { value: undefined, done: true }\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#iterator-helpers
Polyfill of \f[CR]Iterator.prototype.find\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/es-iterator-helpers
es\-shims polyfill of \f[CR]Iterator.prototype.find\f[R]
.UE \c
.IP \(bu 2
\f[CR]Iterator\f[R]
.IP \(bu 2
\f[CR]Iterator.prototype.every()\f[R]
.IP \(bu 2
\f[CR]Iterator.prototype.some()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.find()\f[R]
