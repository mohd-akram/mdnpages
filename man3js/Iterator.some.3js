.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Iterator.some" "JS" "December 7, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator.some \- Iterator.prototype.some()
.SH SYNOPSIS
The \f[B]\f[CB]some()\f[B]\f[R] method of \f[CR]Iterator\f[R] instances
is similar to \f[CR]Array.prototype.some()\f[R]: it tests whether at
least one element produced by the iterator passes the test implemented
by the provided function.
It returns a boolean value.
.SH SYNTAX
.IP
.EX
some(callbackFn)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element produced by the iterator.
It should return a truthy value to indicate the element passes the test,
and a falsy value otherwise.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed.
.TP
\f[B]index\f[R]
The index of the current element being processed.
.RE
.SS Return value
\f[CR]true\f[R] if the callback function returns a truthy value for at
least one element.
Otherwise, \f[CR]false\f[R].
.SH DESCRIPTION
\f[CR]some()\f[R] iterates the iterator and invokes the
\f[CR]callbackFn\f[R] function once for each element.
It returns \f[CR]true\f[R] immediately if the callback function returns
a truthy value.
Otherwise, it iterates until the end of the iterator and returns
\f[CR]false\f[R].
If \f[CR]some()\f[R] returns \f[CR]true\f[R], the underlying iterator is
closed by calling its \f[CR]return()\f[R] method.
.PP
The main advantage of iterator helpers over array methods is that they
are lazy, meaning that they only produce the next value when requested.
This avoids unnecessary computation and also allows them to be used with
infinite iterators.
With infinite iterators, \f[CR]some()\f[R] returns \f[CR]true\f[R] as
soon as the first truthy value is found.
If the \f[CR]callbackFn\f[R] always returns a falsy value, the method
never returns.
.SH EXAMPLES
.SS Using some()
.IP
.EX
\f[B]function\f[R]* fibonacci() {
  \f[B]let\f[R] current = 1;
  \f[B]let\f[R] next = 1;
  \f[B]while\f[R] (\f[B]true\f[R]) {
    \f[B]yield\f[R] current;
    [current, next] = [next, current + next];
  }
}

\f[B]const\f[R] isEven = (x) \f[B]=>\f[R] x % 2 === 0;
console.log(fibonacci().some(isEven)); \f[I]// true\f[R]

\f[B]const\f[R] isNegative = (x) \f[B]=>\f[R] x < 0;
console.log(fibonacci().take(10).some(isNegative)); \f[I]// false\f[R]
console.log(fibonacci().some(isNegative)); \f[I]// Never completes\f[R]
.EE
.PP
Calling \f[CR]some()\f[R] always closes the underlying iterator, even if
the method early\-returns.
The iterator is never left in a half\-way state.
.IP
.EX
\f[B]const\f[R] seq = fibonacci();
console.log(seq.some(isEven)); \f[I]// true\f[R]
console.log(seq.next()); \f[I]// { value: undefined, done: true }\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#iterator-helpers
Polyfill of \f[CR]Iterator.prototype.some\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Iterator\f[R]
.IP \[bu] 2
\f[CR]Iterator.prototype.every()\f[R]
.IP \[bu] 2
\f[CR]Iterator.prototype.find()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.some()\f[R]
