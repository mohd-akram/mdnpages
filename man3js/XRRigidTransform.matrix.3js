.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "XRRigidTransform.matrix" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
XRRigidTransform.matrix \- XRRigidTransform: matrix property
.SH SYNOPSIS
The read\-only \f[CR]XRRigidTransform\f[R] property
\f[B]\f[CB]matrix\f[B]\f[R] returns the transform matrix represented by
the object.
The returned matrix can then be premultiplied with a column vector to
rotate the vector by the 3D rotation specified by the
\f[CR]orientation\f[R], then translate it by the \f[CR]position\f[R].
.SH VALUE
A \f[CR]Float32Array\f[R] containing 16 entries which represents the 4x4
transform matrix which is described by the \f[CR]position\f[R] and
\f[CR]orientation\f[R] properties.
.SH USAGE NOTES
.SS Matrix format
All 4x4 transform matrices used in WebGL are stored in 16\-element
\f[CR]Float32Array\f[R]s.
The values are stored into the array in column\-major order; that is,
each column is written into the array top\-down before moving to the
right one column and writing the next column into the array.
Thus, for an array [a0, a1, a2, \&..., a13, a14, a15], the matrix looks
like this:
[ a0 a4 a8 a12 a1 a5 a9 a13 a2 a6 a10 a14 a3 a7 a11 a15 ]
.PP
.PP
On the first request, the \f[CR]matrix\f[R] gets computed.
After that, it should be cached for performance reasons.
.SS Creating the matrix
In this section, intended for more advanced readers, we cover how the
API calculates the matrix for the specified transform.
It begins by allocating a new matrix and writing a 4x4 identity matrix
into it:
[ 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 ]
.PP
.PP
This is a transform that will not change either the orientation or
position of any point, vector, or object to which it\[cq]s applied.
.PP
Next, the \f[CR]position\f[R] is placed into the right\-hand column,
like this, resulting in a translation matrix that will transform a
coordinate system by the specified distance in each dimension, with no
rotational change.
Here \f[I]px\f[R], \f[I]py\f[R], and \f[I]pz\f[R] are the values of the
\f[CR]x\f[R], \f[CR]y\f[R], and \f[CR]z\f[R] members of the
\f[CR]DOMPointReadOnly\f[R] \f[CR]position\f[R].
[ 1 0 0 p x 0 1 0 p y 0 0 1 p z 0 0 0 1 ]
.PP
.PP
Then a rotation matrix is created by computing a column\-vector rotation
matrix from the unit quaternion specified by \f[CR]orientation\f[R]:
[ 1 \- 2 ( q y 2 + q z 2 ) 2 ( q x q y \- q z q w ) 2 ( q x q z + q y q
w ) 0 2 ( q x q y + q z q w ) 1 \- 2 ( q x 2 + q z 2 ) 2 ( q y q z \- q
x q w ) 0 2 ( q x q z \- q y q w ) 2 ( q y q z + q x q w ) 1 \- 2 ( q x
2 + q y 2 ) 0 0 0 0 1 ]
.PP
.PP
The final transform \f[CR]matrix\f[R] is calculated by multiplying the
translation matrix by the rotation matrix, in the order
\f[CR](translation * rotation)\f[R].
This yields the final transform matrix as returned by \f[CR]matrix\f[R]:
[ 1 \- 2 ( q y 2 + q z 2 ) 2 ( q x q y \- q z q w ) 2 ( q x q z + q y q
w ) p x 2 ( q x q y + q z q w ) 1 \- 2 ( q x 2 + q z 2 ) 2 ( q y q z \-
q x q w ) p y 2 ( q x q z \- q y q w ) 2 ( q y q z + q x q w ) 1 \- 2 (
q x 2 + q y 2 ) p z 0 0 0 1 ]
.PP
.SH EXAMPLES
In this example, a transform is created to create a matrix which can be
used as a transform during rendering of WebGL objects, in order to place
objects to match a given offset and orientation.
The \f[CR]matrix\f[R] is then passed into a library function that uses
WebGL to render an object matching a given name using the transform
matrix specified to position and orient it.
.IP
.EX
let transform = new XRRigidTransform(
  { x: 0, y: 0.5, z: 0.5 },
  { x: 0, y: \-0.5, z: \-0.5, w: 1 },
);
drawGLObject(\[dq]magic\-lamp\[dq], transform.matrix);
.EE
