.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "XRRigidTransform.matrix" "JS" "July 19, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
XRRigidTransform.matrix \- XRRigidTransform: matrix property
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
The read\-only \f[CR]XRRigidTransform\f[R] property
\f[B]\f[CB]matrix\f[B]\f[R] returns the transform matrix represented by
the object.
The returned matrix can then be premultiplied with a column vector to
rotate the vector by the 3D rotation specified by the
\f[CR]orientation\f[R], then translate it by the \f[CR]position\f[R].
.SH VALUE
A \f[CR]Float32Array\f[R] containing 16 entries, which represents the
4x4 transform matrix described by the \f[CR]position\f[R] and
\f[CR]orientation\f[R] properties.
.SH USAGE NOTES
.SS Matrix format
All 4x4 transform matrices used in WebGL are stored in 16\-element
\f[CR]Float32Array\f[R]s.
The values are stored in the array in column\-major order; that is, each
column is written into the array top\-down before moving to the next
column to the right and writing it into the array.
Therefore, for the array \f[CR][a0, a1, a2, \&..., a13, a14, a15]\f[R],
the matrix looks like this:
\ [a0a4a8a12a1a5a9a13a2a6a10a14a3a7a11a15]
.PP
\ 
.PP
On the first request, the \f[CR]matrix\f[R] gets computed.
After that, it should be cached for performance reasons.
.SS Creating the matrix
In this section, intended for more advanced readers, we cover how the
API calculates the matrix for the specified transform.
It begins by allocating a new matrix and writing a 4x4 identity matrix
into it:
\ [1000010000100001]
.PP
\ 
.PP
This is a transform that will not change either the orientation or
position of any point, vector, or object to which it\[cq]s applied.
.PP
Next, the \f[CR]position\f[R] is placed into the right\-hand column,
like this, resulting in a translation matrix that will transform a
coordinate system by the specified distance in each dimension, with no
rotational change.
Here \f[I]p_x\f[R], \f[I]p_y\f[R], and \f[I]p_z\f[R] are the values of
the \f[CR]x\f[R], \f[CR]y\f[R], and \f[CR]z\f[R] members of the
\f[CR]DOMPointReadOnly\f[R] \f[CR]position\f[R].
\ [100px010py001pz0001]
.PP
\ 
.PP
Then a rotation matrix is created by computing a column\-vector rotation
matrix from the unit quaternion specified by \f[CR]orientation\f[R]:
\
[1\-2(qy2+qz2)2(qxqy\-qzqw)2(qxqz+qyqw)02(qxqy+qzqw)1\-2(qx2+qz2)2(qyqz\-qxqw)02(qxqz\-qyqw)2(qyqz+qxqw)1\-2(qx2+qy2)00001]
.PP
\ 
.PP
The final transform \f[CR]matrix\f[R] is calculated by multiplying the
translation matrix by the rotation matrix, in the order
\f[CR](translation * rotation)\f[R].
This yields the final transform matrix as returned by \f[CR]matrix\f[R]:
\
[1\-2(qy2+qz2)2(qxqy\-qzqw)2(qxqz+qyqw)px2(qxqy+qzqw)1\-2(qx2+qz2)2(qyqz\-qxqw)py2(qxqz\-qyqw)2(qyqz+qxqw)1\-2(qx2+qy2)pz0001]
.PP
\ 
.SH EXAMPLES
In this example, a transform is created to create a matrix which can be
used as a transform during rendering of WebGL objects, in order to place
objects to match a given offset and orientation.
The \f[CR]matrix\f[R] is then passed into a library function that uses
WebGL to render an object matching a given name using the transform
matrix specified to position and orient it.
.IP
.EX
\f[B]let\f[R] transform = \f[B]new\f[R] XRRigidTransform(
  { x: 0, y: 0.5, z: 0.5 },
  { x: 0, y: \-0.5, z: \-0.5, w: 1 },
);
drawGLObject(\[dq]magic\-lamp\[dq], transform.matrix);
.EE
