.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "INTL.NUMBERFORMAT.FORMATTOPARTS" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.NumberFormat.formatToParts \-
Intl.NumberFormat.prototype.formatToParts()
.SH SYNOPSIS
The \f[B]\f[CB]formatToParts()\f[B]\f[R] method of
\f[CR]Intl.NumberFormat\f[R] instances returns an array of objects
representing each part of the formatted string that would be returned by
\f[CR]format()\f[R].
It is useful for building custom strings from the locale\-specific
tokens.
.IP
.EX
\f[B]const\f[R] amount = 654321.987;
\f[B]const\f[R] options = { style: \(dqcurrency\(dq, currency: \(dqUSD\(dq };
\f[B]const\f[R] numberFormat = \f[B]new\f[R] Intl.NumberFormat(\(dqen\-US\(dq, options);

\f[B]const\f[R] parts = numberFormat.formatToParts(amount);
\f[B]const\f[R] partValues = parts.map((p) \f[B]=>\f[R] p.value);

console.log(partValues);
\f[I]// Expected output: \(dq[\(dq$\(dq, \(dq654\(dq, \(dq,\(dq, \(dq321\(dq, \(dq.\(dq, \(dq99\(dq]\(dq\f[R]
.EE
.SH SYNTAX
.IP
.EX
formatToParts(number)
.EE
.SS Parameters
.TP
\f[B]number\f[R]
A \f[CR]Number\f[R], \f[CR]BigInt\f[R], or string, to format.
Strings are parsed in the same way as in number conversion, except that
\f[CR]formatToParts()\f[R] will use the exact value that the string
represents, avoiding loss of precision during implicitly conversion to a
number.
.SS Return value
An \f[CR]Array\f[R] of objects containing the formatted number in parts.
Each object has two properties, \f[CR]type\f[R] and \f[CR]value\f[R],
each containing a string.
The string concatenation of \f[CR]value\f[R], in the order provided,
will result in the same string as \f[CR]format()\f[R].
The \f[CR]type\f[R] may be one of the following:
.TP
\f[B]literal\f[R]
Any string that\(cqs a part of the format pattern; for example
\f[CR]\(dq \(dq\f[R].
Note that common tokens like the decimal separator or the plus/minus
signs have their own token types.
.TP
\f[B]integer\f[R]
The integral part of the number, or a segment of it if using grouping
(controlled by \f[CR]options.useGrouping\f[R]).
.TP
\f[B]group\f[R]
The group separator string, such as \f[CR]\(dq,\(dq\f[R].
Only present when using grouping (controlled by
\f[CR]options.useGrouping\f[R]).
.TP
\f[B]decimal\f[R]
The decimal separator string, such as \f[CR]\(dq.\(dq\f[R].
Only present when \f[CR]fraction\f[R] is present.
.TP
\f[B]fraction\f[R]
The fractional part of the number.
.TP
\f[B]compact\f[R]
The compact exponent, such as \f[CR]\(dqM\(dq\f[R] or
\f[CR]\(dqthousands\(dq\f[R].
Only present when \f[CR]options.notation\f[R] is
\f[CR]\(dqcompact\(dq\f[R].
The form (\f[CR]\(dqshort\(dq\f[R] or \f[CR]\(dqlong\(dq\f[R]) can be
controlled via \f[CR]options.compactDisplay\f[R].
.TP
\f[B]exponentSeparator\f[R]
The exponent separator, such as \f[CR]\(dqE\(dq\f[R].
Only present when \f[CR]options.notation\f[R] is
\f[CR]\(dqscientific\(dq\f[R] or \f[CR]\(dqengineering\(dq\f[R].
.TP
\f[B]exponentMinusSign\f[R]
The exponent minus sign string, such as \f[CR]\(dq\-\(dq\f[R].
Only present when \f[CR]options.notation\f[R] is
\f[CR]\(dqscientific\(dq\f[R] or \f[CR]\(dqengineering\(dq\f[R] and the
exponent is negative.
.TP
\f[B]exponentInteger\f[R]
The exponent\(cqs integer value.
Only present when \f[CR]options.notation\f[R] is
\f[CR]\(dqscientific\(dq\f[R] or \f[CR]\(dqengineering\(dq\f[R].
.TP
\f[B]nan\f[R]
A string representing \f[CR]NaN\f[R], such as \f[CR]\(dqNaN\(dq\f[R].
This is the sole token representing the number itself when the number is
\f[CR]NaN\f[R].
.TP
\f[B]infinity\f[R]
A string representing \f[CR]Infinity\f[R] or \f[CR]\-Infinity\f[R], such
as \f[CR]\(dq∞\(dq\f[R].
This is the sole token representing the number itself when the number is
\f[CR]Infinity\f[R] or \f[CR]\-Infinity\f[R].
.TP
\f[B]plusSign\f[R]
The plus sign, such as \f[CR]\(dq+\(dq\f[R].
.TP
\f[B]minusSign\f[R]
The minus sign, such as \f[CR]\(dq\-\(dq\f[R].
.TP
\f[B]percentSign\f[R]
The percent sign, such as \f[CR]\(dq%\(dq\f[R].
Only present when \f[CR]options.style\f[R] is
\f[CR]\(dqpercent\(dq\f[R].
.TP
\f[B]unit\f[R]
The unit string, such as \f[CR]\(dql\(dq\f[R] or
\f[CR]\(dqlitres\(dq\f[R].
Only present when \f[CR]options.style\f[R] is \f[CR]\(dqunit\(dq\f[R].
The form (\f[CR]\(dqshort\(dq\f[R], \f[CR]\(dqnarrow\(dq\f[R], or
\f[CR]\(dqlong\(dq\f[R]) can be controlled via
\f[CR]options.unitDisplay\f[R].
.TP
\f[B]currency\f[R]
The currency string, such as \f[CR]\(dq$\(dq\f[R], \f[CR]\(dq€\(dq\f[R],
\f[CR]\(dqDollar\(dq\f[R], or \f[CR]\(dqEuro\(dq\f[R].
Only present when \f[CR]options.style\f[R] is
\f[CR]\(dqcurrency\(dq\f[R].
The form (\f[CR]\(dqcode\(dq\f[R], \f[CR]\(dqsymbol\(dq\f[R],
\f[CR]\(dqnarrowSymbol\(dq\f[R], or \f[CR]\(dqname\(dq\f[R]) can be
controlled via \f[CR]options.currencyDisplay\f[R].
.TP
\f[B]unknown\f[R]
Reserved for any token that\(cqs not recognized as one of the above;
should be rarely encountered.
.SH EXAMPLES
.SS Using formatToParts()
The \f[CR]format()\f[R] method outputs localized, opaque strings that
cannot be manipulated directly:
.IP
.EX
\f[B]const\f[R] number = 3500;

\f[B]const\f[R] formatter = \f[B]new\f[R] Intl.NumberFormat(\(dqde\-DE\(dq, {
  style: \(dqcurrency\(dq,
  currency: \(dqEUR\(dq,
});

formatter.format(number);
\f[I]// \(dq3.500,00 €\(dq\f[R]
.EE
.PP
However, in many user interfaces you may want to customize the
formatting of this string, or interleave it with other texts.
The \f[CR]formatToParts()\f[R] method produces the same information in
parts:
.IP
.EX
formatter.formatToParts(number);

\f[I]// return value:\f[R]
[
  { type: \(dqinteger\(dq, value: \(dq3\(dq },
  { type: \(dqgroup\(dq, value: \(dq.\(dq },
  { type: \(dqinteger\(dq, value: \(dq500\(dq },
  { type: \(dqdecimal\(dq, value: \(dq,\(dq },
  { type: \(dqfraction\(dq, value: \(dq00\(dq },
  { type: \(dqliteral\(dq, value: \(dq \(dq },
  { type: \(dqcurrency\(dq, value: \(dq€\(dq },
];
.EE
.PP
Now the information is available separately and it can be formatted and
concatenated again in a customized way.
For example by using \f[CR]Array.prototype.map()\f[R], arrow functions,
a switch statement, template literals, and
\f[CR]Array.prototype.join()\f[R], to insert additional markup for
certain components.
.IP
.EX
\f[B]const\f[R] numberString = formatter
  .formatToParts(number)
  .map(({ type, value }) \f[B]=>\f[R] {
    \f[B]switch\f[R] (type) {
      \f[B]case\f[R] \(dqcurrency\(dq:
        \f[B]return\f[R] \(ga<strong>${value}</strong>\(ga;
      \f[B]default\f[R]:
        \f[B]return\f[R] value;
    }
  })
  .join(\(dq\(dq);

console.log(numberString);
\f[I]// \(dq3.500,00 <strong>€</strong>\(dq\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Intl.NumberFormat\f[R]
.IP \(bu 2
\f[CR]Intl.NumberFormat.prototype.format()\f[R]
