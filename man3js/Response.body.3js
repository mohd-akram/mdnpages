.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Response.body" "JS" "November 22, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Response.body \- Response: body property
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]body\f[B]\f[R] read\-only property of the
\f[CR]Response\f[R] interface is a \f[CR]ReadableStream\f[R] of the body
contents.
.SH VALUE
A \f[CR]ReadableStream\f[R], or else \f[CR]null\f[R] for any
\f[CR]Response\f[R] object constructed with a null \f[CR]body\f[R]
property, or for any actual HTTP response that has no body.
.PP
The stream is a readable byte stream, which supports zero\-copy reading
using a \f[CR]ReadableStreamBYOBReader\f[R].
.RS
.PP
\f[B]Note:\f[R] Current browsers don\[cq]t actually conform to the spec
requirement to set the \f[CR]body\f[R] property to \f[CR]null\f[R] for
responses with no body (for example, responses to \f[CR]HEAD\f[R]
requests, or \f[CR]204 No Content\f[R] responses).
.RE
.SH EXAMPLES
.SS Copying an image
In our \c
.UR https://mdn.github.io/dom-examples/streams/simple-pump/
simple stream pump
.UE \c
\ example we fetch an image, expose the response\[cq]s stream using
\f[CR]response.body\f[R], create a reader using
\f[CR]ReadableStream.getReader()\f[R], then enqueue that stream\[cq]s
chunks into a second, custom readable stream \[em] effectively creating
an identical copy of the image.
.IP
.EX
\f[B]const\f[R] image = document.getElementById(\[dq]target\[dq]);

\f[I]// Fetch the original image\f[R]
fetch(\[dq]./tortoise.png\[dq])
  \f[I]// Retrieve its body as ReadableStream\f[R]
  .then((response) \f[B]=>\f[R] response.body)
  .then((body) \f[B]=>\f[R] {
    \f[B]const\f[R] reader = body.getReader();

    \f[B]return\f[R] \f[B]new\f[R] ReadableStream({
      start(controller) {
        \f[B]return\f[R] pump();

        \f[B]function\f[R] pump() {
          \f[B]return\f[R] reader.read().then(({ done, value }) \f[B]=>\f[R] {
            \f[I]// When no more data needs to be consumed, close the stream\f[R]
            \f[B]if\f[R] (done) {
              controller.close();
              \f[B]return\f[R];
            }

            \f[I]// Enqueue the next data chunk into our target stream\f[R]
            controller.enqueue(value);
            \f[B]return\f[R] pump();
          });
        }
      },
    });
  })
  .then((stream) \f[B]=>\f[R] \f[B]new\f[R] Response(stream))
  .then((response) \f[B]=>\f[R] response.blob())
  .then((blob) \f[B]=>\f[R] URL.createObjectURL(blob))
  .then((url) \f[B]=>\f[R] console.log((image.src = url)))
  .catch((err) \f[B]=>\f[R] console.error(err));
.EE
.SS Creating a BYOB reader
In this example we construct a \f[CR]ReadableStreamBYOBReader\f[R] from
the body using
\f[CR]ReadableStream.getReader({mode: \[aq]byob\[aq]})\f[R].
We can then use this reader to implement zero copy transfer of the
response data.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] getProducts(url) {
  \f[B]const\f[R] response = \f[B]await\f[R] fetch(url);
  \f[B]const\f[R] reader = response.body.getReader({ mode: \[dq]byob\[dq] });
  \f[I]// read the response\f[R]
}

getProducts(
  \[dq]https://mdn.github.io/learning\-area/javascript/apis/fetching\-data/can\-store/products.json\[dq],
);
.EE
.SH SEE ALSO
.IP \[bu] 2
Fetch API
.IP \[bu] 2
Streams API
.IP \[bu] 2
ServiceWorker API
