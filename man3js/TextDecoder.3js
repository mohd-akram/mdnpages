.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "TextDecoder" "JS" "March 6, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
TextDecoder \- TextDecoder
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]TextDecoder\f[B]\f[R] interface represents a decoder for
a specific text encoding, such as \f[CR]UTF\-8\f[R],
\f[CR]ISO\-8859\-2\f[R], \f[CR]KOI8\-R\f[R], \f[CR]GBK\f[R], etc.
A decoder takes a stream of bytes as input and emits a stream of code
points.
.SH CONSTRUCTOR
.TP
\f[B]TextDecoder()\f[R]
Returns a newly constructed \f[CR]TextDecoder\f[R] that will generate a
code point stream with the decoding method specified in parameters.
.SH INSTANCE PROPERTIES
\f[I]The \f[CI]TextDecoder\f[I] interface doesn\[cq]t inherit any
properties.\f[R]
.TP
\f[B]TextDecoder.encoding\f[R] \f[I](read\-only)\f[R]
A string containing the name of the decoder, which is a string
describing the method the \f[CR]TextDecoder\f[R] will use.
.TP
\f[B]TextDecoder.fatal\f[R] \f[I](read\-only)\f[R]
A \f[CR]Boolean\f[R] indicating whether the error mode is fatal.
.TP
\f[B]TextDecoder.ignoreBOM\f[R] \f[I](read\-only)\f[R]
A \f[CR]Boolean\f[R] indicating whether the \c
.UR https://www.w3.org/International/questions/qa-byte-order-mark
byte order mark
.UE \c
\ is ignored.
.SH INSTANCE METHODS
\f[I]The \f[CI]TextDecoder\f[I] interface doesn\[cq]t inherit any
methods\f[R].
.TP
\f[B]TextDecoder.decode()\f[R]
Returns a string containing the text decoded with the method of the
specific \f[CR]TextDecoder\f[R] object.
.SH EXAMPLES
.SS Representing text with typed arrays
This example shows how to decode a Chinese/Japanese character
[IMAGE: Chinese character meaning lucky], as represented by five
different typed arrays: \f[CR]Uint8Array\f[R], \f[CR]Int8Array\f[R],
\f[CR]Uint16Array\f[R], \f[CR]Int16Array\f[R], and
\f[CR]Int32Array\f[R].
.IP
.EX
\f[B]let\f[R] utf8decoder = \f[B]new\f[R] TextDecoder(); \f[I]// default \[aq]utf\-8\[aq] or \[aq]utf8\[aq]\f[R]

\f[B]let\f[R] u8arr = \f[B]new\f[R] Uint8Array([240, 160, 174, 183]);
\f[B]let\f[R] i8arr = \f[B]new\f[R] Int8Array([\-16, \-96, \-82, \-73]);
\f[B]let\f[R] u16arr = \f[B]new\f[R] Uint16Array([41200, 47022]);
\f[B]let\f[R] i16arr = \f[B]new\f[R] Int16Array([\-24336, \-18514]);
\f[B]let\f[R] i32arr = \f[B]new\f[R] Int32Array([\-1213292304]);

console.log(utf8decoder.decode(u8arr));
console.log(utf8decoder.decode(i8arr));
console.log(utf8decoder.decode(u16arr));
console.log(utf8decoder.decode(i16arr));
console.log(utf8decoder.decode(i32arr));
.EE
.SS Handling non\-UTF8 text
In this example, we decode the Russian text \[lq]Привет, мир!\[rq],
which means \[lq]Hello, world.\[rq] In our \f[CR]TextDecoder()\f[R]
constructor, we specify the Windows\-1251 character encoding, which is
appropriate for Cyrillic script.
.IP
.EX
\f[B]const\f[R] win1251decoder = \f[B]new\f[R] TextDecoder(\[dq]windows\-1251\[dq]);
\f[B]const\f[R] bytes = \f[B]new\f[R] Uint8Array([
  207, 240, 232, 226, 229, 242, 44, 32, 236, 232, 240, 33,
]);
console.log(win1251decoder.decode(bytes)); \f[I]// Привет, мир!\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
The \f[CR]TextEncoder\f[R] interface describing the inverse operation.
.IP \[bu] 2
A \c
.UR https://github.com/inexorabletash/text-encoding
shim
.UE \c
\ allowing to use this interface in browsers that do not support it.
.IP \[bu] 2
\c
.UR https://nodejs.org/api/util.html#util_class_util_textdecoder
Node.js supports global export from v11.0.0
.UE \c
