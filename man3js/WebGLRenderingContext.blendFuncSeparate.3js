'\" t
.\" Automatically generated by Pandoc 3.4
.\"
.TH "WebGLRenderingContext.blendFuncSeparate" "JS" "September 28, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
WebGLRenderingContext.blendFuncSeparate \- WebGLRenderingContext:
blendFuncSeparate() method
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]WebGLRenderingContext.blendFuncSeparate()\f[B]\f[R]
method of the WebGL API defines which function is used for blending
pixel arithmetic for RGB and alpha components separately.
.SH SYNTAX
.IP
.EX
blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha)
.EE
.SS Parameters
.TP
\f[B]srcRGB\f[R]
A \f[CR]GLenum\f[R] specifying a multiplier for the red, green and blue
(RGB) source blending factors.
The default value is \f[CR]gl.ONE\f[R].
For possible values, see below.
.TP
\f[B]dstRGB\f[R]
A \f[CR]GLenum\f[R] specifying a multiplier for the red, green and blue
(RGB) destination blending factors.
The default value is \f[CR]gl.ZERO\f[R].
For possible values, see below.
.TP
\f[B]srcAlpha\f[R]
A \f[CR]GLenum\f[R] specifying a multiplier for the alpha source
blending factor.
The default value is \f[CR]gl.ONE\f[R].
For possible values, see below.
.TP
\f[B]dstAlpha\f[R]
A \f[CR]GLenum\f[R] specifying a multiplier for the alpha destination
blending factor.
The default value is \f[CR]gl.ZERO\f[R].
For possible values, see below.
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.IP \[bu] 2
If \f[I]srcRGB\f[R], \f[I]dstRGB\f[R], \f[I]srcAlpha\f[R], or
\f[I]dstAlpha\f[R] is not one of the listed possible values, a
\f[CR]gl.INVALID_ENUM\f[R] error is thrown.
.IP \[bu] 2
If a constant color and a constant alpha value are used together as
source (\f[CR]srcRGB\f[R]) and destination (\f[CR]dstRGB\f[R]) factors,
a \f[CR]gl.INVALID_ENUM\f[R] error is thrown.
.SH CONSTANTS
The following constants can be used for \f[I]srcRGB\f[R],
\f[I]dstRGB\f[R], \f[I]srcAlpha\f[R], and \f[I]dstAlpha\f[R]
.PP
The formulas for the blending factors can be described like this (all
RGBA values are between 0 and 1):
.IP \[bu] 2
color(RGB) = (sourceColor * \f[I]srcRGB\f[R]) + (destinationColor *
\f[I]dstRGB\f[R])
.IP \[bu] 2
color(A) = (sourceAlpha * \f[I]srcAlpha\f[R]) + (destinationAlpha *
\f[I]dstAlpha\f[R])
.PP
In the following table, R_S, G_S, B_S, A_S represent respectively the
\f[I]red\f[R], \f[I]green\f[R], \f[I]blue\f[R] and \f[I]alpha\f[R]
component of the source, while R_D, G_D, B_D, A_D represent respectively
the \f[I]red\f[R], \f[I]green\f[R], \f[I]blue\f[R] and \f[I]alpha\f[R]
component of the destination.
Similarly, R_C, G_C, B_C, A_C represent respectively the \f[I]red\f[R],
\f[I]green\f[R], \f[I]blue\f[R] and \f[I]alpha\f[R] component of a
constant color.
They are all values between 0 and 1, included.
.PP
.TS
tab(@);
l l l l.
T{
Constant
T}@T{
RGB factor
T}@T{
Alpha factor
T}@T{
Description
T}
_
T{
\f[CR]gl.ZERO\f[R]
T}@T{
0,0,0
T}@T{
0
T}@T{
Multiplies all colors by 0.
T}
T{
\f[CR]gl.ONE\f[R]
T}@T{
1,1,1,1
T}@T{
1
T}@T{
Multiplies all colors by 1.
T}
T{
\f[CR]gl.SRC_COLOR\f[R]
T}@T{
R~S~, G~S~, B~S~
T}@T{
A~S~
T}@T{
Multiplies all colors by the source colors.
T}
T{
\f[CR]gl.ONE_MINUS_SRC_COLOR\f[R]
T}@T{
1\-R~S~, 1\-G~S~, 1\-B~S~
T}@T{
1\-A~S~
T}@T{
Multiplies all colors by 1 minus each source color.
T}
T{
\f[CR]gl.DST_COLOR\f[R]
T}@T{
R~D~, G~D~, B~D~
T}@T{
A~D~
T}@T{
Multiplies all colors by the destination color.
T}
T{
\f[CR]gl.ONE_MINUS_DST_COLOR\f[R]
T}@T{
1\-R~D~, 1\-G~D~, 1\-B~D~
T}@T{
1\-A~D~
T}@T{
Multiplies all colors by 1 minus each destination color.
T}
T{
\f[CR]gl.SRC_ALPHA\f[R]
T}@T{
A~S~, A~S~, A~S~
T}@T{
A~S~
T}@T{
Multiplies all colors by the source alpha color.
T}
T{
\f[CR]gl.ONE_MINUS_SRC_ALPHA\f[R]
T}@T{
1\-A~S~, 1\-A~S~, 1\-A~S~
T}@T{
1\-A~S~
T}@T{
Multiplies all colors by 1 minus the source alpha color.
T}
T{
\f[CR]gl.DST_ALPHA\f[R]
T}@T{
A~D~, A~D~, A~D~
T}@T{
A~D~
T}@T{
Multiplies all colors by the destination alpha color.
T}
T{
\f[CR]gl.ONE_MINUS_DST_ALPHA\f[R]
T}@T{
1\-A~D~, 1\-A~D~, 1\-A~D~
T}@T{
1\-A~D~
T}@T{
Multiplies all colors by 1 minus the destination alpha color.
T}
T{
\f[CR]gl.CONSTANT_COLOR\f[R]
T}@T{
R~C~, G~C~, B~C~
T}@T{
A~C~
T}@T{
Multiplies all colors by a constant color.
T}
T{
\f[CR]gl.ONE_MINUS_CONSTANT_COLOR\f[R]
T}@T{
1\-R~C~, 1\-G~C~, 1\-B~C~
T}@T{
1\-A~C~
T}@T{
Multiplies all colors by 1 minus a constant color.
T}
T{
\f[CR]gl.CONSTANT_ALPHA\f[R]
T}@T{
A~C~, A~C~, A~C~
T}@T{
A~C~
T}@T{
Multiplies all colors by a constant alpha value.
T}
T{
\f[CR]gl.ONE_MINUS_CONSTANT_ALPHA\f[R]
T}@T{
1\-A~C~, 1\-A~C~, 1\-A~C~
T}@T{
1\-A~C~
T}@T{
Multiplies all colors by 1 minus a constant alpha value.
T}
T{
\f[CR]gl.SRC_ALPHA_SATURATE\f[R]
T}@T{
min(A~S~, 1 \- A~D~), min(A~S~, 1 \- A~D~), min(A~S~, 1 \- A~D~)
T}@T{
1
T}@T{
Multiplies the RGB colors by the smaller of either the source alpha
color or the value of 1 minus the destination alpha color.
The alpha value is multiplied by 1.
T}
.TE
.SH EXAMPLES
To use the blend function, you first have to activate blending with
\f[CR]WebGLRenderingContext.enable()\f[R] with the argument
\f[CR]gl.BLEND\f[R].
.IP
.EX
gl.enable(gl.BLEND);
gl.blendFuncSeparate(gl.SRC_COLOR, gl.DST_COLOR, gl.ONE, gl.ZERO);
.EE
.PP
To get the current blend function, query the \f[CR]BLEND_SRC_RGB\f[R],
\f[CR]BLEND_SRC_ALPHA\f[R], \f[CR]BLEND_DST_RGB\f[R], and
\f[CR]BLEND_DST_ALPHA\f[R] constants which return one of the blend
function constants.
.IP
.EX
gl.enable(gl.BLEND);
gl.blendFuncSeparate(gl.SRC_COLOR, gl.DST_COLOR, gl.ONE, gl.ZERO);
gl.getParameter(gl.BLEND_SRC_RGB) === gl.SRC_COLOR;
\f[I]// true\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]WebGLRenderingContext.blendColor()\f[R]
.IP \[bu] 2
\f[CR]WebGLRenderingContext.blendEquation()\f[R]
