.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "AudioNode.connect" "JS" "April 6, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
AudioNode.connect \- AudioNode: connect() method
.SH SYNOPSIS
The \f[CR]connect()\f[R] method of the \f[CR]AudioNode\f[R] interface
lets you connect one of the node\[cq]s outputs to a target, which may be
either another \f[CR]AudioNode\f[R] (thereby directing the sound data to
the specified node) or an \f[CR]AudioParam\f[R], so that the node\[cq]s
output data is automatically used to change the value of that parameter
over time.
.SH SYNTAX
.IP
.EX
connect(destination)
connect(destination, outputIndex)
connect(destination, outputIndex, inputIndex)
.EE
.SS Parameters
.TP
\f[B]destination\f[R]
The \f[CR]AudioNode\f[R] or \f[CR]AudioParam\f[R] to which to connect.
.TP
\f[B]outputIndex\f[R] \f[I](optional)\f[R]
An index specifying which output of the current \f[CR]AudioNode\f[R] to
connect to the destination.
The index numbers are defined according to the number of output channels
(see Audio channels).
While you can only connect a given output to a given input once
(repeated attempts are ignored), you can connect an output to multiple
inputs by calling \f[CR]connect()\f[R] repeatedly.
This makes fan\-out possible.
The default value is 0.
.TP
\f[B]inputIndex\f[R] \f[I](optional)\f[R]
An index describing which input of the destination you want to connect
the current \f[CR]AudioNode\f[R] to; the default is 0.
The index numbers are defined according to the number of input channels
(see Audio channels).
It is possible to connect an \f[CR]AudioNode\f[R] to another
\f[CR]AudioNode\f[R], which in turn connects back to the first
\f[CR]AudioNode\f[R], creating a cycle.
.SS Return value
If the destination is a node, \f[CR]connect()\f[R] returns a reference
to the destination \f[CR]AudioNode\f[R] object, allowing you to chain
multiple \f[CR]connect()\f[R] calls.
In some browsers, older implementations of this interface return
\f[CR]undefined\f[R].
.PP
If the destination is an \f[CR]AudioParam\f[R], \f[CR]connect()\f[R]
returns \f[CR]undefined\f[R].
.SS Exceptions
.TP
\f[B]IndexSizeError\f[R] \f[B]DOMException\f[R]
Thrown if the value specified as \f[CR]outputIndex\f[R] or
\f[CR]inputIndex\f[R] doesn\[cq]t correspond to an existing input or
output.
.TP
\f[B]InvalidAccessError\f[R] \f[B]DOMException\f[R]
Thrown if the destination node is not part of the same audio context as
the source node.
.TP
\f[B]NotSupportedError\f[R] \f[B]DOMException\f[R]
Thrown if the specified connection would create a cycle (in which the
audio loops back through the same nodes repeatedly) and there are no
\f[CR]DelayNode\f[R] objects in the cycle to prevent the resulting
waveform from getting stuck constructing the same audio frame
indefinitely.
Also thrown if the \f[CR]inputIndex\f[R] parameter is used while the
destination is an \f[CR]AudioParam\f[R].
.SH EXAMPLES
.SS Connecting to an audio input
The most obvious use of the \f[CR]connect()\f[R] method is to direct the
audio output from one node into the audio input of another node for
further processing.
For example, you might send the audio from a
\f[CR]MediaElementAudioSourceNode\f[R]\[em]that is, the audio from an
HTML media element such as \f[CR]<audio>\f[R]\[em]through a band pass
filter implemented using a \f[CR]BiquadFilterNode\f[R] to reduce noise
before then sending the audio along to the speakers.
.PP
This example creates an oscillator, then links it to a gain node, so
that the gain node controls the volume of the oscillator node.
.IP
.EX
const audioCtx = new AudioContext();

const oscillator = audioCtx.createOscillator();
const gainNode = audioCtx.createGain();

oscillator.connect(gainNode);
gainNode.connect(audioCtx.destination);
.EE
.SS AudioParam example
In this example, we will be altering the gain value of a
\f[CR]GainNode\f[R] using an \f[CR]OscillatorNode\f[R] with a slow
frequency value.
This technique is know as an \f[I]LFO\f[R]\-controlled parameter.
.IP
.EX
const audioCtx = new AudioContext();

// create an normal oscillator to make sound
const oscillator = audioCtx.createOscillator();

// create a second oscillator that will be used as an LFO (Low\-frequency
// oscillator), and will control a parameter
const lfo = audioCtx.createOscillator();

// set the frequency of the second oscillator to a low number
lfo.frequency.value = 2.0; // 2Hz: two oscillations per second

// create a gain whose gain AudioParam will be controlled by the LFO
const gain = audioCtx.createGain();

// connect the LFO to the gain AudioParam. This means the value of the LFO
// will not produce any audio, but will change the value of the gain instead
lfo.connect(gain.gain);

// connect the oscillator that will produce audio to the gain
oscillator.connect(gain);

// connect the gain to the destination so we hear sound
gain.connect(audioCtx.destination);

// start the oscillator that will produce audio
oscillator.start();

// start the oscillator that will modify the gain value
lfo.start();
.EE
.SS AudioParam notes
It is possible to connect an \f[CR]AudioNode\f[R] output to more than
one \f[CR]AudioParam\f[R], and more than one AudioNode output to a
single \f[CR]AudioParam\f[R], with multiple calls to
\f[CR]connect()\f[R].
Fan\-in and fan\-out are therefore supported.
.PP
An \f[CR]AudioParam\f[R] will take the rendered audio data from any
\f[CR]AudioNode\f[R] output connected to it and convert it to mono by
down\-mixing (if it is not already mono).
Next, it will mix it together with any other such outputs, and the
intrinsic parameter value (the value the \f[CR]AudioParam\f[R] would
normally have without any audio connections), including any timeline
changes scheduled for the parameter.
.PP
Therefore, it is possible to choose the range in which an
\f[CR]AudioParam\f[R] will change by setting the value of the
\f[CR]AudioParam\f[R] to the central frequency, and to use a
\f[CR]GainNode\f[R] between the audio source and the
\f[CR]AudioParam\f[R] to adjust the range of the \f[CR]AudioParam\f[R]
changes.
.SH SEE ALSO
.IP \[bu] 2
Using the Web Audio API
