.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "FileSystemFileHandle.createSyncAccessHandle" "JS" "October 16, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
FileSystemFileHandle.createSyncAccessHandle \- FileSystemFileHandle:
createSyncAccessHandle() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is only available in Dedicated Web Workers.
.PP
The \f[B]\f[CB]createSyncAccessHandle()\f[B]\f[R] method of the
\f[CR]FileSystemFileHandle\f[R] interface returns a \f[CR]Promise\f[R]
which resolves to a \f[CR]FileSystemSyncAccessHandle\f[R] object that
can be used to synchronously read from and write to a file.
The synchronous nature of this method brings performance advantages, but
it is only usable inside dedicated Web Workers for files within the
origin private file system.
.PP
Creating a \f[CR]FileSystemSyncAccessHandle\f[R] takes an exclusive lock
on the file associated with the file handle.
This prevents the creation of further
\f[CR]FileSystemSyncAccessHandle\f[R]s or
\f[CR]FileSystemWritableFileStream\f[R]s for the file until the existing
access handle is closed.
.SH SYNTAX
.IP
.EX
createSyncAccessHandle()
createSyncAccessHandle(options)
.EE
.SS Parameters
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object with the following properties:
.RS
.TP
\f[B]mode\f[R] \f[I](optional)\f[R] \f[I](non\-standard)\f[R]
A string specifying the locking mode for the access handle.
The default value is \f[CR]\[dq]readwrite\[dq]\f[R].
Possible values are:
.RS
.TP
\f[B]\[dq]read\-only\[dq]\f[R]
Multiple \f[CR]FileSystemSyncAccessHandle\f[R] objects can be opened
simultaneously on a file (for example when using the same app in
multiple tabs), provided they are all opened in
\f[CR]\[dq]read\-only\[dq]\f[R] mode.
Once opened, read\-like methods can be called on the handles \[em]
\f[CR]read()\f[R], \f[CR]getSize()\f[R], and \f[CR]close()\f[R].
.TP
\f[B]\[dq]readwrite\[dq]\f[R]
Only one \f[CR]FileSystemSyncAccessHandle\f[R] object can be opened on a
file.
Attempting to open subsequent handles before the first handle is closed
results in a \f[CR]NoModificationAllowedError\f[R] exception being
thrown.
Once opened, any available method can be called on the handle.
.TP
\f[B]\[dq]readwrite\-unsafe\[dq]\f[R]
Multiple \f[CR]FileSystemSyncAccessHandle\f[R] objects can be opened
simultaneously on a file, provided they are all opened in
\f[CR]\[dq]readwrite\-unsafe\[dq]\f[R] mode.
Once opened, any available method can be called on the handles.
.RE
.RE
.SS Return value
A \f[CR]Promise\f[R] which resolves to a
\f[CR]FileSystemSyncAccessHandle\f[R] object.
.SS Exceptions
.TP
\f[B]NotAllowedError\f[R] \f[B]DOMException\f[R]
Thrown if the \f[CR]PermissionStatus.state\f[R] for the handle is not
\f[CR]granted\f[R] in \f[CR]readwrite\f[R] mode.
.TP
\f[B]InvalidStateError\f[R] \f[B]DOMException\f[R]
Thrown if the \f[CR]FileSystemSyncAccessHandle\f[R] object does not
represent a file in the origin private file system.
.TP
\f[B]NotFoundError\f[R] \f[B]DOMException\f[R]
Thrown if current entry is not found.
.TP
\f[B]NoModificationAllowedError\f[R] \f[B]DOMException\f[R]
Thrown if the browser is not able to acquire a lock on the file
associated with the file handle.
This could be because \f[CR]mode\f[R] is set to \f[CR]readwrite\f[R] and
an attempt is made to open multiple handles simultaneously.
.SH EXAMPLES
.SS Basic usage
The following asynchronous event handler function is contained inside a
Web Worker.
The snippet inside it creates a synchronous file access handle.
.IP
.EX
onmessage = \f[B]async\f[R] (e) \f[B]=>\f[R] {
  \f[I]// Retrieve message sent to work from main script\f[R]
  \f[B]const\f[R] message = e.data;

  \f[I]// Get handle to draft file\f[R]
  \f[B]const\f[R] root = \f[B]await\f[R] navigator.storage.getDirectory();
  \f[B]const\f[R] draftHandle = \f[B]await\f[R] root.getFileHandle(\[dq]draft.txt\[dq], { create: \f[B]true\f[R] });
  \f[I]// Get sync access handle\f[R]
  \f[B]const\f[R] accessHandle = \f[B]await\f[R] draftHandle.createSyncAccessHandle();

  \f[I]// \&...\f[R]

  \f[I]// Always close FileSystemSyncAccessHandle if done.\f[R]
  accessHandle.close();
};
.EE
.SS Complete example with \f[CR]mode\f[R] option
Our \c
.UR https://createsyncaccesshandle-mode-test.glitch.me/
\f[CR]createSyncAccessHandle()\f[R] mode test
.UE \c
\ example provides an \f[CR]<input>\f[R] field to enter text into, and
two buttons \[em] one to write entered text to the end of a file in the
origin private file system, and one to empty the file when it becomes
too full.
.PP
Try exploring the demo above, with the browser developer console open so
you can see what is happening.
If you try opening the demo in multiple browser tabs, you will find that
multiple handles can be opened at once to write to the file at the same
time.
This is because \f[CR]mode: \[dq]readwrite\-unsafe\[dq]\f[R] is set on
the \f[CR]createSyncAccessHandle()\f[R] calls.
.PP
Below we\[cq]ll explore the code.
.SS HTML
The two \f[CR]<button>\f[R] elements and text \f[CR]<input>\f[R] field
look like this:
.IP
.EX
<\f[B]ol\f[R]>
  <\f[B]li\f[R]>
    <\f[B]label\f[R] for=\[dq]file\-text\[dq]>Enter text to write to the file:</\f[B]label\f[R]>
    <\f[B]input\f[R] type=\[dq]text\[dq] id=\[dq]file\-text\[dq] name=\[dq]file\-text\[dq] />
  </\f[B]li\f[R]>
  <\f[B]li\f[R]>
    Write your text to the file: <\f[B]button\f[R] class=\[dq]write\[dq]>Write text</\f[B]button\f[R]>
  </\f[B]li\f[R]>
  <\f[B]li\f[R]>
    Empty the file if it gets too full:
    <\f[B]button\f[R] class=\[dq]empty\[dq]>Empty file</\f[B]button\f[R]>
  </\f[B]li\f[R]>
</\f[B]ol\f[R]>
.EE
.SS Main JavaScript
The main thread JavaScript inside the HTML file is shown below.
We grab references to the write text button, empty file button, and text
input field, then we create a new web worker using the
\f[CR]Worker()\f[R] constructor.
We then define two functions and set them as event handlers on the
buttons:
.IP \[bu] 2
\f[CR]writeToOPFS()\f[R] is run when the write text button is clicked.
This function posts the entered value of the text field to the worker
inside an object using the \f[CR]Worker.postMessage()\f[R] method, then
empties the text field, ready for the next addition.
Note how the passed object also includes a
\f[CR]command: \[dq]write\[dq]\f[R] property to specify that we want to
trigger a write action with this message.
.IP \[bu] 2
\f[CR]emptyOPFS()\f[R] is run when the empty file button is clicked.
This posts an object containing a \f[CR]command: \[dq]empty\[dq]\f[R]
property to the worker specifying that the file is to be emptied.
.IP
.EX
\f[B]const\f[R] writeBtn = document.querySelector(\[dq].write\[dq]);
\f[B]const\f[R] emptyBtn = document.querySelector(\[dq].empty\[dq]);
\f[B]const\f[R] fileText = document.querySelector(\[dq]#file\-text\[dq]);

\f[B]const\f[R] opfsWorker = \f[B]new\f[R] Worker(\[dq]worker.js\[dq]);

\f[B]function\f[R] writeToOPFS() {
  opfsWorker.postMessage({
    command: \[dq]write\[dq],
    content: fileText.value,
  });
  console.log(\[dq]Main script: Text posted to worker\[dq]);
  fileText.value = \[dq]\[dq];
}

\f[B]function\f[R] emptyOPFS() {
  opfsWorker.postMessage({
    command: \[dq]empty\[dq],
  });
}

writeBtn.addEventListener(\[dq]click\[dq], writeToOPFS);
emptyBtn.addEventListener(\[dq]click\[dq], emptyOPFS);
.EE
.SS Worker JavaScript
The worker JavaScript is shown below.
.PP
First, we run a function called \f[CR]initOPFS()\f[R] that gets a
reference to the OPFS root using
\f[CR]StorageManager.getDirectory()\f[R], creates a file and returns its
handle using \f[CR]FileSystemDirectoryHandle.getFileHandle()\f[R], and
then returns a \f[CR]FileSystemSyncAccessHandle\f[R] using
\f[CR]createSyncAccessHandle()\f[R].
This call includes the \f[CR]mode: \[dq]readwrite\-unsafe\[dq]\f[R]
property, allowing multiple handles to access the same file
simultaneously.
.IP
.EX
\f[B]let\f[R] accessHandle;

\f[B]async\f[R] \f[B]function\f[R] initOPFS() {
  \f[B]const\f[R] opfsRoot = \f[B]await\f[R] navigator.storage.getDirectory();
  \f[B]const\f[R] fileHandle = \f[B]await\f[R] opfsRoot.getFileHandle(\[dq]file.txt\[dq], { create: \f[B]true\f[R] });
  accessHandle = \f[B]await\f[R] fileHandle.createSyncAccessHandle({
    mode: \[dq]readwrite\-unsafe\[dq],
  });
}

initOPFS();
.EE
.PP
Inside the worker\[cq]s message event handler function, we first get the
size of the file using \f[CR]getSize()\f[R].
We then check to see whether the data sent in the message includes a
\f[CR]command\f[R] property value of \f[CR]\[dq]empty\[dq]\f[R].
If so, we empty the file using \f[CR]truncate()\f[R] with a value of
\f[CR]0\f[R], and update the file size contained in the \f[CR]size\f[R]
variable.
.PP
If the message data is something else, we:
.IP \[bu] 2
Create a new \f[CR]TextEncoder\f[R] and \f[CR]TextDecoder\f[R] to handle
encoding and decoding the text content later on.
.IP \[bu] 2
Encode the message data and write the result to the end of the file
using \f[CR]write()\f[R], then update the file size contained in the
\f[CR]size\f[R] variable.
.IP \[bu] 2
Create a \f[CR]DataView\f[R] to contain the file contents, and read the
content into it using \f[CR]read()\f[R].
.IP \[bu] 2
Decode the \f[CR]DataView\f[R] contents and log it to the console.
.IP
.EX
onmessage = \f[B]function\f[R] (e) {
  console.log(\[dq]Worker: Message received from main script\[dq]);

  \f[I]// Get the current size of the file\f[R]
  \f[B]let\f[R] size = accessHandle.getSize();

  \f[B]if\f[R] (e.data.command === \[dq]empty\[dq]) {
    \f[I]// Truncate the file to 0 bytes\f[R]
    accessHandle.truncate(0);

    \f[I]// Get the current size of the file\f[R]
    size = accessHandle.getSize();
  } \f[B]else\f[R] {
    \f[B]const\f[R] textEncoder = \f[B]new\f[R] TextEncoder();
    \f[B]const\f[R] textDecoder = \f[B]new\f[R] TextDecoder();

    \f[I]// Encode content to write to the file\f[R]
    \f[B]const\f[R] content = textEncoder.encode(e.data.content);
    \f[I]// Write the content at the end of the file\f[R]
    accessHandle.write(content, { at: size });

    \f[I]// Get the current size of the file\f[R]
    size = accessHandle.getSize();

    \f[I]// Prepare a data view of the length of the file\f[R]
    \f[B]const\f[R] dataView = \f[B]new\f[R] DataView(\f[B]new\f[R] ArrayBuffer(size));

    \f[I]// Read the entire file into the data view\f[R]
    accessHandle.read(dataView, { at: 0 });

    \f[I]// Log the current file contents to the console\f[R]
    console.log(\[dq]File contents: \[dq] + textDecoder.decode(dataView));

    \f[I]// Flush the changes\f[R]
    accessHandle.flush();
  }

  \f[I]// Log the size of the file to the console\f[R]
  console.log(\[dq]Size: \[dq] + size);
};
.EE
.SH SEE ALSO
.IP \[bu] 2
File System API
.IP \[bu] 2
\c
.UR https://developer.chrome.com/docs/capabilities/web-apis/file-system-access
The File System Access API: simplifying access to local files
.UE \c
