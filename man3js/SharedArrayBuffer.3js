.\" Automatically generated by Pandoc 3.4
.\"
.TH "SharedArrayBuffer" "JS" "December 23, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SharedArrayBuffer \- SharedArrayBuffer
.SH SYNOPSIS
The \f[B]\f[CB]SharedArrayBuffer\f[B]\f[R] object is used to represent a
generic raw binary data buffer, similar to the \f[CR]ArrayBuffer\f[R]
object, but in a way that they can be used to create views on shared
memory.
A \f[CR]SharedArrayBuffer\f[R] is not a Transferable Object, unlike an
\f[CR]ArrayBuffer\f[R] which is transferable.
.SH DESCRIPTION
To share memory using \f[CR]SharedArrayBuffer\f[R] objects from one
agent in the cluster to another (an agent is either the web page\[cq]s
main program or one of its web workers), \f[CR]postMessage\f[R] and
structured cloning is used.
.PP
The structured clone algorithm accepts \f[CR]SharedArrayBuffer\f[R]
objects and typed arrays mapped onto \f[CR]SharedArrayBuffer\f[R]
objects.
In both cases, the \f[CR]SharedArrayBuffer\f[R] object is transmitted to
the receiver resulting in a new, private \f[CR]SharedArrayBuffer\f[R]
object in the receiving agent (just as for \f[CR]ArrayBuffer\f[R]).
However, the shared data block referenced by the two
\f[CR]SharedArrayBuffer\f[R] objects is the same data block, and a side
effect to the block in one agent will eventually become visible in the
other agent.
.IP
.EX
\f[B]const\f[R] sab = \f[B]new\f[R] SharedArrayBuffer(1024);
worker.postMessage(sab);
.EE
.PP
Shared memory can be created and updated simultaneously in workers or
the main thread.
Depending on the system (the CPU, the OS, the Browser) it can take a
while until the change is propagated to all contexts.
To synchronize, atomic operations are needed.
.PP
\f[CR]SharedArrayBuffer\f[R] objects are used by some web APIs, such as:
.IP \[bu] 2
\f[CR]WebGLRenderingContext.bufferData()\f[R]
.IP \[bu] 2
\f[CR]WebGLRenderingContext.bufferSubData()\f[R]
.IP \[bu] 2
\f[CR]WebGL2RenderingContext.getBufferSubData()\f[R]
.SS Security requirements
Shared memory and high\-resolution timers were effectively \c
.UR https://blog.mozilla.org/security/2018/01/03/mitigations-landing-new-class-timing-attack/
disabled at the start of 2018
.UE \c
\ in light of \c
.UR https://en.wikipedia.org/wiki/Spectre_(security_vulnerability)
Spectre
.UE \c
\&.
In 2020, a new, secure approach has been standardized to re\-enable
shared memory.
.PP
To use shared memory your document must be in a secure context and
cross\-origin isolated.
You can use the \f[CR]Window.crossOriginIsolated\f[R] and
\f[CR]WorkerGlobalScope.crossOriginIsolated\f[R] properties to check if
the document is cross\-origin isolated:
.IP
.EX
\f[B]const\f[R] myWorker = \f[B]new\f[R] Worker(\[dq]worker.js\[dq]);

\f[B]if\f[R] (crossOriginIsolated) {
  \f[B]const\f[R] buffer = \f[B]new\f[R] SharedArrayBuffer(16);
  myWorker.postMessage(buffer);
} \f[B]else\f[R] {
  \f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(16);
  myWorker.postMessage(buffer);
}
.EE
.PP
When cross\-origin isolated, \f[CR]postMessage()\f[R] no longer throws
for \f[CR]SharedArrayBuffer\f[R] objects, and shared memory across
threads is therefore available.
.SS API availability
Depending on whether the above security measures are taken, the various
memory\-sharing APIs have different availabilities:
.IP \[bu] 2
The \f[CR]Atomics\f[R] object is always available.
.IP \[bu] 2
\f[CR]SharedArrayBuffer\f[R] objects are in principle always available,
but unfortunately the constructor on the global object is hidden, unless
the two headers mentioned above are set, for compatibility with web
content.
There is hope that this restriction can be removed in the future.
\f[CR]WebAssembly.Memory\f[R] can still be used to get an instance.
.IP \[bu] 2
Unless the two headers mentioned above are set, the various
\f[CR]postMessage()\f[R] APIs will throw for
\f[CR]SharedArrayBuffer\f[R] objects.
If they are set, \f[CR]postMessage()\f[R] on \f[CR]Window\f[R] objects
and dedicated workers will function and allow for memory sharing.
.SS WebAssembly shared memory
\f[CR]WebAssembly.Memory\f[R] objects can be created with the
\f[CR]shared\f[R] constructor flag.
When this flag is set to \f[CR]true\f[R], the constructed
\f[CR]Memory\f[R] object can be shared between workers via
\f[CR]postMessage()\f[R], just like \f[CR]SharedArrayBuffer\f[R], and
the backing \f[CR]buffer\f[R] of the \f[CR]Memory\f[R] object is a
\f[CR]SharedArrayBuffer\f[R].
Therefore, the requirements listed above for sharing a
\f[CR]SharedArrayBuffer\f[R] between workers also apply to sharing a
\f[CR]WebAssembly.Memory\f[R].
.PP
The WebAssembly Threads proposal also defines a new set of \c
.UR https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md#atomic-memory-accesses
atomic
.UE \c
\ instructions.
Just as \f[CR]SharedArrayBuffer\f[R] and its methods are unconditionally
enabled (and only sharing between threads is gated on the new headers),
the WebAssembly atomic instructions are also unconditionally allowed.
.SS Growing SharedArrayBuffers
\f[CR]SharedArrayBuffer\f[R] objects can be made growable by including
the \f[CR]maxByteLength\f[R] option when calling the
\f[CR]SharedArrayBuffer()\f[R] constructor.
You can query whether a \f[CR]SharedArrayBuffer\f[R] is growable and
what its maximum size is by accessing its \f[CR]growable\f[R] and
\f[CR]maxByteLength\f[R] properties, respectively.
You can assign a new size to a growable \f[CR]SharedArrayBuffer\f[R]
with a \f[CR]grow()\f[R] call.
New bytes are initialized to 0.
.PP
These features make growing \f[CR]SharedArrayBuffer\f[R]s more efficient
\[em] otherwise, you have to make a copy of the buffer with a new size.
It also gives JavaScript parity with WebAssembly in this regard (Wasm
linear memory can be resized with
\f[CR]WebAssembly.Memory.prototype.grow()\f[R]).
.PP
For security reasons, \f[CR]SharedArrayBuffer\f[R]s cannot be reduced in
size, only grown.
.SH CONSTRUCTOR
.TP
\f[B]SharedArrayBuffer()\f[R]
Creates a new \f[CR]SharedArrayBuffer\f[R] object.
.SH STATIC PROPERTIES
.TP
\f[B]SharedArrayBuffer[Symbol.species]\f[R]
Returns the constructor used to construct return values from
\f[CR]SharedArrayBuffer\f[R] methods.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]SharedArrayBuffer.prototype\f[R]
and shared by all \f[CR]SharedArrayBuffer\f[R] instances.
.TP
\f[B]SharedArrayBuffer.prototype.byteLength\f[R]
The size, in bytes, of the array.
This is established when the array is constructed and can only be
changed using the \f[CR]SharedArrayBuffer.prototype.grow()\f[R] method
if the \f[CR]SharedArrayBuffer\f[R] is growable.
.TP
\f[B]SharedArrayBuffer.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]SharedArrayBuffer\f[R] instances, the initial value is the
\f[CR]SharedArrayBuffer\f[R] constructor.
.TP
\f[B]SharedArrayBuffer.prototype.growable\f[R]
Read\-only.
Returns \f[CR]true\f[R] if the \f[CR]SharedArrayBuffer\f[R] can be
grown, or \f[CR]false\f[R] if not.
.TP
\f[B]SharedArrayBuffer.prototype.maxByteLength\f[R]
The read\-only maximum length, in bytes, that the
\f[CR]SharedArrayBuffer\f[R] can be grown to.
This is established when the array is constructed and cannot be changed.
.TP
\f[B]SharedArrayBuffer.prototype[Symbol.toStringTag]\f[R]
The initial value of the \f[CR][Symbol.toStringTag]\f[R] property is the
string \f[CR]\[dq]SharedArrayBuffer\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH INSTANCE METHODS
.TP
\f[B]SharedArrayBuffer.prototype.grow()\f[R]
Grows the \f[CR]SharedArrayBuffer\f[R] to the specified size, in bytes.
.TP
\f[B]SharedArrayBuffer.prototype.slice()\f[R]
Returns a new \f[CR]SharedArrayBuffer\f[R] whose contents are a copy of
this \f[CR]SharedArrayBuffer\f[R]\[cq]s bytes from \f[CR]begin\f[R],
inclusive, up to \f[CR]end\f[R], exclusive.
If either \f[CR]begin\f[R] or \f[CR]end\f[R] is negative, it refers to
an index from the end of the array, as opposed to from the beginning.
.SH EXAMPLES
.SS Creating a new SharedArrayBuffer
.IP
.EX
\f[B]const\f[R] sab = \f[B]new\f[R] SharedArrayBuffer(1024);
.EE
.SS Slicing the SharedArrayBuffer
.IP
.EX
sab.slice(); \f[I]// SharedArrayBuffer { byteLength: 1024 }\f[R]
sab.slice(2); \f[I]// SharedArrayBuffer { byteLength: 1022 }\f[R]
sab.slice(\-2); \f[I]// SharedArrayBuffer { byteLength: 2 }\f[R]
sab.slice(0, 1); \f[I]// SharedArrayBuffer { byteLength: 1 }\f[R]
.EE
.SS Using it in a WebGL buffer
.IP
.EX
\f[B]const\f[R] canvas = document.querySelector(\[dq]canvas\[dq]);
\f[B]const\f[R] gl = canvas.getContext(\[dq]webgl\[dq]);
\f[B]const\f[R] buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, sab, gl.STATIC_DRAW);
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Atomics\f[R]
.IP \[bu] 2
\f[CR]ArrayBuffer\f[R]
.IP \[bu] 2
JavaScript typed arrays guide
.IP \[bu] 2
Web Workers
.IP \[bu] 2
\c
.UR https://github.com/tc39/proposal-ecmascript-sharedmem/blob/main/TUTORIAL.md
Shared Memory \[en] a brief tutorial
.UE \c
\ in the TC39 ecmascript\-sharedmem proposal
.IP \[bu] 2
\c
.UR https://hacks.mozilla.org/2016/05/a-taste-of-javascripts-new-parallel-primitives/
A Taste of JavaScript\[cq]s New Parallel Primitives
.UE \c
\ on hacks.mozilla.org (2016)
.IP \[bu] 2
\c
.UR https://docs.google.com/document/d/1zDlfvfTJ_9e8Jdc8ehuV4zMEu9ySMCiTGMS9y0GU92k/edit
COOP and COEP explained
.UE \c
\ by the Chrome team (2020)
.IP \[bu] 2
\f[CR]Cross\-Origin\-Opener\-Policy\f[R]
.IP \[bu] 2
\f[CR]Cross\-Origin\-Embedder\-Policy\f[R]
.IP \[bu] 2
\f[CR]Cross\-Origin\-Resource\-Policy\f[R]
.IP \[bu] 2
\f[CR]Window.crossOriginIsolated\f[R] and
\f[CR]WorkerGlobalScope.crossOriginIsolated\f[R]
.IP \[bu] 2
\c
.UR https://developer.chrome.com/blog/enabling-shared-array-buffer/
SharedArrayBuffer updates in Android Chrome 88 and Desktop Chrome 92
.UE \c
\ on developer.chrome.com (2021)
