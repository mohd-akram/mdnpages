.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Array.flat" "JS" "September 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.flat \- Array.prototype.flat()
.SH SYNOPSIS
The \f[B]\f[CB]flat()\f[B]\f[R] method of \f[CR]Array\f[R] instances
creates a new array with all sub\-array elements concatenated into it
recursively up to the specified depth.
.SH SYNTAX
.IP
.EX
flat()
flat(depth)
.EE
.SS Parameters
.TP
\f[B]depth\f[R] \f[I](optional)\f[R]
The depth level specifying how deep a nested array structure should be
flattened.
Defaults to 1.
.SS Return value
A new array with the sub\-array elements concatenated into it.
.SH DESCRIPTION
The \f[CR]flat()\f[R] method is a copying method.
It does not alter \f[CR]this\f[R] but instead returns a shallow copy
that contains the same elements as the ones from the original array.
.PP
The \f[CR]flat()\f[R] method ignores empty slots if the array being
flattened is sparse.
For example, if \f[CR]depth\f[R] is 1, both empty slots in the root
array and in the first level of nested arrays are ignored, but empty
slots in further nested arrays are preserved with the arrays themselves.
.PP
The \f[CR]flat()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
However, its elements must be arrays if they are to be flattened.
.SH EXAMPLES
.SS Flattening nested arrays
.IP
.EX
\f[B]const\f[R] arr1 = [1, 2, [3, 4]];
arr1.flat();
\f[I]// [1, 2, 3, 4]\f[R]

\f[B]const\f[R] arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
\f[I]// [1, 2, 3, 4, [5, 6]]\f[R]

\f[B]const\f[R] arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
\f[I]// [1, 2, 3, 4, 5, 6]\f[R]

\f[B]const\f[R] arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(\f[B]Infinity\f[R]);
\f[I]// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\f[R]
.EE
.SS Using flat() on sparse arrays
The \f[CR]flat()\f[R] method removes empty slots in arrays:
.IP
.EX
\f[B]const\f[R] arr5 = [1, 2, , 4, 5];
console.log(arr5.flat()); \f[I]// [1, 2, 4, 5]\f[R]

\f[B]const\f[R] array = [1, , 3, [\[dq]a\[dq], , \[dq]c\[dq]]];
console.log(array.flat()); \f[I]// [ 1, 3, \[dq]a\[dq], \[dq]c\[dq] ]\f[R]

\f[B]const\f[R] array2 = [1, , 3, [\[dq]a\[dq], , [\[dq]d\[dq], , \[dq]e\[dq]]]];
console.log(array2.flat()); \f[I]// [ 1, 3, \[dq]a\[dq], [\[dq]d\[dq], empty, \[dq]e\[dq]] ]\f[R]
console.log(array2.flat(2)); \f[I]// [ 1, 3, \[dq]a\[dq], \[dq]d\[dq], \[dq]e\[dq]]\f[R]
.EE
.SS Calling flat() on non\-array objects
The \f[CR]flat()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R] and then accesses each property whose key is a
nonnegative integer less than \f[CR]length\f[R].
If the element is not an array, it\[cq]s directly appended to the
result.
If the element is an array, it\[cq]s flattened according to the
\f[CR]depth\f[R] parameter.
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  0: [1, 2],
  \f[I]// Array\-like objects aren\[aq]t flattened\f[R]
  1: { length: 2, 0: 3, 1: 4 },
  2: 5,
  3: 3, \f[I]// ignored by flat() since length is 3\f[R]
};
console.log(Array.prototype.flat.call(arrayLike));
\f[I]// [ 1, 2, { \[aq]0\[aq]: 3, \[aq]1\[aq]: 4, length: 2 }, 5 ]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype.flat\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Indexed collections guide
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.concat()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.flatMap()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.map()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.reduce()\f[R]
