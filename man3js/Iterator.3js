'\" t
.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Iterator" "JS" "August 27, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator \- Iterator
.SH SYNOPSIS
An \f[B]\f[CB]Iterator\f[B]\f[R] object is an object that conforms to
the iterator protocol by providing a \f[CR]next()\f[R] method that
returns an iterator result object.
All built\-in iterators inherit from the \f[CR]Iterator\f[R] class.
The \f[CR]Iterator\f[R] class provides a \f[CR][Symbol.iterator]()\f[R]
method that returns the iterator object itself, making the iterator also
iterable.
It also provides some helper methods for working with iterators.
.SH DESCRIPTION
The following are all built\-in JavaScript iterators:
.IP \[bu] 2
The \f[I]Array Iterator\f[R] returned by
\f[CR]Array.prototype.values()\f[R], \f[CR]Array.prototype.keys()\f[R],
\f[CR]Array.prototype.entries()\f[R],
\f[CR]Array.prototype[Symbol.iterator]()\f[R],
\f[CR]TypedArray.prototype.values()\f[R],
\f[CR]TypedArray.prototype.keys()\f[R],
\f[CR]TypedArray.prototype.entries()\f[R],
\f[CR]TypedArray.prototype[Symbol.iterator]()\f[R], and
\f[CR]arguments[Symbol.iterator]()\f[R].
.IP \[bu] 2
The \f[I]String Iterator\f[R] returned by
\f[CR]String.prototype[Symbol.iterator]()\f[R].
.IP \[bu] 2
The \f[I]Map Iterator\f[R] returned by
\f[CR]Map.prototype.values()\f[R], \f[CR]Map.prototype.keys()\f[R],
\f[CR]Map.prototype.entries()\f[R], and
\f[CR]Map.prototype[Symbol.iterator]()\f[R].
.IP \[bu] 2
The \f[I]Set Iterator\f[R] returned by
\f[CR]Set.prototype.values()\f[R], \f[CR]Set.prototype.keys()\f[R],
\f[CR]Set.prototype.entries()\f[R], and
\f[CR]Set.prototype[Symbol.iterator]()\f[R].
.IP \[bu] 2
The \f[I]RegExp String Iterator\f[R] returned by
\f[CR]RegExp.prototype[Symbol.matchAll]()\f[R] and
\f[CR]String.prototype.matchAll()\f[R].
.IP \[bu] 2
The \f[CR]Generator\f[R] object returned by generator functions.
.IP \[bu] 2
The \f[I]Segments Iterator\f[R] returned by the
\f[CR][Symbol.iterator]()\f[R] method of the \f[CR]Segments\f[R] object
returned by \f[CR]Intl.Segmenter.prototype.segment()\f[R].
.IP \[bu] 2
The \f[I]Iterator Helper\f[R] returned by iterator helper methods such
as \f[CR]Iterator.prototype.filter()\f[R] and
\f[CR]Iterator.prototype.map()\f[R].
.PP
Web APIs may return iterators too.
Some reuse core JavaScript iterators while others define their own
iterators.
For example:
.IP \[bu] 2
Array\-Like objects such as \f[CR]NodeList\f[R] return an \f[I]Array
Iterator\f[R] from their respective methods \f[CR]keys()\f[R],
\f[CR]values()\f[R], \f[CR]entries()\f[R], and
\f[CR][Symbol.iterator]()\f[R].
.IP \[bu] 2
Map\-Like objects from Web APIs such as \f[CR]Headers\f[R] return their
own iterator type like \f[I]Headers Iterator\f[R] from their respective
methods \f[CR]keys()\f[R], \f[CR]values()\f[R], \f[CR]entries()\f[R],
and \f[CR][Symbol.iterator]()\f[R].
.IP \[bu] 2
Set\-Like objects from Web APIs such as \f[CR]FontFaceSet\f[R] return
their own iterator type like \f[I]FontFaceSet Iterator\f[R] from their
respective methods \f[CR]keys()\f[R], \f[CR]values()\f[R],
\f[CR]entries()\f[R], and \f[CR][Symbol.iterator]()\f[R].
.RS
.PP
\f[B]Note:\f[R] \f[CR]NodeIterator\f[R] and other old interfaces are
named as such but do not conform to the iterator protocol or iterable
protocol.
.RE
.PP
Each of these iterators have a distinct prototype object, which defines
the \f[CR]next()\f[R] method used by the particular iterator.
For example, all string iterator objects inherit from a hidden object
\f[CR]StringIteratorPrototype\f[R], which has a \f[CR]next()\f[R] method
that iterates this string by code points.
\f[CR]StringIteratorPrototype\f[R] also has a
\f[CR][Symbol.toStringTag]\f[R] property whose initial value is the
string \f[CR]\[dq]String Iterator\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
Similarly, other iterator prototypes also have their own
\f[CR][Symbol.toStringTag]\f[R] values, which are the same as the names
given above.
.PP
All of these prototype objects inherit from
\f[CR]Iterator.prototype\f[R], which provides a
\f[CR][Symbol.iterator]()\f[R] method that returns the iterator object
itself, making the iterator also iterable.
.SS Iterator helpers
.RS
.PP
\f[B]Note:\f[R] These methods are \f[I]iterator\f[R] helpers, not
\f[I]iterable\f[R] helpers, because the only requirement for an object
to be iterable is just the presence of a \f[CR][Symbol.iterator]()\f[R]
method.
There is no shared prototype to install these methods on.
.RE
.PP
The \f[CR]Iterator\f[R] class itself provides some helper methods for
working with iterators.
For example, you may be tempted to do the following:
.IP
.EX
\f[B]const\f[R] nameToDeposit = \f[B]new\f[R] Map([
  [\[dq]Anne\[dq], 1000],
  [\[dq]Bert\[dq], 1500],
  [\[dq]Carl\[dq], 2000],
]);

\f[B]const\f[R] totalDeposit = [...nameToDeposit.values()].reduce((a, b) \f[B]=>\f[R] a + b);
.EE
.PP
This first converts the iterator returned by
\f[CR]Map.prototype.values()\f[R] to an array, then uses the
\f[CR]Array.prototype.reduce()\f[R] method to calculate the sum.
However, this both creates an intermediate array and iterates the array
twice.
Instead, you can use the \f[CR]reduce()\f[R] method of the iterator
itself:
.IP
.EX
\f[B]const\f[R] totalDeposit = nameToDeposit.values().reduce((a, b) \f[B]=>\f[R] a + b);
.EE
.PP
This method is more efficient, because it only iterates the iterator
once, without memorizing any intermediate values.
Iterator helper methods are necessary to work with infinite iterators:
.IP
.EX
\f[B]function\f[R]* fibonacci() {
  \f[B]let\f[R] current = 1;
  \f[B]let\f[R] next = 1;
  \f[B]while\f[R] (\f[B]true\f[R]) {
    \f[B]yield\f[R] current;
    [current, next] = [next, current + next];
  }
}

\f[B]const\f[R] seq = fibonacci();
\f[B]const\f[R] firstThreeDigitTerm = seq.find((n) \f[B]=>\f[R] n >= 100);
.EE
.PP
You cannot convert \f[CR]seq\f[R] to an array, because it is infinite.
Instead, you can use the \f[CR]find()\f[R] method of the iterator
itself, which only iterates \f[CR]seq\f[R] as far as necessary to find
the first value that satisfies the condition.
.PP
You will find many iterator methods analogous to array methods, such as:
.PP
.TS
tab(@);
lw(36.3n) lw(33.7n).
T{
Iterator method
T}@T{
Array method
T}
_
T{
\f[CR]Iterator.prototype.every()\f[R]
T}@T{
\f[CR]Array.prototype.every()\f[R]
T}
T{
\f[CR]Iterator.prototype.filter()\f[R]
T}@T{
\f[CR]Array.prototype.filter()\f[R]
T}
T{
\f[CR]Iterator.prototype.find()\f[R]
T}@T{
\f[CR]Array.prototype.find()\f[R]
T}
T{
\f[CR]Iterator.prototype.flatMap()\f[R]
T}@T{
\f[CR]Array.prototype.flatMap()\f[R]
T}
T{
\f[CR]Iterator.prototype.forEach()\f[R]
T}@T{
\f[CR]Array.prototype.forEach()\f[R]
T}
T{
\f[CR]Iterator.prototype.map()\f[R]
T}@T{
\f[CR]Array.prototype.map()\f[R]
T}
T{
\f[CR]Iterator.prototype.reduce()\f[R]
T}@T{
\f[CR]Array.prototype.reduce()\f[R]
T}
T{
\f[CR]Iterator.prototype.some()\f[R]
T}@T{
\f[CR]Array.prototype.some()\f[R]
T}
.TE
.PP
\f[CR]Iterator.prototype.drop()\f[R] and
\f[CR]Iterator.prototype.take()\f[R] combined are somewhat analogous to
\f[CR]Array.prototype.slice()\f[R].
.PP
Among these methods, \f[CR]filter()\f[R], \f[CR]flatMap()\f[R],
\f[CR]map()\f[R], \f[CR]drop()\f[R], and \f[CR]take()\f[R] return a new
\f[I]Iterator Helper\f[R] object.
The iterator helper is also an \f[CR]Iterator\f[R] instance, making the
helper methods chainable.
All iterator helper objects inherit from a common prototype object,
which implements the iterator protocol:
.TP
\f[B]next()\f[R]
Calls the \f[CR]next()\f[R] method of the underlying iterator, applies
the helper method to the result, and returns the result.
.TP
\f[B]return()\f[R]
Calls the \f[CR]return()\f[R] method of the underlying iterator, and
returns the result.
.PP
The iterator helper shares the same data source as the underlying
iterator, so iterating the iterator helper causes the underlying
iterator to be iterated as well.
There is no way to \[lq]fork\[rq] an iterator to allow it to be iterated
multiple times.
.IP
.EX
\f[B]const\f[R] it = [1, 2, 3].values();
\f[B]const\f[R] it2 = it.drop(0); \f[I]// Essentially a copy\f[R]
console.log(it.next().value); \f[I]// 1\f[R]
console.log(it2.next().value); \f[I]// 2\f[R]
console.log(it.next().value); \f[I]// 3\f[R]
.EE
.SS Proper iterators
There are two kinds of \[lq]iterators\[rq]: objects that conform to the
iterator protocol (which, at its minimum, only requires the presence of
a \f[CR]next()\f[R] method), and objects that inherit from the
\f[CR]Iterator\f[R] class, which enjoy the helper methods.
They do not entail each other \[em] objects that inherit from
\f[CR]Iterator\f[R] do not automatically become iterators, because the
\f[CR]Iterator\f[R] class does not define a \f[CR]next()\f[R] method.
Instead, the object needs to define a \f[CR]next()\f[R] method itself.
A \f[I]proper iterator\f[R] is one that both conforms to the iterator
protocol and inherits from \f[CR]Iterator\f[R], and most code expect
iterators to be proper iterators and iterables to return proper
iterators.
To create proper iterators, define a class that extends
\f[CR]Iterator\f[R], or use the \f[CR]Iterator.from()\f[R] method.
.IP
.EX
\f[B]class\f[R] MyIterator \f[B]extends\f[R] Iterator {
  next() {
    \f[I]// \&...\f[R]
  }
}

\f[B]const\f[R] myIterator = Iterator.from({
  next() {
    \f[I]// \&...\f[R]
  },
});
.EE
.SH CONSTRUCTOR
.TP
\f[B]Iterator()\f[R] \f[I](experimental)\f[R]
Intended to be extended by other classes that create iterators.
Throws an error when constructed by itself.
.SH STATIC METHODS
.TP
\f[B]Iterator.from()\f[R] \f[I](experimental)\f[R]
Creates a new \f[CR]Iterator\f[R] object from an iterator or iterable
object.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]Iterator.prototype\f[R] and shared
by all \f[CR]Iterator\f[R] instances.
.TP
\f[B]Iterator.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]Iterator\f[R] instances, the initial value is the
\f[CR]Iterator\f[R] constructor.
.TP
\f[B]Iterator.prototype[Symbol.toStringTag]\f[R]
The initial value of the \f[CR][Symbol.toStringTag]\f[R] property is the
string \f[CR]\[dq]Iterator\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.RS
.RS
.PP
\f[B]Note:\f[R] Unlike the \f[CR][Symbol.toStringTag]\f[R] on most
built\-in classes, \f[CR]Iterator.prototype[Symbol.toStringTag]\f[R] is
writable for web compatibility reasons.
.RE
.RE
.SH INSTANCE METHODS
.TP
\f[B]Iterator.prototype.drop()\f[R] \f[I](experimental)\f[R]
Returns a new iterator helper that skips the given number of elements at
the start of this iterator.
.TP
\f[B]Iterator.prototype.every()\f[R] \f[I](experimental)\f[R]
Tests whether all elements produced by the iterator pass the test
implemented by the provided function.
.TP
\f[B]Iterator.prototype.filter()\f[R] \f[I](experimental)\f[R]
Returns a new iterator helper that yields only those elements of the
iterator for which the provided callback function returns
\f[CR]true\f[R].
.TP
\f[B]Iterator.prototype.find()\f[R] \f[I](experimental)\f[R]
Returns the first element produced by the iterator that satisfies the
provided testing function.
If no values satisfy the testing function, \f[CR]undefined\f[R] is
returned.
.TP
\f[B]Iterator.prototype.flatMap()\f[R] \f[I](experimental)\f[R]
Returns a new iterator helper that takes each element in the original
iterator, runs it through a mapping function, and yields elements
returned by the mapping function (which are contained in another
iterator or iterable).
.TP
\f[B]Iterator.prototype.forEach()\f[R] \f[I](experimental)\f[R]
Executes a provided function once for each element produced by the
iterator.
.TP
\f[B]Iterator.prototype.map()\f[R] \f[I](experimental)\f[R]
Returns a new iterator helper that yields elements of the iterator, each
transformed by a mapping function.
.TP
\f[B]Iterator.prototype.reduce()\f[R] \f[I](experimental)\f[R]
Executes a user\-supplied \[lq]reducer\[rq] callback function on each
element produced by the iterator, passing in the return value from the
calculation on the preceding element.
The final result of running the reducer across all elements is a single
value.
.TP
\f[B]Iterator.prototype.some()\f[R] \f[I](experimental)\f[R]
Tests whether at least one element in the iterator passes the test
implemented by the provided function.
It returns a boolean value.
.TP
\f[B]Iterator.prototype.take()\f[R] \f[I](experimental)\f[R]
Returns a new iterator helper that yields the given number of elements
in this iterator and then terminates.
.TP
\f[B]Iterator.prototype.toArray()\f[R] \f[I](experimental)\f[R]
Creates a new \f[CR]Array\f[R] instance populated with the elements
yielded from the iterator.
.TP
\f[B]Iterator.prototype[Symbol.iterator]()\f[R]
Returns the iterator object itself.
This allows iterator objects to also be iterable.
.SH EXAMPLES
.SS Using an iterator as an iterable
All built\-in iterators are also iterable, so you can use them in a
\f[CR]for...of\f[R] loop:
.IP
.EX
\f[B]const\f[R] arrIterator = [1, 2, 3].values();
\f[B]for\f[R] (\f[B]const\f[R] value \f[B]of\f[R] arrIterator) {
  console.log(value);
}
\f[I]// Logs: 1, 2, 3\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#iterator-helpers
Polyfill of \f[CR]Iterator\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]function*\f[R]
.IP \[bu] 2
Iteration protocols
