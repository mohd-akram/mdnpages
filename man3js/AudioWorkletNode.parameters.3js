.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "AudioWorkletNode.parameters" "JS" "March 12, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
AudioWorkletNode.parameters \- AudioWorkletNode: parameters property
.SH SYNOPSIS
\f[B]Secure context\f[R]: This feature is available only in secure
contexts (HTTPS).
.PP
The read\-only \f[B]\f[CB]parameters\f[B]\f[R] property of the
\f[CR]AudioWorkletNode\f[R] interface returns the associated
\f[CR]AudioParamMap\f[R] \[em] that is, a \f[CR]Map\f[R]\-like
collection of \f[CR]AudioParam\f[R] objects.
They are instantiated during creation of the underlying
\f[CR]AudioWorkletProcessor\f[R] according to its
\f[CR]parameterDescriptors\f[R] static getter.
.SH VALUE
The \f[CR]AudioParamMap\f[R] object containing \f[CR]AudioParam\f[R]
instances.
They can be automated in the same way as with default
\f[CR]AudioNode\f[R]s, and their calculated values can be used in the
\f[CR]process\f[R] method of your \f[CR]AudioWorkletProcessor\f[R].
.SH EXAMPLES
To demonstrate creation and usage of custom \f[CR]AudioParam\f[R]s,
we\[cq]ll expand the example from \f[CR]AudioWorkletNode\f[R] page.
There we\[cq]ve created a simple node which outputs white noise.
Here, additionally, we\[cq]ll create a custom gain parameter, so we can
directly change volume of the output (although you could use
\f[CR]GainNode\f[R] to achieve this as well).
.PP
First, we need to define a custom \f[CR]AudioWorkletProcessor\f[R], and
register it.
Note that this should be done in a separate file.
.PP
We expand the processor by adding a static
\f[CR]parameterDescriptors\f[R] getter.
It will be used internally by the \f[CR]AudioWorkletNode\f[R]
constructor to populate its \f[CR]parameters\f[R] with instantiated
\f[CR]AudioParam\f[R] objects.
.IP
.EX
\f[I]// white\-noise\-processor.js\f[R]
\f[B]class\f[R] WhiteNoiseProcessor \f[B]extends\f[R] AudioWorkletProcessor {
  \f[B]static\f[R] \f[B]get\f[R] parameterDescriptors() {
    \f[B]return\f[R] [
      {
        name: \[dq]customGain\[dq],
        defaultValue: 1,
        minValue: 0,
        maxValue: 1,
        automationRate: \[dq]a\-rate\[dq],
      },
    ];
  }

  process(inputs, outputs, parameters) {
    \f[B]const\f[R] output = outputs[0];
    output.forEach((channel) \f[B]=>\f[R] {
      \f[B]for\f[R] (\f[B]let\f[R] i = 0; i < channel.length; i++) {
        channel[i] =
          (Math.random() * 2 \- 1) *
          (parameters[\[dq]customGain\[dq]].length > 1
            ? parameters[\[dq]customGain\[dq]][i]
            : parameters[\[dq]customGain\[dq]][0]);
        \f[I]// note: a parameter contains an array of 128 values (one value for each of 128 samples),\f[R]
        \f[I]// however it may contain a single value which is to be used for all 128 samples\f[R]
        \f[I]// if no automation is scheduled for the moment.\f[R]
      }
    });
    \f[B]return\f[R] \f[B]true\f[R];
  }
}

registerProcessor(\[dq]white\-noise\-processor\[dq], WhiteNoiseProcessor);
.EE
.PP
Next, in our main scripts file we\[cq]ll load the processor, create an
instance of \f[CR]AudioWorkletNode\f[R] passing it the name of the
processor, and connect the node to an audio graph.
.IP
.EX
\f[B]const\f[R] audioContext = \f[B]new\f[R] AudioContext();
\f[B]await\f[R] audioContext.audioWorklet.addModule(\[dq]white\-noise\-processor.js\[dq]);
\f[B]const\f[R] whiteNoiseNode = \f[B]new\f[R] AudioWorkletNode(
  audioContext,
  \[dq]white\-noise\-processor\[dq],
);
whiteNoiseNode.connect(audioContext.destination);
.EE
.PP
Now we can change the gain on the node like this:
.IP
.EX
\f[B]const\f[R] gainParam = whiteNoiseNode.parameters.get(\[dq]customGain\[dq]);
gainParam.setValueAtTime(0, audioContext.currentTime);
gainParam.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.5);
.EE
.SH SEE ALSO
.IP \[bu] 2
Web Audio API
.IP \[bu] 2
Using the Web Audio API
