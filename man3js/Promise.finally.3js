.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Promise.finally" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Promise.finally \- Promise.prototype.finally()
.SH SYNOPSIS
The \f[B]\f[CB]finally()\f[B]\f[R] method of \f[CR]Promise\f[R]
instances schedules a function to be called when the promise is settled
(either fulfilled or rejected).
It immediately returns another \f[CR]Promise\f[R] object, allowing you
to chain calls to other promise methods.
.PP
This lets you avoid duplicating code in both the promise\[cq]s
\f[CR]then()\f[R] and \f[CR]catch()\f[R] handlers.
.SH SYNTAX
.IP
.EX
promiseInstance.finally(onFinally)
.EE
.SS Parameters
.TP
\f[B]onFinally\f[R]
A function to asynchronously execute when this promise becomes settled.
Its return value is ignored unless the returned value is a rejected
promise.
The function is called with no arguments.
.SS Return value
Returns a new \f[CR]Promise\f[R] immediately.
This new promise is always pending when returned, regardless of the
current promise\[cq]s status.
If \f[CR]onFinally\f[R] throws an error or returns a rejected promise,
the new promise will reject with that value.
Otherwise, the new promise will settle with the same state as the
current promise.
.SH DESCRIPTION
The \f[CR]finally()\f[R] method can be useful if you want to do some
processing or cleanup once the promise is settled, regardless of its
outcome.
.PP
The \f[CR]finally()\f[R] method is very similar to calling
\f[CR]then(onFinally, onFinally)\f[R].
However, there are a couple of differences:
.IP \[bu] 2
When creating a function inline, you can pass it once, instead of being
forced to either declare it twice, or create a variable for it.
.IP \[bu] 2
The \f[CR]onFinally\f[R] callback does not receive any argument.
This use case is for precisely when you \f[I]do not care\f[R] about the
rejection reason or the fulfillment value, and so there\[cq]s no need to
provide it.
.IP \[bu] 2
A \f[CR]finally()\f[R] call is usually transparent and reflects the
eventual state of the original promise.
So for example:
.RS 2
.IP \[bu] 2
Unlike \f[CR]Promise.resolve(2).then(() => 77, () => {})\f[R], which
returns a promise eventually fulfilled with the value \f[CR]77\f[R],
\f[CR]Promise.resolve(2).finally(() => 77)\f[R] returns a promise
eventually fulfilled with the value \f[CR]2\f[R].
.IP \[bu] 2
Similarly, unlike \f[CR]Promise.reject(3).then(() => {}, () => 88)\f[R],
which returns a promise eventually fulfilled with the value
\f[CR]88\f[R], \f[CR]Promise.reject(3).finally(() => 88)\f[R] returns a
promise eventually rejected with the reason \f[CR]3\f[R].
.RE
.RS
.PP
\f[B]Note:\f[R] A \f[CR]throw\f[R] (or returning a rejected promise) in
the \f[CR]finally\f[R] callback still rejects the returned promise.
For example, both
\f[CR]Promise.reject(3).finally(() => { throw 99; })\f[R] and
\f[CR]Promise.reject(3).finally(() => Promise.reject(99))\f[R] reject
the returned promise with the reason \f[CR]99\f[R].
.RE
.PP
Like \f[CR]catch()\f[R], \f[CR]finally()\f[R] internally calls the
\f[CR]then\f[R] method on the object upon which it was called.
If \f[CR]onFinally\f[R] is not a function, \f[CR]then()\f[R] is called
with \f[CR]onFinally\f[R] as both arguments \[em] which, for
\f[CR]Promise.prototype.then()\f[R], means that no useful handler is
attached.
Otherwise, \f[CR]then()\f[R] is called with two internally created
functions, which behave like the following:
.RS
.PP
\f[B]Warning:\f[R] This is only for demonstration purposes and is not a
polyfill.
.RE
.IP
.EX
promise.then(
  (value) \f[B]=>\f[R] Promise.resolve(onFinally()).then(() \f[B]=>\f[R] value),
  (reason) \f[B]=>\f[R]
    Promise.resolve(onFinally()).then(() \f[B]=>\f[R] {
      \f[B]throw\f[R] reason;
    }),
);
.EE
.PP
Because \f[CR]finally()\f[R] calls \f[CR]then()\f[R], it supports
subclassing.
Moreover, notice the \f[CR]Promise.resolve()\f[R] call above \[em] in
reality, \f[CR]onFinally()\f[R]\[cq]s return value is resolved using the
same algorithm as \f[CR]Promise.resolve()\f[R], but the actual
constructor used to construct the resolved promise will be the subclass.
\f[CR]finally()\f[R] gets this constructor through
\f[CR]promise.constructor[Symbol.species]\f[R].
.SH EXAMPLES
.SS Using finally()
.IP
.EX
\f[B]let\f[R] isLoading = \f[B]true\f[R];

fetch(myRequest)
  .then((response) \f[B]=>\f[R] {
    \f[B]const\f[R] contentType = response.headers.get(\[dq]content\-type\[dq]);
    \f[B]if\f[R] (contentType && contentType.includes(\[dq]application/json\[dq])) {
      \f[B]return\f[R] response.json();
    }
    \f[B]throw\f[R] \f[B]new\f[R] TypeError(\[dq]Oops, we haven\[aq]t got JSON!\[dq]);
  })
  .then((json) \f[B]=>\f[R] {
    \f[I]/* process your JSON further */\f[R]
  })
  .catch((error) \f[B]=>\f[R] {
    console.error(error); \f[I]// this line can also throw, e.g. when console = {}\f[R]
  })
  .finally(() \f[B]=>\f[R] {
    isLoading = \f[B]false\f[R];
  });
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-promise
Polyfill of \f[CR]Promise.prototype.finally\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Promise\f[R]
.IP \[bu] 2
\f[CR]Promise.prototype.then()\f[R]
.IP \[bu] 2
\f[CR]Promise.prototype.catch()\f[R]
