.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Intl.DateTimeFormat.formatRangeToParts" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.DateTimeFormat.formatRangeToParts \-
Intl.DateTimeFormat.prototype.formatRangeToParts()
.SH SYNOPSIS
The \f[B]\f[CB]formatRangeToParts()\f[B]\f[R] method of
\f[CR]Intl.DateTimeFormat\f[R] instances returns an array of objects
representing each part of the formatted string that would be returned by
\f[CR]formatRange()\f[R].
It is useful for building custom strings from the locale\-specific
tokens.
.IP
.EX
\f[B]const\f[R] startDate = \f[B]new\f[R] Date(Date.UTC(2007, 0, 10, 10, 0, 0)); \f[I]// > \[aq]Wed, 10 Jan 2007 10:00:00 GMT\[aq]\f[R]
\f[B]const\f[R] endDate = \f[B]new\f[R] Date(Date.UTC(2007, 0, 10, 11, 0, 0)); \f[I]// > \[aq]Wed, 10 Jan 2007 11:00:00 GMT\[aq]\f[R]

\f[B]const\f[R] dateTimeFormat = \f[B]new\f[R] Intl.DateTimeFormat(\[dq]en\[dq], {
  hour: \[dq]numeric\[dq],
  minute: \[dq]numeric\[dq],
});

\f[B]const\f[R] parts = dateTimeFormat.formatRangeToParts(startDate, endDate);
\f[B]for\f[R] (\f[B]const\f[R] part \f[B]of\f[R] parts) {
  console.log(part);
}
\f[I]// Expected output (in GMT timezone):\f[R]
\f[I]// Object { type: \[dq]hour\[dq], value: \[dq]2\[dq], source: \[dq]startRange\[dq] }\f[R]
\f[I]// Object { type: \[dq]literal\[dq], value: \[dq]:\[dq], source: \[dq]startRange\[dq] }\f[R]
\f[I]// Object { type: \[dq]minute\[dq], value: \[dq]00\[dq], source: \[dq]startRange\[dq] }\f[R]
\f[I]// Object { type: \[dq]literal\[dq], value: \[dq] \[en] \[dq], source: \[dq]shared\[dq] }\f[R]
\f[I]// Object { type: \[dq]hour\[dq], value: \[dq]3\[dq], source: \[dq]endRange\[dq] }\f[R]
\f[I]// Object { type: \[dq]literal\[dq], value: \[dq]:\[dq], source: \[dq]endRange\[dq] }\f[R]
\f[I]// Object { type: \[dq]minute\[dq], value: \[dq]00\[dq], source: \[dq]endRange\[dq] }\f[R]
\f[I]// Object { type: \[dq]literal\[dq], value: \[dq] \[dq], source: \[dq]shared\[dq] }\f[R]
\f[I]// Object { type: \[dq]dayPeriod\[dq], value: \[dq]AM\[dq], source: \[dq]shared\[dq] }\f[R]
.EE
.SH SYNTAX
.IP
.EX
formatRangeToParts(startDate, endDate)
.EE
.SS Parameters
.TP
\f[B]startDate\f[R]
The start of the date range.
Can be a \f[CR]Date\f[R] or \f[CR]Temporal.PlainDateTime\f[R] object.
Additionally can be a \f[CR]Temporal.PlainTime\f[R],
\f[CR]Temporal.PlainDate\f[R], \f[CR]Temporal.PlainYearMonth\f[R], or
\f[CR]Temporal.PlainMonthDay\f[R] object if the
\f[CR]DateTimeFormat\f[R] object was configured to print at least one
relevant part of the date.
> \f[B]Note:\f[R] > A \f[CR]Temporal.ZonedDateTime\f[R] object will
always throw a \f[CR]TypeError\f[R]; use
\f[CR]Temporal.ZonedDateTime.prototype.toLocaleString()\f[R] or convert
it to a \f[CR]Temporal.PlainDateTime\f[R] object instead.
.TP
\f[B]endDate\f[R]
The end of the date range.
Must have the same type as \f[CR]startDate\f[R].
.SS Return value
An \f[CR]Array\f[R] of objects containing the formatted date range in
parts.
Each object has three properties, \f[CR]type\f[R], \f[CR]value\f[R], and
\f[CR]source\f[R], each containing a string.
The string concatenation of \f[CR]value\f[R], in the order provided,
will result in the same string as \f[CR]formatRange()\f[R].
The \f[CR]type\f[R] may have the same values as
\f[CR]formatToParts()\f[R].
The \f[CR]source\f[R] can be one of the following:
.TP
\f[B]startRange\f[R]
The token is a part of the start date.
.TP
\f[B]endRange\f[R]
The token is a part of the end date.
.TP
\f[B]shared\f[R]
The token is shared between the start and end; for example, if the start
and end dates share the same day period, that token may get reused.
All literals that are part of the range pattern itself, such as the
\f[CR]\[dq] \[en] \[dq]\f[R] separator, are also marked as
\f[CR]shared\f[R].
.PP
If the start and end dates are equivalent at the precision of the
output, then the output has the same list of tokens as calling
\f[CR]formatToParts()\f[R] on the start date, with all tokens marked as
\f[CR]source: \[dq]shared\[dq]\f[R].
.SH EXAMPLES
.SS Using formatRangeToParts()
The \f[CR]formatRange()\f[R] method outputs localized, opaque strings
that cannot be manipulated directly:
.IP
.EX
\f[B]const\f[R] date1 = \f[B]new\f[R] Date(Date.UTC(1906, 0, 10, 10, 0, 0)); \f[I]// Wed, 10 Jan 1906 10:00:00 GMT\f[R]
\f[B]const\f[R] date2 = \f[B]new\f[R] Date(Date.UTC(1906, 0, 10, 11, 0, 0)); \f[I]// Wed, 10 Jan 1906 11:00:00 GMT\f[R]

\f[B]const\f[R] fmt = \f[B]new\f[R] Intl.DateTimeFormat(\[dq]en\[dq], {
  hour: \[dq]numeric\[dq],
  minute: \[dq]numeric\[dq],
});

console.log(fmt.formatRange(date1, date2)); \f[I]// \[aq]10:00 \[en] 11:00 AM\[aq]\f[R]
.EE
.PP
However, in many user interfaces you may want to customize the
formatting of this string, or interleave it with other texts.
The \f[CR]formatRangeToParts()\f[R] method produces the same information
in parts:
.IP
.EX
console.log(fmt.formatRangeToParts(date1, date2));

\f[I]// return value:\f[R]
[
  { type: \[dq]hour\[dq], value: \[dq]10\[dq], source: \[dq]startRange\[dq] },
  { type: \[dq]literal\[dq], value: \[dq]:\[dq], source: \[dq]startRange\[dq] },
  { type: \[dq]minute\[dq], value: \[dq]00\[dq], source: \[dq]startRange\[dq] },
  { type: \[dq]literal\[dq], value: \[dq] \[en] \[dq], source: \[dq]shared\[dq] },
  { type: \[dq]hour\[dq], value: \[dq]11\[dq], source: \[dq]endRange\[dq] },
  { type: \[dq]literal\[dq], value: \[dq]:\[dq], source: \[dq]endRange\[dq] },
  { type: \[dq]minute\[dq], value: \[dq]00\[dq], source: \[dq]endRange\[dq] },
  { type: \[dq]literal\[dq], value: \[dq] \[dq], source: \[dq]shared\[dq] },
  { type: \[dq]dayPeriod\[dq], value: \[dq]AM\[dq], source: \[dq]shared\[dq] },
];
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Intl.DateTimeFormat\f[R]
.IP \[bu] 2
\f[CR]Intl.DateTimeFormat.prototype.formatRange()\f[R]
