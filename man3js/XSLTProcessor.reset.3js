.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "XSLTProcessor.reset" "JS" "August 16, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
XSLTProcessor.reset \- XSLTProcessor: reset() method
.SH SYNOPSIS
The \f[CR]reset()\f[R] method of the \f[CR]XSLTProcessor\f[R] interface
removes all parameters (\f[CR]<xsl:param>\f[R]) and the XSLT stylesheet
from the processor.
The \f[CR]XSLTProcessor\f[R] will then be in its original state when it
was created.
.SH SYNTAX
.IP
.EX
reset()
.EE
.SS Parameters
None.
.SS Return value
None (\f[CR]undefined\f[R]).
.SH EXAMPLES
.SS Using reset()
This example demonstrates how the \f[CR]reset()\f[R] method allows the
same \f[CR]XSLTProcessor\f[R] instance to be reused for multiple
transformations with different stylesheets.
.SS HTML
.IP
.EX
<\f[B]div\f[R] id=\[dq]result\[dq]></\f[B]div\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] xmlString1 = \[ga]
<items>
  <item>Item A</item>
  <item>Item B</item>
</items>
\[ga];

\f[B]const\f[R] xsltString1 = \[ga]
<xsl:stylesheet version=\[dq]1.0\[dq] xmlns:xsl=\[dq]http://www.w3.org/1999/XSL/Transform\[dq]>
  <xsl:template match=\[dq]/\[dq]>
    <ul>
      <xsl:for\-each select=\[dq]items/item\[dq]>
        <li><xsl:value\-of select=\[dq].\[dq]/></li>
      </xsl:for\-each>
    </ul>
  </xsl:template>
</xsl:stylesheet>
\[ga];

\f[B]const\f[R] xmlString2 = \[ga]
<fruits>
  <fruit>Apple</fruit>
  <fruit>Banana</fruit>
</fruits>
\[ga];

\f[B]const\f[R] xsltString2 = \[ga]
<xsl:stylesheet version=\[dq]1.0\[dq] xmlns:xsl=\[dq]http://www.w3.org/1999/XSL/Transform\[dq]>
  <xsl:template match=\[dq]/\[dq]>
    <ol>
      <xsl:for\-each select=\[dq]fruits/fruit\[dq]>
        <li><xsl:value\-of select=\[dq].\[dq]/></li>
      </xsl:for\-each>
    </ol>
  </xsl:template>
</xsl:stylesheet>
\[ga];

\f[B]const\f[R] parser = \f[B]new\f[R] DOMParser();
\f[B]const\f[R] xmlDoc1 = parser.parseFromString(xmlString1, \[dq]application/xml\[dq]);
\f[B]const\f[R] xsltDoc1 = parser.parseFromString(xsltString1, \[dq]application/xml\[dq]);
\f[B]const\f[R] xmlDoc2 = parser.parseFromString(xmlString2, \[dq]application/xml\[dq]);
\f[B]const\f[R] xsltDoc2 = parser.parseFromString(xsltString2, \[dq]application/xml\[dq]);

\f[B]const\f[R] xsltProcessor = \f[B]new\f[R] XSLTProcessor();

\f[I]// Import the first XSLT stylesheet and transform the first XML\f[R]
xsltProcessor.importStylesheet(xsltDoc1);
\f[B]let\f[R] resultFragment = xsltProcessor.transformToFragment(xmlDoc1, document);
document.getElementById(\[dq]result\[dq]).appendChild(resultFragment);

\f[I]// Reset the XSLTProcessor instance\f[R]
xsltProcessor.reset();

\f[I]// Import the second XSLT stylesheet and transform the second XML\f[R]
xsltProcessor.importStylesheet(xsltDoc2);
resultFragment = xsltProcessor.transformToFragment(xmlDoc2, document);
document.getElementById(\[dq]result\[dq]).appendChild(document.createElement(\[dq]hr\[dq]));
document.getElementById(\[dq]result\[dq]).appendChild(resultFragment);
.EE
.SS Result
.SH SEE ALSO
.IP \[bu] 2
\f[CR]XSLTProcessor.getParameter()\f[R]
.IP \[bu] 2
\f[CR]XSLTProcessor.setParameter()\f[R]
.IP \[bu] 2
\f[CR]XSLTProcessor.removeParameter()\f[R]
.IP \[bu] 2
\f[CR]XSLTProcessor.clearParameters()\f[R]
