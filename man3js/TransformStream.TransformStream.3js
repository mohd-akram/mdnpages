.\" Automatically generated by Pandoc 3.4
.\"
.TH "TransformStream.TransformStream" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
TransformStream.TransformStream \- TransformStream: TransformStream()
constructor
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]TransformStream()\f[B]\f[R] constructor creates a new
\f[CR]TransformStream\f[R] object which represents a pair of streams: a
\f[CR]WritableStream\f[R] representing the writable side, and a
\f[CR]ReadableStream\f[R] representing the readable side.
.SH SYNTAX
.IP
.EX
new TransformStream()
new TransformStream(transformer)
new TransformStream(transformer, writableStrategy)
new TransformStream(transformer, writableStrategy, readableStrategy)
.EE
.SS Parameters
.TP
\f[B]transformer\f[R] \f[I](optional)\f[R]
An object representing the \f[CR]transformer\f[R].
If not supplied the resulting stream will be an \f[B]identity transform
stream\f[R] which forwards all chunks written to its writable side to
its readable side, without any changes.
.RS
.PP
The transformer object can contain any of the following methods.
In each method \f[CR]controller\f[R] is an instance of
\f[CR]TransformStreamDefaultController\f[R].
.TP
\f[B]start(controller)\f[R]
Called when the \f[CR]TransformStream\f[R] is constructed.
It is typically used to enqueue chunks using
\f[CR]TransformStreamDefaultController.enqueue()\f[R].
.TP
\f[B]transform(chunk, controller)\f[R]
Called when a chunk written to the writable side is ready to be
transformed, and performs the work of the transformation stream.
It can return a promise to signal success or failure of the write
operation.
If no \f[CR]transform()\f[R] method is supplied, the identity transform
is used, and the chunk will be enqueued with no changes.
.TP
\f[B]flush(controller)\f[R]
Called after all chunks written to the writable side have been
successfully transformed, and the writable side is about to be closed.
.RE
.TP
\f[B]writableStrategy\f[R] \f[I](optional)\f[R]
An object that optionally defines a queuing strategy for the stream.
This takes two parameters:
.RS
.TP
\f[B]highWaterMark\f[R]
A non\-negative integer.
This defines the total number of chunks that can be contained in the
internal queue before backpressure is applied.
.TP
\f[B]size(chunk)\f[R]
A method containing a parameter \f[CR]chunk\f[R].
This indicates the size to use for each chunk, in bytes.
.RE
.TP
\f[B]readableStrategy\f[R] \f[I](optional)\f[R]
An object that optionally defines a queuing strategy for the stream.
This takes two parameters:
.RS
.TP
\f[B]highWaterMark\f[R]
A non\-negative integer.
This defines the total number of chunks that can be contained in the
internal queue before backpressure is applied.
.TP
\f[B]size(chunk)\f[R]
A method containing a parameter \f[CR]chunk\f[R].
This indicates the size to use for each chunk, in bytes.
.RE
.RS
.PP
\f[B]Note:\f[R] You could define your own custom
\f[CR]readableStrategy\f[R] or \f[CR]writableStrategy\f[R], or use an
instance of \f[CR]ByteLengthQueuingStrategy\f[R] or
\f[CR]CountQueuingStrategy\f[R] for the object values.
.RE
.SH EXAMPLES
.SS Transforming text to uppercase
The following example transforms text to uppercase chunk by chunk.
This example is from \c
.UR https://web.dev/articles/streams
Streams\[em]The Definitive Guide
.UE \c
, which has a number of examples of different types of streams.
.IP
.EX
\f[B]function\f[R] upperCaseStream() {
  \f[B]return\f[R] \f[B]new\f[R] TransformStream({
    transform(chunk, controller) {
      controller.enqueue(chunk.toUpperCase());
    },
  });
}

\f[B]function\f[R] appendToDOMStream(el) {
  \f[B]return\f[R] \f[B]new\f[R] WritableStream({
    write(chunk) {
      el.append(chunk);
    },
  });
}

fetch(\[dq]./lorem\-ipsum.txt\[dq]).then((response) \f[B]=>\f[R]
  response.body
    .pipeThrough(\f[B]new\f[R] TextDecoderStream())
    .pipeThrough(upperCaseStream())
    .pipeTo(appendToDOMStream(document.body)),
);
.EE
.SS Creating an identity transform stream
If no \f[CR]transformer\f[R] argument is supplied then the result will
be an identity transform stream which forwards all chunks written to the
writable side to the readable side with no changes.
In the following example an identity transform stream is used to add
buffering to a pipe.
.IP
.EX
\f[B]const\f[R] writableStrategy = \f[B]new\f[R] ByteLengthQueuingStrategy({
  highWaterMark: 1024 * 1024,
});
readableStream
  .pipeThrough(\f[B]new\f[R] TransformStream(\f[B]undefined\f[R], writableStrategy))
  .pipeTo(writableStream);
.EE
