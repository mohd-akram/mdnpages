.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPUBUFFER.MAPASYNC" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPUBuffer.mapAsync \- GPUBuffer: mapAsync() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]mapAsync()\f[B]\f[R] method of the \f[CR]GPUBuffer\f[R]
interface maps the specified range of the \f[CR]GPUBuffer\f[R].
It returns a \f[CR]Promise\f[R] that resolves when the
\f[CR]GPUBuffer\f[R]\(cqs content is ready to be accessed.
While the \f[CR]GPUBuffer\f[R] is mapped it cannot be used in any GPU
commands.
.PP
Once the buffer is successfully mapped (which can be checked via
\f[CR]GPUBuffer.mapState\f[R]), calls to
\f[CR]GPUBuffer.getMappedRange()\f[R] will return an
\f[CR]ArrayBuffer\f[R] containing the \f[CR]GPUBuffer\f[R]\(cqs current
values, to be read and updated by JavaScript as required.
.PP
When you have finished working with the \f[CR]GPUBuffer\f[R] values,
call \f[CR]GPUBuffer.unmap()\f[R] to unmap it, making it accessible to
the GPU again.
.SH SYNTAX
.IP
.EX
mapAsync(mode)
mapAsync(mode, offset, size)
.EE
.SS Parameters
.TP
\f[B]mode\f[R]
A bitwise flag that specifies whether the \f[CR]GPUBuffer\f[R] is mapped
for reading or writing.
Possible values are:
.RS
.TP
\f[B]GPUMapMode.READ\f[R]
The \f[CR]GPUBuffer\f[R] is mapped for reading.
Values can be read, but any changes made to the \f[CR]ArrayBuffer\f[R]
returned by \f[CR]GPUBuffer.getMappedRange()\f[R] will be discarded once
\f[CR]GPUBuffer.unmap()\f[R] is called.
.RS
.PP
Read\-mode mapping can only be used on \f[CR]GPUBuffer\f[R]s that have a
usage of \f[CR]GPUBufferUsage.MAP_READ\f[R] set on them (i.e., when
created with \f[CR]GPUDevice.createBuffer()\f[R]).
.RE
.TP
\f[B]GPUMapMode.WRITE\f[R]
The \f[CR]GPUBuffer\f[R] is mapped for writing.
Values can be read and updated \(em any changes made to the
\f[CR]ArrayBuffer\f[R] returned by \f[CR]GPUBuffer.getMappedRange()\f[R]
will be saved to the \f[CR]GPUBuffer\f[R] once
\f[CR]GPUBuffer.unmap()\f[R] is called.
.RS
.PP
Write\-mode mapping can only be used on \f[CR]GPUBuffer\f[R]s that have
a usage of \f[CR]GPUBufferUsage.MAP_WRITE\f[R] set on them (i.e., when
created with \f[CR]GPUDevice.createBuffer()\f[R]).
.RE
.RE
.TP
\f[B]offset\f[R] \f[I](optional)\f[R]
A number representing the offset, in bytes, from the start of the buffer
to the start of the range to be mapped.
If \f[CR]offset\f[R] is omitted, it defaults to 0.
.TP
\f[B]size\f[R] \f[I](optional)\f[R]
A number representing the size, in bytes, of the range to be mapped.
If \f[CR]size\f[R] is omitted, the range mapped extends to the end of
the \f[CR]GPUBuffer\f[R].
.SS Return value
A \f[CR]Promise\f[R] that resolves to \f[CR]Undefined\f[R] when the
\f[CR]GPUBuffer\f[R]\(cqs content is ready to be accessed.
.SS Validation
The following criteria must be met when calling
\f[B]\f[CB]mapAsync()\f[B]\f[R], otherwise an \f[CR]OperationError\f[R]
\f[CR]DOMException\f[R] is thrown, the promise is rejected, and a
\f[CR]GPUValidationError\f[R] is generated:
.IP \(bu 2
\f[CR]offset\f[R] is a multiple of 8.
.IP \(bu 2
The total range to be mapped (\f[CR]size\f[R] if specified, or
\f[CR]GPUBuffer.size\f[R] \- \f[CR]offset\f[R] if not) is a multiple of
4.
.IP \(bu 2
The total range to be mapped is inside the bounds of the
\f[CR]GPUBuffer\f[R].
.IP \(bu 2
If mode is \f[CR]GPUMapMode.READ\f[R], the \f[CR]GPUBuffer\f[R] has a
usage of \f[CR]GPUBufferUsage.MAP_READ\f[R].
.IP \(bu 2
If mode is \f[CR]GPUMapMode.WRITE\f[R], the \f[CR]GPUBuffer\f[R] has a
usage of \f[CR]GPUBufferUsage.MAP_WRITE\f[R].
.SH EXAMPLES
See the main \f[CR]GPUBuffer\f[R] page for an example.
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
