.\" Automatically generated by Pandoc 3.4
.\"
.TH "WeakRef" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
WeakRef \- WeakRef
.SH SYNOPSIS
A \f[B]\f[CB]WeakRef\f[B]\f[R] object lets you hold a weak reference to
another object, without preventing that object from getting
garbage\-collected.
.SH DESCRIPTION
A \f[CR]WeakRef\f[R] object contains a weak reference to an object,
which is called its \f[I]target\f[R] or \f[I]referent\f[R].
A \f[I]weak reference\f[R] to an object is a reference that does not
prevent the object from being reclaimed by the garbage collector.
In contrast, a normal (or \f[I]strong\f[R]) reference keeps an object in
memory.
When an object no longer has any strong references to it, the JavaScript
engine\[cq]s garbage collector may destroy the object and reclaim its
memory.
If that happens, you can\[cq]t get the object from a weak reference
anymore.
.PP
Because non\-registered symbols are also garbage collectable, they can
also be used as the target of a \f[CR]WeakRef\f[R] object.
However, the use case of this is limited.
.SS Avoid where possible
Correct use of \f[CR]WeakRef\f[R] takes careful thought, and it\[cq]s
best avoided if possible.
It\[cq]s also important to avoid relying on any specific behaviors not
guaranteed by the specification.
When, how, and whether garbage collection occurs is down to the
implementation of any given JavaScript engine.
Any behavior you observe in one engine may be different in another
engine, in another version of the same engine, or even in a slightly
different situation with the same version of the same engine.
Garbage collection is a hard problem that JavaScript engine implementers
are constantly refining and improving their solutions to.
.PP
Here are some specific points included by the authors in the \c
.UR https://github.com/tc39/proposal-weakrefs
proposal
.UE \c
\ that introduced \f[CR]WeakRef\f[R]:
.RS
.PP
\c
.UR https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)
Garbage collectors
.UE \c
\ are complicated.
If an application or library depends on GC cleaning up a WeakRef or
calling a finalizer [cleanup callback] in a timely, predictable manner,
it\[cq]s likely to be disappointed: the cleanup may happen much later
than expected, or not at all.
Sources of variability include:
.IP \[bu] 2
One object might be garbage\-collected much sooner than another object,
even if they become unreachable at the same time, e.g., due to
generational collection.
.IP \[bu] 2
Garbage collection work can be split up over time using incremental and
concurrent techniques.
.IP \[bu] 2
Various runtime heuristics can be used to balance memory usage,
responsiveness.
.IP \[bu] 2
The JavaScript engine may hold references to things which look like they
are unreachable (e.g., in closures, or inline caches).
.IP \[bu] 2
Different JavaScript engines may do these things differently, or the
same engine may change its algorithms across versions.
.IP \[bu] 2
Complex factors may lead to objects being held alive for unexpected
amounts of time, such as use with certain APIs.
.RE
.SS Notes on WeakRefs
.IP \[bu] 2
If your code has just created a \f[CR]WeakRef\f[R] for a target object,
or has gotten a target object from a \f[CR]WeakRef\f[R]\[cq]s
\f[CR]deref\f[R] method, that target object will not be reclaimed until
the end of the current JavaScript \c
.UR https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html#job
job
.UE \c
\ (including any promise reaction jobs that run at the end of a script
job).
That is, you can only \[lq]see\[rq] an object get reclaimed between
turns of the event loop.
This is primarily to avoid making the behavior of any given JavaScript
engine\[cq]s garbage collector apparent in code \[em] because if it
were, people would write code relying on that behavior, which would
break when the garbage collector\[cq]s behavior changed.
(Garbage collection is a hard problem; JavaScript engine implementers
are constantly refining and improving how it works.)
.IP \[bu] 2
If multiple \f[CR]WeakRef\f[R]s have the same target, they\[cq]re
consistent with one another.
The result of calling \f[CR]deref\f[R] on one of them will match the
result of calling \f[CR]deref\f[R] on another of them (in the same job),
you won\[cq]t get the target object from one of them but
\f[CR]undefined\f[R] from another.
.IP \[bu] 2
If the target of a \f[CR]WeakRef\f[R] is also in a
\f[CR]FinalizationRegistry\f[R], the \f[CR]WeakRef\f[R]\[cq]s target is
cleared at the same time or before any cleanup callback associated with
the registry is called; if your cleanup callback calls \f[CR]deref\f[R]
on a \f[CR]WeakRef\f[R] for the object, it will receive
\f[CR]undefined\f[R].
.IP \[bu] 2
You cannot change the target of a \f[CR]WeakRef\f[R], it will always
only ever be the original target object or \f[CR]undefined\f[R] when
that target has been reclaimed.
.IP \[bu] 2
A \f[CR]WeakRef\f[R] might never return \f[CR]undefined\f[R] from
\f[CR]deref\f[R], even if nothing strongly holds the target, because the
garbage collector may never decide to reclaim the object.
.SH CONSTRUCTOR
.TP
\f[B]WeakRef()\f[R]
Creates a new \f[CR]WeakRef\f[R] object.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]WeakRef.prototype\f[R] and shared
by all \f[CR]WeakRef\f[R] instances.
.TP
\f[B]WeakRef.prototype.constructor\f[R] \f[I](optional)\f[R]
The constructor function that created the instance object.
For \f[CR]WeakRef\f[R] instances, the initial value is the
\f[CR]WeakRef\f[R] constructor.
.RS
.RS
.PP
\f[B]Note:\f[R] This property is marked as \[lq]normative optional\[rq]
in the specification, which means a conforming implementation may not
expose the \f[CR]constructor\f[R] property.
This prevents arbitrary code from obtaining the \f[CR]WeakRef\f[R]
constructor and being able to observe garbage collection.
However, all major engines do expose it by default.
.RE
.RE
.TP
\f[B]WeakRef.prototype[Symbol.toStringTag]\f[R]
The initial value of the \f[CR][Symbol.toStringTag]\f[R] property is the
string \f[CR]\[dq]WeakRef\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH INSTANCE METHODS
.TP
\f[B]WeakRef.prototype.deref()\f[R]
Returns the \f[CR]WeakRef\f[R] object\[cq]s target object, or
\f[CR]undefined\f[R] if the target object has been reclaimed.
.SH EXAMPLES
.SS Using a WeakRef object
This example starts a counter shown in a DOM element, stopping when the
element doesn\[cq]t exist anymore:
.IP
.EX
\f[B]class\f[R] Counter {
  constructor(element) {
    \f[I]// Remember a weak reference to the DOM element\f[R]
    \f[B]this\f[R].ref = \f[B]new\f[R] WeakRef(element);
    \f[B]this\f[R].start();
  }

  start() {
    \f[B]if\f[R] (\f[B]this\f[R].timer) {
      \f[B]return\f[R];
    }

    \f[B]this\f[R].count = 0;

    \f[B]const\f[R] tick = () \f[B]=>\f[R] {
      \f[I]// Get the element from the weak reference, if it still exists\f[R]
      \f[B]const\f[R] element = \f[B]this\f[R].ref.deref();
      \f[B]if\f[R] (element) {
        element.textContent = ++\f[B]this\f[R].count;
      } \f[B]else\f[R] {
        \f[I]// The element doesn\[aq]t exist anymore\f[R]
        console.log(\[dq]The element is gone.\[dq]);
        \f[B]this\f[R].stop();
        \f[B]this\f[R].ref = \f[B]null\f[R];
      }
    };

    tick();
    \f[B]this\f[R].timer = setInterval(tick, 1000);
  }

  stop() {
    \f[B]if\f[R] (\f[B]this\f[R].timer) {
      clearInterval(\f[B]this\f[R].timer);
      \f[B]this\f[R].timer = 0;
    }
  }
}

\f[B]const\f[R] counter = \f[B]new\f[R] Counter(document.getElementById(\[dq]counter\[dq]));
setTimeout(() \f[B]=>\f[R] {
  document.getElementById(\[dq]counter\[dq]).remove();
}, 5000);
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]FinalizationRegistry\f[R]
.IP \[bu] 2
\f[CR]WeakSet\f[R]
.IP \[bu] 2
\f[CR]WeakMap\f[R]
