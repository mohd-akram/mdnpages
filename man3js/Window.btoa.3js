.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Window.btoa" "JS" "February 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Window.btoa \- Window: btoa() method
.SH SYNOPSIS
The \f[B]\f[CB]btoa()\f[B]\f[R] method of the \f[CR]Window\f[R]
interface creates a Base64\-encoded ASCII string from a \f[I]binary
string\f[R] (i.e., a string in which each character in the string is
treated as a byte of binary data).
.PP
You can use this method to encode data which may otherwise cause
communication problems, transmit it, then use the
\f[CR]Window.atob()\f[R] method to decode the data again.
For example, you can encode control characters such as ASCII values 0
through 31.
.PP
Also consider using the \f[CR]Uint8Array.prototype.toBase64()\f[R]
method if your data is in a \f[CR]Uint8Array\f[R] object to avoid
creating a string containing raw bytes.
.SH SYNTAX
.IP
.EX
btoa(stringToEncode)
.EE
.SS Parameters
.TP
\f[B]stringToEncode\f[R]
The \f[I]binary string\f[R] to encode.
.SS Return value
An ASCII string containing the Base64 representation of
\f[CR]stringToEncode\f[R].
.SS Exceptions
.TP
\f[B]InvalidCharacterError\f[R] \f[B]DOMException\f[R]
The string contained a character that did not fit in a single byte.
See \[lq]Unicode strings\[rq] below for more detail.
.SH EXAMPLES
.IP
.EX
\f[B]const\f[R] encodedData = window.btoa(\[dq]Hello, world\[dq]); \f[I]// encode a string\f[R]
\f[B]const\f[R] decodedData = window.atob(encodedData); \f[I]// decode the string\f[R]
.EE
.SS Unicode strings
Base64, by design, expects binary data as its input.
In terms of JavaScript strings, this means strings in which the code
point of each character occupies only one byte.
So if you pass a string into \f[CR]btoa()\f[R] containing characters
that occupy more than one byte, you will get an error, because this is
not considered binary data:
.IP
.EX
\f[B]const\f[R] ok = \[dq]a\[dq];
console.log(ok.codePointAt(0).toString(16)); \f[I]//   61: occupies < 1 byte\f[R]

\f[B]const\f[R] notOK = \[dq]âœ“\[dq];
console.log(notOK.codePointAt(0).toString(16)); \f[I]// 2713: occupies > 1 byte\f[R]

console.log(window.btoa(ok)); \f[I]// YQ==\f[R]
console.log(window.btoa(notOK)); \f[I]// error\f[R]
.EE
.PP
Since \f[CR]btoa\f[R] interprets the code points of its input string as
byte values, calling \f[CR]btoa\f[R] on a string will cause a
\[lq]Character Out Of Range\[rq] exception if a character\[cq]s code
point exceeds \f[CR]0xff\f[R].
For use cases where you need to encode arbitrary Unicode text, it is
necessary to first convert the string to its constituent bytes in
UTF\-8, and then encode the bytes.
.PP
The simplest solution is to use \f[CR]TextEncoder\f[R] and
\f[CR]TextDecoder\f[R] to convert between UTF\-8 and single\-byte
representations of the string:
.IP
.EX
\f[B]function\f[R] base64ToBytes(base64) {
  \f[B]const\f[R] binString = atob(base64);
  \f[B]return\f[R] Uint8Array.from(binString, (m) \f[B]=>\f[R] m.codePointAt(0));
}

\f[B]function\f[R] bytesToBase64(bytes) {
  \f[B]const\f[R] binString = Array.from(bytes, (byte) \f[B]=>\f[R]
    String.fromCodePoint(byte),
  ).join(\[dq]\[dq]);
  \f[B]return\f[R] btoa(binString);
}

\f[I]// Usage\f[R]
bytesToBase64(\f[B]new\f[R] TextEncoder().encode(\[dq]a Ä€ ð€€ æ–‡ ðŸ¦„\[dq])); \f[I]// \[dq]YSDEgCDwkICAIOaWhyDwn6aE\[dq]\f[R]
\f[B]new\f[R] TextDecoder().decode(base64ToBytes(\[dq]YSDEgCDwkICAIOaWhyDwn6aE\[dq])); \f[I]// \[dq]a Ä€ ð€€ æ–‡ ðŸ¦„\[dq]\f[R]
.EE
.SS Converting arbitrary binary data
The \f[CR]bytesToBase64\f[R] and \f[CR]base64ToBytes\f[R] functions in
the previous section can be used directly to convert between Base64
strings and \f[CR]Uint8Array\f[R]s.
.PP
For better performance, asynchronous conversion between base64 data URLs
is possible natively within the web platform via the
\f[CR]FileReader\f[R] and \f[CR]fetch\f[R] APIs:
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] bytesToBase64DataUrl(bytes, type = \[dq]application/octet\-stream\[dq]) {
  \f[B]return\f[R] \f[B]await\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
    \f[B]const\f[R] reader = Object.assign(\f[B]new\f[R] FileReader(), {
      onload: () \f[B]=>\f[R] resolve(reader.result),
      onerror: () \f[B]=>\f[R] reject(reader.error),
    });
    reader.readAsDataURL(\f[B]new\f[R] File([bytes], \[dq]\[dq], { type }));
  });
}

\f[B]async\f[R] \f[B]function\f[R] dataUrlToBytes(dataUrl) {
  \f[B]const\f[R] res = \f[B]await\f[R] fetch(dataUrl);
  \f[B]return\f[R] \f[B]new\f[R] Uint8Array(\f[B]await\f[R] res.arrayBuffer());
}

\f[I]// Usage\f[R]
\f[B]await\f[R] bytesToBase64DataUrl(\f[B]new\f[R] Uint8Array([0, 1, 2])); \f[I]// \[dq]data:application/octet\-stream;base64,AAEC\[dq]\f[R]
\f[B]await\f[R] dataUrlToBytes(\[dq]data:application/octet\-stream;base64,AAEC\[dq]); \f[I]// Uint8Array [0, 1, 2]\f[R]
.EE
.RS
.PP
\f[B]Note:\f[R] For supporting environments, also consider the native
\f[CR]Uint8Array.fromBase64()\f[R],
\f[CR]Uint8Array.prototype.toBase64()\f[R], and
\f[CR]Uint8Array.prototype.setFromBase64()\f[R] methods.
.RE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#base64-utility-methods
A polyfill of \f[CR]btoa\f[R]
.UE \c
\ is available in \c
.UR https://github.com/zloirock/core-js
\f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]data\f[R] URLs
.IP \[bu] 2
\f[CR]WorkerGlobalScope.btoa()\f[R]: the same method, but in worker
scopes.
.IP \[bu] 2
\f[CR]Window.atob()\f[R]
.IP \[bu] 2
\f[CR]Uint8Array.prototype.toBase64()\f[R]
.IP \[bu] 2
Base64
