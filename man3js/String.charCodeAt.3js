.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "String.charCodeAt" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.charCodeAt \- String.prototype.charCodeAt()
.SH SYNOPSIS
The \f[B]\f[CB]charCodeAt()\f[B]\f[R] method of \f[CR]String\f[R] values
returns an integer between \f[CR]0\f[R] and \f[CR]65535\f[R]
representing the UTF\-16 code unit at the given index.
.PP
\f[CR]charCodeAt()\f[R] always indexes the string as a sequence of
UTF\-16 code units, so it may return lone surrogates.
To get the full Unicode code point at the given index, use
\f[CR]String.prototype.codePointAt()\f[R].
.SH SYNTAX
.IP
.EX
charCodeAt(index)
.EE
.SS Parameters
.TP
\f[B]index\f[R]
Zero\-based index of the character to be returned.
Converted to an integer \[em] \f[CR]undefined\f[R] is converted to 0.
.SS Return value
An integer between \f[CR]0\f[R] and \f[CR]65535\f[R] representing the
UTF\-16 code unit value of the character at the specified
\f[CR]index\f[R].
If \f[CR]index\f[R] is out of range of \f[CR]0\f[R] \[en]
\f[CR]str.length \- 1\f[R], \f[CR]charCodeAt()\f[R] returns
\f[CR]NaN\f[R].
.SH DESCRIPTION
Characters in a string are indexed from left to right.
The index of the first character is \f[CR]0\f[R], and the index of the
last character in a string called \f[CR]str\f[R] is
\f[CR]str.length \- 1\f[R].
.PP
Unicode code points range from \f[CR]0\f[R] to \f[CR]1114111\f[R]
(\f[CR]0x10FFFF\f[R]).
\f[CR]charCodeAt()\f[R] always returns a value that is less than
\f[CR]65536\f[R], because the higher code points are represented by
\f[I]a pair\f[R] of 16\-bit surrogate pseudo\-characters.
Therefore, in order to get a full character with value greater than
\f[CR]65535\f[R], it is necessary to retrieve not only
\f[CR]charCodeAt(i)\f[R], but also \f[CR]charCodeAt(i + 1)\f[R] (as if
manipulating a string with two characters), or to use
\f[CR]codePointAt(i)\f[R] instead.
For information on Unicode, see UTF\-16 characters, Unicode code points,
and grapheme clusters.
.SH EXAMPLES
.SS Using charCodeAt()
The following example returns \f[CR]65\f[R], the Unicode value for A.
.IP
.EX
\[dq]ABC\[dq].charCodeAt(0); \f[I]// returns 65\f[R]
.EE
.PP
\f[CR]charCodeAt()\f[R] may return lone surrogates, which are not valid
Unicode characters.
.IP
.EX
\f[B]const\f[R] str = \[dq]𠮷𠮾\[dq];
console.log(str.charCodeAt(0)); \f[I]// 55362, or d842, which is not a valid Unicode character\f[R]
console.log(str.charCodeAt(1)); \f[I]// 57271, or dfb7, which is not a valid Unicode character\f[R]
.EE
.PP
To get the full Unicode code point at the given index, use
\f[CR]String.prototype.codePointAt()\f[R].
.IP
.EX
\f[B]const\f[R] str = \[dq]𠮷𠮾\[dq];
console.log(str.codePointAt(0)); \f[I]// 134071\f[R]
.EE
.RS
.PP
\f[B]Note:\f[R] Avoid re\-implementing \f[CR]codePointAt()\f[R] using
\f[CR]charCodeAt()\f[R].
The translation from UTF\-16 surrogates to Unicode code points is
complex, and \f[CR]codePointAt()\f[R] may be more performant as it
directly uses the internal representation of the string.
Install a polyfill for \f[CR]codePointAt()\f[R] if necessary.
.RE
.PP
Below is a possible algorithm to convert a pair of UTF\-16 code units
into a Unicode code point, adapted from the \c
.UR https://unicode.org/faq/utf_bom.html#utf16-3
Unicode FAQ
.UE \c
:
.IP
.EX
\f[I]// constants\f[R]
\f[B]const\f[R] LEAD_OFFSET = 0xd800 \- (0x10000 >> 10);
\f[B]const\f[R] SURROGATE_OFFSET = 0x10000 \- (0xd800 << 10) \- 0xdc00;

\f[B]function\f[R] utf16ToUnicode(lead, trail) {
  \f[B]return\f[R] (lead << 10) + trail + SURROGATE_OFFSET;
}
\f[B]function\f[R] unicodeToUTF16(codePoint) {
  \f[B]const\f[R] lead = LEAD_OFFSET + (codePoint >> 10);
  \f[B]const\f[R] trail = 0xdc00 + (codePoint & 0x3ff);
  \f[B]return\f[R] [lead, trail];
}

\f[B]const\f[R] str = \[dq]𠮷\[dq];
console.log(utf16ToUnicode(str.charCodeAt(0), str.charCodeAt(1))); \f[I]// 134071\f[R]
console.log(str.codePointAt(0)); \f[I]// 134071\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]String.fromCharCode()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.charAt()\f[R]
.IP \[bu] 2
\f[CR]String.fromCodePoint()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.codePointAt()\f[R]
