.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "String.codePointAt" "JS" "July 15, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.codePointAt \- String.prototype.codePointAt()
.SH SYNOPSIS
The \f[B]\f[CB]codePointAt()\f[B]\f[R] method of \f[CR]String\f[R]
values returns a non\-negative integer that is the Unicode code point
value of the character starting at the given index.
Note that the index is still based on UTF\-16 code units, not Unicode
code points.
.SH SYNTAX
.IP
.EX
codePointAt(index)
.EE
.SS Parameters
.TP
\f[B]index\f[R]
Zero\-based index of the character to be returned.
Converted to an integer \[em] \f[CR]undefined\f[R] is converted to 0.
.SS Return value
A non\-negative integer representing the code point value of the
character at the given \f[CR]index\f[R].
.IP \[bu] 2
If \f[CR]index\f[R] is out of the range of \f[CR]0\f[R] \[en]
\f[CR]str.length \- 1\f[R], \f[CR]codePointAt()\f[R] returns
\f[CR]undefined\f[R].
.IP \[bu] 2
If the element at \f[CR]index\f[R] is a UTF\-16 leading surrogate,
returns the code point of the surrogate \f[I]pair\f[R].
.IP \[bu] 2
If the element at \f[CR]index\f[R] is a UTF\-16 trailing surrogate,
returns \f[I]only\f[R] the trailing surrogate code unit.
.SH DESCRIPTION
Characters in a string are indexed from left to right.
The index of the first character is \f[CR]0\f[R], and the index of the
last character in a string called \f[CR]str\f[R] is
\f[CR]str.length \- 1\f[R].
.PP
Unicode code points range from \f[CR]0\f[R] to \f[CR]1114111\f[R]
(\f[CR]0x10FFFF\f[R]).
In UTF\-16, each string index is a code unit with value \f[CR]0\f[R]
\[en] \f[CR]65535\f[R].
Higher code points are represented by \f[I]a pair\f[R] of 16\-bit
surrogate pseudo\-characters.
Therefore, \f[CR]codePointAt()\f[R] returns a code point that may span
two string indices.
For information on Unicode, see UTF\-16 characters, Unicode code points,
and grapheme clusters.
.SH EXAMPLES
.SS Using codePointAt()
.IP
.EX
\[dq]ABC\[dq].codePointAt(0); \f[I]// 65\f[R]
\[dq]ABC\[dq].codePointAt(0).toString(16); \f[I]// 41\f[R]

\[dq]üòç\[dq].codePointAt(0); \f[I]// 128525\f[R]
\[dq]\[rs]ud83d\[rs]ude0d\[dq].codePointAt(0); \f[I]// 128525\f[R]
\[dq]\[rs]ud83d\[rs]ude0d\[dq].codePointAt(0).toString(16); \f[I]// 1f60d\f[R]

\[dq]üòç\[dq].codePointAt(1); \f[I]// 56845\f[R]
\[dq]\[rs]ud83d\[rs]ude0d\[dq].codePointAt(1); \f[I]// 56845\f[R]
\[dq]\[rs]ud83d\[rs]ude0d\[dq].codePointAt(1).toString(16); \f[I]// de0d\f[R]

\[dq]ABC\[dq].codePointAt(42); \f[I]// undefined\f[R]
.EE
.SS Looping with codePointAt()
Because using string indices for looping causes the same code point to
be visited twice (once for the leading surrogate, once for the trailing
surrogate), and the second time \f[CR]codePointAt()\f[R] returns
\f[I]only\f[R] the trailing surrogate, it\[cq]s better to avoid looping
by index.
.PP
\f[B]Bad\f[R]
.IP
.EX
\f[B]const\f[R] str = \[dq]\[rs]ud83d\[rs]udc0e\[rs]ud83d\[rs]udc71\[rs]u2764\[dq];

\f[B]for\f[R] (\f[B]let\f[R] i = 0; i < str.length; i++) {
  console.log(str.codePointAt(i).toString(16));
}
\f[I]// \[aq]1f40e\[aq], \[aq]dc0e\[aq], \[aq]1f471\[aq], \[aq]dc71\[aq], \[aq]2764\[aq]\f[R]
.EE
.PP
Instead, use a \f[CR]for...of\f[R] statement or spread the string, both
of which invoke the string\[cq]s \f[CR][Symbol.iterator]()\f[R], which
iterates by code points.
Then, use \f[CR]codePointAt(0)\f[R] to get the code point of each
element.
.IP
.EX
\f[B]for\f[R] (\f[B]const\f[R] codePoint \f[B]of\f[R] str) {
  console.log(codePoint.codePointAt(0).toString(16));
}
\f[I]// \[aq]1f40e\[aq], \[aq]1f471\[aq], \[aq]2764\[aq]\f[R]

[...str].map((cp) \f[B]=>\f[R] cp.codePointAt(0).toString(16));
\f[I]// [\[aq]1f40e\[aq], \[aq]1f471\[aq], \[aq]2764\[aq]]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-string-and-regexp
Polyfill of \f[CR]String.prototype.codePointAt\f[R] in
\f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]String.fromCodePoint()\f[R]
.IP \[bu] 2
\f[CR]String.fromCharCode()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.charCodeAt()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.charAt()\f[R]
