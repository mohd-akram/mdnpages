.\" Automatically generated by Pandoc 3.4
.\"
.TH "WritableStreamDefaultWriter.close" "JS" "April 22, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
WritableStreamDefaultWriter.close \- WritableStreamDefaultWriter:
close() method
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]close()\f[B]\f[R] method of the
\f[CR]WritableStreamDefaultWriter\f[R] interface closes the associated
writable stream.
.PP
The underlying sink will finish processing any previously\-written
chunks, before invoking the close behavior.
During this time any further attempts to write will fail (without
erroring the stream).
.SH SYNTAX
.IP
.EX
close()
.EE
.SS Parameters
None.
.SS Return value
A \f[CR]Promise\f[R], which fulfills with the \f[CR]undefined\f[R] if
all remaining chunks were successfully written before the close, or
rejects with an error if a problem was encountered during the process.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
The stream you are trying to close is not a \f[CR]WritableStream\f[R].
.SH EXAMPLES
The following example shows the creation of a \f[CR]WritableStream\f[R]
with a custom sink and an API\-supplied queuing strategy.
It then calls a function called \f[CR]sendMessage()\f[R], passing the
newly created stream and a string.
Inside this function it calls the stream\[cq]s \f[CR]getWriter()\f[R]
method, which returns an instance of
\f[CR]WritableStreamDefaultWriter\f[R].
Each chunk of the encoded string is written to the stream using the
\f[CR]write()\f[R] method, and the \f[CR]forEach()\f[R] method of the
encoded \f[CR]Uint8Array\f[R] to process it byte\-by\-byte.
Finally, \f[CR]close()\f[R] is called and the Promise it returns is
handled to deal with success (or any failures) of the chunked write
operations.
.IP
.EX
\f[B]const\f[R] list = document.querySelector(\[dq]ul\[dq]);

\f[B]function\f[R] sendMessage(message, writableStream) {
  \f[I]// defaultWriter is of type WritableStreamDefaultWriter\f[R]
  \f[B]const\f[R] defaultWriter = writableStream.getWriter();
  \f[B]const\f[R] encoder = \f[B]new\f[R] TextEncoder();
  \f[B]const\f[R] encoded = encoder.encode(message);
  encoded.forEach((chunk) \f[B]=>\f[R] {
    defaultWriter.ready
      .then(() \f[B]=>\f[R] {
        defaultWriter.write(chunk);
      })
      .then(() \f[B]=>\f[R] {
        console.log(\[dq]Chunk written to sink.\[dq]);
      })
      .catch((err) \f[B]=>\f[R] {
        console.log(\[dq]Chunk error:\[dq], err);
      });
  });
  \f[I]// Call ready again to ensure that all chunks are written\f[R]
  \f[I]//   before closing the writer.\f[R]
  defaultWriter.ready
    .then(() \f[B]=>\f[R] {
      defaultWriter.close();
    })
    .then(() \f[B]=>\f[R] {
      console.log(\[dq]All chunks written\[dq]);
    })
    .catch((err) \f[B]=>\f[R] {
      console.log(\[dq]Stream error:\[dq], err);
    });
}

\f[B]const\f[R] decoder = \f[B]new\f[R] TextDecoder(\[dq]utf\-8\[dq]);
\f[B]const\f[R] queuingStrategy = \f[B]new\f[R] CountQueuingStrategy({ highWaterMark: 1 });
\f[B]let\f[R] result = \[dq]\[dq];
\f[B]const\f[R] writableStream = \f[B]new\f[R] WritableStream(
  {
    \f[I]// Implement the sink\f[R]
    write(chunk) {
      \f[B]return\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
        \f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(1);
        \f[B]const\f[R] view = \f[B]new\f[R] Uint8Array(buffer);
        view[0] = chunk;
        \f[B]const\f[R] decoded = decoder.decode(view, { stream: \f[B]true\f[R] });
        \f[B]const\f[R] listItem = document.createElement(\[dq]li\[dq]);
        listItem.textContent = \[ga]Chunk decoded: ${decoded}\[ga];
        list.appendChild(listItem);
        result += decoded;
        resolve();
      });
    },
    close() {
      \f[B]const\f[R] listItem = document.createElement(\[dq]li\[dq]);
      listItem.textContent = \[ga][MESSAGE RECEIVED] ${result}\[ga];
      list.appendChild(listItem);
    },
    abort(err) {
      console.log(\[dq]Sink error:\[dq], err);
    },
  },
  queuingStrategy,
);

sendMessage(\[dq]Hello, world.\[dq], writableStream);
.EE
.PP
You can view a live demonstration of this at our \c
.UR https://mdn.github.io/dom-examples/streams/simple-writer/
simple writer example
.UE \c
\&.
