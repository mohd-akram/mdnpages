'\" t
.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Function.prototype" "JS" "February 24, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Function.prototype \- Function: prototype
.SH SYNOPSIS
The \f[B]\f[CB]prototype\f[B]\f[R] data property of a
\f[CR]Function\f[R] instance is used when the function is used as a
constructor with the \f[CR]new\f[R] operator.
It will become the new object\[cq]s prototype.
.RS
.PP
\f[B]Note:\f[R] Not all \f[CR]Function\f[R] objects have the
\f[CR]prototype\f[R] property \[em] see description.
.RE
.SH VALUE
An object.
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
yes
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
no
T}
.TE
.RS
.PP
\f[B]Note:\f[R] Classes are a type of function, so most of the
description here applies to the \f[CR]prototype\f[R] property of classes
too.
The only salient difference is that the \f[CR]prototype\f[R] property of
a class is not writable.
.RE
.SH DESCRIPTION
When a function is called with \f[CR]new\f[R], the constructor\[cq]s
\f[CR]prototype\f[R] property will become the resulting object\[cq]s
prototype.
.IP
.EX
\f[B]function\f[R] Ctor() {}
\f[B]const\f[R] inst = \f[B]new\f[R] Ctor();
console.log(Object.getPrototypeOf(inst) === Ctor.prototype); \f[I]// true\f[R]
.EE
.PP
You can read Inheritance and the prototype chain for more information
about the interactions between a constructor function\[cq]s
\f[CR]prototype\f[R] property and the resulting object\[cq]s prototype.
.PP
A function having a \f[CR]prototype\f[R] property is not sufficient for
it to be eligible as a constructor.
Generator functions have a \f[CR]prototype\f[R] property, but cannot be
called with \f[CR]new\f[R]:
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R]* asyncGeneratorFunction() {}
\f[B]function\f[R]* generatorFunction() {}
.EE
.PP
Instead, generator functions\[cq] \f[CR]prototype\f[R] property is used
when they are called \f[I]without\f[R] \f[CR]new\f[R].
The \f[CR]prototype\f[R] property will become the returned
\f[CR]Generator\f[R] object\[cq]s prototype.
.PP
In addition, some functions may have a \f[CR]prototype\f[R] but throw
unconditionally when called with \f[CR]new\f[R].
For example, the \f[CR]Symbol()\f[R] and \f[CR]BigInt()\f[R] functions
throw when called with \f[CR]new\f[R], because
\f[CR]Symbol.prototype\f[R] and \f[CR]BigInt.prototype\f[R] are only
intended to provide methods for the primitive values, but the wrapper
objects should not be directly constructed.
.PP
The following functions do not have \f[CR]prototype\f[R], and are
therefore ineligible as constructors, even if a \f[CR]prototype\f[R]
property is later manually assigned:
.IP
.EX
\f[B]const\f[R] method = { foo() {} }.foo;
\f[B]const\f[R] arrowFunction = () \f[B]=>\f[R] {};
\f[B]async\f[R] \f[B]function\f[R] asyncFunction() {}
.EE
.PP
The following are valid constructors that have \f[CR]prototype\f[R]:
.IP
.EX
\f[B]class\f[R] Class {}
\f[B]function\f[R] fn() {}
.EE
.PP
A bound function does not have a \f[CR]prototype\f[R] property, but may
be constructable.
When it\[cq]s constructed, the target function is constructed instead,
and if the target function is constructable, it would return a normal
instance.
.IP
.EX
\f[B]const\f[R] boundFunction = \f[B]function\f[R] () {}.bind(\f[B]null\f[R]);
.EE
.PP
A function\[cq]s \f[CR]prototype\f[R] property, by default, is a plain
object with one property: \f[CR]constructor\f[R], which is a reference
to the function itself.
The \f[CR]constructor\f[R] property is writable, non\-enumerable, and
configurable.
.PP
If the \f[CR]prototype\f[R] of a function is reassigned with something
other than an \f[CR]Object\f[R], when the function is called with
\f[CR]new\f[R], the returned object\[cq]s prototype would be
\f[CR]Object.prototype\f[R] instead.
(In other words, \f[CR]new\f[R] ignores the \f[CR]prototype\f[R]
property and constructs a plain object.)
.IP
.EX
\f[B]function\f[R] Ctor() {}
Ctor.prototype = 3;
console.log(Object.getPrototypeOf(\f[B]new\f[R] Ctor()) === Object.prototype); \f[I]// true\f[R]
.EE
.SH EXAMPLES
.SS Changing the prototype of all instances by mutating the prototype property
.IP
.EX
\f[B]function\f[R] Ctor() {}
\f[B]const\f[R] p1 = \f[B]new\f[R] Ctor();
\f[B]const\f[R] p2 = \f[B]new\f[R] Ctor();
Ctor.prototype.prop = 1;
console.log(p1.prop); \f[I]// 1\f[R]
console.log(p2.prop); \f[I]// 1\f[R]
.EE
.SS Adding a non\-method property to a class\[cq]s prototype property
Class fields add properties to each instance.
Class methods declare \f[I]function\f[R] properties on the prototype.
However, there\[cq]s no way to add a non\-function property to the
prototype.
In case you want to share static data between all instances (for
example, \f[CR]Error.prototype.name\f[R] is the same between all error
instances), you can manually assign it on the \f[CR]prototype\f[R] of a
class.
.IP
.EX
\f[B]class\f[R] Dog {
  constructor(name) {
    \f[B]this\f[R].name = name;
  }
}

Dog.prototype.species = \[dq]dog\[dq];

console.log(\f[B]new\f[R] Dog(\[dq]Jack\[dq]).species); \f[I]// \[dq]dog\[dq]\f[R]
.EE
.PP
This can be made more ergonomic using static initialization blocks,
which are called when the class is initialized.
.IP
.EX
\f[B]class\f[R] Dog {
  \f[B]static\f[R] {
    Dog.prototype.species = \[dq]dog\[dq];
  }
  constructor(name) {
    \f[B]this\f[R].name = name;
  }
}

console.log(\f[B]new\f[R] Dog(\[dq]Jack\[dq]).species); \f[I]// \[dq]dog\[dq]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Function\f[R]
.IP \[bu] 2
Inheritance and the prototype chain
