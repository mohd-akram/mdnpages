.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Promise.Symbol.species" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Promise.Symbol.species \- Promise[Symbol.species]
.SH SYNOPSIS
The \f[B]\f[CB]Promise[Symbol.species]\f[B]\f[R] static accessor
property returns the constructor used to construct return values from
promise methods.
.RS
.PP
\f[B]Warning:\f[R] The existence of \f[CR][Symbol.species]\f[R] allows
execution of arbitrary code and may create security vulnerabilities.
It also makes certain optimizations much harder.
Engine implementers are \c
.UR https://github.com/tc39/proposal-rm-builtin-subclassing
investigating whether to remove this feature
.UE \c
\&.
Avoid relying on it if possible.
.RE
.SH SYNTAX
.IP
.EX
Promise[Symbol.species]
.EE
.SS Return value
The value of the constructor (\f[CR]this\f[R]) on which
\f[CR]get [Symbol.species]\f[R] was called.
The return value is used to construct return values from promise
chaining methods that create new promises.
.SH DESCRIPTION
The \f[CR][Symbol.species]\f[R] accessor property returns the default
constructor for \f[CR]Promise\f[R] objects.
Subclass constructors may override it to change the constructor
assignment.
The default implementation is basically:
.IP
.EX
\f[I]// Hypothetical underlying implementation for illustration\f[R]
\f[B]class\f[R] Promise {
  \f[B]static\f[R] \f[B]get\f[R] [Symbol.species]() {
    \f[B]return\f[R] \f[B]this\f[R];
  }
}
.EE
.PP
Because of this polymorphic implementation, \f[CR][Symbol.species]\f[R]
of derived subclasses would also return the constructor itself by
default.
.IP
.EX
\f[B]class\f[R] SubPromise \f[B]extends\f[R] Promise {}
SubPromise[Symbol.species] === SubPromise; \f[I]// true\f[R]
.EE
.PP
Promise chaining methods \[em] \f[CR]then()\f[R], \f[CR]catch()\f[R],
and \f[CR]finally()\f[R] \[em] return new promise objects.
They get the constructor to construct the new promise through
\f[CR]this.constructor[Symbol.species]\f[R].
If \f[CR]this.constructor\f[R] is \f[CR]undefined\f[R], or if
\f[CR]this.constructor[Symbol.species]\f[R] is \f[CR]undefined\f[R] or
\f[CR]null\f[R], the default \f[CR]Promise()\f[R] constructor is used.
Otherwise, the constructor returned by
\f[CR]this.constructor[Symbol.species]\f[R] is used to construct the new
promise object.
.SH EXAMPLES
.SS Species in ordinary objects
The \f[CR]Symbol.species\f[R] property returns the default constructor
function, which is the \f[CR]Promise\f[R] constructor for
\f[CR]Promise\f[R].
.IP
.EX
Promise[Symbol.species]; \f[I]// [Function: Promise]\f[R]
.EE
.SS Species in derived objects
In an instance of a custom \f[CR]Promise\f[R] subclass, such as
\f[CR]MyPromise\f[R], the \f[CR]MyPromise\f[R] species is the
\f[CR]MyPromise\f[R] constructor.
However, you might want to override this, in order to return parent
\f[CR]Promise\f[R] objects in your derived class methods.
.IP
.EX
\f[B]class\f[R] MyPromise \f[B]extends\f[R] Promise {
  \f[I]// Override MyPromise species to the parent Promise constructor\f[R]
  \f[B]static\f[R] \f[B]get\f[R] [Symbol.species]() {
    \f[B]return\f[R] Promise;
  }
}
.EE
.PP
By default, promise methods would return promises with the type of the
subclass.
.IP
.EX
\f[B]class\f[R] MyPromise \f[B]extends\f[R] Promise {
  someValue = 1;
}

console.log(MyPromise.resolve(1).then(() \f[B]=>\f[R] {}).someValue); \f[I]// 1\f[R]
.EE
.PP
By overriding \f[CR][Symbol.species]\f[R], the promise methods will
return the base \f[CR]Promise\f[R] type.
.IP
.EX
\f[B]class\f[R] MyPromise \f[B]extends\f[R] Promise {
  someValue = 1;
  \f[B]static\f[R] \f[B]get\f[R] [Symbol.species]() {
    \f[B]return\f[R] Promise;
  }
}

console.log(MyPromise.resolve(1).then(() \f[B]=>\f[R] {}).someValue); \f[I]// undefined\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Promise\f[R]
.IP \[bu] 2
\f[CR]Symbol.species\f[R]
