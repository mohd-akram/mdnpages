.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "SubtleCrypto.verify" "JS" "September 25, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SubtleCrypto.verify \- SubtleCrypto: verify() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]verify()\f[B]\f[R] method of the \f[CR]SubtleCrypto\f[R]
interface verifies a digital signature.
.PP
It takes as its arguments a key to verify the signature with, some
algorithm\-specific parameters, the signature, and the original signed
data.
It returns a \f[CR]Promise\f[R] which will be fulfilled with a boolean
value indicating whether the signature is valid.
.SH SYNTAX
.IP
.EX
verify(algorithm, key, signature, data)
.EE
.SS Parameters
.TP
\f[B]algorithm\f[R]
A string or object defining the algorithm to use, and for some algorithm
choices, some extra parameters.
The values given for the extra parameters must match those passed into
the corresponding \f[CR]sign()\f[R] call.
.RS
.IP \[bu] 2
To use RSASSA\-PKCS1\-v1_5, pass the string
\f[CR]\[dq]RSASSA\-PKCS1\-v1_5\[dq]\f[R] or an object of the form
\f[CR]{ \[dq]name\[dq]: \[dq]RSASSA\-PKCS1\-v1_5\[dq] }\f[R].
.IP \[bu] 2
To use RSA\-PSS, pass an \f[CR]RsaPssParams\f[R] object.
.IP \[bu] 2
To use ECDSA, pass an \f[CR]EcdsaParams\f[R] object.
.IP \[bu] 2
To use HMAC, pass the string \f[CR]\[dq]HMAC\[dq]\f[R] or an object of
the form \f[CR]{ \[dq]name\[dq]: \[dq]HMAC\[dq] }\f[R].
.IP \[bu] 2
To use Ed25519, pass an object of the form
\f[CR]{ \[dq]name\[dq]: \[dq]Ed25519\[dq] }\f[R].
.RE
.TP
\f[B]key\f[R]
A \f[CR]CryptoKey\f[R] containing the key that will be used to verify
the signature.
It is the secret key for a symmetric algorithm and the public key for a
public\-key system.
.TP
\f[B]signature\f[R]
A \f[CR]ArrayBuffer\f[R] containing the signature to verify.
.TP
\f[B]data\f[R]
A \f[CR]ArrayBuffer\f[R] containing the data whose signature is to be
verified.
.SS Return value
A \f[CR]Promise\f[R] that fulfills with a boolean value: \f[CR]true\f[R]
if the signature is valid, \f[CR]false\f[R] otherwise.
.SS Exceptions
The promise is rejected when the following exception is encountered:
.TP
\f[B]InvalidAccessError\f[R] \f[B]DOMException\f[R]
Raised when the encryption key is not a key for the requested verifying
algorithm or when trying to use an algorithm that is either unknown or
isn\[cq]t suitable for a verify operation.
.SH SUPPORTED ALGORITHMS
The \f[CR]verify()\f[R] method supports the same algorithms as the
\f[CR]sign()\f[R] method.
.SH EXAMPLES
.RS
.PP
\f[B]Note:\f[R] You can \c
.UR https://mdn.github.io/dom-examples/web-crypto/sign-verify/index.html
try the working examples
.UE \c
\ out on GitHub.
.RE
.SS RSASSA\-PKCS1\-v1_5
This code uses a public key to verify a signature.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/sign-verify/rsassa-pkcs1.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[I]/*\f[R]
\f[I]Fetch the contents of the \[dq]message\[dq] textbox, and encode it\f[R]
\f[I]in a form we can use for sign operation.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getMessageEncoding() {
  \f[B]const\f[R] messageBox = document.querySelector(\[dq].rsassa\-pkcs1 #message\[dq]);
  \f[B]let\f[R] message = messageBox.value;
  \f[B]let\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] enc.encode(message);
}

\f[I]/*\f[R]
\f[I]Fetch the encoded message\-to\-sign and verify it against the stored signature.\f[R]
\f[I]* If it checks out, set the \[dq]valid\[dq] class on the signature.\f[R]
\f[I]* Otherwise set the \[dq]invalid\[dq] class.\f[R]
\f[I]*/\f[R]
\f[B]async\f[R] \f[B]function\f[R] verifyMessage(publicKey) {
  \f[B]const\f[R] signatureValue = document.querySelector(
    \[dq].rsassa\-pkcs1 .signature\-value\[dq],
  );
  signatureValue.classList.remove(\[dq]valid\[dq], \[dq]invalid\[dq]);

  \f[B]let\f[R] encoded = getMessageEncoding();
  \f[B]let\f[R] result = \f[B]await\f[R] window.crypto.subtle.verify(
    \[dq]RSASSA\-PKCS1\-v1_5\[dq],
    publicKey,
    signature,
    encoded,
  );

  signatureValue.classList.add(result ? \[dq]valid\[dq] : \[dq]invalid\[dq]);
}
.EE
.SS RSA\-PSS
This code uses a public key to verify a signature.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/sign-verify/rsa-pss.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[I]/*\f[R]
\f[I]Fetch the contents of the \[dq]message\[dq] textbox, and encode it\f[R]
\f[I]in a form we can use for sign operation.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getMessageEncoding() {
  \f[B]const\f[R] messageBox = document.querySelector(\[dq].rsa\-pss #message\[dq]);
  \f[B]let\f[R] message = messageBox.value;
  \f[B]let\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] enc.encode(message);
}

\f[I]/*\f[R]
\f[I]Fetch the encoded message\-to\-sign and verify it against the stored signature.\f[R]
\f[I]* If it checks out, set the \[dq]valid\[dq] class on the signature.\f[R]
\f[I]* Otherwise set the \[dq]invalid\[dq] class.\f[R]
\f[I]*/\f[R]
\f[B]async\f[R] \f[B]function\f[R] verifyMessage(publicKey) {
  \f[B]const\f[R] signatureValue = document.querySelector(\[dq].rsa\-pss .signature\-value\[dq]);
  signatureValue.classList.remove(\[dq]valid\[dq], \[dq]invalid\[dq]);

  \f[B]let\f[R] encoded = getMessageEncoding();
  \f[B]let\f[R] result = \f[B]await\f[R] window.crypto.subtle.verify(
    {
      name: \[dq]RSA\-PSS\[dq],
      saltLength: 32,
    },
    publicKey,
    signature,
    encoded,
  );

  signatureValue.classList.add(result ? \[dq]valid\[dq] : \[dq]invalid\[dq]);
}
.EE
.SS ECDSA
This code uses a public key to verify a signature.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/sign-verify/ecdsa.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[I]/*\f[R]
\f[I]Fetch the contents of the \[dq]message\[dq] textbox, and encode it\f[R]
\f[I]in a form we can use for sign operation.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getMessageEncoding() {
  \f[B]const\f[R] messageBox = document.querySelector(\[dq].ecdsa #message\[dq]);
  \f[B]let\f[R] message = messageBox.value;
  \f[B]let\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] enc.encode(message);
}

\f[I]/*\f[R]
\f[I]Fetch the encoded message\-to\-sign and verify it against the stored signature.\f[R]
\f[I]* If it checks out, set the \[dq]valid\[dq] class on the signature.\f[R]
\f[I]* Otherwise set the \[dq]invalid\[dq] class.\f[R]
\f[I]*/\f[R]
\f[B]async\f[R] \f[B]function\f[R] verifyMessage(publicKey) {
  \f[B]const\f[R] signatureValue = document.querySelector(\[dq].ecdsa .signature\-value\[dq]);
  signatureValue.classList.remove(\[dq]valid\[dq], \[dq]invalid\[dq]);

  \f[B]let\f[R] encoded = getMessageEncoding();
  \f[B]let\f[R] result = \f[B]await\f[R] window.crypto.subtle.verify(
    {
      name: \[dq]ECDSA\[dq],
      hash: { name: \[dq]SHA\-384\[dq] },
    },
    publicKey,
    signature,
    encoded,
  );

  signatureValue.classList.add(result ? \[dq]valid\[dq] : \[dq]invalid\[dq]);
}
.EE
.SS HMAC
This code uses a secret key to verify a signature.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/sign-verify/hmac.js
See the complete code on GitHub.
.UE \c
.IP
.EX
\f[I]/*\f[R]
\f[I]Fetch the contents of the \[dq]message\[dq] textbox, and encode it\f[R]
\f[I]in a form we can use for sign operation.\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] getMessageEncoding() {
  \f[B]const\f[R] messageBox = document.querySelector(\[dq].hmac #message\[dq]);
  \f[B]let\f[R] message = messageBox.value;
  \f[B]let\f[R] enc = \f[B]new\f[R] TextEncoder();
  \f[B]return\f[R] enc.encode(message);
}

\f[I]/*\f[R]
\f[I]Fetch the encoded message\-to\-sign and verify it against the stored signature.\f[R]
\f[I]* If it checks out, set the \[dq]valid\[dq] class on the signature.\f[R]
\f[I]* Otherwise set the \[dq]invalid\[dq] class.\f[R]
\f[I]*/\f[R]
\f[B]async\f[R] \f[B]function\f[R] verifyMessage(key) {
  \f[B]const\f[R] signatureValue = document.querySelector(\[dq].hmac .signature\-value\[dq]);
  signatureValue.classList.remove(\[dq]valid\[dq], \[dq]invalid\[dq]);

  \f[B]let\f[R] encoded = getMessageEncoding();
  \f[B]let\f[R] result = \f[B]await\f[R] window.crypto.subtle.verify(
    \[dq]HMAC\[dq],
    key,
    signature,
    encoded,
  );

  signatureValue.classList.add(result ? \[dq]valid\[dq] : \[dq]invalid\[dq]);
}
.EE
.SS Ed25519
The Ed25519 live example in \f[CR]SubtleCrypto.sign()\f[R] shows how to
generate public and private keys, use the private key to sign some data,
and then use the public key to verify the signature.
.PP
The excerpt below shows the part that is relevant for verifying the
signature using the public key and encoded data:
.IP
.EX
\f[I]// Verify the signature using the public key\f[R]
\f[B]const\f[R] verifyResult = \f[B]await\f[R] crypto.subtle.verify(
  {
    name: \[dq]Ed25519\[dq],
  },
  publicKey,
  signature,
  encodedData,
);
\f[I]// True if the signature is valid.\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]SubtleCrypto.sign()\f[R].
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc3447
RFC 3447
.UE \c
\ specifies RSASSA\-PKCS1\-v1_5.
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc3447
RFC 3447
.UE \c
\ specifies RSA\-PSS.
.IP \[bu] 2
\c
.UR https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
FIPS\-186
.UE \c
\ specifies ECDSA.
.IP \[bu] 2
\c
.UR https://csrc.nist.gov/files/pubs/fips/198-1/final/docs/fips-198-1_final.pdf
FIPS 198\-1
.UE \c
\ specifies HMAC.
