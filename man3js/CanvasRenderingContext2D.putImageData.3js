.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "CANVASRENDERINGCONTEXT2D.PUTIMAGEDATA" "3JS" "May 23, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
CanvasRenderingContext2D.putImageData \- CanvasRenderingContext2D:
putImageData() method
.SH SYNOPSIS
The \f[B]\f[CB]CanvasRenderingContext2D.putImageData()\f[B]\f[R] method
of the Canvas 2D API paints data from the given \f[CR]ImageData\f[R]
object onto the canvas.
If a dirty rectangle is provided, only the pixels from that rectangle
are painted.
This method is not affected by the canvas transformation matrix.
.RS
.PP
\f[B]Note:\f[R] Image data can be retrieved from a canvas using the
\f[CR]getImageData()\f[R] method.
.RE
.PP
You can find more information about \f[CR]putImageData()\f[R] and
general manipulation of canvas contents in the article Pixel
manipulation with canvas.
.SH SYNTAX
.IP
.EX
putImageData(imageData, dx, dy)
putImageData(imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight)
.EE
.SS Parameters
.TP
\f[B]imageData\f[R]
An \f[CR]ImageData\f[R] object containing the array of pixel values.
.TP
\f[B]dx\f[R]
Horizontal position (x coordinate) at which to place the image data in
the destination canvas.
.TP
\f[B]dy\f[R]
Vertical position (y coordinate) at which to place the image data in the
destination canvas.
.TP
\f[B]dirtyX\f[R] \f[I](optional)\f[R]
Horizontal position (x coordinate) of the top\-left corner from which
the image data will be extracted.
Defaults to \f[CR]0\f[R].
.TP
\f[B]dirtyY\f[R] \f[I](optional)\f[R]
Vertical position (y coordinate) of the top\-left corner from which the
image data will be extracted.
Defaults to \f[CR]0\f[R].
.TP
\f[B]dirtyWidth\f[R] \f[I](optional)\f[R]
Width of the rectangle to be painted.
Defaults to the width of the image data.
.TP
\f[B]dirtyHeight\f[R] \f[I](optional)\f[R]
Height of the rectangle to be painted.
Defaults to the height of the image data.
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.TP
\f[B]NotSupportedError\f[R] \f[B]DOMException\f[R]
Thrown if any of the arguments is infinite.
.TP
\f[B]InvalidStateError\f[R] \f[B]DOMException\f[R]
Thrown if the \f[CR]ImageData\f[R] object\(cqs data has been detached.
.SH EXAMPLES
.SS Understanding putImageData
To understand what this algorithm does under the hood, here is an
implementation on top of \f[CR]CanvasRenderingContext2D.fillRect()\f[R].
.SS HTML
.IP
.EX
<\f[B]canvas\f[R] id=\(dqcanvas\(dq></\f[B]canvas\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] canvas = document.getElementById(\(dqcanvas\(dq);
\f[B]const\f[R] ctx = canvas.getContext(\(dq2d\(dq);

\f[B]function\f[R] putImageData(
  ctx,
  imageData,
  dx,
  dy,
  dirtyX = 0,
  dirtyY = 0,
  dirtyWidth = imageData.width,
  dirtyHeight = imageData.height,
) {
  \f[B]const\f[R] data = imageData.data;
  \f[B]const\f[R] height = imageData.height;
  \f[B]const\f[R] width = imageData.width;
  \f[B]const\f[R] limitBottom = dirtyY + dirtyHeight;
  \f[B]const\f[R] limitRight = dirtyX + dirtyWidth;
  \f[B]for\f[R] (\f[B]let\f[R] y = dirtyY; y < limitBottom; y++) {
    \f[B]for\f[R] (\f[B]let\f[R] x = dirtyX; x < limitRight; x++) {
      \f[B]const\f[R] pos = y * width + x;
      ctx.fillStyle = \(gargb(${data[pos * 4 + 0]} ${data[pos * 4 + 1]}
      ${data[pos * 4 + 2]} / ${data[pos * 4 + 3] / 255})\(ga;
      ctx.fillRect(x + dx, y + dy, 1, 1);
    }
  }
}

\f[I]// Draw content onto the canvas\f[R]
ctx.fillRect(0, 0, 100, 100);
\f[I]// Create an ImageData object from it\f[R]
\f[B]const\f[R] imagedata = ctx.getImageData(0, 0, 100, 100);
\f[I]// use the putImageData function that illustrates how putImageData works\f[R]
putImageData(ctx, imagedata, 150, 0, 50, 50, 25, 25);
.EE
.SS Result
.SS Data loss due to browser optimization
.RS
.PP
\f[B]Warning:\f[R] Due to the lossy nature of converting to and from
premultiplied alpha color values, pixels that have just been set using
\f[CR]putImageData()\f[R] might be returned to an equivalent
\f[CR]getImageData()\f[R] as different values.
.RE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] canvas = document.createElement(\(dqcanvas\(dq);
canvas.width = 1;
canvas.height = 1;
\f[B]const\f[R] context = canvas.getContext(\(dq2d\(dq);
\f[B]const\f[R] imgData = context.getImageData(0, 0, canvas.width, canvas.height);
\f[B]const\f[R] pixels = imgData.data;
pixels[0 + 0] = 1;
pixels[0 + 1] = 127;
pixels[0 + 2] = 255;
pixels[0 + 3] = 1;
console.log(\(dqbefore:\(dq, pixels);
context.putImageData(imgData, 0, 0);
\f[B]const\f[R] imgData2 = context.getImageData(0, 0, canvas.width, canvas.height);
\f[B]const\f[R] pixels2 = imgData2.data;
console.log(\(dqafter:\(dq, pixels2);
.EE
.PP
The output might look like:
.IP
.EX
before: Uint8ClampedArray(4) [ 1, 127, 255, 1 ]
after: Uint8ClampedArray(4) [ 255, 255, 255, 1 ]
.EE
.SH SEE ALSO
.IP \(bu 2
The interface defining this method: \f[CR]CanvasRenderingContext2D\f[R]
.IP \(bu 2
\f[CR]ImageData\f[R] object
.IP \(bu 2
\f[CR]CanvasRenderingContext2D.getImageData()\f[R]
.IP \(bu 2
Pixel manipulation with canvas
