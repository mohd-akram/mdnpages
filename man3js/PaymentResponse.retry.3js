.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "PAYMENTRESPONSE.RETRY" "3JS" "March 7, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
PaymentResponse.retry \- PaymentResponse: retry() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
The \f[CR]PaymentResponse\f[R] interface\(cqs
\f[B]\f[CB]retry()\f[B]\f[R] method makes it possible to ask the user to
retry a payment after an error occurs during processing.
.PP
This lets your app gracefully deal with situations such as invalid
shipping addresses or declined credit cards.
.SH SYNTAX
.IP
.EX
retry(errorFields)
.EE
.SS Parameters
.TP
\f[B]errorFields\f[R]
An object, with the following properties:
.RS
.TP
\f[B]error\f[R] \f[I](optional)\f[R]
A general description of a payment error from which the user may attempt
to recover by retrying the payment, possibly after correcting mistakes
in the payment information.
\f[CR]error\f[R] can be provided all by itself to provide only a generic
error message, or in concert with the other properties to serve as an
overview while other properties\(cq values guide the user to errors in
specific fields in the payment form.
.TP
\(gapaymentMethod \f[I](optional)\f[R]
Any payment\-method\-specific errors which may have occurred.
This object\(cqs contents will vary depending on the payment method
used.
.RE
.SS Return value
A \f[CR]Promise\f[R] which is resolved when the payment is successfully
completed.
The promise is rejected with an appropriate exception value if the
payment fails again.
.PP
Typically you will use this by calling \f[CR]show()\f[R], then entering
a loop or recursive function that checks the \f[CR]PaymentResponse\f[R]
for errors or other reasons to retry the payment request.
If a retry is needed, the loop calls \f[CR]retry()\f[R], then loops back
to check the response when it comes in.
The loop exits only when the user either cancels the payment request or
the request is successful.
.PP
See the example below for a thorough example, but the basic concept, in
outline form, is:
.IP "1." 3
Create a new \f[CR]PaymentRequest\f[R] (\f[CR]new\f[R]
\f[CR]PaymentRequest()\f[R])
.IP "2." 3
Display the payment request (\f[CR]PaymentRequest.show()\f[R]
.IP "3." 3
If \f[CR]show()\f[R] resolves, the returned \f[CR]PaymentResponse\f[R]
describes the requested payment and the options chosen by the user.
Continue with the following steps:
.RS 4
.IP "1." 3
Validate the returned response; if there are any fields whose values are
not acceptable, call the response\(cqs \f[CR]complete()\f[R] method with
a value of \f[CR]\(dqfail\(dq\f[R] to indicate failure.
.IP "2." 3
If the response\(cqs data is valid and acceptable, call
\f[CR]complete(\(dqsuccess\(dq)\f[R] to finalize the payment and process
it.
.RE
.IP "4." 3
If \f[CR]show()\f[R] is rejected, the payment request failed, usually
because either there\(cqs already one being processed, because the user
agent doesn\(cqt support any of the specified payment methods, or
because of a security issue.
See the list of exceptions for \f[CR]show()\f[R] for further details.
Call \f[CR]complete(\(dqfail\(dq)\f[R] to close the payment request.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] handlePayment() {
  \f[B]const\f[R] payRequest = \f[B]new\f[R] PaymentRequest(methodData, details, options);

  \f[B]try\f[R] {
    \f[B]let\f[R] payResponse = \f[B]await\f[R] payRequest.show();

    \f[B]while\f[R] (validate(payResponse)) {
      \f[I]/* let the user edit the payment information,\f[R]
\f[I]         wait until they submit */\f[R]
      \f[B]await\f[R] response.retry();
    }
    \f[B]await\f[R] payResponse.complete(\(dqsuccess\(dq);
  } \f[B]catch\f[R] (err) {
    \f[I]/* handle the exception */\f[R]
  }
}
.EE
.SH EXAMPLES
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R] doPaymentRequest() {
  \f[B]const\f[R] request = \f[B]new\f[R] PaymentRequest(methodData, details, options);
  \f[B]const\f[R] response = \f[B]await\f[R] request.show();
  \f[B]await\f[R] recursiveValidate(request, response);
  \f[B]await\f[R] response.complete(\(dqsuccess\(dq);
}

\f[I]// Keep validating until the data looks good!\f[R]
\f[B]async\f[R] \f[B]function\f[R] recursiveValidate(request, response) {
  \f[B]const\f[R] promisesToFixThings = [];
  \f[B]const\f[R] errors = \f[B]await\f[R] validate(request, response);
  \f[B]if\f[R] (!errors) {
    \f[B]return\f[R];
  }
  \f[B]if\f[R] (errors.shippingAddress) {
    \f[I]// \(dqshippingaddresschange\(dq fired at request object\f[R]
    \f[B]const\f[R] promise = fixField(
      request,
      \(dqshippingaddresschange\(dq,
      shippingValidator,
    );
    promisesToFixThings.push(promise);
  }
  \f[B]if\f[R] (errors.payer) {
    \f[I]// \(dqpayerdetailchange\(dq fired at response object\f[R]
    \f[B]const\f[R] promise = fixField(response, \(dqpayerdetailchange\(dq, payerValidator);
    promisesToFixThings.push(promise);
  }
  \f[B]await\f[R] Promise.all([response.retry(errors), ...promisesToFixThings]);
  \f[B]await\f[R] recursiveValidate(request, response);
}

\f[B]function\f[R] fixField(requestOrResponse, event, validator) {
  \f[B]return\f[R] \f[B]new\f[R] Promise((resolve) \f[B]=>\f[R] {
    \f[I]// Browser keeps calling this until promise resolves.\f[R]
    requestOrResponse.addEventListener(event, \f[B]async\f[R] \f[B]function\f[R] listener(ev) {
      \f[B]const\f[R] promiseToValidate = validator(requestOrResponse);
      ev.updateWith(promiseToValidate);
      \f[B]const\f[R] errors = \f[B]await\f[R] promiseToValidate;
      \f[B]if\f[R] (!errors) {
        \f[I]// yay! fixed!\f[R]
        event.removeEventListener(event, listener);
        resolve();
      }
    });
  });
}

doPaymentRequest();
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]PaymentResponse\f[R] interface.
