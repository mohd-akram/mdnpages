.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "XRInputSource.targetRaySpace" "JS" "March 12, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
XRInputSource.targetRaySpace \- XRInputSource: targetRaySpace property
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
The read\-only \f[CR]XRInputSource\f[R] property
\f[B]\f[CB]targetRaySpace\f[B]\f[R] returns an \f[CR]XRSpace\f[R]
(typically an \f[CR]XRReferenceSpace\f[R]) representing the position and
orientation of the target ray in the virtual space.
Its native origin tracks the position of the origin point of the target
ray, and its orientation indicates the orientation of the controller
device itself.
These values, interpreted in the context of the input source\[cq]s
\f[CR]targetRayMode\f[R], can be used both to fully interpret the device
as an input source.
.PP
To obtain an \f[CR]XRSpace\f[R] representing the input controller\[cq]s
position and orientation in virtual space, use the \f[CR]gripSpace\f[R]
property.
.SH VALUE
An \f[CR]XRSpace\f[R] object\[em]typically an
\f[CR]XRReferenceSpace\f[R] or
\f[CR]XRBoundedReferenceSpace\f[R]\[em]which represents the position and
orientation of the input controller\[cq]s target ray in virtual space.
.PP
The native origin of the returned \f[CR]XRSpace\f[R] is located at the
point from which the target ray is emitted, and the orientation of the
space indicates the direction in which the target ray is pointing.
.SH USAGE NOTES
All input sources\[em]regardless of their
\f[CR]targetRayMode\f[R]\[em]have a valid \f[CR]targetRaySpace\f[R].
The exact meaning of this space varies, however, depending on the mode:
.IP \[bu] 2
Every gaze input (\f[CR]targetRayMode\f[R] value of \f[CR]gaze\f[R]),
shares the same \f[CR]XRSpace\f[R] object as their target ray space,
since the gaze input comes from the viewer\[cq]s head.
This shared space represents the same location as the space returned by
the \f[CR]XRSession\f[R] method \f[CR]requestReferenceSpace()\f[R], but
is maintained as a different object to allow for future enhancements to
the API.
.IP \[bu] 2
The target ray space reported by tracked pointer inputs
(\f[CR]targetRayMode\f[R] of \f[CR]tracked\-pointer\f[R]) is actually
based upon the true spatial position and orientation of the input
device.
.PP
To determine the position and orientation of the target ray while
rendering a frame, pass it into the \f[CR]XRFrame\f[R] method
\f[CR]getPose()\f[R] method, then use the returned \f[CR]XRPose\f[R]
object\[cq]s \f[CR]transform\f[R] to gather the spatial information you
need.
.SH EXAMPLES
This fragment of code shows part of a function to be called once every
frame.
It looks for inputs which have a non\-\f[CR]null\f[R]
\f[CR]targetRaySpace\f[R].
Inputs which have a value for this property represent inputs that
project a target ray outward from the user.
.PP
For each such input, this example looks for inputs whose
\f[CR]targetRayMode\f[R] is \f[CR]tracked\-pointer\f[R], indicating that
the input is in fact intended to represent a targeting device rather
than a gazing device, screen tap, or mouse click.
For tracked pointers, a function \f[CR]myRenderTargetRayAsBeam()\f[R] is
called to render a beam from the input controller\[cq]s virtual position
outward in the direction it\[cq]s pointing.
.PP
The code should continue to perform tasks such as drawing controllers or
any objects representative of the user\[cq]s hands\[cq] positions in the
virtual space, as well as any other input\-related tasks.
.IP
.EX
\f[B]function\f[R] updateInputSources(session, frame, refSpace) {
  \f[B]for\f[R] (\f[B]const\f[R] source \f[B]of\f[R] session.getInputSources()) {
    \f[B]const\f[R] targetRayPose = frame.getPose(inputSource.targetRaySpace, refSpace);

    \f[B]if\f[R] (targetRayPose) {
      \f[B]if\f[R] (source.targetRayMode === \[dq]tracked\-pointer\[dq]) {
        myRenderTargetRayAsBeam(targetRayPose);
      }
    }

    \f[I]// \&...\f[R]
  }
}
.EE
.SH SEE ALSO
.IP \[bu] 2
WebXR Device API
.IP \[bu] 2
Inputs and input sources
.IP \[bu] 2
Using gamepads in WebXR applications
