.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ATOMICS.PAUSE" "3JS" "March 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Atomics.pause \- Atomics.pause()
.SH SYNOPSIS
The \f[B]\f[CB]Atomics.pause()\f[B]\f[R] static method provides a
micro\-wait primitive that hints to the CPU that the caller is spinning
while waiting on access to a shared resource.
This allows the system to reduce the resources allocated to the core
(such as power) or thread, without yielding the current thread.
.PP
\f[CR]pause()\f[R] has no observable behavior other than timing.
The exact behavior is dependent on the CPU architecture and the
operating system.
For example, in Intel x86, it may be a \f[CR]pause\f[R] instruction as
per \c
.UR https://www.intel.com/content/www/us/en/content-details/671488/intel-64-and-ia-32-architectures-optimization-reference-manual-volume-1.html
Intel\(cqs optimization manual
.UE \c
\&.
It could be a no\-op in certain platforms.
.SH SYNTAX
.IP
.EX
Atomics.pause()
Atomics.pause(durationHint)
.EE
.SS Parameters
.TP
\f[B]durationHint\f[R] \f[I](optional)\f[R]
An integer that an implementation may use to determine how long to wait.
For a value \f[CR]n + 1\f[R], an implementation waits at least as long
as it does for a given value \f[CR]n\f[R].
The exact number has no physical meaning.
There may be an internal upper bound on the maximum amount of time
paused on the order of tens to hundreds of nanoseconds.
This can be used to implement a backoff strategy by increasing the
\f[CR]durationHint\f[R] passed in.
There is no guarantee that an implementation will make use of this hint.
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if \f[CR]durationHint\f[R] is not an integer or
\f[CR]undefined\f[R].
.SH EXAMPLES
.SS Using Atomics.pause()
Calling \f[CR]Atomics.wait()\f[R] or \f[CR]Atomics.waitAsync()\f[R] in
order to wait for access to shared memory causes the thread to be
scheduled out of the core and then back in again after the wait.
This is efficient during times of high contention, where access to the
shared memory could take some time.
When contention is low, then it is often more efficient to poll on the
lock without yielding the thread: this approach is known as \c
.UR https://en.wikipedia.org/wiki/Busy_waiting
busy waiting
.UE \c
\ or \c
.UR https://en.wikipedia.org/wiki/Spinlock
spinlocking
.UE \c
\&.
The \f[CR]pause()\f[R] method allows you to spinlock more efficiently
while waiting, by providing a hint to the CPU about what the thread is
doing, and hence its low need for resources.
.PP
To cater for both conditions, a common approach is to first spinlock in
the hope that contention is low, and then wait if the lock is not gained
after a short time.
If we acquired the lock via spinlocking already, then the
\f[CR]wait()\f[R] call will be a no\-op.
.PP
The example below shows how this approach can be used with
\f[CR]Atomics.pause()\f[R] and \f[CR]Atomics.wait()\f[R].
.RS
.PP
\f[B]Warning:\f[R] Using spinlocking on the main thread is not
recommended, as it will freeze the entire page.
In general, unless designed very carefully, spinlocks may not actually
be more performant than a regular wait.
.RE
.IP
.EX
\f[I]// Imagine another thread also has access to this shared memory\f[R]
\f[B]const\f[R] sab = \f[B]new\f[R] SharedArrayBuffer(1024);
\f[B]const\f[R] i32 = \f[B]new\f[R] Int32Array(sab);

\f[I]// Fast path: spin the CPU for a short while\f[R]
\f[B]let\f[R] spin = 0;
\f[B]do\f[R] {
  \f[B]if\f[R] (Atomics.compareExchange(i32, 0, 0, 1) === 0) {
    \f[B]break\f[R];
  }
  Atomics.pause();
  spin++;
} \f[B]while\f[R] (spin < 10);

\f[I]// Slow path: wait for the lock\f[R]
\f[I]// This can only be called in a worker thread,\f[R]
\f[I]// because the main thread cannot be blocked\f[R]
Atomics.wait(i32, 0, 1);
.EE
.SS Backoff strategies
The \f[CR]durationHint\f[R] parameter can be used to implement backoff
strategies.
For example, a thread can start with a small hint and increase it
exponentially on each iteration.
This is preferable to calling \f[CR]pause()\f[R] many times because in
un\-JITed code, function calls themselves have a high overhead.
.RS
.PP
\f[B]Note:\f[R] Implementations may not actually use
\f[CR]durationHint\f[R] at all and always wait for a constant time.
.RE
.IP
.EX
\f[I]// Exponential backoff\f[R]
\f[B]for\f[R] (\f[B]let\f[R] hint = 1; hint < 1000; hint *= 2) {
  Atomics.pause(hint);
}

\f[I]// Linear backoff\f[R]
\f[B]for\f[R] (\f[B]let\f[R] hint = 1; hint < 100; hint++) {
  Atomics.pause(hint);
}
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Atomics\f[R]
.IP \(bu 2
\f[CR]Atomics.wait()\f[R]
.IP \(bu 2
\f[CR]Atomics.waitAsync()\f[R]
