.\" Automatically generated by Pandoc 3.4
.\"
.TH "Promise.race" "JS" "October 7, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Promise.race \- Promise.race()
.SH SYNOPSIS
The \f[B]\f[CB]Promise.race()\f[B]\f[R] static method takes an iterable
of promises as input and returns a single \f[CR]Promise\f[R].
This returned promise settles with the eventual state of the first
promise that settles.
.SH SYNTAX
.IP
.EX
Promise.race(iterable)
.EE
.SS Parameters
.TP
\f[B]iterable\f[R]
An iterable (such as an \f[CR]Array\f[R]) of promises.
.SS Return value
A \f[CR]Promise\f[R] that \f[B]asynchronously settles\f[R] with the
eventual state of the first promise in the \f[CR]iterable\f[R] to
settle.
In other words, it fulfills if the first promise to settle is fulfilled,
and rejects if the first promise to settle is rejected.
The returned promise remains pending forever if the \f[CR]iterable\f[R]
passed is empty.
If the \f[CR]iterable\f[R] passed is non\-empty but contains no pending
promises, the returned promise is still asynchronously (instead of
synchronously) settled.
.SH DESCRIPTION
The \f[CR]Promise.race()\f[R] method is one of the promise concurrency
methods.
It\[cq]s useful when you want the first async task to complete, but do
not care about its eventual state (i.e.\ it can either succeed or fail).
.PP
If the iterable contains one or more non\-promise values and/or an
already settled promise, then \f[CR]Promise.race()\f[R] will settle to
the first of these values found in the iterable.
.SH EXAMPLES
.SS Using Promise.race()
This example shows how \f[CR]Promise.race()\f[R] can be used to race
several timers implemented with \f[CR]setTimeout()\f[R].
The timer with the shortest time always wins the race and becomes the
resulting promise\[cq]s state.
.IP
.EX
\f[B]function\f[R] sleep(time, value, state) {
  \f[B]return\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
    setTimeout(() \f[B]=>\f[R] {
      \f[B]if\f[R] (state === \[dq]fulfill\[dq]) {
        \f[B]return\f[R] resolve(value);
      } \f[B]else\f[R] {
        \f[B]return\f[R] reject(\f[B]new\f[R] Error(value));
      }
    }, time);
  });
}

\f[B]const\f[R] p1 = sleep(500, \[dq]one\[dq], \[dq]fulfill\[dq]);
\f[B]const\f[R] p2 = sleep(100, \[dq]two\[dq], \[dq]fulfill\[dq]);

Promise.race([p1, p2]).then((value) \f[B]=>\f[R] {
  console.log(value); \f[I]// \[dq]two\[dq]\f[R]
  \f[I]// Both fulfill, but p2 is faster\f[R]
});

\f[B]const\f[R] p3 = sleep(100, \[dq]three\[dq], \[dq]fulfill\[dq]);
\f[B]const\f[R] p4 = sleep(500, \[dq]four\[dq], \[dq]reject\[dq]);

Promise.race([p3, p4]).then(
  (value) \f[B]=>\f[R] {
    console.log(value); \f[I]// \[dq]three\[dq]\f[R]
    \f[I]// p3 is faster, so it fulfills\f[R]
  },
  (error) \f[B]=>\f[R] {
    \f[I]// Not called\f[R]
  },
);

\f[B]const\f[R] p5 = sleep(500, \[dq]five\[dq], \[dq]fulfill\[dq]);
\f[B]const\f[R] p6 = sleep(100, \[dq]six\[dq], \[dq]reject\[dq]);

Promise.race([p5, p6]).then(
  (value) \f[B]=>\f[R] {
    \f[I]// Not called\f[R]
  },
  (error) \f[B]=>\f[R] {
    console.error(error.message); \f[I]// \[dq]six\[dq]\f[R]
    \f[I]// p6 is faster, so it rejects\f[R]
  },
);
.EE
.SS Asynchronicity of Promise.race
This following example demonstrates the asynchronicity of
\f[CR]Promise.race\f[R].
Unlike other promise concurrency methods, \f[CR]Promise.race\f[R] is
always asynchronous: it never settles synchronously, even when the
\f[CR]iterable\f[R] is empty.
.IP
.EX
\f[I]// Passing an array of promises that are already resolved,\f[R]
\f[I]// to trigger Promise.race as soon as possible\f[R]
\f[B]const\f[R] resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)];

\f[B]const\f[R] p = Promise.race(resolvedPromisesArray);
\f[I]// Immediately logging the value of p\f[R]
console.log(p);

\f[I]// Using setTimeout, we can execute code after the stack is empty\f[R]
setTimeout(() \f[B]=>\f[R] {
  console.log(\[dq]the stack is now empty\[dq]);
  console.log(p);
});

\f[I]// Logs, in order:\f[R]
\f[I]// Promise { <state>: \[dq]pending\[dq] }\f[R]
\f[I]// the stack is now empty\f[R]
\f[I]// Promise { <state>: \[dq]fulfilled\[dq], <value>: 33 }\f[R]
.EE
.PP
An empty iterable causes the returned promise to be forever pending:
.IP
.EX
\f[B]const\f[R] foreverPendingPromise = Promise.race([]);
console.log(foreverPendingPromise);
setTimeout(() \f[B]=>\f[R] {
  console.log(\[dq]the stack is now empty\[dq]);
  console.log(foreverPendingPromise);
});

\f[I]// Logs, in order:\f[R]
\f[I]// Promise { <state>: \[dq]pending\[dq] }\f[R]
\f[I]// the stack is now empty\f[R]
\f[I]// Promise { <state>: \[dq]pending\[dq] }\f[R]
.EE
.PP
If the iterable contains one or more non\-promise value and/or an
already settled promise, then \f[CR]Promise.race\f[R] will settle to the
first of these values found in the array:
.IP
.EX
\f[B]const\f[R] foreverPendingPromise = Promise.race([]);
\f[B]const\f[R] alreadyFulfilledProm = Promise.resolve(100);

\f[B]const\f[R] arr = [foreverPendingPromise, alreadyFulfilledProm, \[dq]non\-Promise value\[dq]];
\f[B]const\f[R] arr2 = [foreverPendingPromise, \[dq]non\-Promise value\[dq], Promise.resolve(100)];
\f[B]const\f[R] p = Promise.race(arr);
\f[B]const\f[R] p2 = Promise.race(arr2);

console.log(p);
console.log(p2);
setTimeout(() \f[B]=>\f[R] {
  console.log(\[dq]the stack is now empty\[dq]);
  console.log(p);
  console.log(p2);
});

\f[I]// Logs, in order:\f[R]
\f[I]// Promise { <state>: \[dq]pending\[dq] }\f[R]
\f[I]// Promise { <state>: \[dq]pending\[dq] }\f[R]
\f[I]// the stack is now empty\f[R]
\f[I]// Promise { <state>: \[dq]fulfilled\[dq], <value>: 100 }\f[R]
\f[I]// Promise { <state>: \[dq]fulfilled\[dq], <value>: \[dq]non\-Promise value\[dq] }\f[R]
.EE
.SS Using Promise.race() to implement request timeout
You can race a potentially long\-lasting request with a timer that
rejects, so that when the time limit has elapsed, the resulting promise
automatically rejects.
.IP
.EX
\f[B]const\f[R] data = Promise.race([
  fetch(\[dq]/api\[dq]),
  \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
    \f[I]// Reject after 5 seconds\f[R]
    setTimeout(() \f[B]=>\f[R] reject(\f[B]new\f[R] Error(\[dq]Request timed out\[dq])), 5000);
  }),
])
  .then((res) \f[B]=>\f[R] res.json())
  .catch((err) \f[B]=>\f[R] displayError(err));
.EE
.PP
If the \f[CR]data\f[R] promise fulfills, it will contain the data
fetched from \f[CR]/api\f[R]; otherwise, it will reject if
\f[CR]fetch\f[R] remains pending for 5 seconds and loses the race with
the \f[CR]setTimeout\f[R] timer.
.SS Using Promise.race() to detect the status of a promise
Because \f[CR]Promise.race()\f[R] resolves to the first non\-pending
promise in the iterable, we can check a promise\[cq]s state, including
if it\[cq]s pending.
This example is adapted from \c
.UR https://github.com/kudla/promise-status-async/blob/master/lib/promiseState.js
\f[CR]promise\-status\-async\f[R]
.UE \c
\&.
.IP
.EX
\f[B]function\f[R] promiseState(promise) {
  \f[B]const\f[R] pendingState = { status: \[dq]pending\[dq] };

  \f[B]return\f[R] Promise.race([promise, pendingState]).then(
    (value) \f[B]=>\f[R]
      value === pendingState ? value : { status: \[dq]fulfilled\[dq], value },
    (reason) \f[B]=>\f[R] ({ status: \[dq]rejected\[dq], reason }),
  );
}
.EE
.PP
In this function, if \f[CR]promise\f[R] is pending, the second value,
\f[CR]pendingState\f[R], which is a non\-promise, becomes the result of
the race; otherwise, if \f[CR]promise\f[R] is already settled, we may
know its state through the \f[CR]onFulfilled\f[R] and
\f[CR]onRejected\f[R] handlers.
For example:
.IP
.EX
\f[B]const\f[R] p1 = \f[B]new\f[R] Promise((res) \f[B]=>\f[R] setTimeout(() \f[B]=>\f[R] res(100), 100));
\f[B]const\f[R] p2 = \f[B]new\f[R] Promise((res) \f[B]=>\f[R] setTimeout(() \f[B]=>\f[R] res(200), 200));
\f[B]const\f[R] p3 = \f[B]new\f[R] Promise((res, rej) \f[B]=>\f[R] setTimeout(() \f[B]=>\f[R] rej(300), 100));

\f[B]async\f[R] \f[B]function\f[R] getStates() {
  console.log(\f[B]await\f[R] promiseState(p1));
  console.log(\f[B]await\f[R] promiseState(p2));
  console.log(\f[B]await\f[R] promiseState(p3));
}

console.log(\[dq]Immediately after initiation:\[dq]);
getStates();
setTimeout(() \f[B]=>\f[R] {
  console.log(\[dq]After waiting for 100ms:\[dq]);
  getStates();
}, 100);

\f[I]// Logs:\f[R]
\f[I]// Immediately after initiation:\f[R]
\f[I]// { status: \[aq]pending\[aq] }\f[R]
\f[I]// { status: \[aq]pending\[aq] }\f[R]
\f[I]// { status: \[aq]pending\[aq] }\f[R]
\f[I]// After waiting for 100ms:\f[R]
\f[I]// { status: \[aq]fulfilled\[aq], value: 100 }\f[R]
\f[I]// { status: \[aq]pending\[aq] }\f[R]
\f[I]// { status: \[aq]rejected\[aq], reason: 300 }\f[R]
.EE
.RS
.PP
\f[B]Note:\f[R] The \f[CR]promiseState\f[R] function still runs
asynchronously, because there is no way to synchronously get a
promise\[cq]s value (i.e.\ without \f[CR]then()\f[R] or
\f[CR]await\f[R]), even when it is already settled.
However, \f[CR]promiseState()\f[R] always fulfills within one tick and
never actually waits for any promise\[cq]s settlement.
.RE
.SS Comparison with Promise.any()
\f[CR]Promise.race\f[R] takes the first settled \f[CR]Promise\f[R].
.IP
.EX
\f[B]const\f[R] promise1 = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  setTimeout(resolve, 500, \[dq]one\[dq]);
});

\f[B]const\f[R] promise2 = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  setTimeout(reject, 100, \[dq]two\[dq]);
});

Promise.race([promise1, promise2])
  .then((value) \f[B]=>\f[R] {
    console.log(\[dq]succeeded with value:\[dq], value);
  })
  .catch((reason) \f[B]=>\f[R] {
    \f[I]// Only promise1 is fulfilled, but promise2 is faster\f[R]
    console.error(\[dq]failed with reason:\[dq], reason);
  });
\f[I]// failed with reason: two\f[R]
.EE
.PP
\f[CR]Promise.any\f[R] takes the first fulfilled \f[CR]Promise\f[R].
.IP
.EX
\f[B]const\f[R] promise1 = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  setTimeout(resolve, 500, \[dq]one\[dq]);
});

\f[B]const\f[R] promise2 = \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
  setTimeout(reject, 100, \[dq]two\[dq]);
});

Promise.any([promise1, promise2])
  .then((value) \f[B]=>\f[R] {
    \f[I]// Only promise1 is fulfilled, even though promise2 settled sooner\f[R]
    console.log(\[dq]succeeded with value:\[dq], value);
  })
  .catch((reason) \f[B]=>\f[R] {
    console.error(\[dq]failed with reason:\[dq], reason);
  });
\f[I]// succeeded with value: one\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Promise\f[R]
.IP \[bu] 2
\f[CR]Promise.all()\f[R]
.IP \[bu] 2
\f[CR]Promise.allSettled()\f[R]
.IP \[bu] 2
\f[CR]Promise.any()\f[R]
