'\" t
.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GLOBALTHIS" "3JS" "April 3, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
globalThis \- globalThis
.SH SYNOPSIS
The \f[B]\f[CB]globalThis\f[B]\f[R] global property contains the global
\f[CR]this\f[R] value, which is usually akin to the global object.
.IP
.EX
\f[B]function\f[R] canMakeHTTPRequest() {
  \f[B]return\f[R] \f[B]typeof\f[R] globalThis.XMLHttpRequest === \(dqfunction\(dq;
}

console.log(canMakeHTTPRequest());
\f[I]// Expected output (in a browser): true\f[R]
.EE
.SH VALUE
The global \f[CR]this\f[R] object.
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
yes
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
yes
T}
.TE
.RS
.PP
\f[B]Note:\f[R] The \f[CR]globalThis\f[R] property is configurable and
writable so that code authors can hide it when executing untrusted code
and prevent exposing the global object.
.RE
.SH DESCRIPTION
Historically, accessing the global object has required different syntax
in different JavaScript environments.
On the web you can use \f[CR]window\f[R], \f[CR]self\f[R], or
\f[CR]frames\f[R] \- but in Web Workers only \f[CR]self\f[R] will work.
In Node.js none of these work, and you must instead use
\f[CR]global\f[R].
The \f[CR]this\f[R] keyword could be used inside functions running in
non\(enstrict mode, but \f[CR]this\f[R] will be \f[CR]undefined\f[R] in
modules and inside functions running in strict mode.
You can also use \f[CR]Function(\(aqreturn this\(aq)()\f[R], but
environments that disable \f[CR]eval()\f[R], like CSP in browsers,
prevent use of \f[CR]Function\f[R] in this way.
.PP
The \f[CR]globalThis\f[R] property provides a standard way of accessing
the global \f[CR]this\f[R] value (and hence the global object itself)
across environments.
Unlike similar properties such as \f[CR]window\f[R] and \f[CR]self\f[R],
it\(cqs guaranteed to work in window and non\-window contexts.
In this way, you can access the global object in a consistent manner
without having to know which environment the code is being run in.
To help you remember the name, just remember that in global scope the
\f[CR]this\f[R] value is \f[CR]globalThis\f[R].
.RS
.PP
\f[B]Note:\f[R] \f[CR]globalThis\f[R] is generally the same concept as
the global object (i.e., adding properties to \f[CR]globalThis\f[R]
makes them global variables) \(em this is the case for browsers and Node
\(em but hosts are allowed to provide a different value for
\f[CR]globalThis\f[R] that\(cqs unrelated to the global object.
.RE
.SS HTML and the WindowProxy
In many engines \f[CR]globalThis\f[R] will be a reference to the actual
global object, but in web browsers, due to iframe and cross\-window
security considerations, it references a \f[CR]Proxy\f[R] around the
actual global object (which you can\(cqt directly access).
This distinction is rarely relevant in common usage, but important to be
aware of.
.SS Naming
Several other popular name choices such as \f[CR]self\f[R] and
\f[CR]global\f[R] were removed from consideration because of their
potential to break compatibility with existing code.
See the \c
.UR https://github.com/tc39/proposal-global/blob/master/NAMING.md
language proposal\(cqs \(lqnaming\(rq document
.UE \c
\ for more details.
.PP
\f[CR]globalThis\f[R] is, quite literally, the global \f[CR]this\f[R]
value.
It\(cqs the same value as the \f[CR]this\f[R] value in a non\-strict
function called without an object.
It\(cqs also the value of \f[CR]this\f[R] in the global scope of a
script.
.SH EXAMPLES
.SS Search for the global across environments
Usually, the global object does not need to be explicitly specified \(em
its properties are automatically accessible as global variables.
.IP
.EX
console.log(window.Math === Math); \f[I]// true\f[R]
.EE
.PP
However, one case where one needs to explicitly access the global object
is when \f[I]writing\f[R] to it, usually for the purpose of polyfills.
.PP
Prior to \f[CR]globalThis\f[R], the only reliable cross\-platform way to
get the global object for an environment was
\f[CR]Function(\(aqreturn this\(aq)()\f[R].
However, this causes CSP violations in some settings, so authors would
use a piecewise definition like this (slightly adapted from the \c
.UR https://github.com/zloirock/core-js/blob/master/packages/core-js/internals/global-this.js
original core\-js source
.UE \c
):
.IP
.EX
\f[B]function\f[R] check(it) {
  \f[I]// Math is known to exist as a global in every environment.\f[R]
  \f[B]return\f[R] it && it.Math === Math && it;
}

\f[B]const\f[R] globalObject =
  check(\f[B]typeof\f[R] window === \(dqobject\(dq && window) ||
  check(\f[B]typeof\f[R] self === \(dqobject\(dq && self) ||
  check(\f[B]typeof\f[R] global === \(dqobject\(dq && global) ||
  \f[I]// This returns undefined when running in strict mode\f[R]
  (\f[B]function\f[R] () {
    \f[B]return\f[R] \f[B]this\f[R];
  })() ||
  Function(\(dqreturn this\(dq)();
.EE
.PP
After obtaining the global object, we can define new globals on it.
For example, adding an implementation for \f[CR]Intl\f[R]:
.IP
.EX
\f[B]if\f[R] (\f[B]typeof\f[R] globalObject.Intl === \(dqundefined\(dq) {
  \f[I]// No Intl in this environment; define our own on the global scope\f[R]
  Object.defineProperty(globalObject, \(dqIntl\(dq, {
    value: {
      \f[I]// Our Intl implementation\f[R]
    },
    enumerable: \f[B]false\f[R],
    configurable: \f[B]true\f[R],
    writable: \f[B]true\f[R],
  });
}
.EE
.PP
With \f[CR]globalThis\f[R] available, the additional search for the
global across environments is not necessary anymore:
.IP
.EX
\f[B]if\f[R] (\f[B]typeof\f[R] globalThis.Intl === \(dqundefined\(dq) {
  Object.defineProperty(globalThis, \(dqIntl\(dq, {
    value: {
      \f[I]// Our Intl implementation\f[R]
    },
    enumerable: \f[B]false\f[R],
    configurable: \f[B]true\f[R],
    writable: \f[B]true\f[R],
  });
}
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-globalthis
Polyfill of \f[CR]globalThis\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/globalthis
es\-shims polyfill of \f[CR]globalThis\f[R]
.UE \c
.IP \(bu 2
\f[CR]this\f[R]
