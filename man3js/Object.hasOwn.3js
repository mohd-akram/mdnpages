.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "OBJECT.HASOWN" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.hasOwn \- Object.hasOwn()
.SH SYNOPSIS
The \f[B]\f[CB]Object.hasOwn()\f[B]\f[R] static method returns
\f[CR]true\f[R] if the specified object has the indicated property as
its \f[I]own\f[R] property.
If the property is inherited, or does not exist, the method returns
\f[CR]false\f[R].
.RS
.PP
\f[B]Note:\f[R] \f[CR]Object.hasOwn()\f[R] is intended as a replacement
for \f[CR]Object.prototype.hasOwnProperty()\f[R].
.RE
.IP
.EX
\f[B]const\f[R] object1 = {
  prop: \(dqexists\(dq,
};

console.log(Object.hasOwn(object1, \(dqprop\(dq));
\f[I]// Expected output: true\f[R]

console.log(Object.hasOwn(object1, \(dqtoString\(dq));
\f[I]// Expected output: false\f[R]

console.log(Object.hasOwn(object1, \(dqundeclaredPropertyValue\(dq));
\f[I]// Expected output: false\f[R]
.EE
.SH SYNTAX
.IP
.EX
Object.hasOwn(obj, prop)
.EE
.SS Parameters
.TP
\f[B]obj\f[R]
The JavaScript object instance to test.
.TP
\f[B]prop\f[R]
The \f[CR]String\f[R] name or Symbol of the property to test.
.SS Return value
\f[CR]true\f[R] if the specified object has directly defined the
specified property.
Otherwise \f[CR]false\f[R]
.SH DESCRIPTION
The \f[CR]Object.hasOwn()\f[R] method returns \f[CR]true\f[R] if the
specified property is a direct property of the object \(em even if the
property value is \f[CR]null\f[R] or \f[CR]undefined\f[R].
The method returns \f[CR]false\f[R] if the property is inherited, or has
not been declared at all.
Unlike the \f[CR]in\f[R] operator, this method does not check for the
specified property in the object\(cqs prototype chain.
.PP
It is recommended over \f[CR]Object.prototype.hasOwnProperty()\f[R]
because it works for \f[CR]null\f[R]\-prototype objects and with objects
that have overridden the inherited \f[CR]hasOwnProperty()\f[R] method.
While it is possible to workaround these problems by accessing
\f[CR]Object.prototype.hasOwnProperty()\f[R] on another object (like
\f[CR]Object.prototype.hasOwnProperty.call(obj, prop)\f[R],
\f[CR]Object.hasOwn()\f[R] is more intuitive and concise.
.SH EXAMPLES
.SS Using Object.hasOwn() to test for a property\(cqs existence
The following code shows how to determine whether the \f[CR]example\f[R]
object contains a property named \f[CR]prop\f[R].
.IP
.EX
\f[B]const\f[R] example = {};
Object.hasOwn(example, \(dqprop\(dq); \f[I]// false \- \(aqprop\(aq has not been defined\f[R]

example.prop = \(dqexists\(dq;
Object.hasOwn(example, \(dqprop\(dq); \f[I]// true \- \(aqprop\(aq has been defined\f[R]

example.prop = \f[B]null\f[R];
Object.hasOwn(example, \(dqprop\(dq); \f[I]// true \- own property exists with value of null\f[R]

example.prop = \f[B]undefined\f[R];
Object.hasOwn(example, \(dqprop\(dq); \f[I]// true \- own property exists with value of undefined\f[R]
.EE
.SS Direct vs.\ inherited properties
The following example differentiates between direct properties and
properties inherited through the prototype chain:
.IP
.EX
\f[B]const\f[R] example = {};
example.prop = \(dqexists\(dq;

\f[I]// \(gahasOwn\(ga will only return true for direct properties:\f[R]
Object.hasOwn(example, \(dqprop\(dq); \f[I]// true\f[R]
Object.hasOwn(example, \(dqtoString\(dq); \f[I]// false\f[R]
Object.hasOwn(example, \(dqhasOwnProperty\(dq); \f[I]// false\f[R]

\f[I]// The \(gain\(ga operator will return true for direct or inherited properties:\f[R]
\(dqprop\(dq \f[B]in\f[R] example; \f[I]// true\f[R]
\(dqtoString\(dq \f[B]in\f[R] example; \f[I]// true\f[R]
\(dqhasOwnProperty\(dq \f[B]in\f[R] example; \f[I]// true\f[R]
.EE
.SS Iterating over the properties of an object
To iterate over the enumerable properties of an object, you
\f[I]should\f[R] use:
.IP
.EX
\f[B]const\f[R] example = { foo: \f[B]true\f[R], bar: \f[B]true\f[R] };
\f[B]for\f[R] (\f[B]const\f[R] name \f[B]of\f[R] Object.keys(example)) {
  \f[I]// \&...\f[R]
}
.EE
.PP
But if you need to use \f[CR]for...in\f[R], you can use
\f[CR]Object.hasOwn()\f[R] to skip the inherited properties:
.IP
.EX
\f[B]const\f[R] example = { foo: \f[B]true\f[R], bar: \f[B]true\f[R] };
\f[B]for\f[R] (\f[B]const\f[R] name \f[B]in\f[R] example) {
  \f[B]if\f[R] (Object.hasOwn(example, name)) {
    \f[I]// \&...\f[R]
  }
}
.EE
.SS Checking if an Array index exists
The elements of an \f[CR]Array\f[R] are defined as direct properties, so
you can use \f[CR]hasOwn()\f[R] method to check whether a particular
index exists:
.IP
.EX
\f[B]const\f[R] fruits = [\(dqApple\(dq, \(dqBanana\(dq, \(dqWatermelon\(dq, \(dqOrange\(dq];
Object.hasOwn(fruits, 3); \f[I]// true (\(aqOrange\(aq)\f[R]
Object.hasOwn(fruits, 4); \f[I]// false \- not defined\f[R]
.EE
.SS Problematic cases for hasOwnProperty()
This section demonstrates that \f[CR]Object.hasOwn()\f[R] is immune to
the problems that affect \f[CR]hasOwnProperty()\f[R].
Firstly, it can be used with objects that have re\-implemented
\f[CR]hasOwnProperty()\f[R].
In the example below, the re\-implemented \f[CR]hasOwnProperty()\f[R]
method reports false for \f[I]every\f[R] property, but the behavior of
\f[CR]Object.hasOwn()\f[R] remains unaffected:
.IP
.EX
\f[B]const\f[R] foo = {
  hasOwnProperty() {
    \f[B]return\f[R] \f[B]false\f[R];
  },
  bar: \(dqThe dragons be out of office\(dq,
};

console.log(foo.hasOwnProperty(\(dqbar\(dq)); \f[I]// false\f[R]

console.log(Object.hasOwn(foo, \(dqbar\(dq)); \f[I]// true\f[R]
.EE
.PP
It can also be used with \f[CR]null\f[R]\-prototype objects.
These do not inherit from \f[CR]Object.prototype\f[R], and so
\f[CR]hasOwnProperty()\f[R] is inaccessible.
.IP
.EX
\f[B]const\f[R] foo = Object.create(\f[B]null\f[R]);
foo.prop = \(dqexists\(dq;

console.log(foo.hasOwnProperty(\(dqprop\(dq));
\f[I]// Uncaught TypeError: foo.hasOwnProperty is not a function\f[R]

console.log(Object.hasOwn(foo, \(dqprop\(dq)); \f[I]// true\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-object
Polyfill of \f[CR]Object.hasOwn\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/object.hasown
es\-shims polyfill of \f[CR]Object.hasOwn\f[R]
.UE \c
.IP \(bu 2
\f[CR]Object.prototype.hasOwnProperty()\f[R]
.IP \(bu 2
Enumerability and ownership of properties
.IP \(bu 2
\f[CR]Object.getOwnPropertyNames()\f[R]
.IP \(bu 2
\f[CR]for...in\f[R]
.IP \(bu 2
\f[CR]in\f[R]
.IP \(bu 2
Inheritance and the prototype chain
