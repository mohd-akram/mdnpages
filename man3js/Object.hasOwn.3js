.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Object.hasOwn" "JS" "September 25, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.hasOwn \- Object.hasOwn()
.SH SYNOPSIS
The \f[B]\f[CB]Object.hasOwn()\f[B]\f[R] static method returns
\f[CR]true\f[R] if the specified object has the indicated property as
its \f[I]own\f[R] property.
If the property is inherited, or does not exist, the method returns
\f[CR]false\f[R].
.RS
.PP
\f[B]Note:\f[R] \f[CR]Object.hasOwn()\f[R] is intended as a replacement
for \f[CR]Object.prototype.hasOwnProperty()\f[R].
.RE
.SH SYNTAX
.IP
.EX
Object.hasOwn(obj, prop)
.EE
.SS Parameters
.TP
\f[B]obj\f[R]
The JavaScript object instance to test.
.TP
\f[B]prop\f[R]
The \f[CR]String\f[R] name or Symbol of the property to test.
.SS Return value
\f[CR]true\f[R] if the specified object has directly defined the
specified property.
Otherwise \f[CR]false\f[R]
.SH DESCRIPTION
The \f[B]\f[CB]Object.hasOwn()\f[B]\f[R] method returns \f[CR]true\f[R]
if the specified property is a direct property of the object \[em] even
if the property value is \f[CR]null\f[R] or \f[CR]undefined\f[R].
The method returns \f[CR]false\f[R] if the property is inherited, or has
not been declared at all.
Unlike the \f[CR]in\f[R] operator, this method does not check for the
specified property in the object\[cq]s prototype chain.
.PP
It is recommended over \f[CR]Object.prototype.hasOwnProperty()\f[R]
because it works for \f[CR]null\f[R]\-prototype objects and with objects
that have overridden the inherited \f[CR]hasOwnProperty()\f[R] method.
While it is possible to workaround these problems by calling
\f[CR]Object.prototype.hasOwnProperty()\f[R] on an external object,
\f[CR]Object.hasOwn()\f[R] is more intuitive.
.SH EXAMPLES
.SS Using hasOwn to test for a property\[cq]s existence
The following code shows how to determine whether the \f[CR]example\f[R]
object contains a property named \f[CR]prop\f[R].
.IP
.EX
\f[B]const\f[R] example = {};
Object.hasOwn(example, \[dq]prop\[dq]); \f[I]// false \- \[aq]prop\[aq] has not been defined\f[R]

example.prop = \[dq]exists\[dq];
Object.hasOwn(example, \[dq]prop\[dq]); \f[I]// true \- \[aq]prop\[aq] has been defined\f[R]

example.prop = \f[B]null\f[R];
Object.hasOwn(example, \[dq]prop\[dq]); \f[I]// true \- own property exists with value of null\f[R]

example.prop = \f[B]undefined\f[R];
Object.hasOwn(example, \[dq]prop\[dq]); \f[I]// true \- own property exists with value of undefined\f[R]
.EE
.SS Direct vs.\ inherited properties
The following example differentiates between direct properties and
properties inherited through the prototype chain:
.IP
.EX
\f[B]const\f[R] example = {};
example.prop = \[dq]exists\[dq];

\f[I]// \[ga]hasOwn\[ga] will only return true for direct properties:\f[R]
Object.hasOwn(example, \[dq]prop\[dq]); \f[I]// true\f[R]
Object.hasOwn(example, \[dq]toString\[dq]); \f[I]// false\f[R]
Object.hasOwn(example, \[dq]hasOwnProperty\[dq]); \f[I]// false\f[R]

\f[I]// The \[ga]in\[ga] operator will return true for direct or inherited properties:\f[R]
\[dq]prop\[dq] \f[B]in\f[R] example; \f[I]// true\f[R]
\[dq]toString\[dq] \f[B]in\f[R] example; \f[I]// true\f[R]
\[dq]hasOwnProperty\[dq] \f[B]in\f[R] example; \f[I]// true\f[R]
.EE
.SS Iterating over the properties of an object
To iterate over the enumerable properties of an object, you
\f[I]should\f[R] use:
.IP
.EX
\f[B]const\f[R] example = { foo: \f[B]true\f[R], bar: \f[B]true\f[R] };
\f[B]for\f[R] (\f[B]const\f[R] name \f[B]of\f[R] Object.keys(example)) {
  \f[I]// \&...\f[R]
}
.EE
.PP
But if you need to use \f[CR]for...in\f[R], you can use
\f[CR]Object.hasOwn()\f[R] to skip the inherited properties:
.IP
.EX
\f[B]const\f[R] example = { foo: \f[B]true\f[R], bar: \f[B]true\f[R] };
\f[B]for\f[R] (\f[B]const\f[R] name \f[B]in\f[R] example) {
  \f[B]if\f[R] (Object.hasOwn(example, name)) {
    \f[I]// \&...\f[R]
  }
}
.EE
.SS Checking if an Array index exists
The elements of an \f[CR]Array\f[R] are defined as direct properties, so
you can use \f[CR]hasOwn()\f[R] method to check whether a particular
index exists:
.IP
.EX
\f[B]const\f[R] fruits = [\[dq]Apple\[dq], \[dq]Banana\[dq], \[dq]Watermelon\[dq], \[dq]Orange\[dq]];
Object.hasOwn(fruits, 3); \f[I]// true (\[aq]Orange\[aq])\f[R]
Object.hasOwn(fruits, 4); \f[I]// false \- not defined\f[R]
.EE
.SS Problematic cases for hasOwnProperty
This section demonstrates that \f[CR]hasOwn()\f[R] is immune to the
problems that affect \f[CR]hasOwnProperty\f[R].
Firstly, it can be used with objects that have reimplemented
\f[CR]hasOwnProperty()\f[R]:
.IP
.EX
\f[B]const\f[R] foo = {
  hasOwnProperty() {
    \f[B]return\f[R] \f[B]false\f[R];
  },
  bar: \[dq]The dragons be out of office\[dq],
};

\f[B]if\f[R] (Object.hasOwn(foo, \[dq]bar\[dq])) {
  console.log(foo.bar); \f[I]// true \- re\-implementation of hasOwnProperty() does not affect Object\f[R]
}
.EE
.PP
It can also be used with \f[CR]null\f[R]\-prototype objects.
These do not inherit from \f[CR]Object.prototype\f[R], and so
\f[CR]hasOwnProperty()\f[R] is inaccessible.
.IP
.EX
\f[B]const\f[R] foo = Object.create(\f[B]null\f[R]);
foo.prop = \[dq]exists\[dq];
\f[B]if\f[R] (Object.hasOwn(foo, \[dq]prop\[dq])) {
  console.log(foo.prop); \f[I]// true \- works irrespective of how the object is created.\f[R]
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-object
Polyfill of \f[CR]Object.hasOwn\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Object.prototype.hasOwnProperty()\f[R]
.IP \[bu] 2
Enumerability and ownership of properties
.IP \[bu] 2
\f[CR]Object.getOwnPropertyNames()\f[R]
.IP \[bu] 2
\f[CR]for...in\f[R]
.IP \[bu] 2
\f[CR]in\f[R]
.IP \[bu] 2
Inheritance and the prototype chain
