.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "SYMBOL.SYMBOL" "3JS" "March 14, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Symbol.Symbol \- Symbol() constructor
.SH SYNOPSIS
The \f[B]\f[CB]Symbol()\f[B]\f[R] function returns primitive values of
type Symbol.
.IP
.EX
\f[B]const\f[R] symbol1 = Symbol();
\f[B]const\f[R] symbol2 = Symbol(42);
\f[B]const\f[R] symbol3 = Symbol(\(dqfoo\(dq);

console.log(\f[B]typeof\f[R] symbol1);
\f[I]// Expected output: \(dqsymbol\(dq\f[R]

console.log(symbol2 === 42);
\f[I]// Expected output: false\f[R]

console.log(symbol3.toString());
\f[I]// Expected output: \(dqSymbol(foo)\(dq\f[R]

console.log(Symbol(\(dqfoo\(dq) === Symbol(\(dqfoo\(dq));
\f[I]// Expected output: false\f[R]
.EE
.SH SYNTAX
.IP
.EX
Symbol()
Symbol(description)
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]Symbol()\f[R] can only be called without
\f[CR]new\f[R].
Attempting to construct it with \f[CR]new\f[R] throws a
\f[CR]TypeError\f[R].
.RE
.SS Parameters
.TP
\f[B]description\f[R] \f[I](optional)\f[R]
A string.
A description of the symbol which can be used for debugging but not to
access the symbol itself.
.SH EXAMPLES
.SS Creating symbols
To create a new primitive symbol, you write \f[CR]Symbol()\f[R] with an
optional string as its description:
.IP
.EX
\f[B]const\f[R] sym1 = Symbol();
\f[B]const\f[R] sym2 = Symbol(\(dqfoo\(dq);
\f[B]const\f[R] sym3 = Symbol(\(dqfoo\(dq);
.EE
.PP
The above code creates three new symbols.
Note that \f[CR]Symbol(\(dqfoo\(dq)\f[R] does not coerce the string
\f[CR]\(dqfoo\(dq\f[R] into a symbol.
It creates a new symbol each time:
.IP
.EX
Symbol(\(dqfoo\(dq) === Symbol(\(dqfoo\(dq); \f[I]// false\f[R]
.EE
.SS new Symbol()
The following syntax with the \f[CR]new\f[R] operator will throw a
\f[CR]TypeError\f[R]:
.PP
\f[B]Bad\f[R]
.IP
.EX
\f[B]const\f[R] sym = \f[B]new\f[R] Symbol(); \f[I]// TypeError\f[R]
.EE
.PP
This prevents authors from creating an explicit \f[CR]Symbol\f[R]
wrapper object instead of a new symbol value and might be surprising as
creating explicit wrapper objects around primitive data types is
generally possible (for example, \f[CR]new Boolean\f[R],
\f[CR]new String\f[R] and \f[CR]new Number\f[R]).
.PP
If you really want to create a \f[CR]Symbol\f[R] wrapper object, you can
use the \f[CR]Object()\f[R] function:
.IP
.EX
\f[B]const\f[R] sym = Symbol(\(dqfoo\(dq);
\f[B]const\f[R] symObj = Object(sym);
\f[B]typeof\f[R] sym; \f[I]// \(dqsymbol\(dq\f[R]
\f[B]typeof\f[R] symObj; \f[I]// \(dqobject\(dq\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-symbol
Polyfill of \f[CR]Symbol\f[R] in \f[CR]core\-js\f[R]
.UE \c
