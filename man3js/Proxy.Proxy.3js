.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Proxy.Proxy" "JS" "September 12, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Proxy.Proxy \- Proxy() constructor
.SH SYNOPSIS
The \f[B]\f[CB]Proxy()\f[B]\f[R] constructor creates \f[CR]Proxy\f[R]
objects.
.SH SYNTAX
.IP
.EX
new Proxy(target, handler)
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]Proxy()\f[R] can only be constructed with
\f[CR]new\f[R].
Attempting to call it without \f[CR]new\f[R] throws a
\f[CR]TypeError\f[R].
.RE
.SS Parameters
.TP
\f[B]target\f[R]
A target object to wrap with \f[CR]Proxy\f[R].
It can be any sort of object, including a native array, a function, or
even another proxy.
.TP
\f[B]handler\f[R]
An object whose properties are functions that define the behavior of the
proxy when an operation is performed on it.
.SH DESCRIPTION
Use the \f[CR]Proxy()\f[R] constructor to create a new \f[CR]Proxy\f[R]
object.
This constructor takes two mandatory arguments:
.IP \[bu] 2
\f[CR]target\f[R] is the object for which you want to create the proxy
.IP \[bu] 2
\f[CR]handler\f[R] is the object that defines the custom behavior of the
proxy.
.PP
An empty handler will create a proxy that behaves, in almost all
respects, exactly like the target.
By defining any of a set group of functions on the \f[CR]handler\f[R]
object, you can customize specific aspects of the proxy\[cq]s behavior.
For example, by defining \f[CR]get()\f[R] you can provide a customized
version of the target\[cq]s property accessor.
.SS Handler functions
This section lists all the handler functions you can define.
Handler functions are sometimes called \f[I]traps\f[R], because they
trap calls to the underlying target object.
.TP
\f[B]handler.apply()\f[R]
A trap for a function call.
.TP
\f[B]handler.construct()\f[R]
A trap for the \f[CR]new\f[R] operator.
.TP
\f[B]handler.defineProperty()\f[R]
A trap for \f[CR]Object.defineProperty\f[R].
.TP
\f[B]handler.deleteProperty()\f[R]
A trap for the \f[CR]delete\f[R] operator.
.TP
\f[B]handler.get()\f[R]
A trap for getting property values.
.TP
\f[B]handler.getOwnPropertyDescriptor()\f[R]
A trap for \f[CR]Object.getOwnPropertyDescriptor\f[R].
.TP
\f[B]handler.getPrototypeOf()\f[R]
A trap for \f[CR]Object.getPrototypeOf\f[R].
.TP
\f[B]handler.has()\f[R]
A trap for the \f[CR]in\f[R] operator.
.TP
\f[B]handler.isExtensible()\f[R]
A trap for \f[CR]Object.isExtensible\f[R].
.TP
\f[B]handler.ownKeys()\f[R]
A trap for \f[CR]Object.getOwnPropertyNames\f[R] and
\f[CR]Object.getOwnPropertySymbols\f[R].
.TP
\f[B]handler.preventExtensions()\f[R]
A trap for \f[CR]Object.preventExtensions\f[R].
.TP
\f[B]handler.set()\f[R]
A trap for setting property values.
.TP
\f[B]handler.setPrototypeOf()\f[R]
A trap for \f[CR]Object.setPrototypeOf\f[R].
.SH EXAMPLES
.SS Selectively proxy property accessors
In this example the target has two properties, \f[CR]notProxied\f[R] and
\f[CR]proxied\f[R].
We define a handler that returns a different value for
\f[CR]proxied\f[R], and lets any other accesses through to the target.
.IP
.EX
\f[B]const\f[R] target = {
  notProxied: \[dq]original value\[dq],
  proxied: \[dq]original value\[dq],
};

\f[B]const\f[R] handler = {
  \f[B]get\f[R](target, prop, receiver) {
    \f[B]if\f[R] (prop === \[dq]proxied\[dq]) {
      \f[B]return\f[R] \[dq]replaced value\[dq];
    }
    \f[B]return\f[R] Reflect.get(...\f[B]arguments\f[R]);
  },
};

\f[B]const\f[R] proxy = \f[B]new\f[R] Proxy(target, handler);

console.log(proxy.notProxied); \f[I]// \[dq]original value\[dq]\f[R]
console.log(proxy.proxied); \f[I]// \[dq]replaced value\[dq]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
Meta programming guide
.IP \[bu] 2
\f[CR]Reflect\f[R]
