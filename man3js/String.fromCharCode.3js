.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "String.fromCharCode" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.fromCharCode \- String.fromCharCode()
.SH SYNOPSIS
The \f[B]\f[CB]String.fromCharCode()\f[B]\f[R] static method returns a
string created from the specified sequence of UTF\-16 code units.
.IP
.EX
console.log(String.fromCharCode(189, 43, 190, 61));
\f[I]// Expected output: \[dq]½+¾=\[dq]\f[R]
.EE
.SH SYNTAX
.IP
.EX
String.fromCharCode()
String.fromCharCode(num1)
String.fromCharCode(num1, num2)
String.fromCharCode(num1, num2, /* \&..., */ numN)
.EE
.SS Parameters
.TP
\f[B]num1\f[R], \&..., \f[B]numN\f[R]
A number between \f[CR]0\f[R] and \f[CR]65535\f[R] (\f[CR]0xFFFF\f[R])
representing a UTF\-16 code unit.
Numbers greater than \f[CR]0xFFFF\f[R] are truncated to the last 16
bits.
No validity checks are performed.
.SS Return value
A string of length \f[CR]N\f[R] consisting of the \f[CR]N\f[R] specified
UTF\-16 code units.
.SH DESCRIPTION
Because \f[CR]fromCharCode()\f[R] is a static method of
\f[CR]String\f[R], you always use it as
\f[CR]String.fromCharCode()\f[R], rather than as a method of a
\f[CR]String\f[R] value you created.
.PP
Unicode code points range from \f[CR]0\f[R] to \f[CR]1114111\f[R]
(\f[CR]0x10FFFF\f[R]).
\f[CR]charCodeAt()\f[R] always returns a value that is less than
\f[CR]65536\f[R], because the higher code points are represented by
\f[I]a pair\f[R] of 16\-bit surrogate pseudo\-characters.
Therefore, in order to produce a full character with value greater than
\f[CR]65535\f[R], it is necessary to provide two code units (as if
manipulating a string with two characters).
For information on Unicode, see UTF\-16 characters, Unicode code points,
and grapheme clusters.
.PP
Because \f[CR]fromCharCode()\f[R] only works with 16\-bit values (same
as the \f[CR]\[rs]u\f[R] escape sequence), a surrogate pair is required
in order to return a supplementary character.
For example, both \f[CR]String.fromCharCode(0xd83c, 0xdf03)\f[R] and
\f[CR]\[dq]\[rs]ud83c\[rs]udf03\[dq]\f[R] return code point
\f[CR]U+1F303\f[R] \[lq]Night with Stars\[rq].
While there is a mathematical relationship between the supplementary
code point value (e.g.\ \f[CR]0x1f303\f[R]) and both surrogate values
that represent it (e.g., \f[CR]0xd83c\f[R] and \f[CR]0xdf03\f[R]), it
does require an extra step to either calculate or look up the surrogate
pair values every time a supplementary code point is to be used.
For this reason, it\[cq]s more convenient to use
\f[CR]String.fromCodePoint()\f[R], which allows for returning
supplementary characters based on their actual code point value.
For example, \f[CR]String.fromCodePoint(0x1f303)\f[R] returns code point
\f[CR]U+1F303\f[R] \[lq]Night with Stars\[rq].
.SH EXAMPLES
.SS Using fromCharCode()
BMP characters, in UTF\-16, use a single code unit:
.IP
.EX
String.fromCharCode(65, 66, 67); \f[I]// returns \[dq]ABC\[dq]\f[R]
String.fromCharCode(0x2014); \f[I]// returns \[dq]\[em]\[dq]\f[R]
String.fromCharCode(0x12014); \f[I]// also returns \[dq]\[em]\[dq]; the digit 1 is truncated and ignored\f[R]
String.fromCharCode(8212); \f[I]// also returns \[dq]\[em]\[dq]; 8212 is the decimal form of 0x2014\f[R]
.EE
.PP
Supplementary characters, in UTF\-16, require two code units (i.e.\ a
surrogate pair):
.IP
.EX
String.fromCharCode(0xd83c, 0xdf03); \f[I]// Code Point U+1F303 \[dq]Night with\f[R]
String.fromCharCode(55356, 57091); \f[I]// Stars\[dq] === \[dq]\[rs]uD83C\[rs]uDF03\[dq]\f[R]

String.fromCharCode(0xd834, 0xdf06, 0x61, 0xd834, 0xdf07); \f[I]// \[dq]\[rs]uD834\[rs]uDF06a\[rs]uD834\[rs]uDF07\[dq]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]String.fromCodePoint()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.charAt()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.charCodeAt()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.codePointAt()\f[R]
