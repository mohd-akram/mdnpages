.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "INTL.LISTFORMAT.LISTFORMAT" "3JS" "March 14, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.ListFormat.ListFormat \- Intl.ListFormat() constructor
.SH SYNOPSIS
The \f[B]\f[CB]Intl.ListFormat()\f[B]\f[R] constructor creates
\f[CR]Intl.ListFormat\f[R] objects.
.IP
.EX
\f[B]const\f[R] vehicles = [\(dqMotorcycle\(dq, \(dqBus\(dq, \(dqCar\(dq];

\f[B]const\f[R] formatter = \f[B]new\f[R] Intl.ListFormat(\(dqen\(dq, {
  style: \(dqlong\(dq,
  type: \(dqconjunction\(dq,
});
console.log(formatter.format(vehicles));
\f[I]// Expected output: \(dqMotorcycle, Bus, and Car\(dq\f[R]

\f[B]const\f[R] formatter2 = \f[B]new\f[R] Intl.ListFormat(\(dqde\(dq, {
  style: \(dqshort\(dq,
  type: \(dqdisjunction\(dq,
});
console.log(formatter2.format(vehicles));
\f[I]// Expected output: \(dqMotorcycle, Bus oder Car\(dq\f[R]

\f[B]const\f[R] formatter3 = \f[B]new\f[R] Intl.ListFormat(\(dqen\(dq, { style: \(dqnarrow\(dq, type: \(dqunit\(dq });
console.log(formatter3.format(vehicles));
\f[I]// Expected output: \(dqMotorcycle Bus Car\(dq\f[R]
.EE
.SH SYNTAX
.IP
.EX
new Intl.ListFormat()
new Intl.ListFormat(locales)
new Intl.ListFormat(locales, options)
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]Intl.ListFormat()\f[R] can only be constructed
with \f[CR]new\f[R].
Attempting to call it without \f[CR]new\f[R] throws a
\f[CR]TypeError\f[R].
.RE
.SS Parameters
.TP
\f[B]locales\f[R] \f[I](optional)\f[R]
A string with a BCP 47 language tag or an \f[CR]Intl.Locale\f[R]
instance, or an array of such locale identifiers.
The runtime\(cqs default locale is used when \f[CR]undefined\f[R] is
passed or when none of the specified locale identifiers is supported.
For the general form and interpretation of the \f[CR]locales\f[R]
argument, see the parameter description on the \f[CR]Intl\f[R] main
page.
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object containing the following properties, in the order they are
retrieved (all of them are optional):
.RS
.TP
\f[B]localeMatcher\f[R]
The locale matching algorithm to use.
Possible values are \f[CR]\(dqlookup\(dq\f[R] and
\f[CR]\(dqbest fit\(dq\f[R]; the default is \f[CR]\(dqbest fit\(dq\f[R].
For information about this option, see Locale identification and
negotiation.
.TP
\f[B]type\f[R]
Indicates the type of grouping.
Possible values are:
.RS
.TP
\f[B]\(dqconjunction\(dq\f[R] (default)
For \(lqand\(rq\-based grouping of the list items: \(lqA, B, and C\(rq
.TP
\f[B]\(dqdisjunction\(dq\f[R]
For \(lqor\(rq\-based grouping of the list items: \(lqA, B, or C\(rq
.TP
\f[B]\(dqunit\(dq\f[R]
For grouping the list items as a compound unit (neither
\(lqand\(rq\-based nor \(lqor\(rq\-based): \(lqA, B, C\(rq
.RE
.TP
\f[B]style\f[R]
The grouping style (for example, whether list separators and
conjunctions are included).
Possible values are:
.RS
.TP
\f[B]\(dqlong\(dq\f[R] (default)
The typical list format.
For example, \(lqA, B, and C\(rq
.TP
\f[B]\(dqshort\(dq\f[R]
The spacing, the length or presence of a conjunction, and the separators
may change.
Usually, you would want the input elements to be abbreviated too.
For example, \(lqA, B, & C\(rq
.TP
\f[B]\(dqnarrow\(dq\f[R]
Where possible, the list format is further abbreviated, so that the
output is as short as possible.
For example, \(lqA, B, C\(rq
.RE
.RE
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]locales\f[R] or \f[CR]options\f[R] contain invalid
values.
.SH EXAMPLES
.SS Using format
The following example shows how to create a List formatter using the
English language.
.IP
.EX
\f[B]const\f[R] list = [\(dqMotorcycle\(dq, \(dqBus\(dq, \(dqCar\(dq];

console.log(\f[B]new\f[R] Intl.ListFormat(\(dqen\-GB\(dq, { type: \(dqconjunction\(dq }).format(list));
\f[I]// Motorcycle, Bus and Car\f[R]

console.log(\f[B]new\f[R] Intl.ListFormat(\(dqen\-GB\(dq, { type: \(dqdisjunction\(dq }).format(list));
\f[I]// Motorcycle, Bus or Car\f[R]
.EE
.SS Oxford comma
\c
.UR https://en.wikipedia.org/wiki/Serial_comma
Oxford comma
.UE \c
\ is a comma placed immediately before the coordinating conjunction
(usually \(lqand\(rq or \(lqor\(rq) in a list of three or more terms.
Somewhat controversially, the \f[CR]en\-US\f[R] locale uses the Oxford
comma, while the \f[CR]en\-GB\f[R] locale does not.
.IP
.EX
\f[B]const\f[R] list = [\(dqMotorcycle\(dq, \(dqBus\(dq, \(dqCar\(dq];

console.log(\f[B]new\f[R] Intl.ListFormat(\(dqen\-GB\(dq, { type: \(dqconjunction\(dq }).format(list));
\f[I]// Motorcycle, Bus and Car\f[R]

console.log(\f[B]new\f[R] Intl.ListFormat(\(dqen\-US\(dq, { type: \(dqconjunction\(dq }).format(list));
\f[I]// Motorcycle, Bus, and Car\f[R]
.EE
.SS Unit formatting
Use \f[CR]style: \(dqunit\(dq\f[R] to format the list items as a
compound unit.
In fact, \f[CR]Intl.DurationFormat\f[R] uses unit\-style list formatting
under the hood to format durations.
.IP
.EX
\f[B]const\f[R] marathon = [
  [42, \(dqkilometer\(dq],
  [195, \(dqmeter\(dq],
];

console.log(
  \f[B]new\f[R] Intl.ListFormat(\(dqen\-US\(dq, { type: \(dqunit\(dq }).format(
    marathon.map((component) \f[B]=>\f[R]
      component[0].toLocaleString(\(dqen\-US\(dq, {
        style: \(dqunit\(dq,
        unit: component[1],
        unitDisplay: \(dqlong\(dq,
      }),
    ),
  ),
);
\f[I]// 42 kilometers, 195 meters\f[R]
.EE
.SS Short and narrow style
The \f[CR]\(dqshort\(dq\f[R] and \f[CR]\(dqnarrow\(dq\f[R] styles are
useful for compact representations of lists.
.IP
.EX
\f[B]const\f[R] list = [\(dqMotorcycle\(dq, \(dqBus\(dq, \(dqCar\(dq];
console.log(\f[B]new\f[R] Intl.ListFormat(\(dqen\-US\(dq, { style: \(dqshort\(dq }).format(list));
\f[I]// Motorcycle, Bus, & Car\f[R]

console.log(\f[B]new\f[R] Intl.ListFormat(\(dqen\-US\(dq, { style: \(dqnarrow\(dq }).format(list));
\f[I]// Motorcycle, Bus, Car\f[R]

console.log(\f[B]new\f[R] Intl.ListFormat(\(dqen\-GB\(dq, { style: \(dqshort\(dq }).format(list));
\f[I]// Motorcycle, Bus and Car\f[R]

console.log(\f[B]new\f[R] Intl.ListFormat(\(dqen\-GB\(dq, { style: \(dqnarrow\(dq }).format(list));
\f[I]// Motorcycle, Bus, Car\f[R]
.EE
.PP
The input elements are not transformed, but you will often want to
abbreviate them too.
.IP
.EX
\f[B]const\f[R] marathon = [
  [42, \(dqkilometer\(dq],
  [195, \(dqmeter\(dq],
];

\f[B]function\f[R] formatDistance(locale, distance, style) {
  \f[B]return\f[R] \f[B]new\f[R] Intl.ListFormat(locale, { type: \(dqunit\(dq, style }).format(
    marathon.map((component) \f[B]=>\f[R]
      component[0].toLocaleString(locale, {
        style: \(dqunit\(dq,
        unit: component[1],
        unitDisplay: style,
      }),
    ),
  );
}

console.log(formatDistance(\(dqen\-US\(dq, marathon, \(dqlong\(dq));
\f[I]// 42 kilometers, 195 meters\f[R]
console.log(formatDistance(\(dqen\-US\(dq, marathon, \(dqshort\(dq));
\f[I]// 42 km, 195 m\f[R]
console.log(formatDistance(\(dqen\-US\(dq, marathon, \(dqnarrow\(dq));
\f[I]// 42km 195m\f[R]
.EE
.SS Selection of conjunction
The conjunction word used may depend on the list items\(cq string
values.
For example, in Spanish, the conjunction is \f[CR]\(dqy\(dq\f[R] for
most words, but \f[CR]\(dqe\(dq\f[R] for words starting with the vowel
\f[CR]\(dqi\(dq\f[R].
.IP
.EX
\f[B]const\f[R] words = [\(dqfuerte\(dq, \(dqindomable\(dq];
\f[B]const\f[R] formatter = \f[B]new\f[R] Intl.ListFormat(\(dqes\-ES\(dq, { type: \(dqconjunction\(dq });

console.log(formatter.format(words));
\f[I]// fuerte e indomable\f[R]
console.log(formatter.format(words.toReversed()));
\f[I]// indomable y fuerte\f[R]
.EE
.PP
The algorithm used to determine the conjunction is not perfect (for
example, it can\(cqt always tell a word\(cqs pronunciation from its
spelling), but it should work in the general case.
.SH SEE ALSO
.IP \(bu 2
\f[CR]Intl.ListFormat\f[R]
.IP \(bu 2
\f[CR]Intl\f[R]
