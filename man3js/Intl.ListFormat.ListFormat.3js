.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Intl.ListFormat.ListFormat" "JS" "February 26, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.ListFormat.ListFormat \- Intl.ListFormat() constructor
.SH SYNOPSIS
The \f[B]\f[CB]Intl.ListFormat()\f[B]\f[R] constructor creates
\f[CR]Intl.ListFormat\f[R] objects.
.IP
.EX
\f[B]const\f[R] vehicles = [\[dq]Motorcycle\[dq], \[dq]Bus\[dq], \[dq]Car\[dq]];

\f[B]const\f[R] formatter = \f[B]new\f[R] Intl.ListFormat(\[dq]en\[dq], {
  style: \[dq]long\[dq],
  type: \[dq]conjunction\[dq],
});
console.log(formatter.format(vehicles));
\f[I]// Expected output: \[dq]Motorcycle, Bus, and Car\[dq]\f[R]

\f[B]const\f[R] formatter2 = \f[B]new\f[R] Intl.ListFormat(\[dq]de\[dq], {
  style: \[dq]short\[dq],
  type: \[dq]disjunction\[dq],
});
console.log(formatter2.format(vehicles));
\f[I]// Expected output: \[dq]Motorcycle, Bus oder Car\[dq]\f[R]

\f[B]const\f[R] formatter3 = \f[B]new\f[R] Intl.ListFormat(\[dq]en\[dq], { style: \[dq]narrow\[dq], type: \[dq]unit\[dq] });
console.log(formatter3.format(vehicles));
\f[I]// Expected output: \[dq]Motorcycle Bus Car\[dq]\f[R]
.EE
.SH SYNTAX
.IP
.EX
new Intl.ListFormat()
new Intl.ListFormat(locales)
new Intl.ListFormat(locales, options)
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]Intl.ListFormat()\f[R] can only be constructed
with \f[CR]new\f[R].
Attempting to call it without \f[CR]new\f[R] throws a
\f[CR]TypeError\f[R].
.RE
.SS Parameters
.TP
\f[B]locales\f[R] \f[I](optional)\f[R]
A string with a BCP 47 language tag or an \f[CR]Intl.Locale\f[R]
instance, or an array of such locale identifiers.
The runtime\[cq]s default locale is used when \f[CR]undefined\f[R] is
passed or when none of the specified locale identifiers is supported.
For the general form and interpretation of the \f[CR]locales\f[R]
argument, see the parameter description on the \f[CR]Intl\f[R] main
page.
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object containing the following properties, in the order they are
retrieved (all of them are optional):
.RS
.TP
\f[B]localeMatcher\f[R]
The locale matching algorithm to use.
Possible values are \f[CR]\[dq]lookup\[dq]\f[R] and
\f[CR]\[dq]best fit\[dq]\f[R]; the default is
\f[CR]\[dq]best fit\[dq]\f[R].
For information about this option, see Locale identification and
negotiation.
.TP
\f[B]type\f[R]
Indicates the type of grouping.
Possible values are:
.RS
.TP
\f[B]\[dq]conjunction\[dq]\f[R] (default)
For \[lq]and\[rq]\-based grouping of the list items: \[lq]A, B, and
C\[rq]
.TP
\f[B]\[dq]disjunction\[dq]\f[R]
For \[lq]or\[rq]\-based grouping of the list items: \[lq]A, B, or C\[rq]
.TP
\f[B]\[dq]unit\[dq]\f[R]
For grouping the list items as a compound unit (neither
\[lq]and\[rq]\-based nor \[lq]or\[rq]\-based): \[lq]A, B, C\[rq]
.RE
.TP
\f[B]style\f[R]
The grouping style (for example, whether list separators and
conjunctions are included).
Possible values are:
.RS
.TP
\f[B]\[dq]long\[dq]\f[R] (default)
The typical list format.
For example, \[lq]A, B, and C\[rq]
.TP
\f[B]\[dq]short\[dq]\f[R]
The spacing, the length or presence of a conjunction, and the separators
may change.
Usually, you would want the input elements to be abbreviated too.
For example, \[lq]A, B, & C\[rq]
.TP
\f[B]\[dq]narrow\[dq]\f[R]
Where possible, the list format is further abbreviated, so that the
output is as short as possible.
For example, \[lq]A, B, C\[rq]
.RE
.RE
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]locales\f[R] or \f[CR]options\f[R] contain invalid
values.
.SH EXAMPLES
.SS Using format
The following example shows how to create a List formatter using the
English language.
.IP
.EX
\f[B]const\f[R] list = [\[dq]Motorcycle\[dq], \[dq]Bus\[dq], \[dq]Car\[dq]];

console.log(\f[B]new\f[R] Intl.ListFormat(\[dq]en\-GB\[dq], { type: \[dq]conjunction\[dq] }).format(list));
\f[I]// Motorcycle, Bus and Car\f[R]

console.log(\f[B]new\f[R] Intl.ListFormat(\[dq]en\-GB\[dq], { type: \[dq]disjunction\[dq] }).format(list));
\f[I]// Motorcycle, Bus or Car\f[R]
.EE
.SS Oxford comma
\c
.UR https://en.wikipedia.org/wiki/Serial_comma
Oxford comma
.UE \c
\ is a comma placed immediately before the coordinating conjunction
(usually \[lq]and\[rq] or \[lq]or\[rq]) in a list of three or more
terms.
Somewhat controversially, the \f[CR]en\-US\f[R] locale uses the Oxford
comma, while the \f[CR]en\-GB\f[R] locale does not.
.IP
.EX
\f[B]const\f[R] list = [\[dq]Motorcycle\[dq], \[dq]Bus\[dq], \[dq]Car\[dq]];

console.log(\f[B]new\f[R] Intl.ListFormat(\[dq]en\-GB\[dq], { type: \[dq]conjunction\[dq] }).format(list));
\f[I]// Motorcycle, Bus and Car\f[R]

console.log(\f[B]new\f[R] Intl.ListFormat(\[dq]en\-US\[dq], { type: \[dq]conjunction\[dq] }).format(list));
\f[I]// Motorcycle, Bus, and Car\f[R]
.EE
.SS Unit formatting
Use \f[CR]style: \[dq]unit\[dq]\f[R] to format the list items as a
compound unit.
In fact, \f[CR]Intl.DurationFormat\f[R] uses unit\-style list formatting
under the hood to format durations.
.IP
.EX
\f[B]const\f[R] marathon = [
  [42, \[dq]kilometer\[dq]],
  [195, \[dq]meter\[dq]],
];

console.log(
  \f[B]new\f[R] Intl.ListFormat(\[dq]en\-US\[dq], { type: \[dq]unit\[dq] }).format(
    marathon.map((component) \f[B]=>\f[R]
      component[0].toLocaleString(\[dq]en\-US\[dq], {
        style: \[dq]unit\[dq],
        unit: component[1],
        unitDisplay: \[dq]long\[dq],
      }),
    ),
  ),
);
\f[I]// 42 kilometers, 195 meters\f[R]
.EE
.SS Short and narrow style
The \f[CR]\[dq]short\[dq]\f[R] and \f[CR]\[dq]narrow\[dq]\f[R] styles
are useful for compact representations of lists.
.IP
.EX
\f[B]const\f[R] list = [\[dq]Motorcycle\[dq], \[dq]Bus\[dq], \[dq]Car\[dq]];
console.log(\f[B]new\f[R] Intl.ListFormat(\[dq]en\-US\[dq], { style: \[dq]short\[dq] }).format(list));
\f[I]// Motorcycle, Bus, & Car\f[R]

console.log(\f[B]new\f[R] Intl.ListFormat(\[dq]en\-US\[dq], { style: \[dq]narrow\[dq] }).format(list));
\f[I]// Motorcycle, Bus, Car\f[R]

console.log(\f[B]new\f[R] Intl.ListFormat(\[dq]en\-GB\[dq], { style: \[dq]short\[dq] }).format(list));
\f[I]// Motorcycle, Bus and Car\f[R]

console.log(\f[B]new\f[R] Intl.ListFormat(\[dq]en\-GB\[dq], { style: \[dq]narrow\[dq] }).format(list));
\f[I]// Motorcycle, Bus, Car\f[R]
.EE
.PP
The input elements are not transformed, but you will often want to
abbreviate them too.
.IP
.EX
\f[B]const\f[R] marathon = [
  [42, \[dq]kilometer\[dq]],
  [195, \[dq]meter\[dq]],
];

\f[B]function\f[R] formatDistance(locale, distance, style) {
  \f[B]return\f[R] \f[B]new\f[R] Intl.ListFormat(locale, { type: \[dq]unit\[dq], style }).format(
    marathon.map((component) \f[B]=>\f[R]
      component[0].toLocaleString(locale, {
        style: \[dq]unit\[dq],
        unit: component[1],
        unitDisplay: style,
      }),
    ),
  );
}

console.log(formatDistance(\[dq]en\-US\[dq], marathon, \[dq]long\[dq]));
\f[I]// 42 kilometers, 195 meters\f[R]
console.log(formatDistance(\[dq]en\-US\[dq], marathon, \[dq]short\[dq]));
\f[I]// 42 km, 195 m\f[R]
console.log(formatDistance(\[dq]en\-US\[dq], marathon, \[dq]narrow\[dq]));
\f[I]// 42km 195m\f[R]
.EE
.SS Selection of conjunction
The conjunction word used may depend on the list items\[cq] string
values.
For example, in Spanish, the conjunction is \f[CR]\[dq]y\[dq]\f[R] for
most words, but \f[CR]\[dq]e\[dq]\f[R] for words starting with the vowel
\f[CR]\[dq]i\[dq]\f[R].
.IP
.EX
\f[B]const\f[R] words = [\[dq]fuerte\[dq], \[dq]indomable\[dq]];
\f[B]const\f[R] formatter = \f[B]new\f[R] Intl.ListFormat(\[dq]es\-ES\[dq], { type: \[dq]conjunction\[dq] });

console.log(formatter.format(words));
\f[I]// fuerte e indomable\f[R]
console.log(formatter.format(words.toReversed()));
\f[I]// indomable y fuerte\f[R]
.EE
.PP
The algorithm used to determine the conjunction is not perfect (for
example, it can\[cq]t always tell a word\[cq]s pronunciation from its
spelling), but it should work in the general case.
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Intl.ListFormat\f[R]
.IP \[bu] 2
\f[CR]Intl\f[R]
