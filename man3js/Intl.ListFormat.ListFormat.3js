.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Intl.ListFormat.ListFormat" "JS" "March 15, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.ListFormat.ListFormat \- Intl.ListFormat() constructor
.SH SYNOPSIS
The \f[B]\f[CB]Intl.ListFormat()\f[B]\f[R] constructor creates
\f[CR]Intl.ListFormat\f[R] objects.
.SH SYNTAX
.IP
.EX
new Intl.ListFormat()
new Intl.ListFormat(locales)
new Intl.ListFormat(locales, options)
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]Intl.ListFormat()\f[R] can only be constructed
with \f[CR]new\f[R].
Attempting to call it without \f[CR]new\f[R] throws a
\f[CR]TypeError\f[R].
.RE
.SS Parameters
.TP
\f[B]locales\f[R] \f[I](optional)\f[R]
A string with a BCP 47 language tag or an \f[CR]Intl.Locale\f[R]
instance, or an array of such locale identifiers.
The runtime\[cq]s default locale is used when \f[CR]undefined\f[R] is
passed or when none of the specified locale identifiers is supported.
For the general form and interpretation of the \f[CR]locales\f[R]
argument, see the parameter description on the \f[CR]Intl\f[R] main
page.
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object containing the following properties, in the order they are
retrieved (all of them are optional):
.RS
.TP
\f[B]localeMatcher\f[R]
The locale matching algorithm to use.
Possible values are \f[CR]\[dq]lookup\[dq]\f[R] and
\f[CR]\[dq]best fit\[dq]\f[R]; the default is
\f[CR]\[dq]best fit\[dq]\f[R].
For information about this option, see Locale identification and
negotiation.
.TP
\f[B]type\f[R]
Indicates the type of grouping.
Possible values are:
.RS
.TP
\f[B]\[dq]conjunction\[dq]\f[R] (default)
For \[lq]and\[rq]\-based grouping of the list items: \[lq]A, B, and
C\[rq]
.TP
\f[B]\[dq]disjunction\[dq]\f[R]
For \[lq]or\[rq]\-based grouping of the list items: \[lq]A, B, or C\[rq]
.TP
\f[B]\[dq]unit\[dq]\f[R]
For grouping the list items as a unit (neither \[lq]and\[rq]\-based nor
\[lq]or\[rq]\-based): \[lq]A, B, C\[rq]
.RE
.TP
\f[B]style\f[R]
The grouping style (for example, whether list separators and
conjunctions are included).
Possible values are:
.RS
.TP
\f[B]\[dq]long\[dq]\f[R] (default)
E.g.
\[lq]A, B, and C\[rq]
.TP
\f[B]\[dq]short\[dq]\f[R]
E.g.
\[lq]A, B, C\[rq]
.TP
\f[B]\[dq]narrow\[dq]\f[R]
E.g.
\[lq]A B C\[rq]
.RE
.RE
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]locales\f[R] or \f[CR]options\f[R] contain invalid
values.
.SH EXAMPLES
.SS Using format
The following example shows how to create a List formatter using the
English language.
.IP
.EX
\f[B]const\f[R] list = [\[dq]Motorcycle\[dq], \[dq]Bus\[dq], \[dq]Car\[dq]];

console.log(
  \f[B]new\f[R] Intl.ListFormat(\[dq]en\-GB\[dq], { style: \[dq]long\[dq], type: \[dq]conjunction\[dq] }).format(
    list,
  ),
);
\f[I]// Motorcycle, Bus and Car\f[R]

console.log(\f[B]new\f[R] Intl.ListFormat(\[dq]en\-GB\[dq], { style: \[dq]long\[dq] }).format(list));
\f[I]// Motorcycle, Bus and Car\f[R]

console.log(\f[B]new\f[R] Intl.ListFormat(\[dq]en\-US\[dq], { style: \[dq]long\[dq] }).format(list));
\f[I]// Motorcycle, Bus, and Car\f[R]

console.log(
  \f[B]new\f[R] Intl.ListFormat(\[dq]en\-GB\[dq], { style: \[dq]short\[dq], type: \[dq]conjunction\[dq] }).format(
    list,
  ),
);
\f[I]// Motorcycle, Bus and Car\f[R]

console.log(
  \f[B]new\f[R] Intl.ListFormat(\[dq]en\-US\[dq], { style: \[dq]short\[dq], type: \[dq]conjunction\[dq] }).format(
    list,
  ),
);
\f[I]// Motorcycle, Bus, & Car\f[R]

console.log(
  \f[B]new\f[R] Intl.ListFormat(\[dq]en\-GB\[dq], { style: \[dq]narrow\[dq], type: \[dq]conjunction\[dq] }).format(
    list,
  ),
);
\f[I]// Motorcycle, Bus, Car\f[R]

console.log(
  \f[B]new\f[R] Intl.ListFormat(\[dq]en\-GB\[dq], { style: \[dq]long\[dq], type: \[dq]disjunction\[dq] }).format(
    list,
  ),
);
\f[I]// Motorcycle, Bus or Car\f[R]

console.log(
  \f[B]new\f[R] Intl.ListFormat(\[dq]en\-GB\[dq], { style: \[dq]short\[dq], type: \[dq]disjunction\[dq] }).format(
    list,
  ),
);
\f[I]// Motorcycle, Bus or Car\f[R]

console.log(
  \f[B]new\f[R] Intl.ListFormat(\[dq]en\-GB\[dq], { style: \[dq]narrow\[dq], type: \[dq]disjunction\[dq] }).format(
    list,
  ),
);
\f[I]// Motorcycle, Bus or Car\f[R]

console.log(\f[B]new\f[R] Intl.ListFormat(\[dq]en\-US\[dq], { style: \[dq]narrow\[dq] }).format(list));
\f[I]// Motorcycle, Bus, Car\f[R]

console.log(
  \f[B]new\f[R] Intl.ListFormat(\[dq]en\-GB\[dq], { style: \[dq]narrow\[dq], type: \[dq]unit\[dq] }).format(list),
);
\f[I]// Motorcycle Bus Car\f[R]

console.log(
  \f[B]new\f[R] Intl.ListFormat(\[dq]en\-US\[dq], { style: \[dq]long\[dq] }).format([
    \[dq]30 degrees\[dq],
    \[dq]15 minutes\[dq],
    \[dq]50 seconds\[dq],
  ]),
);
\f[I]// 30 degrees, 15 minutes, and 50 seconds\f[R]

console.log(
  \f[B]new\f[R] Intl.ListFormat(\[dq]en\-US\[dq], { style: \[dq]narrow\[dq] }).format([
    \[dq]30 degrees\[dq],
    \[dq]15 minutes\[dq],
    \[dq]50 seconds\[dq],
  ]),
);
\f[I]// 30 degrees, 15 minutes, 50 seconds\f[R]

console.log(
  \f[B]new\f[R] Intl.ListFormat(\[dq]en\-US\[dq], { style: \[dq]narrow\[dq], type: \[dq]unit\[dq] }).format([
    \[dq]30°\[dq],
    \[dq]15′\[dq],
    \[dq]50″\[dq],
  ]),
);
\f[I]// 30° 15′ 50″\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Intl.ListFormat\f[R]
.IP \[bu] 2
\f[CR]Intl\f[R]
