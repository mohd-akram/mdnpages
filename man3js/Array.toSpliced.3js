.\" Automatically generated by Pandoc 3.4
.\"
.TH "Array.toSpliced" "JS" "February 8, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.toSpliced \- Array.prototype.toSpliced()
.SH SYNOPSIS
The \f[B]\f[CB]toSpliced()\f[B]\f[R] method of \f[CR]Array\f[R]
instances is the copying version of the \f[CR]splice()\f[R] method.
It returns a new array with some elements removed and/or replaced at a
given index.
.SH SYNTAX
.IP
.EX
toSpliced(start)
toSpliced(start, deleteCount)
toSpliced(start, deleteCount, item1)
toSpliced(start, deleteCount, item1, item2)
toSpliced(start, deleteCount, item1, item2, /* \&..., */ itemN)
.EE
.SS Parameters
.TP
\f[B]start\f[R]
Zero\-based index at which to start changing the array, converted to an
integer.
.RS
.IP \[bu] 2
Negative index counts back from the end of the array \[em] if
\f[CR]\-array.length <= start < 0\f[R], \f[CR]start + array.length\f[R]
is used.
.IP \[bu] 2
If \f[CR]start < \-array.length\f[R] or \f[CR]start\f[R] is omitted,
\f[CR]0\f[R] is used.
.IP \[bu] 2
If \f[CR]start >= array.length\f[R], no element will be deleted, but the
method will behave as an adding function, adding as many elements as
provided.
.RE
.TP
\f[B]deleteCount\f[R] \f[I](optional)\f[R]
An integer indicating the number of elements in the array to remove from
\f[CR]start\f[R].
.RS
.PP
If \f[CR]deleteCount\f[R] is omitted, or if its value is greater than or
equal to the number of elements after the position specified by
\f[CR]start\f[R], then all the elements from \f[CR]start\f[R] to the end
of the array will be deleted.
However, if you wish to pass any \f[CR]itemN\f[R] parameter, you should
pass \f[CR]Infinity\f[R] as \f[CR]deleteCount\f[R] to delete all
elements after \f[CR]start\f[R], because an explicit
\f[CR]undefined\f[R] gets converted to \f[CR]0\f[R].
.PP
If \f[CR]deleteCount\f[R] is \f[CR]0\f[R] or negative, no elements are
removed.
In this case, you should specify at least one new element (see below).
.RE
.TP
\f[B]item1\f[R], \&..., \f[B]itemN\f[R] \f[I](optional)\f[R]
The elements to add to the array, beginning from \f[CR]start\f[R].
.RS
.PP
If you do not specify any elements, \f[CR]toSpliced()\f[R] will only
remove elements from the array.
.RE
.SS Return value
A new array that consists of all elements before \f[CR]start\f[R],
\f[CR]item1\f[R], \f[CR]item2\f[R], \&..., \f[CR]itemN\f[R], and all
elements after \f[CR]start + deleteCount\f[R].
.SH DESCRIPTION
The \f[CR]toSpliced()\f[R] method, like \f[CR]splice()\f[R], does
multiple things at once: it removes the given number of elements from
the array, starting at a given index, and then inserts the given
elements at the same index.
However, it returns a new array instead of modifying the original array.
The deleted elements therefore are not returned from this method.
.PP
The \f[CR]toSpliced()\f[R] method never produces a sparse array.
If the source array is sparse, the empty slots will be replaced with
\f[CR]undefined\f[R] in the new array.
.PP
The \f[CR]toSpliced()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
.SH EXAMPLES
.SS Deleting, adding, and replacing elements
You can use \f[CR]toSpliced()\f[R] to delete, add, and replace elements
in an array and create a new array more efficiently than using
\f[CR]slice()\f[R] and \f[CR]concat()\f[R].
.IP
.EX
\f[B]const\f[R] months = [\[dq]Jan\[dq], \[dq]Mar\[dq], \[dq]Apr\[dq], \[dq]May\[dq]];

\f[I]// Inserting an element at index 1\f[R]
\f[B]const\f[R] months2 = months.toSpliced(1, 0, \[dq]Feb\[dq]);
console.log(months2); \f[I]// [\[dq]Jan\[dq], \[dq]Feb\[dq], \[dq]Mar\[dq], \[dq]Apr\[dq], \[dq]May\[dq]]\f[R]

\f[I]// Deleting two elements starting from index 2\f[R]
\f[B]const\f[R] months3 = months2.toSpliced(2, 2);
console.log(months3); \f[I]// [\[dq]Jan\[dq], \[dq]Feb\[dq], \[dq]May\[dq]]\f[R]

\f[I]// Replacing one element at index 1 with two new elements\f[R]
\f[B]const\f[R] months4 = months3.toSpliced(1, 1, \[dq]Feb\[dq], \[dq]Mar\[dq]);
console.log(months4); \f[I]// [\[dq]Jan\[dq], \[dq]Feb\[dq], \[dq]Mar\[dq], \[dq]May\[dq]]\f[R]

\f[I]// Original array is not modified\f[R]
console.log(months); \f[I]// [\[dq]Jan\[dq], \[dq]Mar\[dq], \[dq]Apr\[dq], \[dq]May\[dq]]\f[R]
.EE
.SS Using toSpliced() on sparse arrays
The \f[CR]toSpliced()\f[R] method always creates a dense array.
.IP
.EX
\f[B]const\f[R] arr = [1, , 3, 4, , 6];
console.log(arr.toSpliced(1, 2)); \f[I]// [1, 4, undefined, 6]\f[R]
.EE
.SS Calling toSpliced() on non\-array objects
The \f[CR]toSpliced()\f[R] method reads the \f[CR]length\f[R] property
of \f[CR]this\f[R].
It then reads the integer\-keyed properties needed and writes them into
the new array.
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  unrelated: \[dq]foo\[dq],
  0: 5,
  2: 4,
};
console.log(Array.prototype.toSpliced.call(arrayLike, 0, 1, 2, 3));
\f[I]// [2, 3, undefined, 4]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#change-array-by-copy
Polyfill of \f[CR]Array.prototype.toSpliced\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Array.prototype.splice()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.toReversed()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.toSorted()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.with()\f[R]
