.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "MutationRecord.nextSibling" "JS" "April 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
MutationRecord.nextSibling \- MutationRecord: nextSibling property
.SH SYNOPSIS
The \f[CR]MutationRecord\f[R] read\-only property
\f[B]\f[CB]nextSibling\f[B]\f[R] is the next sibling of an added or
removed child node of the \f[CR]target\f[R] of a
\f[CR]MutationObserver\f[R].
.SH VALUE
If a node is added to or removed from the \f[CR]target\f[R] of a
\f[CR]MutationObserver\f[R], the value is the \f[CR]Node\f[R] that is
the next sibling of the added or removed node: that is, the node
immediately following this one in the parent\[cq]s \f[CR]childNodes\f[R]
list.
.PP
The value is \f[CR]null\f[R] if there are no added or removed nodes, or
if the node is the last child of its parent.
.SH EXAMPLES
.SS Log the next sibling of a mutation
This adds a node every time you click the button, but it adds the node
at the \f[I]start of the target\f[R], not the end.
Then the observer logs the \f[CR]textContent\f[R] of the
\f[CR]nextSibling\f[R] of the added node.
.SS HTML
.IP
.EX
<\f[B]button\f[R] id=\[dq]add\-nodes\[dq]>Add a node</\f[B]button\f[R]>
<\f[B]button\f[R] id=\[dq]reset\[dq]>Reset</\f[B]button\f[R]>

<\f[B]pre\f[R] id=\[dq]log\[dq] class=\[dq]log\[dq]>Next sibling of added node:</\f[B]pre\f[R]>
<\f[B]div\f[R] id=\[dq]target\[dq]><\f[B]p\f[R]>Node #0</\f[B]p\f[R]></\f[B]div\f[R]>
.EE
.SS JavaScript
.IP
.EX
\f[B]const\f[R] addNodes = document.querySelector(\[dq]#add\-nodes\[dq]);
\f[B]const\f[R] reset = document.querySelector(\[dq]#reset\[dq]);
\f[B]const\f[R] target = document.querySelector(\[dq]#target\[dq]);
\f[B]let\f[R] nodeNumber = 1;

addNodes.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
  \f[B]const\f[R] newPara = document.createElement(\[dq]p\[dq]);
  newPara.textContent = \[ga]Node #${nodeNumber}\[ga];
  nodeNumber++;
  target.insertBefore(newPara, target.firstChild);
});

reset.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] self.location.reload());

\f[B]function\f[R] logNextSibling(records) {
  \f[B]for\f[R] (\f[B]const\f[R] record \f[B]of\f[R] records) {
    \f[B]if\f[R] (record.type === \[dq]childList\[dq]) {
      \f[B]for\f[R] (\f[B]const\f[R] newNode \f[B]of\f[R] record.addedNodes) {
        log.textContent = \[ga]Next sibling of added node: ${record.nextSibling?.textContent}\[ga];
      }
    }
  }
}

\f[B]const\f[R] observer = \f[B]new\f[R] MutationObserver(logNextSibling);
observer.observe(target, { childList: \f[B]true\f[R] });
.EE
.SS Result
