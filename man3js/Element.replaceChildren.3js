.\" Automatically generated by Pandoc 3.4
.\"
.TH "Element.replaceChildren" "JS" "July 12, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Element.replaceChildren \- Element: replaceChildren() method
.SH SYNOPSIS
The \f[B]\f[CB]Element.replaceChildren()\f[B]\f[R] method replaces the
existing children of a \f[CR]Node\f[R] with a specified new set of
children.
These can be string or \f[CR]Node\f[R] objects.
.SH SYNTAX
.IP
.EX
replaceChildren(param1)
replaceChildren(param1, param2)
replaceChildren(param1, param2, /* \&..., */ paramN)
.EE
.SS Parameters
.TP
\f[B]param1\f[R], \&..., \f[B]paramN\f[R]
A set of \f[CR]Node\f[R] objects or strings to replace the
\f[CR]Element\f[R]\[cq]s existing children with.
If no replacement objects are specified, then the \f[CR]Element\f[R] is
emptied of all child nodes.
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.TP
\f[B]HierarchyRequestError\f[R] \f[B]DOMException\f[R]
Thrown when the \c
.UR https://dom.spec.whatwg.org/#concept-node-tree
constraints of the node tree
.UE \c
\ are violated.
.SH EXAMPLES
.SS Emptying a node
\f[CR]replaceChildren()\f[R] provides a very convenient mechanism for
emptying a node of all its children.
You call it on the parent node without any argument specified:
.IP
.EX
myNode.replaceChildren();
.EE
.SS Transferring nodes between elements
\f[CR]replaceChildren()\f[R] enables you to easily transfer nodes
between elements, without having to resort to verbose looping code.
For example, say we have a simple application allowing you to choose
what food you want for your party.
This HTML might look something like this:
.IP
.EX
<\f[B]h2\f[R]>Party food option list</\f[B]h2\f[R]>

<\f[B]main\f[R]>
  <\f[B]div\f[R]>
    <\f[B]label\f[R] for=\[dq]no\[dq]>No thanks!</\f[B]label\f[R]>

    <\f[B]select\f[R] id=\[dq]no\[dq] multiple size=\[dq]10\[dq]>
      <\f[B]option\f[R]>Apples</\f[B]option\f[R]>
      <\f[B]option\f[R]>Oranges</\f[B]option\f[R]>
      <\f[B]option\f[R]>Grapes</\f[B]option\f[R]>
      <\f[B]option\f[R]>Bananas</\f[B]option\f[R]>
      <\f[B]option\f[R]>Kiwi fruits</\f[B]option\f[R]>
      <\f[B]option\f[R]>Chocolate cookies</\f[B]option\f[R]>
      <\f[B]option\f[R]>Peanut cookies</\f[B]option\f[R]>
      <\f[B]option\f[R]>Chocolate bars</\f[B]option\f[R]>
      <\f[B]option\f[R]>Ham Sandwiches</\f[B]option\f[R]>
      <\f[B]option\f[R]>Cheese Sandwiches</\f[B]option\f[R]>
      <\f[B]option\f[R]>Falafel sandwiches</\f[B]option\f[R]>
      <\f[B]option\f[R]>Ice cream</\f[B]option\f[R]>
      <\f[B]option\f[R]>Jelly</\f[B]option\f[R]>
      <\f[B]option\f[R]>Carrot sticks and hummus</\f[B]option\f[R]>
      <\f[B]option\f[R]>Margherita pizza</\f[B]option\f[R]>
      <\f[B]option\f[R]>Pepperoni pizza</\f[B]option\f[R]>
      <\f[B]option\f[R]>Vegan veggie pizza</\f[B]option\f[R]>
    </\f[B]select\f[R]>
  </\f[B]div\f[R]>

  <\f[B]div\f[R] class=\[dq]buttons\[dq]>
    <\f[B]button\f[R] id=\[dq]to\-yes\[dq]>Transfer to \[dq]Yes\[dq] \-\-&gt;</\f[B]button\f[R]>
    <\f[B]button\f[R] id=\[dq]to\-no\[dq]>&lt;\-\- Transfer to \[dq]No\[dq]</\f[B]button\f[R]>
  </\f[B]div\f[R]>

  <\f[B]div\f[R]>
    <\f[B]label\f[R] for=\[dq]yes\[dq]>Yes please!</\f[B]label\f[R]>

    <\f[B]select\f[R] id=\[dq]yes\[dq] multiple size=\[dq]10\[dq]></\f[B]select\f[R]>
  </\f[B]div\f[R]>
</\f[B]main\f[R]>
.EE
.PP
It would make sense to use some simple CSS to lay out the two select
lists in a line alongside one another, with the control buttons in
between them:
.IP
.EX
main {
  \f[B]display\f[R]: flex;
}

div {
  \f[B]margin\-right\f[R]: 20px;
}

label,
button {
  \f[B]display\f[R]: block;
}

\&.buttons {
  \f[B]display\f[R]: flex;
  \f[B]flex\-flow\f[R]: column;
  \f[B]justify\-content\f[R]: center;
}

select {
  \f[B]width\f[R]: 200px;
}
.EE
.PP
What we want to do is transfer any selected options in the \[lq]no\[rq]
list over to the \[lq]yes\[rq] list when the \[lq]yes\[rq] button is
pressed, and transfer any selected options in the \[lq]yes\[rq] list
over to the \[lq]no\[rq] list when the \[lq]no\[rq] button is pressed.
.PP
To do this, we give each of the buttons a click event handler, which
collects together the selected options you want to transfer in one
constant, and the existing options in the list you are transferring to
in another constant.
It then calls \f[CR]replaceChildren()\f[R] on the list to transfer the
options to, using the spread operator to pass in all the options
contained in both constants.
.IP
.EX
\f[B]const\f[R] noSelect = document.getElementById(\[dq]no\[dq]);
\f[B]const\f[R] yesSelect = document.getElementById(\[dq]yes\[dq]);
\f[B]const\f[R] noBtn = document.getElementById(\[dq]to\-no\[dq]);
\f[B]const\f[R] yesBtn = document.getElementById(\[dq]to\-yes\[dq]);

yesBtn.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
  \f[B]const\f[R] selectedTransferOptions =
    document.querySelectorAll(\[dq]#no option:checked\[dq]);
  \f[B]const\f[R] existingYesOptions = document.querySelectorAll(\[dq]#yes option\[dq]);
  yesSelect.replaceChildren(...selectedTransferOptions, ...existingYesOptions);
});

noBtn.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
  \f[B]const\f[R] selectedTransferOptions = document.querySelectorAll(
    \[dq]#yes option:checked\[dq],
  );
  \f[B]const\f[R] existingNoOptions = document.querySelectorAll(\[dq]#no option\[dq]);
  noSelect.replaceChildren(...selectedTransferOptions, ...existingNoOptions);
});
.EE
.PP
The end result looks like this:
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Element.prepend()\f[R]
.IP \[bu] 2
\f[CR]Element.append()\f[R]
.IP \[bu] 2
\f[CR]NodeList\f[R]
