.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "String.localeCompare" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.localeCompare \- String.prototype.localeCompare()
.SH SYNOPSIS
The \f[B]\f[CB]localeCompare()\f[B]\f[R] method of \f[CR]String\f[R]
values returns a number indicating whether this string comes before, or
after, or is the same as the given string in sort order.
In implementations with \f[CR]Intl.Collator\f[R] API support, this
method delegates to \f[CR]Intl.Collator\f[R].
.PP
When comparing large numbers of strings, such as in sorting large
arrays, it is better to create an \f[CR]Intl.Collator\f[R] object and
use the function provided by its \f[CR]compare()\f[R] method.
.IP
.EX
\f[B]const\f[R] a = \[dq]réservé\[dq]; \f[I]// With accents, lowercase\f[R]
\f[B]const\f[R] b = \[dq]RESERVE\[dq]; \f[I]// No accents, uppercase\f[R]

console.log(a.localeCompare(b));
\f[I]// Expected output: 1\f[R]
console.log(a.localeCompare(b, \[dq]en\[dq], { sensitivity: \[dq]base\[dq] }));
\f[I]// Expected output: 0\f[R]
.EE
.SH SYNTAX
.IP
.EX
localeCompare(compareString)
localeCompare(compareString, locales)
localeCompare(compareString, locales, options)
.EE
.SS Parameters
The \f[CR]locales\f[R] and \f[CR]options\f[R] parameters customize the
behavior of the function and let applications specify the language whose
formatting conventions should be used.
.PP
In implementations that support the \f[CR]Intl.Collator\f[R] API, these
parameters correspond exactly to the \f[CR]Intl.Collator()\f[R]
constructor\[cq]s parameters.
Implementations without \f[CR]Intl.Collator\f[R] support are asked to
ignore both parameters, making the comparison result returned entirely
implementation\-dependent \[em] it\[cq]s only required to be
\f[I]consistent\f[R].
.TP
\f[B]compareString\f[R]
The string against which the \f[CR]referenceStr\f[R] is compared.
All values are coerced to strings, so omitting it or passing
\f[CR]undefined\f[R] causes \f[CR]localeCompare()\f[R] to compare
against the string \f[CR]\[dq]undefined\[dq]\f[R], which is rarely what
you want.
.TP
\f[B]locales\f[R] \f[I](optional)\f[R]
A string with a BCP 47 language tag, or an array of such strings.
Corresponds to the \f[CR]locales\f[R] parameter of the
\f[CR]Intl.Collator()\f[R] constructor.
.RS
.PP
In implementations without \f[CR]Intl.Collator\f[R] support, this
parameter is ignored and the host\[cq]s locale is usually used.
.RE
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object adjusting the output format.
Corresponds to the \f[CR]options\f[R] parameter of the
\f[CR]Intl.Collator()\f[R] constructor.
.RS
.PP
In implementations without \f[CR]Intl.Collator\f[R] support, this
parameter is ignored.
.RE
.PP
See the \f[CR]Intl.Collator()\f[R] constructor for details on the
\f[CR]locales\f[R] and \f[CR]options\f[R] parameters and how to use
them.
.SS Return value
A \f[B]negative\f[R] number if \f[CR]referenceStr\f[R] occurs before
\f[CR]compareString\f[R]; \f[B]positive\f[R] if the
\f[CR]referenceStr\f[R] occurs after \f[CR]compareString\f[R];
\f[CR]0\f[R] if they are equivalent.
.PP
In implementations with \f[CR]Intl.Collator\f[R], this is equivalent to
\f[CR]new Intl.Collator(locales, options).compare(referenceStr, compareString)\f[R].
.SH DESCRIPTION
Returns an integer indicating whether the \f[CR]referenceStr\f[R] comes
before, after or is equivalent to the \f[CR]compareString\f[R].
.IP \[bu] 2
Negative when the \f[CR]referenceStr\f[R] occurs before
\f[CR]compareString\f[R]
.IP \[bu] 2
Positive when the \f[CR]referenceStr\f[R] occurs after
\f[CR]compareString\f[R]
.IP \[bu] 2
Returns \f[CR]0\f[R] if they are equivalent
.RS
.PP
\f[B]Warning:\f[R] Do not rely on exact return values of \f[CR]\-1\f[R]
or \f[CR]1\f[R]!
.PP
Negative and positive integer results vary between browsers (as well as
between browser versions) because the ECMAScript specification only
mandates negative and positive values.
Some browsers may return \f[CR]\-2\f[R] or \f[CR]2\f[R], or even some
other negative or positive value.
.RE
.SH EXAMPLES
.SS Using localeCompare()
.IP
.EX
\f[I]// The letter \[dq]a\[dq] is before \[dq]c\[dq] yielding a negative value\f[R]
\[dq]a\[dq].localeCompare(\[dq]c\[dq]); \f[I]// \-2 or \-1 (or some other negative value)\f[R]

\f[I]// Alphabetically the word \[dq]check\[dq] comes after \[dq]against\[dq] yielding a positive value\f[R]
\[dq]check\[dq].localeCompare(\[dq]against\[dq]); \f[I]// 2 or 1 (or some other positive value)\f[R]

\f[I]// \[dq]a\[dq] and \[dq]a\[dq] are equivalent yielding a neutral value of zero\f[R]
\[dq]a\[dq].localeCompare(\[dq]a\[dq]); \f[I]// 0\f[R]
.EE
.SS Sort an array
\f[CR]localeCompare()\f[R] enables case\-insensitive sorting for an
array.
.IP
.EX
\f[B]const\f[R] items = [\[dq]réservé\[dq], \[dq]Premier\[dq], \[dq]Cliché\[dq], \[dq]communiqué\[dq], \[dq]café\[dq], \[dq]Adieu\[dq]];
items.sort((a, b) \f[B]=>\f[R] a.localeCompare(b, \[dq]fr\[dq], { ignorePunctuation: \f[B]true\f[R] }));
\f[I]// [\[aq]Adieu\[aq], \[aq]café\[aq], \[aq]Cliché\[aq], \[aq]communiqué\[aq], \[aq]Premier\[aq], \[aq]réservé\[aq]]\f[R]
.EE
.SS Check browser support for extended arguments
The \f[CR]locales\f[R] and \f[CR]options\f[R] arguments are not
supported in all browsers yet.
.PP
To check whether an implementation supports them, use the
\f[CR]\[dq]i\[dq]\f[R] argument (a requirement that illegal language
tags are rejected) and look for a \f[CR]RangeError\f[R] exception:
.IP
.EX
\f[B]function\f[R] localeCompareSupportsLocales() {
  \f[B]try\f[R] {
    \[dq]foo\[dq].localeCompare(\[dq]bar\[dq], \[dq]i\[dq]);
  } \f[B]catch\f[R] (e) {
    \f[B]return\f[R] e.name === \[dq]RangeError\[dq];
  }
  \f[B]return\f[R] \f[B]false\f[R];
}
.EE
.SS Using locales
The results provided by \f[CR]localeCompare()\f[R] vary between
languages.
In order to get the sort order of the language used in the user
interface of your application, make sure to specify that language (and
possibly some fallback languages) using the \f[CR]locales\f[R] argument:
.IP
.EX
console.log(\[dq]ä\[dq].localeCompare(\[dq]z\[dq], \[dq]de\[dq])); \f[I]// a negative value: in German, ä sorts before z\f[R]
console.log(\[dq]ä\[dq].localeCompare(\[dq]z\[dq], \[dq]sv\[dq])); \f[I]// a positive value: in Swedish, ä sorts after z\f[R]
.EE
.SS Using options
The results provided by \f[CR]localeCompare()\f[R] can be customized
using the \f[CR]options\f[R] argument:
.IP
.EX
\f[I]// in German, ä has a as the base letter\f[R]
console.log(\[dq]ä\[dq].localeCompare(\[dq]a\[dq], \[dq]de\[dq], { sensitivity: \[dq]base\[dq] })); \f[I]// 0\f[R]

\f[I]// in Swedish, ä and a are separate base letters\f[R]
console.log(\[dq]ä\[dq].localeCompare(\[dq]a\[dq], \[dq]sv\[dq], { sensitivity: \[dq]base\[dq] })); \f[I]// a positive value\f[R]
.EE
.SS Numeric sorting
.IP
.EX
\f[I]// by default, \[dq]2\[dq] > \[dq]10\[dq]\f[R]
console.log(\[dq]2\[dq].localeCompare(\[dq]10\[dq])); \f[I]// 1\f[R]

\f[I]// numeric using options:\f[R]
console.log(\[dq]2\[dq].localeCompare(\[dq]10\[dq], \f[B]undefined\f[R], { numeric: \f[B]true\f[R] })); \f[I]// \-1\f[R]

\f[I]// numeric using locales tag:\f[R]
console.log(\[dq]2\[dq].localeCompare(\[dq]10\[dq], \[dq]en\-u\-kn\-true\[dq])); \f[I]// \-1\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Intl.Collator\f[R]
