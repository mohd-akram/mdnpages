.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "URLSearchParams" "JS" "February 26, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
URLSearchParams \- URLSearchParams
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]URLSearchParams\f[B]\f[R] interface defines utility
methods to work with the query string of a URL.
.PP
\f[CR]URLSearchParams\f[R] objects are iterable, so they can directly be
used in a \f[CR]for...of\f[R] structure to iterate over key/value pairs
in the same order as they appear in the query string, for example the
following two lines are equivalent:
.IP
.EX
\f[B]for\f[R] (\f[B]const\f[R] [key, value] \f[B]of\f[R] mySearchParams) {
}
\f[B]for\f[R] (\f[B]const\f[R] [key, value] \f[B]of\f[R] mySearchParams.entries()) {
}
.EE
.PP
Although \f[CR]URLSearchParams\f[R] is functionally similar to a
\f[CR]Map\f[R], when iterating, it may suffer from some pitfalls that
\f[CR]Map\f[R] doesn\[cq]t encounter due to how it\[cq]s implemented.
.SH CONSTRUCTOR
.TP
\f[B]URLSearchParams()\f[R]
Returns a \f[CR]URLSearchParams\f[R] object instance.
.SH INSTANCE PROPERTIES
.TP
\f[B]size\f[R] \f[I](read\-only)\f[R]
Indicates the total number of search parameter entries.
.SH INSTANCE METHODS
.TP
\f[B]URLSearchParams[Symbol.iterator]()\f[R]
Returns an \f[CR]iterator\f[R] allowing iteration through all key/value
pairs contained in this object in the same order as they appear in the
query string.
.TP
\f[B]URLSearchParams.append()\f[R]
Appends a specified key/value pair as a new search parameter.
.TP
\f[B]URLSearchParams.delete()\f[R]
Deletes search parameters that match a name, and optional value, from
the list of all search parameters.
.TP
\f[B]URLSearchParams.entries()\f[R]
Returns an \f[CR]iterator\f[R] allowing iteration through all key/value
pairs contained in this object in the same order as they appear in the
query string.
.TP
\f[B]URLSearchParams.forEach()\f[R]
Allows iteration through all values contained in this object via a
callback function.
.TP
\f[B]URLSearchParams.get()\f[R]
Returns the first value associated with the given search parameter.
.TP
\f[B]URLSearchParams.getAll()\f[R]
Returns all the values associated with a given search parameter.
.TP
\f[B]URLSearchParams.has()\f[R]
Returns a boolean value indicating if a given parameter, or parameter
and value pair, exists.
.TP
\f[B]URLSearchParams.keys()\f[R]
Returns an \f[CR]iterator\f[R] allowing iteration through all keys of
the key/value pairs contained in this object.
.TP
\f[B]URLSearchParams.set()\f[R]
Sets the value associated with a given search parameter to the given
value.
If there are several values, the others are deleted.
.TP
\f[B]URLSearchParams.sort()\f[R]
Sorts all key/value pairs, if any, by their keys.
.TP
\f[B]URLSearchParams.toString()\f[R]
Returns a string containing a query string suitable for use in a URL.
.TP
\f[B]URLSearchParams.values()\f[R]
Returns an \f[CR]iterator\f[R] allowing iteration through all values of
the key/value pairs contained in this object.
.SH EXAMPLES
.SS Using URLSearchParams
.IP
.EX
\f[B]const\f[R] paramsString = \[dq]q=URLUtils.searchParams&topic=api\[dq];
\f[B]const\f[R] searchParams = \f[B]new\f[R] URLSearchParams(paramsString);

\f[I]// Iterating the search parameters\f[R]
\f[B]for\f[R] (\f[B]const\f[R] p \f[B]of\f[R] searchParams) {
  console.log(p);
}

console.log(searchParams.has(\[dq]topic\[dq])); \f[I]// true\f[R]
console.log(searchParams.has(\[dq]topic\[dq], \[dq]fish\[dq])); \f[I]// false\f[R]
console.log(searchParams.get(\[dq]topic\[dq]) === \[dq]api\[dq]); \f[I]// true\f[R]
console.log(searchParams.getAll(\[dq]topic\[dq])); \f[I]// [\[dq]api\[dq]]\f[R]
console.log(searchParams.get(\[dq]foo\[dq]) === \f[B]null\f[R]); \f[I]// true\f[R]
console.log(searchParams.append(\[dq]topic\[dq], \[dq]webdev\[dq]));
console.log(searchParams.toString()); \f[I]// \[dq]q=URLUtils.searchParams&topic=api&topic=webdev\[dq]\f[R]
console.log(searchParams.set(\[dq]topic\[dq], \[dq]More webdev\[dq]));
console.log(searchParams.toString()); \f[I]// \[dq]q=URLUtils.searchParams&topic=More+webdev\[dq]\f[R]
console.log(searchParams.delete(\[dq]topic\[dq]));
console.log(searchParams.toString()); \f[I]// \[dq]q=URLUtils.searchParams\[dq]\f[R]
.EE
.PP
Search parameters can also be an object.
.IP
.EX
\f[B]const\f[R] paramsObj = { foo: \[dq]bar\[dq], baz: \[dq]bar\[dq] };
\f[B]const\f[R] searchParams = \f[B]new\f[R] URLSearchParams(paramsObj);

console.log(searchParams.toString()); \f[I]// \[dq]foo=bar&baz=bar\[dq]\f[R]
console.log(searchParams.has(\[dq]foo\[dq])); \f[I]// true\f[R]
console.log(searchParams.get(\[dq]foo\[dq])); \f[I]// \[dq]bar\[dq]\f[R]
.EE
.SS Parsing window.location
Unlike \f[CR]URL\f[R], the \f[CR]Location\f[R] interface does not
provide a readily\-available \f[CR]searchParams\f[R] property.
We can parse \f[CR]location.search\f[R] with \f[CR]URLSearchParams\f[R].
.IP
.EX
\f[I]// Assume page has location:\f[R]
\f[I]// https://developer.mozilla.org/en\-US/docs/Web/API/URLSearchParams?foo=a\f[R]
\f[B]const\f[R] paramsString = window.location.search;
\f[B]const\f[R] searchParams = \f[B]new\f[R] URLSearchParams(paramsString);
console.log(searchParams.get(\[dq]foo\[dq])); \f[I]// a\f[R]
.EE
.SS Duplicate search parameters
.IP
.EX
\f[B]const\f[R] paramStr = \[dq]foo=bar&foo=baz\[dq];
\f[B]const\f[R] searchParams = \f[B]new\f[R] URLSearchParams(paramStr);

console.log(searchParams.toString()); \f[I]// \[dq]foo=bar&foo=baz\[dq]\f[R]
console.log(searchParams.has(\[dq]foo\[dq])); \f[I]// true\f[R]
console.log(searchParams.get(\[dq]foo\[dq])); \f[I]// bar, only returns the first value\f[R]
console.log(searchParams.getAll(\[dq]foo\[dq])); \f[I]// [\[dq]bar\[dq], \[dq]baz\[dq]]\f[R]
.EE
.SS No URL parsing
The \f[CR]URLSearchParams\f[R] constructor does \f[I]not\f[R] parse full
URLs.
However, it will strip an initial leading \f[CR]?\f[R] off of a string,
if present.
.IP
.EX
\f[B]const\f[R] paramsString1 = \[dq]http://example.com/search?query=%40\[dq];
\f[B]const\f[R] searchParams1 = \f[B]new\f[R] URLSearchParams(paramsString1);

console.log(searchParams1.has(\[dq]query\[dq])); \f[I]// false\f[R]
console.log(searchParams1.has(\[dq]http://example.com/search?query\[dq])); \f[I]// true\f[R]

console.log(searchParams1.get(\[dq]query\[dq])); \f[I]// null\f[R]
console.log(searchParams1.get(\[dq]http://example.com/search?query\[dq])); \f[I]// \[dq]\[at]\[dq] (equivalent to decodeURIComponent(\[aq]%40\[aq]))\f[R]

\f[B]const\f[R] paramsString2 = \[dq]?query=value\[dq];
\f[B]const\f[R] searchParams2 = \f[B]new\f[R] URLSearchParams(paramsString2);
console.log(searchParams2.has(\[dq]query\[dq])); \f[I]// true\f[R]

\f[B]const\f[R] url = \f[B]new\f[R] URL(\[dq]http://example.com/search?query=%40\[dq]);
\f[B]const\f[R] searchParams3 = \f[B]new\f[R] URLSearchParams(url.search);
console.log(searchParams3.has(\[dq]query\[dq])); \f[I]// true\f[R]
.EE
.SS Percent encoding
\f[CR]URLSearchParams\f[R] objects percent\-encode anything in the \c
.UR https://url.spec.whatwg.org/#application-x-www-form-urlencoded-percent-encode-set
\f[CR]application/x\-www\-form\-urlencoded\f[R] percent\-encode set
.UE \c
\ (which contains all code points except ASCII alphanumeric,
\f[CR]*\f[R], \f[CR]\-\f[R], \f[CR].\f[R], and \f[CR]_\f[R]), and encode
U+0020 SPACE as \f[CR]+\f[R].
However, it only handles percent\-encoding when serializing and
deserializing full URL search params syntax.
When interacting with individual keys and values, you always use the
unencoded version.
.IP
.EX
\f[I]// Creation from parsing a string: percent\-encoding is decoded\f[R]
\f[B]const\f[R] params = \f[B]new\f[R] URLSearchParams(\[dq]%24%25%26=%28%29%2B\[dq]);
\f[I]// Retrieving all keys/values: only decoded values are returned\f[R]
console.log([...params]); \f[I]// [[\[dq]$%&\[dq], \[dq]()+\[dq]]]\f[R]
\f[I]// Getting an individual value: use the decoded key and get the decoded value\f[R]
console.log(params.get(\[dq]$%&\[dq])); \f[I]// \[dq]()+\[dq]\f[R]
console.log(params.get(\[dq]%24%25%26\[dq])); \f[I]// null\f[R]
\f[I]// Setting an individual value: use the unencoded key and value\f[R]
params.append(\[dq]$%&$#\[at]+\[dq], \[dq]$#&*\[at]#()+\[dq]);
\f[I]// Serializing: percent\-encoding is applied\f[R]
console.log(params.toString());
\f[I]// \[dq]%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B\[dq]\f[R]
.EE
.PP
If you append a key/value pair with a percent\-encoded key, that key is
treated as unencoded and is encoded again.
.IP
.EX
\f[B]const\f[R] params = \f[B]new\f[R] URLSearchParams();

params.append(\[dq]%24%26\[dq], \[dq]value\[dq]);
params.toString(); \f[I]// \[dq]%2524%2526=value\[dq]\f[R]
.EE
.SS Preserving plus signs
The \f[CR]URLSearchParams\f[R] constructor interprets plus signs
(\f[CR]+\f[R]) as spaces, which might cause problems.
In the example below, we use hexadecimal escape sequences to mimic a
string containing binary data (where every byte carries information)
that needs to be stored in the URL search params.
Note how the encoded string produced by \f[CR]btoa()\f[R] contains
\f[CR]+\f[R] and isn\[cq]t preserved by \f[CR]URLSearchParams\f[R].
.IP
.EX
\f[B]const\f[R] rawData = \[dq]\[rs]x13à\[rs]x17\[at]\[rs]x1F\[rs]x80\[dq];
\f[B]const\f[R] base64Data = btoa(rawData); \f[I]// \[aq]E+AXQB+A\[aq]\f[R]

\f[B]const\f[R] searchParams = \f[B]new\f[R] URLSearchParams(\[ga]bin=${base64Data}\[ga]); \f[I]// \[aq]bin=E+AXQB+A\[aq]\f[R]
\f[B]const\f[R] binQuery = searchParams.get(\[dq]bin\[dq]); \f[I]// \[aq]E AXQB A\[aq], \[aq]+\[aq] is replaced by spaces\f[R]

console.log(atob(binQuery) === rawData); \f[I]// false\f[R]
.EE
.PP
Never construct \f[CR]URLSearchParams\f[R] objects using dynamically
interpolated strings.
Instead, use the \f[CR]append()\f[R] method, which as mentioned above,
interprets all characters as\-is.
.IP
.EX
\f[B]const\f[R] rawData = \[dq]\[rs]x13à\[rs]x17\[at]\[rs]x1F\[rs]x80\[dq];
\f[B]const\f[R] base64Data = btoa(rawData); \f[I]// \[aq]E+AXQB+A\[aq]\f[R]

\f[B]const\f[R] searchParams = \f[B]new\f[R] URLSearchParams();
searchParams.append(\[dq]bin\[dq], base64Data); \f[I]// \[aq]bin=E%2BAXQB%2BA\[aq]\f[R]
\f[B]const\f[R] binQuery = searchParams.get(\[dq]bin\[dq]); \f[I]// \[aq]E+AXQB+A\[aq]\f[R]

console.log(atob(binQuery) === rawData); \f[I]// true\f[R]
.EE
.SS Interaction with URL.searchParams
The \f[CR]URL.searchParams\f[R] property exposes the URL\[cq]s
\f[CR]search\f[R] string as a \f[CR]URLSearchParams\f[R] object.
When updating this \f[CR]URLSearchParams\f[R], the URL\[cq]s
\f[CR]search\f[R] is updated with its serialization.
However, \f[CR]URL.search\f[R] encodes a subset of characters that
\f[CR]URLSearchParams\f[R] does, and encodes spaces as \f[CR]%20\f[R]
instead of \f[CR]+\f[R].
This may cause some surprising interactions\[em]if you update
\f[CR]searchParams\f[R], even with the same values, the URL may be
serialized differently.
.IP
.EX
\f[B]const\f[R] url = \f[B]new\f[R] URL(\[dq]https://example.com/?a=b \[ti]\[dq]);
console.log(url.href); \f[I]// \[dq]https://example.com/?a=b%20\[ti]\[dq]\f[R]
console.log(url.searchParams.toString()); \f[I]// \[dq]a=b+%7E\[dq]\f[R]
\f[I]// This should be a no\-op, but it changes the URL\[aq]s query to the\f[R]
\f[I]// serialization of its searchParams\f[R]
url.searchParams.sort();
console.log(url.href); \f[I]// \[dq]https://example.com/?a=b+%7E\[dq]\f[R]

\f[B]const\f[R] url2 = \f[B]new\f[R] URL(\[dq]https://example.com?search=1234&param=my%20param\[dq]);
console.log(url2.search); \f[I]// \[dq]?search=1234&param=my%20param\[dq]\f[R]
url2.searchParams.delete(\[dq]search\[dq]);
console.log(url2.search); \f[I]// \[dq]?param=my+param\[dq]\f[R]
.EE
.SS Empty value vs.\ no value
\f[CR]URLSearchParams\f[R] doesn\[cq]t distinguish between a parameter
with nothing after the \f[CR]=\f[R], and a parameter that doesn\[cq]t
have a \f[CR]=\f[R] altogether.
.IP
.EX
\f[B]const\f[R] emptyVal = \f[B]new\f[R] URLSearchParams(\[dq]foo=&bar=baz\[dq]);
console.log(emptyVal.get(\[dq]foo\[dq])); \f[I]// returns \[aq]\[aq]\f[R]
\f[B]const\f[R] noEquals = \f[B]new\f[R] URLSearchParams(\[dq]foo&bar=baz\[dq]);
console.log(noEquals.get(\[dq]foo\[dq])); \f[I]// also returns \[aq]\[aq]\f[R]
console.log(noEquals.toString()); \f[I]// \[aq]foo=&bar=baz\[aq]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#url-and-urlsearchparams
Polyfill of \f[CR]URLSearchParams\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
The \f[CR]URL\f[R] interface.
.IP \[bu] 2
\c
.UR https://developer.chrome.com/blog/urlsearchparams/
Google Developers: Easy URL manipulation with URLSearchParams
.UE \c
