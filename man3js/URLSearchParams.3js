.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "URLSearchParams" "JS" "August 12, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
URLSearchParams \- URLSearchParams
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]URLSearchParams\f[B]\f[R] interface defines utility
methods to work with the query string of a URL.
.PP
\f[CR]URLSearchParams\f[R] objects are iterable, so they can directly be
used in a \f[CR]for...of\f[R] structure to iterate over key/value pairs
in the same order as they appear in the query string, for example the
following two lines are equivalent:
.IP
.EX
\f[B]for\f[R] (\f[B]const\f[R] [key, value] \f[B]of\f[R] mySearchParams) {
}
\f[B]for\f[R] (\f[B]const\f[R] [key, value] \f[B]of\f[R] mySearchParams.entries()) {
}
.EE
.PP
Although \f[CR]URLSearchParams\f[R] is functionally similar to a
\f[CR]Map\f[R], when iterating, it may suffer from some pitfalls that
\f[CR]Map\f[R] doesn\[cq]t encounter due to how it\[cq]s implemented.
.SH CONSTRUCTOR
.TP
\f[B]URLSearchParams()\f[R]
Returns a \f[CR]URLSearchParams\f[R] object instance.
.SH INSTANCE PROPERTIES
.TP
\f[B]size\f[R] \f[I](read\-only)\f[R]
Indicates the total number of search parameter entries.
.SH INSTANCE METHODS
.TP
\f[B]URLSearchParams[Symbol.iterator]()\f[R]
Returns an \f[CR]iterator\f[R] allowing iteration through all key/value
pairs contained in this object in the same order as they appear in the
query string.
.TP
\f[B]URLSearchParams.append()\f[R]
Appends a specified key/value pair as a new search parameter.
.TP
\f[B]URLSearchParams.delete()\f[R]
Deletes search parameters that match a name, and optional value, from
the list of all search parameters.
.TP
\f[B]URLSearchParams.entries()\f[R]
Returns an \f[CR]iterator\f[R] allowing iteration through all key/value
pairs contained in this object in the same order as they appear in the
query string.
.TP
\f[B]URLSearchParams.forEach()\f[R]
Allows iteration through all values contained in this object via a
callback function.
.TP
\f[B]URLSearchParams.get()\f[R]
Returns the first value associated with the given search parameter.
.TP
\f[B]URLSearchParams.getAll()\f[R]
Returns all the values associated with a given search parameter.
.TP
\f[B]URLSearchParams.has()\f[R]
Returns a boolean value indicating if a given parameter, or parameter
and value pair, exists.
.TP
\f[B]URLSearchParams.keys()\f[R]
Returns an \f[CR]iterator\f[R] allowing iteration through all keys of
the key/value pairs contained in this object.
.TP
\f[B]URLSearchParams.set()\f[R]
Sets the value associated with a given search parameter to the given
value.
If there are several values, the others are deleted.
.TP
\f[B]URLSearchParams.sort()\f[R]
Sorts all key/value pairs, if any, by their keys.
.TP
\f[B]URLSearchParams.toString()\f[R]
Returns a string containing a query string suitable for use in a URL.
.TP
\f[B]URLSearchParams.values()\f[R]
Returns an \f[CR]iterator\f[R] allowing iteration through all values of
the key/value pairs contained in this object.
.SH EXAMPLES
.IP
.EX
\f[B]const\f[R] paramsString = \[dq]q=URLUtils.searchParams&topic=api\[dq];
\f[B]const\f[R] searchParams = \f[B]new\f[R] URLSearchParams(paramsString);

\f[I]// Iterating the search parameters\f[R]
\f[B]for\f[R] (\f[B]const\f[R] p \f[B]of\f[R] searchParams) {
  console.log(p);
}

console.log(searchParams.has(\[dq]topic\[dq])); \f[I]// true\f[R]
console.log(searchParams.has(\[dq]topic\[dq], \[dq]fish\[dq])); \f[I]// false\f[R]
console.log(searchParams.get(\[dq]topic\[dq]) === \[dq]api\[dq]); \f[I]// true\f[R]
console.log(searchParams.getAll(\[dq]topic\[dq])); \f[I]// [\[dq]api\[dq]]\f[R]
console.log(searchParams.get(\[dq]foo\[dq]) === \f[B]null\f[R]); \f[I]// true\f[R]
console.log(searchParams.append(\[dq]topic\[dq], \[dq]webdev\[dq]));
console.log(searchParams.toString()); \f[I]// \[dq]q=URLUtils.searchParams&topic=api&topic=webdev\[dq]\f[R]
console.log(searchParams.set(\[dq]topic\[dq], \[dq]More webdev\[dq]));
console.log(searchParams.toString()); \f[I]// \[dq]q=URLUtils.searchParams&topic=More+webdev\[dq]\f[R]
console.log(searchParams.delete(\[dq]topic\[dq]));
console.log(searchParams.toString()); \f[I]// \[dq]q=URLUtils.searchParams\[dq]\f[R]
.EE
.IP
.EX
\f[I]// Search parameters can also be an object\f[R]
\f[B]const\f[R] paramsObj = { foo: \[dq]bar\[dq], baz: \[dq]bar\[dq] };
\f[B]const\f[R] searchParams = \f[B]new\f[R] URLSearchParams(paramsObj);

console.log(searchParams.toString()); \f[I]// \[dq]foo=bar&baz=bar\[dq]\f[R]
console.log(searchParams.has(\[dq]foo\[dq])); \f[I]// true\f[R]
console.log(searchParams.get(\[dq]foo\[dq])); \f[I]// \[dq]bar\[dq]\f[R]
.EE
.SS Duplicate search parameters
.IP
.EX
\f[B]const\f[R] paramStr = \[dq]foo=bar&foo=baz\[dq];
\f[B]const\f[R] searchParams = \f[B]new\f[R] URLSearchParams(paramStr);

console.log(searchParams.toString()); \f[I]// \[dq]foo=bar&foo=baz\[dq]\f[R]
console.log(searchParams.has(\[dq]foo\[dq])); \f[I]// true\f[R]
console.log(searchParams.get(\[dq]foo\[dq])); \f[I]// bar, only returns the first value\f[R]
console.log(searchParams.getAll(\[dq]foo\[dq])); \f[I]// [\[dq]bar\[dq], \[dq]baz\[dq]]\f[R]
.EE
.SS No URL parsing
The \f[CR]URLSearchParams\f[R] constructor does \f[I]not\f[R] parse full
URLs.
However, it will strip an initial leading \f[CR]?\f[R] off of a string,
if present.
.IP
.EX
\f[B]const\f[R] paramsString1 = \[dq]http://example.com/search?query=%40\[dq];
\f[B]const\f[R] searchParams1 = \f[B]new\f[R] URLSearchParams(paramsString1);

console.log(searchParams1.has(\[dq]query\[dq])); \f[I]// false\f[R]
console.log(searchParams1.has(\[dq]http://example.com/search?query\[dq])); \f[I]// true\f[R]

console.log(searchParams1.get(\[dq]query\[dq])); \f[I]// null\f[R]
console.log(searchParams1.get(\[dq]http://example.com/search?query\[dq])); \f[I]// \[dq]\[at]\[dq] (equivalent to decodeURIComponent(\[aq]%40\[aq]))\f[R]

\f[B]const\f[R] paramsString2 = \[dq]?query=value\[dq];
\f[B]const\f[R] searchParams2 = \f[B]new\f[R] URLSearchParams(paramsString2);
console.log(searchParams2.has(\[dq]query\[dq])); \f[I]// true\f[R]

\f[B]const\f[R] url = \f[B]new\f[R] URL(\[dq]http://example.com/search?query=%40\[dq]);
\f[B]const\f[R] searchParams3 = \f[B]new\f[R] URLSearchParams(url.search);
console.log(searchParams3.has(\[dq]query\[dq])); \f[I]// true\f[R]
.EE
.SS Preserving plus signs
The \f[CR]URLSearchParams\f[R] constructor interprets plus signs
(\f[CR]+\f[R]) as spaces, which might cause problems.
In the example below, we use hexadecimal escape sequences to mimic a
string containing binary data (where every byte carries information)
that needs to be stored in the URL search params.
Note how the encoded string produced by \f[CR]btoa()\f[R] contains
\f[CR]+\f[R] and isn\[cq]t preserved by \f[CR]URLSearchParams\f[R].
.IP
.EX
\f[B]const\f[R] rawData = \[dq]\[rs]x13à\[rs]x17\[at]\[rs]x1F\[rs]x80\[dq];
\f[B]const\f[R] base64Data = btoa(rawData); \f[I]// \[aq]E+AXQB+A\[aq]\f[R]

\f[B]const\f[R] searchParams = \f[B]new\f[R] URLSearchParams(\[ga]bin=${base64Data}\[ga]); \f[I]// \[aq]bin=E+AXQB+A\[aq]\f[R]
\f[B]const\f[R] binQuery = searchParams.get(\[dq]bin\[dq]); \f[I]// \[aq]E AXQB A\[aq], \[aq]+\[aq] is replaced by spaces\f[R]

console.log(atob(binQuery) === rawData); \f[I]// false\f[R]
.EE
.PP
You can avoid this by encoding the data with the
\f[CR]encodeURIComponent()\f[R].
.IP
.EX
\f[B]const\f[R] rawData = \[dq]\[rs]x13à\[rs]x17\[at]\[rs]x1F\[rs]x80\[dq];
\f[B]const\f[R] base64Data = btoa(rawData); \f[I]// \[aq]E+AXQB+A\[aq]\f[R]
\f[B]const\f[R] encodedBase64Data = encodeURIComponent(base64Data); \f[I]// \[aq]E%2BAXQB%2BA\[aq]\f[R]

\f[B]const\f[R] searchParams = \f[B]new\f[R] URLSearchParams(\[ga]bin=${encodedBase64Data}\[ga]); \f[I]// \[aq]bin=E%2BAXQB%2BA\[aq]\f[R]
\f[B]const\f[R] binQuery = searchParams.get(\[dq]bin\[dq]); \f[I]// \[aq]E+AXQB+A\[aq]\f[R]

console.log(atob(binQuery) === rawData); \f[I]// true\f[R]
.EE
.SS Empty value vs.\ no value
\f[CR]URLSearchParams\f[R] doesn\[cq]t distinguish between a parameter
with nothing after the \f[CR]=\f[R], and a parameter that doesn\[cq]t
have a \f[CR]=\f[R] altogether.
.IP
.EX
\f[B]const\f[R] emptyVal = \f[B]new\f[R] URLSearchParams(\[dq]foo=&bar=baz\[dq]);
console.log(emptyVal.get(\[dq]foo\[dq])); \f[I]// returns \[aq]\[aq]\f[R]
\f[B]const\f[R] noEquals = \f[B]new\f[R] URLSearchParams(\[dq]foo&bar=baz\[dq]);
console.log(noEquals.get(\[dq]foo\[dq])); \f[I]// also returns \[aq]\[aq]\f[R]
console.log(noEquals.toString()); \f[I]// \[aq]foo=&bar=baz\[aq]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#url-and-urlsearchparams
Polyfill of \f[CR]URLSearchParams\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
The \f[CR]URL\f[R] interface.
.IP \[bu] 2
\c
.UR https://developer.chrome.com/blog/urlsearchparams/
Google Developers: Easy URL manipulation with URLSearchParams
.UE \c
