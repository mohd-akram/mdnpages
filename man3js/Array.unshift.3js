.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ARRAY.UNSHIFT" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.unshift \- Array.prototype.unshift()
.SH SYNOPSIS
The \f[B]\f[CB]unshift()\f[B]\f[R] method of \f[CR]Array\f[R] instances
adds the specified elements to the beginning of an array and returns the
new length of the array.
.IP
.EX
\f[B]const\f[R] array1 = [1, 2, 3];

console.log(array1.unshift(4, 5));
\f[I]// Expected output: 5\f[R]

console.log(array1);
\f[I]// Expected output: Array [4, 5, 1, 2, 3]\f[R]
.EE
.SH SYNTAX
.IP
.EX
unshift()
unshift(element1)
unshift(element1, element2)
unshift(element1, element2, /* \&..., */ elementN)
.EE
.SS Parameters
.TP
\f[B]element1\f[R], \&..., \f[B]elementN\f[R]
The elements to add to the front of the \f[CR]arr\f[R].
.SS Return value
The new \f[CR]length\f[R] property of the object upon which the method
was called.
.SH DESCRIPTION
The \f[CR]unshift()\f[R] method inserts the given values to the
beginning of an array\-like object.
.PP
\f[CR]Array.prototype.push()\f[R] has similar behavior to
\f[CR]unshift()\f[R], but applied to the end of an array.
.PP
Please note that, if multiple elements are passed as parameters,
they\(cqre inserted in chunk at the beginning of the object, in the
exact same order they were passed as parameters.
Hence, calling \f[CR]unshift()\f[R] with \f[CR]n\f[R] arguments
\f[B]once\f[R], or calling it \f[CR]n\f[R] times with \f[B]1\f[R]
argument (with a loop, for example), don\(cqt yield the same results.
.PP
See example:
.IP
.EX
\f[B]let\f[R] arr = [4, 5, 6];

arr.unshift(1, 2, 3);
console.log(arr);
\f[I]// [1, 2, 3, 4, 5, 6]\f[R]

arr = [4, 5, 6]; \f[I]// resetting the array\f[R]

arr.unshift(1);
arr.unshift(2);
arr.unshift(3);

console.log(arr);
\f[I]// [3, 2, 1, 4, 5, 6]\f[R]
.EE
.PP
The \f[CR]unshift()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
Although strings are also array\-like, this method is not suitable to be
applied on them, as strings are immutable.
.SH EXAMPLES
.SS Using unshift()
.IP
.EX
\f[B]const\f[R] arr = [1, 2];

arr.unshift(0); \f[I]// result of the call is 3, which is the new array length\f[R]
\f[I]// arr is [0, 1, 2]\f[R]

arr.unshift(\-2, \-1); \f[I]// the new array length is 5\f[R]
\f[I]// arr is [\-2, \-1, 0, 1, 2]\f[R]

arr.unshift([\-4, \-3]); \f[I]// the new array length is 6\f[R]
\f[I]// arr is [[\-4, \-3], \-2, \-1, 0, 1, 2]\f[R]

arr.unshift([\-7, \-6], [\-5]); \f[I]// the new array length is 8\f[R]
\f[I]// arr is [ [\-7, \-6], [\-5], [\-4, \-3], \-2, \-1, 0, 1, 2 ]\f[R]
.EE
.SS Calling unshift() on non\-array objects
The \f[CR]unshift()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R].
It shifts all indices in the range \f[CR]0\f[R] to
\f[CR]length \- 1\f[R] right by the number of arguments (incrementing
their values by this number).
Then, it sets each index starting at \f[CR]0\f[R] with the arguments
passed to \f[CR]unshift()\f[R].
Finally, it sets the \f[CR]length\f[R] to the previous length plus the
number of prepended elements.
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  unrelated: \(dqfoo\(dq,
  2: 4,
};
Array.prototype.unshift.call(arrayLike, 1, 2);
console.log(arrayLike);
\f[I]// { \(aq0\(aq: 1, \(aq1\(aq: 2, \(aq4\(aq: 4, length: 5, unrelated: \(aqfoo\(aq }\f[R]

\f[B]const\f[R] plainObj = {};
\f[I]// There\(aqs no length property, so the length is 0\f[R]
Array.prototype.unshift.call(plainObj, 1, 2);
console.log(plainObj);
\f[I]// { \(aq0\(aq: 1, \(aq1\(aq: 2, length: 2 }\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype.unshift\f[R] in \f[CR]core\-js\f[R]
with fixes of this method
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/array.prototype.unshift
es\-shims polyfill of \f[CR]Array.prototype.unshift\f[R]
.UE \c
.IP \(bu 2
Indexed collections guide
.IP \(bu 2
\f[CR]Array\f[R]
.IP \(bu 2
\f[CR]Array.prototype.push()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.pop()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.shift()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.concat()\f[R]
.IP \(bu 2
\f[CR]Array.prototype.splice()\f[R]
