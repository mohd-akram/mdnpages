.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "REFLECT" "3JS" "July 13, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Reflect \- Reflect
.SH SYNOPSIS
The \f[B]\f[CB]Reflect\f[B]\f[R] namespace object contains static
methods for invoking interceptable JavaScript object internal methods.
The methods are the same as those of proxy handlers.
.SH DESCRIPTION
Unlike most global objects, \f[CR]Reflect\f[R] is not a constructor.
You cannot use it with the \f[CR]new\f[R] operator or invoke the
\f[CR]Reflect\f[R] object as a function.
All properties and methods of \f[CR]Reflect\f[R] are static (just like
the \f[CR]Math\f[R] object).
.PP
The \f[CR]Reflect\f[R] object provides a collection of static functions
which have the same names as the proxy handler methods.
.PP
The major use case of \f[CR]Reflect\f[R] is to provide default
forwarding behavior in \f[CR]Proxy\f[R] handler traps.
A trap is used to intercept an operation on an object \(em it provides a
custom implementation for an object internal method.
The \f[CR]Reflect\f[R] API is used to invoke the corresponding internal
method.
For example, the code below creates a proxy \f[CR]p\f[R] with a
\f[CR]deleteProperty\f[R] trap that intercepts the \f[CR][[Delete]]\f[R]
internal method.
\f[CR]Reflect.deleteProperty()\f[R] is used to invoke the default
\f[CR][[Delete]]\f[R] behavior on \f[CR]targetObject\f[R] directly.
You can replace it with \f[CR]delete\f[R], but using \f[CR]Reflect\f[R]
saves you from having to remember the syntax that each internal method
corresponds to.
.IP
.EX
\f[B]const\f[R] p = \f[B]new\f[R] Proxy(
  {},
  {
    deleteProperty(targetObject, property) {
      \f[I]// Custom functionality: log the deletion\f[R]
      console.log(\(dqDeleting property:\(dq, property);

      \f[I]// Execute the default introspection behavior\f[R]
      \f[B]return\f[R] Reflect.deleteProperty(targetObject, property);
    },
  },
);
.EE
.PP
The \f[CR]Reflect\f[R] methods also allow finer control of how the
internal method is invoked.
For example, \f[CR]Reflect.construct()\f[R] is the only way to construct
a target function with a specific \f[CR]new.target\f[R] value.
If you use the \f[CR]new\f[R] operator to invoke a function, the
\f[CR]new.target\f[R] value is always the function itself.
This has important effects with subclassing.
For another example, \f[CR]Reflect.get()\f[R] allows you to run a getter
with a custom \f[CR]this\f[R] value, while property accessors always use
the current object as the \f[CR]this\f[R] value.
.PP
Nearly every \f[CR]Reflect\f[R] method\(cqs behavior can be done with
some other syntax or method.
Some of these methods have corresponding static methods of the same name
on \f[CR]Object\f[R], although they do have some subtle differences.
For the exact differences, see the description for each
\f[CR]Reflect\f[R] method.
.SH STATIC PROPERTIES
.TP
\f[B]Reflect[Symbol.toStringTag]\f[R]
The initial value of the \f[CR][Symbol.toStringTag]\f[R] property is the
string \f[CR]\(dqReflect\(dq\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH STATIC METHODS
.TP
\f[B]Reflect.apply()\f[R]
Calls a \f[CR]target\f[R] function with arguments as specified by the
\f[CR]argumentsList\f[R] parameter.
See also \f[CR]Function.prototype.apply()\f[R].
.TP
\f[B]Reflect.construct()\f[R]
The \f[CR]new\f[R] operator as a function.
Equivalent to calling \f[CR]new target(...argumentsList)\f[R].
Also provides the option to specify a different prototype.
.TP
\f[B]Reflect.defineProperty()\f[R]
Similar to \f[CR]Object.defineProperty()\f[R].
Returns a boolean that is \f[CR]true\f[R] if the property was
successfully defined.
.TP
\f[B]Reflect.deleteProperty()\f[R]
The \f[CR]delete\f[R] operator as a function.
Equivalent to calling \f[CR]delete target[propertyKey]\f[R].
.TP
\f[B]Reflect.get()\f[R]
Returns the value of the property.
Works like getting a property from an object
(\f[CR]target[propertyKey]\f[R]) as a function.
.TP
\f[B]Reflect.getOwnPropertyDescriptor()\f[R]
Similar to \f[CR]Object.getOwnPropertyDescriptor()\f[R].
Returns a property descriptor of the given property if it exists on the
object, \f[CR]undefined\f[R] otherwise.
.TP
\f[B]Reflect.getPrototypeOf()\f[R]
Same as \f[CR]Object.getPrototypeOf()\f[R].
.TP
\f[B]Reflect.has()\f[R]
Returns a boolean indicating whether the target has the property.
Either as own or inherited.
Works like the \f[CR]in\f[R] operator as a function.
.TP
\f[B]Reflect.isExtensible()\f[R]
Same as \f[CR]Object.isExtensible()\f[R].
Returns a boolean that is \f[CR]true\f[R] if the target is extensible.
.TP
\f[B]Reflect.ownKeys()\f[R]
Returns an array of the target object\(cqs own (not inherited) property
keys.
.TP
\f[B]Reflect.preventExtensions()\f[R]
Similar to \f[CR]Object.preventExtensions()\f[R].
Returns a boolean that is \f[CR]true\f[R] if the update was successful.
.TP
\f[B]Reflect.set()\f[R]
A function that assigns values to properties.
Returns a boolean that is \f[CR]true\f[R] if the update was successful.
.TP
\f[B]Reflect.setPrototypeOf()\f[R]
A function that sets the prototype of an object.
Returns a boolean that is \f[CR]true\f[R] if the update was successful.
.SH EXAMPLES
.SS Detecting whether an object contains certain properties
.IP
.EX
\f[B]const\f[R] duck = {
  name: \(dqMaurice\(dq,
  color: \(dqwhite\(dq,
  greeting() {
    console.log(\(gaQuaaaack! My name is ${\f[B]this\f[R].name}\(ga);
  },
};

Reflect.has(duck, \(dqcolor\(dq);
\f[I]// true\f[R]
Reflect.has(duck, \(dqhaircut\(dq);
\f[I]// false\f[R]
.EE
.SS Returning the object\(cqs own keys
.IP
.EX
Reflect.ownKeys(duck);
\f[I]// [ \(dqname\(dq, \(dqcolor\(dq, \(dqgreeting\(dq ]\f[R]
.EE
.SS Adding a new property to the object
.IP
.EX
Reflect.set(duck, \(dqeyes\(dq, \(dqblack\(dq);
\f[I]// returns \(dqtrue\(dq if successful\f[R]
\f[I]// \(dqduck\(dq now contains the property \(dqeyes: \(aqblack\(aq\(dq\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Proxy\f[R]
