.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Uint8Array.fromBase64" "JS" "November 5, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Uint8Array.fromBase64 \- Uint8Array.fromBase64()
.SH SYNOPSIS
The \f[B]\f[CB]Uint8Array.fromBase64()\f[B]\f[R] static method creates a
new \f[CR]Uint8Array\f[R] object from a base64\-encoded string.
.PP
This method should be preferred over \f[CR]Window.atob()\f[R] because it
results in a byte array, which is easier to work with than a string
containing raw bytes, unless your decoded binary data is actually
intended to be ASCII text.
If you already have an array buffer allocated and you want to populate
it, use the instance method
\f[CR]Uint8Array.prototype.setFromBase64()\f[R] instead.
.SH SYNTAX
.IP
.EX
Uint8Array.fromBase64(string)
Uint8Array.fromBase64(string, options)
.EE
.SS Parameters
.TP
\f[B]string\f[R]
A base64 string encoding bytes to convert to a \f[CR]Uint8Array\f[R].
The string must only contain characters in the base64 alphabet, which
includes A\[en]Z, a\[en]z, 0\[en]9, and two special characters, which
are either \f[CR]+\f[R] and \f[CR]/\f[R] (if using
\f[CR]alphabet: \[dq]base64\[dq]\f[R] in \f[CR]options\f[R]) or
\f[CR]\-\f[R] and \f[CR]_\f[R] (if using
\f[CR]alphabet: \[dq]base64url\[dq]\f[R] in \f[CR]options\f[R]).
It may have padding \f[CR]=\f[R] characters at the end.
Any ASCII white space characters within the string are ignored.
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object customizing the base64 string interpretation process.
It can contain the following properties:
.RS
.TP
\f[B]alphabet\f[R] \f[I](optional)\f[R]
A string specifying the base64 alphabet to use.
It can be one of the following:
.RS
.TP
\f[B]\[dq]base64\[dq]\f[R] (default)
Accept input encoded with the standard base64 alphabet, which uses
\f[CR]+\f[R] and \f[CR]/\f[R].
.TP
\f[B]\[dq]base64url\[dq]\f[R]
Accept input encoded with the URL\-safe base64 alphabet, which uses
\f[CR]\-\f[R] and \f[CR]_\f[R].
.RE
.TP
\f[B]lastChunkHandling\f[R] \f[I](optional)\f[R]
A string specifying how to handle the last chunk of the base64 string.
Because every 4 characters in base64 encodes 3 bytes, the string is
separated into chunks of 4 characters.
If the last chunk has fewer than 4 characters, it needs to be handled
differently.
It can be one of the following:
.RS
.TP
\f[B]\[dq]loose\[dq]\f[R] (default)
The last chunk can either be 2 or 3 base64 characters, or exactly 4
characters long with padding \f[CR]=\f[R] characters.
The last chunk is decoded and appended to the result.
.TP
\f[B]\[dq]strict\[dq]\f[R]
The last chunk must be exactly 4 characters long with padding
\f[CR]=\f[R] characters.
Furthermore, overflow bits (trailing bits from the last base64 character
that don\[cq]t represent any data) must be 0.
The last chunk is decoded and appended to the result.
.TP
\f[B]\[dq]stop\-before\-partial\[dq]\f[R]
If the last chunk is exactly 4 characters long with padding \f[CR]=\f[R]
characters, then it\[cq]s decoded and appended to the result.
Otherwise, the last partial chunk is ignored (but if it contains one
base64 character followed by \f[CR]=\f[R], then a syntax error is still
thrown).
This is useful if the string is coming from a stream and the last chunk
is not yet complete.
To know how many characters of the input were read, use
\f[CR]Uint8Array.prototype.setFromBase64()\f[R] instead (the linked page
also contains an example of stream decoding using
\f[CR]\[dq]stop\-before\-partial\[dq]\f[R]).
.RE
.RE
.SS Return value
A new \f[CR]Uint8Array\f[R] object containing the decoded bytes from the
base64\-encoded string.
.SS Exceptions
.TP
\f[B]SyntaxError\f[R]
Thrown if the input string contains characters outside the specified
alphabet, or if the last chunk does not satisfy the
\f[CR]lastChunkHandling\f[R] option.
.TP
\f[B]TypeError\f[R]
Thrown in one of the following cases:
.RS
.IP \[bu] 2
The input string is not a string.
.IP \[bu] 2
The \f[CR]options\f[R] object is not an object or \f[CR]undefined\f[R].
.IP \[bu] 2
The options are not of the expected values or \f[CR]undefined\f[R].
.RE
.SH EXAMPLES
.SS Decoding a base64 string
This example uses the default \f[CR]alphabet\f[R] and
\f[CR]lastChunkHandling\f[R] options to decode a base64 string.
Note that:
.IP \[bu] 2
The whitespace in the space is ignored.
.IP \[bu] 2
The string has 14 base64 characters, not a multiple of 4.
This is only valid and decodable with
\f[CR]lastChunkHandling: \[dq]loose\[dq]\f[R].
.IP \[bu] 2
The last chunk, \f[CR]Ph\f[R], ends in the character \f[CR]h\f[R] which
is \f[CR]0b100001\f[R] in base64, so the last \f[CR]0001\f[R] bits are
\[lq]overflow bits\[rq] and are ignored.
This is only valid and decodable with
\f[CR]lastChunkHandling: \[dq]loose\[dq]\f[R].
.IP
.EX
\f[B]const\f[R] uint8Array = Uint8Array.fromBase64(\[dq]PGI+ TURO PC9i Ph\[dq]);
console.log(uint8Array); \f[I]// Uint8Array(10) [60, 98, 62, 77, 68, 78, 60, 47, 98, 62]\f[R]
.EE
.SS Decoding a URL\-safe base64 string
This example uses the \f[CR]alphabet\f[R] option to decode a URL\-safe
base64 string.
.IP
.EX
\f[B]const\f[R] uint8Array = Uint8Array.fromBase64(\[dq]PGI\-TUROPC9iPg\[dq], {
  alphabet: \[dq]base64url\[dq],
});
console.log(uint8Array); \f[I]// Uint8Array(10) [60, 98, 62, 77, 68, 78, 60, 47, 98, 62]\f[R]
.EE
.SS Decoding a base64 string with strict last chunk handling
This example uses the \f[CR]lastChunkHandling\f[R] option to decode a
base64 string, where the last chunk must be exactly 4 characters long
with padding \f[CR]=\f[R] characters, and the overflow bits must be 0.
.IP
.EX
\f[B]const\f[R] array1 = Uint8Array.fromBase64(\[dq]PGI+ TURO PC9i Pg==\[dq], {
  lastChunkHandling: \[dq]strict\[dq],
});
console.log(array1); \f[I]// Uint8Array(10) [60, 98, 62, 77, 68, 78, 60, 47, 98, 62]\f[R]

\f[B]const\f[R] array2 = Uint8Array.fromBase64(\[dq]PGI+ TURO PC9i Ph==\[dq], {
  lastChunkHandling: \[dq]strict\[dq],
});
\f[I]// Throws a SyntaxError because h is 0b100001, where the last 4 bits are not 0\f[R]

\f[B]const\f[R] array3 = Uint8Array.fromBase64(\[dq]PGI+ TURO PC9i Pg\[dq], {
  lastChunkHandling: \[dq]strict\[dq],
});
\f[I]// Throws a SyntaxError because the last chunk is not exactly 4 characters long\f[R]
.EE
.SS Decoding a base64 string with partial last chunk handling
This example uses the \f[CR]lastChunkHandling\f[R] option to decode a
base64 string, ignoring any partial last chunk.
.IP
.EX
\f[I]// The last chunk is complete\f[R]
\f[B]const\f[R] array1 = Uint8Array.fromBase64(\[dq]PGI+ TURO PC9i\[dq], {
  lastChunkHandling: \[dq]stop\-before\-partial\[dq],
});
console.log(array1); \f[I]// Uint8Array(9) [60, 98, 62, 77, 68, 78, 60, 47, 98]\f[R]

\f[I]// The last chunk is also complete with padding\f[R]
\f[B]const\f[R] array2 = Uint8Array.fromBase64(\[dq]PGI+ TURO PC9i Pg==\[dq], {
  lastChunkHandling: \[dq]stop\-before\-partial\[dq],
});
console.log(array2); \f[I]// Uint8Array(10) [60, 98, 62, 77, 68, 78, 60, 47, 98, 62]\f[R]

\f[I]// The last chunk is partial; it\[aq]s ignored\f[R]
\f[B]const\f[R] array3 = Uint8Array.fromBase64(\[dq]PGI+ TURO PC9i Pg\[dq], {
  lastChunkHandling: \[dq]stop\-before\-partial\[dq],
});
console.log(array3); \f[I]// Uint8Array(9) [60, 98, 62, 77, 68, 78, 60, 47, 98]\f[R]

\f[I]// The last chunk is partial with padding; it\[aq]s still ignored\f[R]
\f[B]const\f[R] array4 = Uint8Array.fromBase64(\[dq]PGI+ TURO PC9i Pg=\[dq], {
  lastChunkHandling: \[dq]stop\-before\-partial\[dq],
});
console.log(array4); \f[I]// Uint8Array(9) [60, 98, 62, 77, 68, 78, 60, 47, 98]\f[R]

\f[I]// The last chunk is partial, but it contains one base64 character followed by \[ga]=\[ga]\f[R]
\f[B]const\f[R] array5 = Uint8Array.fromBase64(\[dq]PGI+ TURO PC9i P=\[dq], {
  lastChunkHandling: \[dq]stop\-before\-partial\[dq],
});
\f[I]// Throws a SyntaxError because this cannot possibly be part of a valid base64 string\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#uint8array-to--from-base64-and-hex
Polyfill of \f[CR]Uint8Array.fromBase64\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Uint8Array\f[R]
.IP \[bu] 2
\f[CR]Uint8Array.prototype.setFromBase64()\f[R]
.IP \[bu] 2
\f[CR]Uint8Array.prototype.toBase64()\f[R]
.IP \[bu] 2
\f[CR]Window.atob()\f[R]
