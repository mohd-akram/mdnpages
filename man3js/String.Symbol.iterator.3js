.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "String.Symbol.iterator" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.Symbol.iterator \- String.prototypeSymbol.iterator
.SH SYNOPSIS
The \f[B]\f[CB][Symbol.iterator]()\f[B]\f[R] method of \f[CR]String\f[R]
values implements the iterable protocol and allows strings to be
consumed by most syntaxes expecting iterables, such as the spread syntax
and \f[CR]for...of\f[R] loops.
It returns a string iterator object that yields the Unicode code points
of the string value as individual strings.
.IP
.EX
\f[B]const\f[R] str = \[dq]The quick red fox jumped over the lazy dog\[aq]s back.\[dq];

\f[B]const\f[R] iterator = str[Symbol.iterator]();
\f[B]let\f[R] theChar = iterator.next();

\f[B]while\f[R] (!theChar.done && theChar.value !== \[dq] \[dq]) {
  console.log(theChar.value);
  theChar = iterator.next();
  \f[I]// Expected output: \[dq]T\[dq]\f[R]
  \f[I]//                  \[dq]h\[dq]\f[R]
  \f[I]//                  \[dq]e\[dq]\f[R]
}
.EE
.SH SYNTAX
.IP
.EX
string[Symbol.iterator]()
.EE
.SS Parameters
None.
.SS Return value
A new iterable iterator object that yields the Unicode code points of
the string value as individual strings.
.SH DESCRIPTION
Strings are iterated by Unicode code points.
This means grapheme clusters will be split, but surrogate pairs will be
preserved.
.IP
.EX
\f[I]// \[dq]Backhand Index Pointing Right: Dark Skin Tone\[dq]\f[R]
[...\[dq]üëâüèø\[dq]]; \f[I]// [\[aq]üëâ\[aq], \[aq]üèø\[aq]]\f[R]
\f[I]// splits into the basic \[dq]Backhand Index Pointing Right\[dq] emoji and\f[R]
\f[I]// the \[dq]Dark skin tone\[dq] emoji\f[R]

\f[I]// \[dq]Family: Man, Boy\[dq]\f[R]
[...\[dq]üë®‚Äçüë¶\[dq]]; \f[I]// [ \[aq]üë®\[aq], \[aq]‚Äç\[aq], \[aq]üë¶\[aq] ]\f[R]
\f[I]// splits into the \[dq]Man\[dq] and \[dq]Boy\[dq] emoji, joined by a ZWJ\f[R]
.EE
.SH EXAMPLES
.SS Iteration using for\&...of loop
Note that you seldom need to call this method directly.
The existence of the \f[CR][Symbol.iterator]()\f[R] method makes strings
iterable, and iterating syntaxes like the \f[CR]for...of\f[R] loop
automatically call this method to obtain the iterator to loop over.
.IP
.EX
\f[B]const\f[R] str = \[dq]A\[rs]uD835\[rs]uDC68B\[rs]uD835\[rs]uDC69C\[rs]uD835\[rs]uDC6A\[dq];

\f[B]for\f[R] (\f[B]const\f[R] v \f[B]of\f[R] str) {
  console.log(v);
}
\f[I]// \[dq]A\[dq]\f[R]
\f[I]// \[dq]\[rs]uD835\[rs]uDC68\[dq]\f[R]
\f[I]// \[dq]B\[dq]\f[R]
\f[I]// \[dq]\[rs]uD835\[rs]uDC69\[dq]\f[R]
\f[I]// \[dq]C\[dq]\f[R]
\f[I]// \[dq]\[rs]uD835\[rs]uDC6A\[dq]\f[R]
.EE
.SS Manually hand\-rolling the iterator
You may still manually call the \f[CR]next()\f[R] method of the returned
iterator object to achieve maximum control over the iteration process.
.IP
.EX
\f[B]const\f[R] str = \[dq]A\[rs]uD835\[rs]uDC68\[dq];

\f[B]const\f[R] strIter = str[Symbol.iterator]();

console.log(strIter.next().value); \f[I]// \[dq]A\[dq]\f[R]
console.log(strIter.next().value); \f[I]// \[dq]\[rs]uD835\[rs]uDC68\[dq]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-string-and-regexp
Polyfill of \f[CR]String.prototype[Symbol.iterator]\f[R] in
\f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Numbers and strings guide
.IP \[bu] 2
\f[CR]Symbol.iterator\f[R]
.IP \[bu] 2
Iteration protocols
