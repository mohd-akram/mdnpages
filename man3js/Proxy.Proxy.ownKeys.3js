.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "PROXY.PROXY.OWNKEYS" "3JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Proxy.Proxy.ownKeys \- handler.ownKeys()
.SH SYNOPSIS
The \f[B]\f[CB]handler.ownKeys()\f[B]\f[R] method is a trap for the
\f[CR][[OwnPropertyKeys]]\f[R] object internal method, which is used by
operations such as \f[CR]Object.keys()\f[R],
\f[CR]Reflect.ownKeys()\f[R], etc.
.IP
.EX
\f[B]const\f[R] monster1 = {
  _age: 111,
  [Symbol(\(dqsecret\(dq)]: \(dqI am scared!\(dq,
  eyeCount: 4,
};

\f[B]const\f[R] handler1 = {
  ownKeys(target) {
    \f[B]return\f[R] Reflect.ownKeys(target);
  },
};

\f[B]const\f[R] proxy1 = \f[B]new\f[R] Proxy(monster1, handler1);

\f[B]for\f[R] (\f[B]const\f[R] key \f[B]of\f[R] Object.keys(proxy1)) {
  console.log(key);
  \f[I]// Expected output: \(dq_age\(dq\f[R]
  \f[I]// Expected output: \(dqeyeCount\(dq\f[R]
}
.EE
.SH SYNTAX
.IP
.EX
new Proxy(target, {
  ownKeys(target) {
  }
})
.EE
.SS Parameters
The following parameter is passed to the \f[CR]ownKeys()\f[R] method.
\f[CR]this\f[R] is bound to the handler.
.TP
\f[B]target\f[R]
The target object.
.SS Return value
The \f[CR]ownKeys()\f[R] method must return an array\-like object where
each element is either a \f[CR]String\f[R] or a \f[CR]Symbol\f[R]
containing no duplicate items.
.SH DESCRIPTION
.SS Interceptions
This trap can intercept these operations:
.IP \(bu 2
\f[CR]Object.getOwnPropertyNames()\f[R]
.IP \(bu 2
\f[CR]Object.getOwnPropertySymbols()\f[R]
.IP \(bu 2
\f[CR]Object.keys()\f[R]
.IP \(bu 2
\f[CR]Reflect.ownKeys()\f[R]
.PP
Or any other operation that invokes the \f[CR][[OwnPropertyKeys]]\f[R]
internal method.
.SS Invariants
The proxy\(cqs \f[CR][[OwnPropertyKeys]]\f[R] internal method throws a
\f[CR]TypeError\f[R] if the handler definition violates one of the
following invariants:
.IP \(bu 2
The result is an \f[CR]Object\f[R].
.IP \(bu 2
The list of keys contains no duplicate values.
.IP \(bu 2
The type of each key is either a \f[CR]String\f[R] or a
\f[CR]Symbol\f[R].
.IP \(bu 2
The result list must contain the keys of all non\-configurable own
properties of the target object.
That is, for all keys returned by \f[CR]Reflect.ownKeys()\f[R] on the
target object, if the key reports \f[CR]configurable: false\f[R] by
\f[CR]Reflect.getOwnPropertyDescriptor()\f[R], then the key must be
included in the result List.
.IP \(bu 2
If the target object is not extensible, then the result list must
contain all the keys of the own properties of the target object and no
other values.
That is, if \f[CR]Reflect.isExtensible()\f[R] returns \f[CR]false\f[R]
on \f[CR]target\f[R], then the result list must contain the same values
as the result of \f[CR]Reflect.ownKeys()\f[R] on \f[CR]target\f[R].
.SH EXAMPLES
.SS Trapping of getOwnPropertyNames
The following code traps \f[CR]Object.getOwnPropertyNames()\f[R].
.IP
.EX
\f[B]const\f[R] p = \f[B]new\f[R] Proxy(
  {},
  {
    ownKeys(target) {
      console.log(\(dqcalled\(dq);
      \f[B]return\f[R] [\(dqa\(dq, \(dqb\(dq, \(dqc\(dq];
    },
  },
);

console.log(Object.getOwnPropertyNames(p));
\f[I]// \(dqcalled\(dq\f[R]
\f[I]// [ \(aqa\(aq, \(aqb\(aq, \(aqc\(aq ]\f[R]
.EE
.PP
The following code violates an invariant.
.PP
\f[B]Bad\f[R]
.IP
.EX
\f[B]const\f[R] obj = {};
Object.defineProperty(obj, \(dqa\(dq, {
  configurable: \f[B]false\f[R],
  enumerable: \f[B]true\f[R],
  value: 10,
});

\f[B]const\f[R] p = \f[B]new\f[R] Proxy(obj, {
  ownKeys(target) {
    \f[B]return\f[R] [123, 12.5, \f[B]true\f[R], \f[B]false\f[R], \f[B]undefined\f[R], \f[B]null\f[R], {}, []];
  },
});

console.log(Object.getOwnPropertyNames(p));

\f[I]// TypeError: proxy [[OwnPropertyKeys]] must return an array\f[R]
\f[I]// with only string and symbol elements\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Proxy\f[R]
.IP \(bu 2
\f[CR]Proxy()\f[R] constructor
.IP \(bu 2
\f[CR]Object.getOwnPropertyNames()\f[R]
.IP \(bu 2
\f[CR]Reflect.ownKeys()\f[R]
