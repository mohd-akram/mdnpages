.\" Automatically generated by Pandoc 3.4
.\"
.TH "SubtleCrypto.exportKey" "JS" "September 25, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SubtleCrypto.exportKey \- SubtleCrypto: exportKey() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]exportKey()\f[B]\f[R] method of the
\f[CR]SubtleCrypto\f[R] interface exports a key: that is, it takes as
input a \f[CR]CryptoKey\f[R] object and gives you the key in an
external, portable format.
.PP
To export a key, the key must have \f[CR]CryptoKey.extractable\f[R] set
to \f[CR]true\f[R].
.PP
Keys can be exported in several formats: see Supported formats in the
\f[CR]SubtleCrypto.importKey()\f[R] page for details.
.PP
Keys are not exported in an encrypted format: to encrypt keys when
exporting them use the \f[CR]SubtleCrypto.wrapKey()\f[R] API instead.
.SH SYNTAX
.IP
.EX
exportKey(format, key)
.EE
.SS Parameters
.TP
\f[B]format\f[R]
A string value describing the data format in which the key should be
exported.
It can be one of the following:
.RS
.IP \[bu] 2
\f[CR]raw\f[R]: Raw format.
.IP \[bu] 2
\f[CR]pkcs8\f[R]: PKCS #8 format.
.IP \[bu] 2
\f[CR]spki\f[R]: SubjectPublicKeyInfo format.
.IP \[bu] 2
\f[CR]jwk\f[R]: JSON Web Key format.
.RE
.TP
\f[B]key\f[R]
The \f[CR]CryptoKey\f[R] to export.
.SS Return value
A \f[CR]Promise\f[R].
.IP \[bu] 2
If \f[CR]format\f[R] was \f[CR]jwk\f[R], then the promise fulfills with
a JSON object containing the key.
.IP \[bu] 2
Otherwise the promise fulfills with an \f[CR]ArrayBuffer\f[R] containing
the key.
.SS Exceptions
The promise is rejected when one of the following exceptions is
encountered:
.TP
\f[B]InvalidAccessError\f[R] \f[B]DOMException\f[R]
Raised when trying to export a non\-extractable key.
.TP
\f[B]NotSupported\f[R] \f[B]DOMException\f[R]
Raised when trying to export in an unknown format.
.TP
\f[B]TypeError\f[R]
Raised when trying to use an invalid format.
.SH EXAMPLES
.RS
.PP
\f[B]Note:\f[R] You can \c
.UR https://mdn.github.io/dom-examples/web-crypto/export-key/index.html
try the working examples
.UE \c
\ out on GitHub.
.RE
.SS Raw export
This example exports an AES key as an \f[CR]ArrayBuffer\f[R] containing
the bytes for the key.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/export-key/raw.js
See the complete code on GitHub
.UE \c
\&.
.IP
.EX
\f[I]/*\f[R]
\f[I]Export the given key and write it into the \[dq]exported\-key\[dq] space.\f[R]
\f[I]*/\f[R]
\f[B]async\f[R] \f[B]function\f[R] exportCryptoKey(key) {
  \f[B]const\f[R] exported = \f[B]await\f[R] window.crypto.subtle.exportKey(\[dq]raw\[dq], key);
  \f[B]const\f[R] exportedKeyBuffer = \f[B]new\f[R] Uint8Array(exported);

  \f[B]const\f[R] exportKeyOutput = document.querySelector(\[dq].exported\-key\[dq]);
  exportKeyOutput.textContent = \[ga][${exportedKeyBuffer}]\[ga];
}

\f[I]/*\f[R]
\f[I]Generate an encrypt/decrypt secret key,\f[R]
\f[I]then set up an event listener on the \[dq]Export\[dq] button.\f[R]
\f[I]*/\f[R]
window.crypto.subtle
  .generateKey(
    {
      name: \[dq]AES\-GCM\[dq],
      length: 256,
    },
    \f[B]true\f[R],
    [\[dq]encrypt\[dq], \[dq]decrypt\[dq]],
  )
  .then((key) \f[B]=>\f[R] {
    \f[B]const\f[R] exportButton = document.querySelector(\[dq].raw\[dq]);
    exportButton.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
      exportCryptoKey(key);
    });
  });
.EE
.SS PKCS #8 export
This example exports an RSA private signing key as a PKCS #8 object.
The exported key is then PEM\-encoded.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/export-key/pkcs8.js
See the complete code on GitHub
.UE \c
\&.
.IP
.EX
\f[I]/*\f[R]
\f[I]Convert an ArrayBuffer into a string\f[R]
\f[I]from https://developer.chrome.com/blog/how\-to\-convert\-arraybuffer\-to\-and\-from\-string/\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] ab2str(buf) {
  \f[B]return\f[R] String.fromCharCode.apply(\f[B]null\f[R], \f[B]new\f[R] Uint8Array(buf));
}

\f[I]/*\f[R]
\f[I]Export the given key and write it into the \[dq]exported\-key\[dq] space.\f[R]
\f[I]*/\f[R]
\f[B]async\f[R] \f[B]function\f[R] exportCryptoKey(key) {
  \f[B]const\f[R] exported = \f[B]await\f[R] window.crypto.subtle.exportKey(\[dq]pkcs8\[dq], key);
  \f[B]const\f[R] exportedAsString = ab2str(exported);
  \f[B]const\f[R] exportedAsBase64 = window.btoa(exportedAsString);
  \f[B]const\f[R] pemExported = \[ga]\-\-\-\-\-BEGIN PRIVATE KEY\-\-\-\-\-\[rs]n${exportedAsBase64}\[rs]n\-\-\-\-\-END PRIVATE KEY\-\-\-\-\-\[ga];

  \f[B]const\f[R] exportKeyOutput = document.querySelector(\[dq].exported\-key\[dq]);
  exportKeyOutput.textContent = pemExported;
}

\f[I]/*\f[R]
\f[I]Generate a sign/verify key pair,\f[R]
\f[I]then set up an event listener on the \[dq]Export\[dq] button.\f[R]
\f[I]*/\f[R]
window.crypto.subtle
  .generateKey(
    {
      name: \[dq]RSA\-PSS\[dq],
      \f[I]// Consider using a 4096\-bit key for systems that require long\-term security\f[R]
      modulusLength: 2048,
      publicExponent: \f[B]new\f[R] Uint8Array([1, 0, 1]),
      hash: \[dq]SHA\-256\[dq],
    },
    \f[B]true\f[R],
    [\[dq]sign\[dq], \[dq]verify\[dq]],
  )
  .then((keyPair) \f[B]=>\f[R] {
    \f[B]const\f[R] exportButton = document.querySelector(\[dq].pkcs8\[dq]);
    exportButton.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
      exportCryptoKey(keyPair.privateKey);
    });
  });
.EE
.SS SubjectPublicKeyInfo export
This example exports an RSA public encryption key as a PEM\-encoded
SubjectPublicKeyInfo object.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/export-key/spki.js
See the complete code on GitHub
.UE \c
\&.
.IP
.EX
\f[I]/*\f[R]
\f[I]Convert an ArrayBuffer into a string\f[R]
\f[I]from https://developer.chrome.com/blog/how\-to\-convert\-arraybuffer\-to\-and\-from\-string/\f[R]
\f[I]*/\f[R]
\f[B]function\f[R] ab2str(buf) {
  \f[B]return\f[R] String.fromCharCode.apply(\f[B]null\f[R], \f[B]new\f[R] Uint8Array(buf));
}

\f[I]/*\f[R]
\f[I]Export the given key and write it into the \[dq]exported\-key\[dq] space.\f[R]
\f[I]*/\f[R]
\f[B]async\f[R] \f[B]function\f[R] exportCryptoKey(key) {
  \f[B]const\f[R] exported = \f[B]await\f[R] window.crypto.subtle.exportKey(\[dq]spki\[dq], key);
  \f[B]const\f[R] exportedAsString = ab2str(exported);
  \f[B]const\f[R] exportedAsBase64 = window.btoa(exportedAsString);
  \f[B]const\f[R] pemExported = \[ga]\-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-\[rs]n${exportedAsBase64}\[rs]n\-\-\-\-\-END PUBLIC KEY\-\-\-\-\-\[ga];

  \f[B]const\f[R] exportKeyOutput = document.querySelector(\[dq].exported\-key\[dq]);
  exportKeyOutput.textContent = pemExported;
}

\f[I]/*\f[R]
\f[I]Generate an encrypt/decrypt key pair,\f[R]
\f[I]then set up an event listener on the \[dq]Export\[dq] button.\f[R]
\f[I]*/\f[R]
window.crypto.subtle
  .generateKey(
    {
      name: \[dq]RSA\-OAEP\[dq],
      \f[I]// Consider using a 4096\-bit key for systems that require long\-term security\f[R]
      modulusLength: 2048,
      publicExponent: \f[B]new\f[R] Uint8Array([1, 0, 1]),
      hash: \[dq]SHA\-256\[dq],
    },
    \f[B]true\f[R],
    [\[dq]encrypt\[dq], \[dq]decrypt\[dq]],
  )
  .then((keyPair) \f[B]=>\f[R] {
    \f[B]const\f[R] exportButton = document.querySelector(\[dq].spki\[dq]);
    exportButton.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
      exportCryptoKey(keyPair.publicKey);
    });
  });
.EE
.SS JSON Web Key export
This example exports an ECDSA private signing key as a JSON Web Key
object.
\c
.UR https://github.com/mdn/dom-examples/blob/main/web-crypto/export-key/jwk.js
See the complete code on GitHub
.UE \c
\&.
.IP
.EX
\f[I]/*\f[R]
\f[I]Export the given key and write it into the \[dq]exported\-key\[dq] space.\f[R]
\f[I]*/\f[R]
\f[B]async\f[R] \f[B]function\f[R] exportCryptoKey(key) {
  \f[B]const\f[R] exported = \f[B]await\f[R] window.crypto.subtle.exportKey(\[dq]jwk\[dq], key);
  \f[B]const\f[R] exportKeyOutput = document.querySelector(\[dq].exported\-key\[dq]);
  exportKeyOutput.textContent = JSON.stringify(exported, \f[B]null\f[R], \[dq] \[dq]);
}

\f[I]/*\f[R]
\f[I]Generate a sign/verify key pair,\f[R]
\f[I]then set up an event listener on the \[dq]Export\[dq] button.\f[R]
\f[I]*/\f[R]
window.crypto.subtle
  .generateKey(
    {
      name: \[dq]ECDSA\[dq],
      namedCurve: \[dq]P\-384\[dq],
    },
    \f[B]true\f[R],
    [\[dq]sign\[dq], \[dq]verify\[dq]],
  )
  .then((keyPair) \f[B]=>\f[R] {
    \f[B]const\f[R] exportButton = document.querySelector(\[dq].jwk\[dq]);
    exportButton.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
      exportCryptoKey(keyPair.privateKey);
    });
  });
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]SubtleCrypto.importKey()\f[R]
.IP \[bu] 2
\f[CR]SubtleCrypto.wrapKey()\f[R]
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc5208
PKCS #8 format
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc5280#section-4.1
SubjectPublicKeyInfo format
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc7517
JSON Web Key format
.UE \c
\&.
