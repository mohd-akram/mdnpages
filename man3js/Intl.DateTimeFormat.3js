.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Intl.DateTimeFormat" "JS" "July 13, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.DateTimeFormat \- Intl.DateTimeFormat
.SH SYNOPSIS
The \f[B]\f[CB]Intl.DateTimeFormat\f[B]\f[R] object enables
language\-sensitive date and time formatting.
.SH CONSTRUCTOR
.TP
\f[B]Intl.DateTimeFormat()\f[R]
Creates a new \f[CR]Intl.DateTimeFormat\f[R] object.
.SH STATIC METHODS
.TP
\f[B]Intl.DateTimeFormat.supportedLocalesOf()\f[R]
Returns an array containing those of the provided locales that are
supported without having to fall back to the runtime\[cq]s default
locale.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]Intl.DateTimeFormat.prototype\f[R]
and shared by all \f[CR]Intl.DateTimeFormat\f[R] instances.
.TP
\f[B]Intl.DateTimeFormat.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]Intl.DateTimeFormat\f[R] instances, the initial value is the
\f[CR]Intl.DateTimeFormat\f[R] constructor.
.TP
\f[B]Intl.DateTimeFormat.prototype[Symbol.toStringTag]\f[R]
The initial value of the \f[CR][Symbol.toStringTag]\f[R] property is the
string \f[CR]\[dq]Intl.DateTimeFormat\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH INSTANCE METHODS
.TP
\f[B]Intl.DateTimeFormat.prototype.format()\f[R]
Getter function that formats a date according to the locale and
formatting options of this \f[CR]DateTimeFormat\f[R] object.
.TP
\f[B]Intl.DateTimeFormat.prototype.formatRange()\f[R]
This method receives two Dates and formats the date range in the most
concise way based on the locale and options provided when instantiating
\f[CR]DateTimeFormat\f[R].
.TP
\f[B]Intl.DateTimeFormat.prototype.formatRangeToParts()\f[R]
This method receives two Dates and returns an Array of objects
containing the locale\-specific tokens representing each part of the
formatted date range.
.TP
\f[B]Intl.DateTimeFormat.prototype.formatToParts()\f[R]
Returns an \f[CR]Array\f[R] of objects representing the date string in
parts that can be used for custom locale\-aware formatting.
.TP
\f[B]Intl.DateTimeFormat.prototype.resolvedOptions()\f[R]
Returns a new object with properties reflecting the locale and
formatting options computed during initialization of the object.
.SH EXAMPLES
.SS Using DateTimeFormat
In basic use without specifying a locale, \f[CR]DateTimeFormat\f[R] uses
the default locale and default options.
.IP
.EX
\f[B]const\f[R] date = \f[B]new\f[R] Date(Date.UTC(2012, 11, 20, 3, 0, 0));

\f[I]// toLocaleString without arguments depends on the implementation,\f[R]
\f[I]// the default locale, and the default time zone\f[R]
console.log(\f[B]new\f[R] Intl.DateTimeFormat().format(date));
\f[I]// \[dq]12/19/2012\[dq] if run with en\-US locale (language) and time zone America/Los_Angeles (UTC\-0800)\f[R]
.EE
.SS Using locales
This example shows some of the variations in localized date and time
formats.
In order to get the format of the language used in the user interface of
your application, make sure to specify that language (and possibly some
fallback languages) using the \f[CR]locales\f[R] argument:
.IP
.EX
\f[B]const\f[R] date = \f[B]new\f[R] Date(Date.UTC(2012, 11, 20, 3, 0, 0));

\f[I]// Results below use the time zone of America/Los_Angeles (UTC\-0800, Pacific Standard Time)\f[R]

\f[I]// US English uses month\-day\-year order\f[R]
console.log(\f[B]new\f[R] Intl.DateTimeFormat(\[dq]en\-US\[dq]).format(date));
\f[I]// \[dq]12/19/2012\[dq]\f[R]

\f[I]// British English uses day\-month\-year order\f[R]
console.log(\f[B]new\f[R] Intl.DateTimeFormat(\[dq]en\-GB\[dq]).format(date));
\f[I]// \[dq]19/12/2012\[dq]\f[R]

\f[I]// Korean uses year\-month\-day order\f[R]
console.log(\f[B]new\f[R] Intl.DateTimeFormat(\[dq]ko\-KR\[dq]).format(date));
\f[I]// \[dq]2012. 12. 19.\[dq]\f[R]

\f[I]// Arabic in most Arabic speaking countries uses real Arabic digits\f[R]
console.log(\f[B]new\f[R] Intl.DateTimeFormat(\[dq]ar\-EG\[dq]).format(date));
\f[I]// \[dq]١٩‏/١٢‏/٢٠١٢\[dq]\f[R]

\f[I]// for Japanese, applications may want to use the Japanese calendar,\f[R]
\f[I]// where 2012 was the year 24 of the Heisei era\f[R]
console.log(\f[B]new\f[R] Intl.DateTimeFormat(\[dq]ja\-JP\-u\-ca\-japanese\[dq]).format(date));
\f[I]// \[dq]24/12/19\[dq]\f[R]

\f[I]// when requesting a language that may not be supported, such as\f[R]
\f[I]// Balinese, include a fallback language, in this case Indonesian\f[R]
console.log(\f[B]new\f[R] Intl.DateTimeFormat([\[dq]ban\[dq], \[dq]id\[dq]]).format(date));
\f[I]// \[dq]19/12/2012\[dq]\f[R]
.EE
.SS Using options
The date and time formats can be customized using the \f[CR]options\f[R]
argument:
.IP
.EX
\f[B]const\f[R] date = \f[B]new\f[R] Date(Date.UTC(2012, 11, 20, 3, 0, 0, 200));

\f[I]// request a weekday along with a long date\f[R]
\f[B]let\f[R] options = {
  weekday: \[dq]long\[dq],
  year: \[dq]numeric\[dq],
  month: \[dq]long\[dq],
  day: \[dq]numeric\[dq],
};
console.log(\f[B]new\f[R] Intl.DateTimeFormat(\[dq]de\-DE\[dq], options).format(date));
\f[I]// \[dq]Donnerstag, 20. Dezember 2012\[dq]\f[R]

\f[I]// an application may want to use UTC and make that visible\f[R]
options.timeZone = \[dq]UTC\[dq];
options.timeZoneName = \[dq]short\[dq];
console.log(\f[B]new\f[R] Intl.DateTimeFormat(\[dq]en\-US\[dq], options).format(date));
\f[I]// \[dq]Thursday, December 20, 2012, GMT\[dq]\f[R]

\f[I]// sometimes you want to be more precise\f[R]
options = {
  hour: \[dq]numeric\[dq],
  minute: \[dq]numeric\[dq],
  second: \[dq]numeric\[dq],
  timeZone: \[dq]Australia/Sydney\[dq],
  timeZoneName: \[dq]short\[dq],
};
console.log(\f[B]new\f[R] Intl.DateTimeFormat(\[dq]en\-AU\[dq], options).format(date));
\f[I]// \[dq]2:00:00 pm AEDT\[dq]\f[R]

\f[I]// sometimes you want to be very precise\f[R]
options.fractionalSecondDigits = 3; \f[I]//number digits for fraction\-of\-seconds\f[R]
console.log(\f[B]new\f[R] Intl.DateTimeFormat(\[dq]en\-AU\[dq], options).format(date));
\f[I]// \[dq]2:00:00.200 pm AEDT\[dq]\f[R]

\f[I]// sometimes even the US needs 24\-hour time\f[R]
options = {
  year: \[dq]numeric\[dq],
  month: \[dq]numeric\[dq],
  day: \[dq]numeric\[dq],
  hour: \[dq]numeric\[dq],
  minute: \[dq]numeric\[dq],
  second: \[dq]numeric\[dq],
  hour12: \f[B]false\f[R],
  timeZone: \[dq]America/Los_Angeles\[dq],
};
console.log(\f[B]new\f[R] Intl.DateTimeFormat(\[dq]en\-US\[dq], options).format(date));
\f[I]// \[dq]12/19/2012, 19:00:00\[dq]\f[R]

\f[I]// to specify options but use the browser\[aq]s default locale, use undefined\f[R]
console.log(\f[B]new\f[R] Intl.DateTimeFormat(\f[B]undefined\f[R], options).format(date));
\f[I]// \[dq]12/19/2012, 19:00:00\[dq]\f[R]

\f[I]// sometimes it\[aq]s helpful to include the period of the day\f[R]
options = { hour: \[dq]numeric\[dq], dayPeriod: \[dq]short\[dq] };
console.log(\f[B]new\f[R] Intl.DateTimeFormat(\[dq]en\-US\[dq], options).format(date));
\f[I]// 10 at night\f[R]
.EE
.PP
The used calendar and numbering formats can also be set independently
via \f[CR]options\f[R] arguments:
.IP
.EX
\f[B]const\f[R] options = { calendar: \[dq]chinese\[dq], numberingSystem: \[dq]arab\[dq] };
\f[B]const\f[R] dateFormat = \f[B]new\f[R] Intl.DateTimeFormat(\f[B]undefined\f[R], options);
\f[B]const\f[R] usedOptions = dateFormat.resolvedOptions();

console.log(usedOptions.calendar);
\f[I]// \[dq]chinese\[dq]\f[R]

console.log(usedOptions.numberingSystem);
\f[I]// \[dq]arab\[dq]\f[R]

console.log(usedOptions.timeZone);
\f[I]// \[dq]America/New_York\[dq] (the users default timezone)\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://formatjs.io/docs/polyfills/intl-datetimeformat/
Polyfill of \f[CR]Intl.DateTimeFormat\f[R] in FormatJS
.UE \c
.IP \[bu] 2
\f[CR]Intl\f[R]
