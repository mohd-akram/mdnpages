.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "RTCICECANDIDATE.USERNAMEFRAGMENT" "3JS" "March 17, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCIceCandidate.usernameFragment \- RTCIceCandidate: usernameFragment
property
.SH SYNOPSIS
The read\-only \f[B]\f[CB]usernameFragment\f[B]\f[R] property on the
\f[CR]RTCIceCandidate\f[R] interface is a string indicating the username
fragment (\(lqufrag\(rq) that uniquely identifies a single ICE
interaction session.
.PP
This value is specified using the \f[CR]usernameFragment\f[R] property
in the \f[CR]candidateInfo\f[R] options object that is passed to the
\f[CR]RTCIceCandidate()\f[R] constructor.
If you call the constructor with an m\-line string instead of the
options object, the value of \f[CR]usernameFragment\f[R] is extracted
from the specified candidate m\-line string.
.PP
Note that 24 bits of the username fragment are required to be randomized
by the browser.
See Randomization below for details.
.SH VALUE
A string containing the username fragment (usually referred to in
shorthand as \(lqufrag\(rq or \(lqice\-ufrag\(rq) that, along with the
ICE password (\(lqice\-pwd\(rq), uniquely identifies a single ongoing
ICE interaction, including for any communication with the STUN server.
The string may be up to 256 characters long, and has no default value.
.SS Randomization
At least 24 bits of the text in the \f[CR]ufrag\f[R] are required to be
randomly selected by the ICE layer at the beginning of the ICE session.
The specifics for which bits are random and what the remainder of the
\f[CR]ufrag\f[R] text are left up to the browser implementation to
decide.
For example, a browser might choose to always use a 24\-character
\f[CR]ufrag\f[R] in which bit 4 of each character is randomly selected
between 0 and 1.
Another example: it might take a user\-defined string and append three
8\-bit random bytes to the end.
Or perhaps every character is entirely random.
.SH USAGE NOTES
ICE uses the \f[CR]usernameFragment\f[R] and password to ensure message
integrity.
This avoids crosstalk among multiple ongoing ICE sessions, but, more
importantly, helps secure ICE transactions (and all of WebRTC by
extension) against attacks that might try to inject themselves into an
ICE exchange.
.RS
.PP
\f[B]Note:\f[R] There is no API to obtain the ICE password, for what
should be fairly obvious security reasons.
.RE
.PP
The \f[CR]usernameFragment\f[R] and password both change every time an
ICE restart occurs.
.SH EXAMPLES
Although the WebRTC infrastructure will filter out obsolete candidates
for you after an ICE restart, you can do it yourself if you\(cqre trying
to absolutely minimize the number of messages going back and forth.
.PP
To do so, you can compare the value of \f[CR]usernameFragment\f[R] to
the current \f[CR]usernameFragment\f[R] being used for the connection
after receiving the candidate from the signaling server and before
calling \f[CR]addIceCandidate()\f[R] to add it to the set of possible
candidates.
.PP
When the web app receives a message from the signaling server that
includes a candidate to be added to the \f[CR]RTCPeerConnection\f[R],
you can (and generally \f[I]should\f[R]) call
\f[CR]addIceCandidate()\f[R].
There\(cqs not typically a need to manually worry about filtering the
candidates.
.PP
However, let\(cqs imagine that we do need to minimize traffic.
The function below, \f[CR]ssNewCandidate()\f[R], is called when a
message, \f[CR]signalMsg\f[R], arrives from the signaling server that
contains an ICE candidate to be added to the
\f[CR]RTCPeerConnection\f[R].
To avoid including candidates obsoleted by an ICE restart, we can use
code like this:
.IP
.EX
\f[B]const\f[R] ssNewCandidate = (signalMsg) \f[B]=>\f[R] {
  \f[B]const\f[R] candidate = \f[B]new\f[R] RTCIceCandidate(signalMsg.candidate);
  \f[B]const\f[R] receivers = pc.getReceivers();

  \f[B]for\f[R] (\f[B]const\f[R] receiver \f[B]of\f[R] receivers) {
    \f[B]const\f[R] parameters = receiver.transport.iceTransport.getRemoteParameters();

    \f[B]if\f[R] (parameters.usernameFragment === candidate.usernameFragment) {
      \f[B]return\f[R];
    }
  }

  pc.addIceCandidate(candidate).catch(window.reportError);
};
.EE
.PP
This walks through the list of the \f[CR]RTCRtpReceiver\f[R] objects
being used to receive ICE data, and looks to see if the
\f[CR]usernameFragment\f[R] indicated in the candidate matches any of
them.
If it does, \f[CR]ssNewCandidate()\f[R] aborts.
Otherwise, after checking every receiver, it adds the new candidate to
the connection.
