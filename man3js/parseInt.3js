.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "parseInt" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
parseInt \- parseInt()
.SH SYNOPSIS
The \f[B]\f[CB]parseInt()\f[B]\f[R] function parses a string argument
and returns an integer of the specified \c
.UR https://en.wikipedia.org/wiki/Radix
radix
.UE \c
\ (the base in mathematical numeral systems).
.SH SYNTAX
.IP
.EX
parseInt(string)
parseInt(string, radix)
.EE
.SS Parameters
.TP
\f[B]string\f[R]
A string starting with an integer.
Leading whitespace in this argument is ignored.
.TP
\f[B]radix\f[R] \f[I](optional)\f[R]
An integer between \f[CR]2\f[R] and \f[CR]36\f[R] that represents the
\f[I]radix\f[R] (the base in mathematical numeral systems) of the
\f[CR]string\f[R].
It is converted to a 32\-bit integer; if it\[cq]s nonzero and outside
the range of [2, 36] after conversion, the function will always return
\f[CR]NaN\f[R].
If \f[CR]0\f[R] or not provided, the radix will be inferred based on
\f[CR]string\f[R]\[cq]s value.
Be careful \[em] this does \f[I]not\f[R] always default to
\f[CR]10\f[R]!
The description below explains in more detail what happens when
\f[CR]radix\f[R] is not provided.
.SS Return value
An integer parsed from the given \f[CR]string\f[R], or \f[CR]NaN\f[R]
when
.IP \[bu] 2
the \f[CR]radix\f[R] as a 32\-bit integer is smaller than \f[CR]2\f[R]
or bigger than \f[CR]36\f[R], or
.IP \[bu] 2
the first non\-whitespace character cannot be converted to a number.
.RS
.PP
\f[B]Note:\f[R] JavaScript does not have the distinction of
\[lq]floating point numbers\[rq] and \[lq]integers\[rq] on the language
level.
\f[CR]parseInt()\f[R] and \f[CR]parseFloat()\f[R] only differ in their
parsing behavior, but not necessarily their return values.
For example, \f[CR]parseInt(\[dq]42\[dq])\f[R] and
\f[CR]parseFloat(\[dq]42\[dq])\f[R] would return the same value: a
\f[CR]Number\f[R] 42.
.RE
.SH DESCRIPTION
The \f[CR]parseInt\f[R] function converts its first argument to a
string, parses that string, then returns an integer or \f[CR]NaN\f[R].
.PP
If not \f[CR]NaN\f[R], the return value will be the integer that is the
first argument taken as a number in the specified \f[CR]radix\f[R].
(For example, a \f[CR]radix\f[R] of \f[CR]10\f[R] converts from a
decimal number, \f[CR]8\f[R] converts from octal, \f[CR]16\f[R] from
hexadecimal, and so on.)
.PP
The \f[CR]radix\f[R] argument is converted to a number.
If it\[cq]s unprovided, or if the value becomes 0, \f[CR]NaN\f[R] or
\f[CR]Infinity\f[R] (\f[CR]undefined\f[R] is coerced to \f[CR]NaN\f[R]),
JavaScript assumes the following:
.IP "1." 3
If the input \f[CR]string\f[R], with leading whitespace and possible
\f[CR]+\f[R]/\f[CR]\-\f[R] signs removed, begins with \f[CR]0x\f[R] or
\f[CR]0X\f[R] (a zero, followed by lowercase or uppercase X),
\f[CR]radix\f[R] is assumed to be \f[CR]16\f[R] and the rest of the
string is parsed as a hexadecimal number.
.IP "2." 3
If the input \f[CR]string\f[R] begins with any other value, the radix is
\f[CR]10\f[R] (decimal).
.RS
.PP
\f[B]Note:\f[R] Other prefixes like \f[CR]0b\f[R], which are valid in
number literals, are treated as normal digits by \f[CR]parseInt()\f[R].
\f[CR]parseInt()\f[R] does \f[I]not\f[R] treat strings beginning with a
\f[CR]0\f[R] character as octal values either.
The only prefix that \f[CR]parseInt()\f[R] recognizes is \f[CR]0x\f[R]
or \f[CR]0X\f[R] for hexadecimal values \[em] everything else is parsed
as a decimal value if \f[CR]radix\f[R] is missing.
\f[CR]Number()\f[R] or \f[CR]BigInt()\f[R] can be used instead to parse
these prefixes.
.RE
.PP
If the radix is \f[CR]16\f[R], \f[CR]parseInt()\f[R] allows the string
to be optionally prefixed by \f[CR]0x\f[R] or \f[CR]0X\f[R] after the
optional sign character (\f[CR]+\f[R]/\f[CR]\-\f[R]).
.PP
If the radix value (coerced if necessary) is not in range [2, 36]
(inclusive) \f[CR]parseInt\f[R] returns \f[CR]NaN\f[R].
.PP
For radices above \f[CR]10\f[R], letters of the English alphabet
indicate numerals greater than \f[CR]9\f[R].
For example, for hexadecimal numbers (base \f[CR]16\f[R]), \f[CR]A\f[R]
through \f[CR]F\f[R] are used.
The letters are case\-insensitive.
.PP
\f[CR]parseInt\f[R] understands exactly two signs: \f[CR]+\f[R] for
positive, and \f[CR]\-\f[R] for negative.
It is done as an initial step in the parsing after whitespace is
removed.
If no signs are found, the algorithm moves to the following step;
otherwise, it removes the sign and runs the number\-parsing on the rest
of the string.
.PP
If \f[CR]parseInt\f[R] encounters a character that is not a numeral in
the specified \f[CR]radix\f[R], it ignores it and all succeeding
characters and returns the integer value parsed up to that point.
For example, although \f[CR]1e3\f[R] technically encodes an integer (and
will be correctly parsed to the integer \f[CR]1000\f[R] by
\f[CR]parseFloat()\f[R]), \f[CR]parseInt(\[dq]1e3\[dq], 10)\f[R] returns
\f[CR]1\f[R], because \f[CR]e\f[R] is not a valid numeral in base 10.
Because \f[CR].\f[R] is not a numeral either, the return value will
always be an integer.
.PP
If the first character cannot be converted to a number with the radix in
use, \f[CR]parseInt\f[R] returns \f[CR]NaN\f[R].
Leading whitespace is allowed.
.PP
For arithmetic purposes, the \f[CR]NaN\f[R] value is not a number in any
radix.
You can call the \f[CR]Number.isNaN\f[R] function to determine if the
result of \f[CR]parseInt\f[R] is \f[CR]NaN\f[R].
If \f[CR]NaN\f[R] is passed on to arithmetic operations, the operation
result will also be \f[CR]NaN\f[R].
.PP
Because large numbers use the \f[CR]e\f[R] character in their string
representation (e.g.\ \f[CR]6.022e23\f[R] for 6.022 Ã— 10\[ha]23), using
\f[CR]parseInt\f[R] to truncate numbers will produce unexpected results
when used on very large or very small numbers.
\f[CR]parseInt\f[R] should \f[I]not\f[R] be used as a substitute for
\f[CR]Math.trunc()\f[R].
.PP
To convert a number to its string literal in a particular radix, use
\f[CR]thatNumber.toString(radix)\f[R].
.PP
Because \f[CR]parseInt()\f[R] returns a number, it may suffer from loss
of precision if the integer represented by the string is outside the
safe range.
The \f[CR]BigInt()\f[R] function supports parsing integers of arbitrary
length accurately, by returning a \f[CR]BigInt\f[R].
.SH EXAMPLES
.SS Using parseInt()
The following examples all return \f[CR]15\f[R]:
.IP
.EX
parseInt(\[dq]0xF\[dq], 16);
parseInt(\[dq]F\[dq], 16);
parseInt(\[dq]17\[dq], 8);
parseInt(\[dq]015\[dq], 10);
parseInt(\[dq]15,123\[dq], 10);
parseInt(\[dq]FXX123\[dq], 16);
parseInt(\[dq]1111\[dq], 2);
parseInt(\[dq]15 * 3\[dq], 10);
parseInt(\[dq]15e2\[dq], 10);
parseInt(\[dq]15px\[dq], 10);
parseInt(\[dq]12\[dq], 13);
.EE
.PP
The following examples all return \f[CR]NaN\f[R]:
.IP
.EX
parseInt(\[dq]Hello\[dq], 8); \f[I]// Not a number at all\f[R]
parseInt(\[dq]546\[dq], 2); \f[I]// Digits other than 0 or 1 are invalid for binary radix\f[R]
.EE
.PP
The following examples all return \f[CR]\-15\f[R]:
.IP
.EX
parseInt(\[dq]\-F\[dq], 16);
parseInt(\[dq]\-0F\[dq], 16);
parseInt(\[dq]\-0XF\[dq], 16);
parseInt(\[dq]\-17\[dq], 8);
parseInt(\[dq]\-15\[dq], 10);
parseInt(\[dq]\-1111\[dq], 2);
parseInt(\[dq]\-15e1\[dq], 10);
parseInt(\[dq]\-12\[dq], 13);
.EE
.PP
The following example returns \f[CR]224\f[R]:
.IP
.EX
parseInt(\[dq]0e0\[dq], 16);
.EE
.PP
\f[CR]parseInt()\f[R] does not handle \f[CR]BigInt\f[R] values.
It stops at the \f[CR]n\f[R] character, and treats the preceding string
as a normal integer, with possible loss of precision.
.PP
\f[B]Bad\f[R]
.IP
.EX
parseInt(\[dq]900719925474099267n\[dq]);
\f[I]// 900719925474099300\f[R]
.EE
.PP
You should pass the string to the \f[CR]BigInt()\f[R] function instead,
without the trailing \f[CR]n\f[R] character.
.PP
\f[B]Good\f[R]
.IP
.EX
BigInt(\[dq]900719925474099267\[dq]);
\f[I]// 900719925474099267n\f[R]
.EE
.PP
\f[CR]parseInt\f[R] doesn\[cq]t work with numeric separators:
.PP
\f[B]Bad\f[R]
.IP
.EX
parseInt(\[dq]123_456\[dq]); \f[I]// 123\f[R]
.EE
.SS Using parseInt() on non\-strings
\f[CR]parseInt()\f[R] can have interesting results when working on
non\-strings combined with a high radix; for example, \f[CR]36\f[R]
(which makes all alphanumeric characters valid numeric digits).
.IP
.EX
parseInt(\f[B]null\f[R], 36); \f[I]// 1112745: The string \[dq]null\[dq] is 1112745 in base 36\f[R]
parseInt(\f[B]undefined\f[R], 36); \f[I]// 86464843759093: The string \[dq]undefined\[dq] is 86464843759093 in base 36\f[R]
.EE
.PP
In general, it\[cq]s a bad idea to use \f[CR]parseInt()\f[R] on
non\-strings, especially to use it as a substitution for
\f[CR]Math.trunc()\f[R].
It may work on small numbers:
.IP
.EX
parseInt(15.99, 10); \f[I]// 15\f[R]
parseInt(\-15.1, 10); \f[I]// \-15\f[R]
.EE
.PP
However, it only happens to work because the string representation of
these numbers uses basic fractional notation
(\f[CR]\[dq]15.99\[dq]\f[R], \f[CR]\[dq]\-15.1\[dq]\f[R]), where
\f[CR]parseInt()\f[R] stops at the decimal point.
Numbers greater than or equal to 1e+21 or less than or equal to 1e\-7
use exponential notation (\f[CR]\[dq]1.5e+22\[dq]\f[R],
\f[CR]\[dq]1.51e\-8\[dq]\f[R]) in their string representation, and
\f[CR]parseInt()\f[R] will stop at the \f[CR]e\f[R] character or decimal
point, which always comes after the first digit.
This means for large and small numbers, \f[CR]parseInt()\f[R] will
return a one\-digit integer:
.PP
\f[B]Bad\f[R]
.IP
.EX
parseInt(4.7 * 1e22, 10); \f[I]// Very large number becomes 4\f[R]
parseInt(0.00000000000434, 10); \f[I]// Very small number becomes 4\f[R]

parseInt(0.0000001, 10); \f[I]// 1\f[R]
parseInt(0.000000123, 10); \f[I]// 1\f[R]
parseInt(1e\-7, 10); \f[I]// 1\f[R]
parseInt(1000000000000000000000, 10); \f[I]// 1\f[R]
parseInt(123000000000000000000000, 10); \f[I]// 1\f[R]
parseInt(1e21, 10); \f[I]// 1\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]parseFloat()\f[R]
.IP \[bu] 2
\f[CR]Number()\f[R] constructor
.IP \[bu] 2
\f[CR]Number.parseFloat()\f[R]
.IP \[bu] 2
\f[CR]Number.parseInt()\f[R]
.IP \[bu] 2
\f[CR]isNaN()\f[R]
.IP \[bu] 2
\f[CR]Number.prototype.toString()\f[R]
.IP \[bu] 2
\f[CR]Object.prototype.valueOf()\f[R]
.IP \[bu] 2
\f[CR]BigInt()\f[R] constructor
