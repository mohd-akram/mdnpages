.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "NUMBER.TOFIXED" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Number.toFixed \- Number.prototype.toFixed()
.SH SYNOPSIS
The \f[B]\f[CB]toFixed()\f[B]\f[R] method of \f[CR]Number\f[R] values
returns a string representing this number using \c
.UR https://en.wikipedia.org/wiki/Fixed-point_arithmetic
fixed\-point notation
.UE \c
\ with the specified number of decimal places.
.IP
.EX
\f[B]function\f[R] financial(x) {
  \f[B]return\f[R] Number.parseFloat(x).toFixed(2);
}

console.log(financial(123.456));
\f[I]// Expected output: \(dq123.46\(dq\f[R]

console.log(financial(0.004));
\f[I]// Expected output: \(dq0.00\(dq\f[R]

console.log(financial(\(dq1.23e+5\(dq));
\f[I]// Expected output: \(dq123000.00\(dq\f[R]
.EE
.SH SYNTAX
.IP
.EX
toFixed()
toFixed(digits)
.EE
.SS Parameters
.TP
\f[B]digits\f[R] \f[I](optional)\f[R]
The number of digits to appear after the decimal point; should be a
value between \f[CR]0\f[R] and \f[CR]100\f[R], inclusive.
If this argument is omitted, it is treated as \f[CR]0\f[R].
.SS Return value
A string representing the given number using fixed\-point notation.
Scientific notation is used if the number\(cqs magnitude (ignoring sign)
is greater than or equal to 10\(ha21 (same return value as
\f[CR]Number.prototype.toString()\f[R]).
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]digits\f[R] is not between \f[CR]0\f[R] and
\f[CR]100\f[R] (inclusive).
.TP
\f[B]TypeError\f[R]
Thrown if this method is invoked on an object that is not a
\f[CR]Number\f[R].
.SH DESCRIPTION
The \f[CR]toFixed()\f[R] method returns a string representation of a
number without using exponential notation and with exactly
\f[CR]digits\f[R] digits after the decimal point.
The number is rounded if necessary, and the fractional part is padded
with zeros if necessary so that it has the specified length.
.PP
If the absolute value of the number is greater or equal to 10\(ha21,
this method uses the same algorithm as
\f[CR]Number.prototype.toString()\f[R] and returns a string in
exponential notation.
\f[CR]toFixed()\f[R] returns \f[CR]\(dqInfinity\(dq\f[R],
\f[CR]\(dqNaN\(dq\f[R], or \f[CR]\(dq\-Infinity\(dq\f[R] if the value of
the number is non\-finite.
.PP
The output of \f[CR]toFixed()\f[R] may be more precise than
\f[CR]toString()\f[R] for some values, because \f[CR]toString()\f[R]
only prints enough significant digits to distinguish the number from
adjacent number values.
For example:
.IP
.EX
(1000000000000000128).toString(); \f[I]// \(aq1000000000000000100\(aq\f[R]
(1000000000000000128).toFixed(0); \f[I]// \(aq1000000000000000128\(aq\f[R]
.EE
.PP
However, choosing a \f[CR]digits\f[R] precision that\(cqs too high can
return unexpected results, because decimal fractional numbers cannot be
represented precisely in floating point.
For example:
.IP
.EX
(0.3).toFixed(50); \f[I]// \(aq0.29999999999999998889776975374843459576368331909180\(aq\f[R]
.EE
.SH EXAMPLES
.SS Using toFixed()
.IP
.EX
\f[B]const\f[R] numObj = 12345.6789;

numObj.toFixed(); \f[I]// \(aq12346\(aq; rounding, no fractional part\f[R]
numObj.toFixed(1); \f[I]// \(aq12345.7\(aq; it rounds up\f[R]
numObj.toFixed(6); \f[I]// \(aq12345.678900\(aq; additional zeros\f[R]
(1.23e20).toFixed(2); \f[I]// \(aq123000000000000000000.00\(aq\f[R]
(1.23e\-10).toFixed(2); \f[I]// \(aq0.00\(aq\f[R]
(2.34).toFixed(1); \f[I]// \(aq2.3\(aq\f[R]
(2.35).toFixed(1); \f[I]// \(aq2.4\(aq; it rounds up\f[R]
(2.55).toFixed(1); \f[I]// \(aq2.5\(aq\f[R]
\f[I]// it rounds down as it can\(aqt be represented exactly by a float and the\f[R]
\f[I]// closest representable float is lower\f[R]
(2.449999999999999999).toFixed(1); \f[I]// \(aq2.5\(aq\f[R]
\f[I]// it rounds up as it\(aqs less than Number.EPSILON away from 2.45.\f[R]
\f[I]// This literal actually encodes the same number value as 2.45\f[R]

(6.02 * 10 ** 23).toFixed(50); \f[I]// \(aq6.019999999999999e+23\(aq; large numbers still use exponential notation\f[R]
.EE
.SS Using toFixed() with negative numbers
Because member access has higher precedence than unary minus, you need
to group the negative number expression to get a string.
.IP
.EX
\-2.34.toFixed(1); // \-2.3; a number
(\-2.34).toFixed(1); // \(aq\-2.3\(aq
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Number.prototype.toExponential()\f[R]
.IP \(bu 2
\f[CR]Number.prototype.toPrecision()\f[R]
.IP \(bu 2
\f[CR]Number.prototype.toString()\f[R]
.IP \(bu 2
\f[CR]Number.EPSILON\f[R]
