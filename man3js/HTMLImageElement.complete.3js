.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "HTMLImageElement.complete" "JS" "April 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
HTMLImageElement.complete \- HTMLImageElement: complete property
.SH SYNOPSIS
The read\-only \f[CR]HTMLImageElement\f[R] interface\[cq]s
\f[B]\f[CB]complete\f[B]\f[R] attribute is a Boolean value which
indicates whether or not the image has completely loaded.
.SH VALUE
A Boolean value which is \f[CR]true\f[R] if the image has completely
loaded; otherwise, the value is \f[CR]false\f[R].
.PP
The image is considered completely loaded if any of the following are
true:
.IP \[bu] 2
Neither the \f[CR]src\f[R] nor the \f[CR]srcset\f[R] attribute is
specified.
.IP \[bu] 2
The \f[CR]srcset\f[R] attribute is absent and the \f[CR]src\f[R]
attribute, while specified, is the empty string (\f[CR]\[dq]\[dq]\f[R]).
.IP \[bu] 2
The image resource has been fully fetched and has been queued for
rendering/compositing.
.IP \[bu] 2
The image element has previously determined that the image is fully
available and ready for use.
.IP \[bu] 2
The image is \[lq]broken;\[rq] that is, the image failed to load due to
an error or because image loading is disabled.
.PP
It\[cq]s worth noting that due to the image potentially being received
asynchronously, the value of \f[CR]complete\f[R] may change while your
script is running.
.SH EXAMPLES
Consider a photo library app that provides the ability to open images
into a lightbox mode for improved viewing as well as editing of the
image.
These photos may be very large, so you don\[cq]t want to wait for them
to load, so your code uses \f[CR]async\f[R]/\f[CR]await\f[R] to load the
images in the background.
.PP
But imagine that you have other code that needs to only run when the
image has completed loading, such as a command that performs red\-eye
removal on the image in the lightbox.
While ideally this command wouldn\[cq]t even be executed if the image
hasn\[cq]t fully loaded, for improved reliability you want to check to
ensure this is the case.
.PP
So the \f[CR]fixRedEyeCommand()\f[R] function, which is called by the
button that triggers red\-eye removal, checks the value of the lightbox
image\[cq]s \f[CR]complete\f[R] property before attempting to do its
work.
This is demonstrated in the code below.
.IP
.EX
\f[B]let\f[R] lightboxElem = document.querySelector(\[dq]#lightbox\[dq]);
\f[B]let\f[R] lightboxImgElem = lightboxElem.querySelector(\[dq]img\[dq]);
\f[B]let\f[R] lightboxControlsElem = lightboxElem.querySelector(\[dq].toolbar\[dq]);

\f[B]async\f[R] \f[B]function\f[R] loadImage(url, elem) {
  \f[B]return\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
    elem.onload = () \f[B]=>\f[R] resolve(elem);
    elem.onerror = reject;
    elem.src = url;
  });
}

\f[B]async\f[R] \f[B]function\f[R] lightBox(url) {
  lightboxElem.style.display = \[dq]block\[dq];
  \f[B]await\f[R] loadImage(\[dq]https://somesite.net/huge\-image.jpg\[dq], lightboxImgElem);
  lightboxControlsElem.disabled = \f[B]false\f[R];
}

\f[I]// \&...\f[R]

\f[B]function\f[R] fixRedEyeCommand() {
  \f[B]if\f[R] (lightboxElem.style.display === \[dq]block\[dq] && lightboxImgElem.complete) {
    fixRedEye(lightboxImgElem);
  } \f[B]else\f[R] {
    \f[I]/* can\[aq]t start doing this until the image is fully loaded */\f[R]
  }
}
.EE
