.\" Automatically generated by Pandoc 3.4
.\"
.TH "RTCRtpScriptTransformer.options" "JS" "September 8, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCRtpScriptTransformer.options \- RTCRtpScriptTransformer: options
property
.SH SYNOPSIS
The \f[B]\f[CB]options\f[B]\f[R] read\-only property of the
\f[CR]RTCRtpScriptTransformer\f[R] interface returns the object that was
(optionally) passed as the second argument during construction of the
corresponding \f[CR]RTCRtpScriptTransform\f[R].
.SH VALUE
An object.
.SH DESCRIPTION
The simplest use of options is for the main thread to indicate whether
the corresponding \f[CR]RTCRtpScriptTransform\f[R] is to be added to the
WebRTC sender or receiver pipeline.
This is important if the same worker is used for processing both
incoming and outgoing encoded frames, as it allows code to determine
what transform should be applied to the frames.
.PP
Options can also be used to send/transfer the second port of a message
channel to the worker\-side transform.
This channel can then be used to send dynamic information to a transform
stream, such as when encryption keys are changed or added.
Note that you might also send messages to the transform using
\f[CR]Worker.postMessage()\f[R], but you would then have to
appropriately redirect the messages if the worker is used in different
contexts (while a message port option provides a direct channel for a
specific transform).
.SH EXAMPLES
.SS How to indicate the current WebRTC pipeline
\f[CR]RTCRtpScriptTransform\f[R] is constructed with a particular
\f[CR]Worker\f[R] and options, and then inserted into either the WebRTC
outgoing or incoming pipeline by assigning it to
\f[CR]RTCRtpSender.transform\f[R] or
\f[CR]RTCRtpReceiver.transform\f[R], respectively.
If the same worker is used in the transforms for the incoming and
outgoing pipeline, then you need to supply options in the constructor to
indicate whether encoded frames to be transformed are incoming or
outgoing.
.PP
The example below shows how this might be done for a
\f[CR]RTCRtpScriptTransform\f[R] added to the sender pipeline after
adding a track to the peer connection (\f[CR]RTCPeerConnection\f[R]),
and then adding another transform to the receiver pipeline when a track
is received.
.IP
.EX
\f[I]// videoSender is an RTCRtpSender.\f[R]
\f[B]const\f[R] videoSender = peerConnection.addTrack(track, mediaStream);
videoSender.transform = \f[B]new\f[R] RTCRtpScriptTransform(worker, {
  name: \[dq]senderTransform\[dq],
});
.EE
.IP
.EX
peerConnection.ontrack = (event) \f[B]=>\f[R] {
  \f[I]// event.receiver is an RTCRtpReceiver\f[R]
  event.receiver.transform = \f[B]new\f[R] RTCRtpScriptTransform(worker, {
    someOption: \[dq]receiverTransform\[dq],
  });
};
.EE
.PP
In each case above we supply an object with a different value for the
option object\[cq]s \f[CR]name\f[R] property, which indicates the
pipeline that the transform was added to.
Note that the names and values of properties in \f[CR]options\f[R] is
arbitrary: what matters is that the main thread and worker thread both
know what properties and values are used.
.PP
The following code how the passed options are used in the worker.
First we implement a handler for the \f[CR]rtctransform\f[R] event,
which is fired at the global worker object on construction of the
corresponding \f[CR]RTCRtpScriptTransform\f[R], and when new frames are
enqueued for processing.
\f[CR]event.transformer\f[R] is a \f[CR]RTCRtpScriptTransformer\f[R]
that has a \f[CR]readable\f[R], \f[CR]writable\f[R], and
\f[CR]options\f[R] property.
.IP
.EX
addEventListener(\[dq]rtctransform\[dq], (event) \f[B]=>\f[R] {
  \f[B]let\f[R] transform;
  \f[I]// Select a transform based on passed options\f[R]
  \f[B]if\f[R] (event.transformer.options.name == \[dq]senderTransform\[dq])
    transform = createSenderTransform(); \f[I]// A TransformStream\f[R]
  \f[B]else\f[R] \f[B]if\f[R] (event.transformer.options.name == \[dq]receiverTransform\[dq])
    transform = createReceiverTransform(); \f[I]// A TransformStream\f[R]
  \f[B]else\f[R] \f[B]return\f[R];

  \f[I]// Pipe frames from the readable to writeable through TransformStream\f[R]
  event.transformer.readable
    .pipeThrough(transform)
    .pipeTo(event.transformer.writable);
});
.EE
.PP
The code creates a different \f[CR]TransformStream\f[R] to process
outgoing and incoming frames, using \f[CR]createSenderTransform()\f[R]
or \f[CR]createReceiverTransform()\f[R], based on the passed options (it
then pipes frames from the \f[CR]readable\f[R], through the selected
\f[CR]TransformStream\f[R], to the \f[CR]writable\f[R]).
.SS Passing a message port to a transform
This example shows how to create a message channel and transfer one of
its ports to the WebRTC encoded transform running in the worker.
This main thread can then send and transfer objects and messages to the
transformer running in the worker after construction, and vice versa.
.PP
The code below first creates a \f[CR]MessageChannel\f[R] and then
constructs a \f[CR]RTCRtpScriptTransform\f[R] passing the
\f[CR]port2\f[R] value as an property in the options argument.
The port is also included in the array passed as the third constructor
argument, so that it is transferred into the worker context.
.IP
.EX
\f[B]const\f[R] channel = \f[B]new\f[R] MessageChannel();

\f[B]const\f[R] transform = \f[B]new\f[R] RTCRtpScriptTransform(
  worker,
  { purpose: \[dq]encrypter\[dq], port: channel.port2 },
  [channel.port2],
);
.EE
.PP
The worker can then get the port from the \f[CR]rtctransform\f[R] event
fired at the global worker object.
.IP
.EX
\f[B]let\f[R] messagePort;
addEventListener(\[dq]rtctransform\[dq], (event) \f[B]=>\f[R] {
  messagePort = event.transformer.options.port;
  \f[I]// ... other transformer code\f[R]
});
.EE
.PP
Code in each end of the channel can send and transfer objects to the
other end using \f[CR]MessagePort.postMessage()\f[R], and listen for
incoming messages using its \f[CR]message\f[R] event.
.PP
For example, assuming we had an encryption key in a
\f[CR]Uint8Array\f[R] typed array named \f[CR]encryptionKey\f[R], we
could transfer it from the main thread to the worker as shown:
.IP
.EX
\f[B]const\f[R] encryptionKeyBuffer = encryptionKey.buffer;
channel.port1.postMessage(encryptionKeyBuffer, [encryptionKeyBuffer]);
.EE
.PP
The worker would listen for the \f[CR]message\f[R] event to get the key:
.IP
.EX
  messagePort.addEventListener(\[dq]message\[dq], (event) \f[B]=>\f[R] {
    \f[B]const\f[R] encryptionKeyBuffer = event.data;
    \f[I]// ... Use the encryptionKeyBuffer for encryption or any other purpose\f[R]
  };
.EE
.PP
See message channel for more information and examples.
.SH SEE ALSO
.IP \[bu] 2
Using WebRTC Encoded Transforms
