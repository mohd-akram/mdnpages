.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Element.querySelectorAll" "JS" "December 19, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Element.querySelectorAll \- Element: querySelectorAll() method
.SH SYNOPSIS
The \f[CR]Element\f[R] method \f[B]\f[CB]querySelectorAll()\f[B]\f[R]
returns a static (not live) \f[CR]NodeList\f[R] representing a list of
elements matching the specified group of selectors which are descendants
of the element on which the method was called.
.SH SYNTAX
.IP
.EX
querySelectorAll(selectors)
.EE
.SS Parameters
.TP
\f[B]selectors\f[R]
A string containing one or more selectors to match.
This string must be a valid CSS selector string; if it isn\[cq]t, a
\f[CR]SyntaxError\f[R] exception is thrown.
.RS
.PP
Note that the HTML specification does not require attribute values to be
valid CSS identifiers.
If a \f[CR]class\f[R] or \f[CR]id\f[R] attribute value is not a valid
CSS identifier, then you must escape it before using it in a selector,
either by calling \f[CR]CSS.escape()\f[R] on the value, or using one of
the techniques described in Escaping characters.
See Escaping attribute values for an example.
.PP
The selectors are applied to the entire document, not just the
particular element on which \f[CR]querySelectorAll()\f[R] is called.
To restrict the selector to the element on which
\f[CR]querySelectorAll()\f[R] is called, include the \f[CR]:scope\f[R]
pseudo\-class at the start of the selector.
See the selector scope example.
.RE
.SS Return value
A non\-live \f[CR]NodeList\f[R] containing one \f[CR]Element\f[R] object
for each descendant node that matches at least one of the specified
selectors.
The elements are in document order \[em] that is, parents before
children, earlier siblings before later siblings.
.RS
.PP
\f[B]Note:\f[R] If the specified \f[CR]selectors\f[R] include a CSS
pseudo\-element, the returned list is always empty.
.RE
.SS Exceptions
.TP
\f[B]SyntaxError\f[R] \f[B]DOMException\f[R]
Thrown if the syntax of the specified \f[CR]selectors\f[R] string is not
valid.
.SH EXAMPLES
.SS Getting all elements with a custom data value
This example uses the attribute selector to select multiple elements
with a \f[CR]data\-name\f[R] data attribute that contains
\[lq]funnel\-chart\-percent\[rq].
.IP
.EX
<\f[B]section\f[R] class=\[dq]box\[dq] id=\[dq]sect1\[dq]>
  <\f[B]div\f[R] data\-name=\[dq]funnel\-chart\-percent1\[dq]>10.900%</\f[B]div\f[R]>
  <\f[B]div\f[R] data\-name=\[dq]funnel\-chart\-percent2\[dq]>3700.00%</\f[B]div\f[R]>
  <\f[B]div\f[R] data\-name=\[dq]funnel\-chart\-percent3\[dq]>0.00%</\f[B]div\f[R]>
</\f[B]section\f[R]>
.EE
.IP
.EX
\f[B]const\f[R] refs = [
  ...document.querySelectorAll(\[ga][data\-name*=\[dq]funnel\-chart\-percent\[dq]]\[ga]),
];
.EE
.SS Obtaining a list of matches
To obtain a \f[CR]NodeList\f[R] of all of the \f[CR]<p>\f[R] elements
contained within the element \f[CR]myBox\f[R]:
.IP
.EX
\f[B]const\f[R] matches = myBox.querySelectorAll(\[dq]p\[dq]);
.EE
.PP
This example returns a list of all \f[CR]<div>\f[R] elements within
\f[CR]myBox\f[R] with a class of either \f[CR]note\f[R] or
\f[CR]alert\f[R]:
.IP
.EX
\f[B]const\f[R] matches = myBox.querySelectorAll(\[dq]div.note, div.alert\[dq]);
.EE
.PP
Here, we get a list of the document\[cq]s \f[CR]<p>\f[R] elements whose
immediate parent element is a \f[CR]<div>\f[R] with the class
\f[CR]\[dq]highlighted\[dq]\f[R] and which are located inside a
container whose ID is \f[CR]\[dq]test\[dq]\f[R].
.IP
.EX
\f[B]const\f[R] container = document.querySelector(\[dq]#test\[dq]);
\f[B]const\f[R] matches = container.querySelectorAll(\[dq]div.highlighted > p\[dq]);
.EE
.PP
This example uses an attribute selector to return a list of the
\f[CR]<iframe>\f[R] elements in the document that contain an attribute
named \f[CR]\[dq]data\-src\[dq]\f[R]:
.IP
.EX
\f[B]const\f[R] matches = document.querySelectorAll(\[dq]iframe[data\-src]\[dq]);
.EE
.PP
Here, an attribute selector is used to return a list of the list items
contained within a list whose ID is \f[CR]\[dq]user\-list\[dq]\f[R]
which have a \f[CR]\[dq]data\-active\[dq]\f[R] attribute whose value is
\f[CR]\[dq]1\[dq]\f[R]:
.IP
.EX
\f[B]const\f[R] container = document.querySelector(\[dq]#user\-list\[dq]);
\f[B]const\f[R] matches = container.querySelectorAll(\[dq]li[data\-active=\[aq]1\[aq]]\[dq]);
.EE
.SS Accessing the matches
Once the \f[CR]NodeList\f[R] of matching elements is returned, you can
examine it just like any array.
If the array is empty (that is, its \f[CR]length\f[R] property is
\f[CR]0\f[R]), then no matches were found.
.PP
Otherwise, you can use standard array notation to access the contents of
the list.
You can use any common looping statement, such as:
.IP
.EX
\f[B]const\f[R] highlightedItems = userList.querySelectorAll(\[dq].highlighted\[dq]);

highlightedItems.forEach((userItem) \f[B]=>\f[R] {
  deleteUser(userItem);
});
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]NodeList\f[R] is not a genuine array, that is to
say it doesn\[cq]t have array methods like \f[CR]slice\f[R],
\f[CR]some\f[R], \f[CR]map\f[R], etc.
To convert it into an array, try \f[CR]Array.from(nodeList)\f[R].
.RE
.SS Selector scope
The \f[CR]querySelectorAll()\f[R] method applies its selectors to the
whole document: they are not scoped to the element on which the method
is called.
To scope the selectors, include the \f[CR]:scope\f[R] pseudo\-class at
the start of the selector string.
.SS HTML
In this example the HTML contains:
.IP \[bu] 2
two buttons: \f[CR]#select\f[R] and \f[CR]#select\-scope\f[R]
.IP \[bu] 2
three nested \f[CR]<div>\f[R] elements: \f[CR]#outer\f[R],
\f[CR]#subject\f[R], and \f[CR]#inner\f[R]
.IP \[bu] 2
a \f[CR]<pre>\f[R] element which the example uses for output.
.IP
.EX
<\f[B]button\f[R] id=\[dq]select\[dq]>Select</\f[B]button\f[R]>
<\f[B]button\f[R] id=\[dq]select\-scope\[dq]>Select with :scope</\f[B]button\f[R]>

<\f[B]div\f[R] id=\[dq]outer\[dq]>
  #outer
  <\f[B]div\f[R] id=\[dq]subject\[dq]>
    #subject
    <\f[B]div\f[R] id=\[dq]inner\[dq]>#inner</\f[B]div\f[R]>
  </\f[B]div\f[R]>
</\f[B]div\f[R]>

<\f[B]pre\f[R] id=\[dq]output\[dq]></\f[B]pre\f[R]>
.EE
.SS JavaScript
In the JavaScript, we first select the \f[CR]#subject\f[R] element.
.PP
When the \f[CR]#select\f[R] button is pressed, we call
\f[CR]querySelectorAll()\f[R] on \f[CR]#subject\f[R], passing
\f[CR]\[dq]#outer #inner\[dq]\f[R] as the selector string.
.PP
When the \f[CR]#select\-scope\f[R] button is pressed, we again call
\f[CR]querySelectorAll()\f[R] on \f[CR]#subject\f[R], but this time we
pass \f[CR]\[dq]:scope #outer #inner\[dq]\f[R] as the selector string.
.IP
.EX
\f[B]const\f[R] subject = document.querySelector(\[dq]#subject\[dq]);

\f[B]const\f[R] select = document.querySelector(\[dq]#select\[dq]);
select.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
  \f[B]const\f[R] selected = subject.querySelectorAll(\[dq]#outer #inner\[dq]);
  output.textContent = \[ga]Selection count: ${selected.length}\[ga];
});

\f[B]const\f[R] selectScope = document.querySelector(\[dq]#select\-scope\[dq]);
selectScope.addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
  \f[B]const\f[R] selected = subject.querySelectorAll(\[dq]:scope #outer #inner\[dq]);
  output.textContent = \[ga]Selection count: ${selected.length}\[ga];
});
.EE
.SS Result
When we press \[lq]Select\[rq], the selector selects all elements with
an ID of \f[CR]inner\f[R] that also have an ancestor with an ID of
\f[CR]outer\f[R].
Note that even though \f[CR]#outer\f[R] is outside the
\f[CR]#subject\f[R] element, it is still used in selection, so our
\f[CR]#inner\f[R] element is found.
.PP
When we press \[lq]Select with :scope\[rq], the \f[CR]:scope\f[R]
pseudo\-class restricts the selector scope to \f[CR]#subject\f[R], so
\f[CR]#outer\f[R] is not used in selector matching, and we don\[cq]t
find the \f[CR]#inner\f[R] element.
.SS Escaping attribute values
This example shows that if an HTML document contains an \f[CR]id\f[R]
which is not a valid CSS identifier, then we must escape the attribute
value before using it in \f[CR]querySelectorAll()\f[R].
.SS HTML
In the following code, a \f[CR]<div>\f[R] element has an \f[CR]id\f[R]
of \f[CR]\[dq]this?element\[dq]\f[R], which is not a valid CSS
identifier, because the \f[CR]\[dq]?\[dq]\f[R] character is not allowed
in CSS identifiers.
.PP
We also have three buttons, and a \f[CR]<pre>\f[R] element for logging
errors.
.IP
.EX
<\f[B]div\f[R] id=\[dq]container\[dq]>
  <\f[B]div\f[R] id=\[dq]this?element\[dq]></\f[B]div\f[R]>
</\f[B]div\f[R]>

<\f[B]button\f[R] id=\[dq]no\-escape\[dq]>No escape</\f[B]button\f[R]>
<\f[B]button\f[R] id=\[dq]css\-escape\[dq]>CSS.escape()</\f[B]button\f[R]>
<\f[B]button\f[R] id=\[dq]manual\-escape\[dq]>Manual escape</\f[B]button\f[R]>

<\f[B]pre\f[R] id=\[dq]log\[dq]></\f[B]pre\f[R]>
.EE
.SS CSS
.IP
.EX
div {
  \f[B]background\-color\f[R]: blue;
  \f[B]margin\f[R]: 1rem 0;
  \f[B]height\f[R]: 100px;
  \f[B]width\f[R]: 200px;
}
.EE
.SS JavaScript
All three buttons, when clicked, try to select the \f[CR]<div>\f[R], and
then set its background color to a random value.
.IP \[bu] 2
The first button uses the \f[CR]\[dq]this?element\[dq]\f[R] value
directly.
.IP \[bu] 2
The second button escapes the value using \f[CR]CSS.escape()\f[R].
.IP \[bu] 2
The third button explicitly escapes the \f[CR]\[dq]?\[dq]\f[R] character
using a backslash.
Note that we must also escape the backslash itself, using another
backslash, like: \f[CR]\[dq]\[rs]\[rs]?\[dq]\f[R].
.IP
.EX
\f[B]const\f[R] container = document.querySelector(\[dq]#container\[dq]);
\f[B]const\f[R] log = document.querySelector(\[dq]#log\[dq]);

\f[B]function\f[R] random(number) {
  \f[B]return\f[R] Math.floor(Math.random() * number);
}

\f[B]function\f[R] setBackgroundColor(id) {
  log.textContent = \[dq]\[dq];

  \f[B]try\f[R] {
    \f[B]const\f[R] elements = container.querySelectorAll(\[ga]#${id}\[ga]);
    \f[B]const\f[R] randomColor = \[ga]rgb(${random(255)} ${random(255)} ${random(255)})\[ga];
    elements[0].style.backgroundColor = randomColor;
  } \f[B]catch\f[R] (e) {
    log.textContent = e;
  }
}

document.querySelector(\[dq]#no\-escape\[dq]).addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
  setBackgroundColor(\[dq]this?element\[dq]);
});

document.querySelector(\[dq]#css\-escape\[dq]).addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
  setBackgroundColor(CSS.escape(\[dq]this?element\[dq]));
});

document.querySelector(\[dq]#manual\-escape\[dq]).addEventListener(\[dq]click\[dq], () \f[B]=>\f[R] {
  setBackgroundColor(\[dq]this\[rs]\[rs]?element\[dq]);
});
.EE
.SS Result
Clicking the first button gives an error, while the second and third
buttons work properly.
.SH SEE ALSO
.IP \[bu] 2
Locating DOM elements using selectors
.IP \[bu] 2
Attribute selectors in the CSS Guide
.IP \[bu] 2
Attribute selectors in the MDN Learning Area
.IP \[bu] 2
\f[CR]Element.querySelector()\f[R]
.IP \[bu] 2
\f[CR]Document.querySelector()\f[R] and
\f[CR]Document.querySelectorAll()\f[R]
.IP \[bu] 2
\f[CR]DocumentFragment.querySelector()\f[R] and
\f[CR]DocumentFragment.querySelectorAll()\f[R]
