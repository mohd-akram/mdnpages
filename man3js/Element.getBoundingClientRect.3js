.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ELEMENT.GETBOUNDINGCLIENTRECT" "3JS" "July 30, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Element.getBoundingClientRect \- Element: getBoundingClientRect() method
.SH SYNOPSIS
The \f[B]\f[CB]Element.getBoundingClientRect()\f[B]\f[R] method returns
a \f[CR]DOMRect\f[R] object providing information about the size of an
element and its position relative to the viewport.
.SH SYNTAX
.IP
.EX
getBoundingClientRect()
.EE
.SS Parameters
None.
.SS Return value
The returned value is a \f[CR]DOMRect\f[R] object which is the smallest
rectangle which contains the entire element, including its padding and
border\-width.
The \f[CR]left\f[R], \f[CR]top\f[R], \f[CR]right\f[R],
\f[CR]bottom\f[R], \f[CR]x\f[R], \f[CR]y\f[R], \f[CR]width\f[R], and
\f[CR]height\f[R] properties describe the position and size of the
overall rectangle in pixels.
Properties other than \f[CR]width\f[R] and \f[CR]height\f[R] are
relative to the top\-left of the viewport.
[IMAGE: DOMRect object that is the smallest rectangle containing the
entire element.]
DOMRect object that is the smallest rectangle containing the entire
element.
.PP
The \f[CR]width\f[R] and \f[CR]height\f[R] properties of the
\f[CR]DOMRect\f[R] object returned by the method include the
\f[CR]padding\f[R] and \f[CR]border\-width\f[R], not only the content
width/height.
In the standard box model, this would be equal to the \f[CR]width\f[R]
or \f[CR]height\f[R] property of the element + \f[CR]padding\f[R] +
\f[CR]border\-width\f[R].
But if \f[CR]box\-sizing: border\-box\f[R] is set for the element this
would be directly equal to its \f[CR]width\f[R] or \f[CR]height\f[R].
.PP
The returned value can be thought of as the union of the rectangles
returned by \f[CR]getClientRects()\f[R] for the element, i.e., the CSS
border\-boxes associated with the element.
.PP
Empty border\-boxes are completely ignored.
If all the element\(cqs border\-boxes are empty, then a rectangle is
returned with a \f[CR]width\f[R] and \f[CR]height\f[R] of zero and where
the \f[CR]top\f[R] and \f[CR]left\f[R] are the top\-left of the
border\-box for the first CSS box (in content order) for the element.
.PP
The amount of scrolling that has been done of the viewport area (or any
other scrollable element) is taken into account when computing the
bounding rectangle.
This means that the rectangle\(cqs boundary edges (\f[CR]top\f[R],
\f[CR]right\f[R], \f[CR]bottom\f[R], \f[CR]left\f[R]) change their
values every time the scrolling position changes (because their values
are relative to the viewport and not absolute).
.PP
If you need the bounding rectangle relative to the top\-left corner of
the document, just add the current scrolling position to the
\f[CR]top\f[R] and \f[CR]left\f[R] properties (these can be obtained
using \f[CR]window.scrollY\f[R] and \f[CR]window.scrollX\f[R]) to get a
bounding rectangle which is independent from the current scrolling
position.
.SH EXAMPLES
.SS Basic
This simple example retrieves the \f[CR]DOMRect\f[R] object representing
the bounding client rect of a simple \f[CR]<div>\f[R] element, and
prints out its properties below it.
.IP
.EX
<\f[B]div\f[R]></\f[B]div\f[R]>
.EE
.IP
.EX
div {
  \f[B]width\f[R]: 400px;
  \f[B]height\f[R]: 200px;
  \f[B]padding\f[R]: 20px;
  \f[B]margin\f[R]: 50px auto;
  \f[B]background\f[R]: purple;
}
.EE
.IP
.EX
\f[B]let\f[R] elem = document.querySelector(\(dqdiv\(dq);
\f[B]let\f[R] rect = elem.getBoundingClientRect();
\f[B]for\f[R] (\f[B]const\f[R] key \f[B]in\f[R] rect) {
  \f[B]if\f[R] (\f[B]typeof\f[R] rect[key] !== \(dqfunction\(dq) {
    \f[B]let\f[R] para = document.createElement(\(dqp\(dq);
    para.textContent = \(ga${key} : ${rect[key]}\(ga;
    document.body.appendChild(para);
  }
}
.EE
.PP
Notice how the \f[CR]width\f[R]/\f[CR]height\f[R] are equal to its
\f[CR]width\f[R]/\f[CR]height\f[R] + \f[CR]padding\f[R].
.PP
Also note how the values of \f[CR]x\f[R]/\f[CR]left\f[R],
\f[CR]y\f[R]/\f[CR]top\f[R], \f[CR]right\f[R], and \f[CR]bottom\f[R] are
equal to the absolute distance from the relevant edge of the viewport to
that side of the element, in each case.
.SS Scrolling
This example demonstrates how bounding client rect is changing when
document is scrolled.
.IP
.EX
<\f[B]div\f[R] id=\(dqexample\(dq></\f[B]div\f[R]>
<\f[B]div\f[R] id=\(dqcontrols\(dq></\f[B]div\f[R]>
.EE
.IP
.EX
div#example {
  \f[B]width\f[R]: 400px;
  \f[B]height\f[R]: 200px;
  \f[B]padding\f[R]: 20px;
  \f[B]margin\f[R]: 50px auto;
  \f[B]background\f[R]: purple;
}

body {
  \f[B]padding\-bottom\f[R]: 1000px;
}
p {
  \f[B]margin\f[R]: 0;
}
.EE
.IP
.EX
\f[B]function\f[R] update() {
  \f[B]const\f[R] container = document.getElementById(\(dqcontrols\(dq);
  \f[B]const\f[R] elem = document.getElementById(\(dqexample\(dq);
  \f[B]const\f[R] rect = elem.getBoundingClientRect();

  container.textContent = \(dq\(dq;
  \f[B]for\f[R] (\f[B]const\f[R] key \f[B]in\f[R] rect) {
    \f[B]if\f[R] (\f[B]typeof\f[R] rect[key] !== \(dqfunction\(dq) {
      \f[B]let\f[R] para = document.createElement(\(dqp\(dq);
      para.textContent = \(ga${key} : ${rect[key]}\(ga;
      container.appendChild(para);
    }
  }
}

document.addEventListener(\(dqscroll\(dq, update);
update();
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]getClientRects()\f[R]
