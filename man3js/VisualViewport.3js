.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "VISUALVIEWPORT" "3JS" "November 21, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
VisualViewport \- VisualViewport
.SH SYNOPSIS
The \f[B]\f[CB]VisualViewport\f[B]\f[R] interface of the Visual Viewport
API represents the visual viewport for a given window.
For a page containing iframes, each iframe, as well as the containing
page, will have a unique window object.
Each window on a page will have a unique \f[CR]VisualViewport\f[R]
representing the properties associated with that window.
.PP
You can get a window\(cqs visual viewport using
\f[CR]Window.visualViewport\f[R].
.RS
.PP
\f[B]Note:\f[R] Only the top\-level window has a visual viewport
that\(cqs distinct from the layout viewport.
Therefore, it\(cqs generally only the \f[CR]VisualViewport\f[R] object
of the top\-level window that\(cqs useful.
For an \f[CR]<iframe>\f[R], visual viewport metrics like
\f[CR]VisualViewport.width\f[R] always correspond to layout viewport
metrics like \f[CR]document.documentElement.clientWidth\f[R].
.RE
.SH INSTANCE PROPERTIES
\f[I]Also inherits properties from its parent interface,
\f[CI]EventTarget\f[I].\f[R]
.TP
\f[B]VisualViewport.offsetLeft\f[R] \f[I](read\-only)\f[R]
Returns the offset of the left edge of the visual viewport from the left
edge of the layout viewport in CSS pixels.
.TP
\f[B]VisualViewport.offsetTop\f[R] \f[I](read\-only)\f[R]
Returns the offset of the top edge of the visual viewport from the top
edge of the layout viewport in CSS pixels.
.TP
\f[B]VisualViewport.pageLeft\f[R] \f[I](read\-only)\f[R]
Returns the x coordinate of the visual viewport relative to the initial
containing block origin of the top edge in CSS pixels.
.TP
\f[B]VisualViewport.pageTop\f[R] \f[I](read\-only)\f[R]
Returns the y coordinate of the visual viewport relative to the initial
containing block origin of the top edge in CSS pixels.
.TP
\f[B]VisualViewport.width\f[R] \f[I](read\-only)\f[R]
Returns the width of the visual viewport in CSS pixels.
.TP
\f[B]VisualViewport.height\f[R] \f[I](read\-only)\f[R]
Returns the height of the visual viewport in CSS pixels.
.TP
\f[B]VisualViewport.scale\f[R] \f[I](read\-only)\f[R]
Returns the pinch\-zoom scaling factor applied to the visual viewport.
.SH INSTANCE METHODS
\f[I]Also inherits methods from its parent interface,
\f[CI]EventTarget\f[I].\f[R]
.SH EVENTS
Listen to these events using \f[CR]addEventListener()\f[R] or by
assigning an event listener to the relevant \f[CR]oneventname\f[R]
property of this interface.
.TP
\f[B]resize\f[R]
Fired when the visual viewport is resized.
Also available via the \f[CR]onresize\f[R] property.
.TP
\f[B]scroll\f[R]
Fired when the visual viewport is scrolled.
Also available via the \f[CR]onscroll\f[R] property.
.TP
\f[B]scrollend\f[R]
Fired when a scrolling operation on the visual viewport ends.
Also available via the \f[CR]onscrollend\f[R] property.
.SH EXAMPLES
.SS Hiding an overlaid box on zoom
This example, taken from the \c
.UR https://github.com/WICG/visual-viewport
Visual Viewport README
.UE \c
, shows how to write a bit of code that will hide an overlaid box (which
might contain an advert, say) when the user zooms in.
This is a nice way to improve the user experience when zooming in on
pages.
A \c
.UR https://wicg.github.io/visual-viewport/examples/hide-on-zoom.html
live sample
.UE \c
\ is also available.
.IP
.EX
\f[B]const\f[R] bottomBar = document.getElementById(\(dqbottom\-bar\(dq);
\f[B]const\f[R] viewport = window.visualViewport;

\f[B]function\f[R] resizeHandler() {
  bottomBar.style.display = viewport.scale > 1.3 ? \(dqnone\(dq : \(dqblock\(dq;
}

window.visualViewport.addEventListener(\(dqresize\(dq, resizeHandler);
.EE
.SS Simulating position: device\-fixed
This example, also taken from the \c
.UR https://github.com/WICG/visual-viewport
Visual Viewport README
.UE \c
, shows how to use this API to simulate
\f[CR]position: device\-fixed\f[R], which fixes elements to the visual
viewport.
A \c
.UR https://wicg.github.io/visual-viewport/examples/fixed-to-viewport.html
live sample
.UE \c
\ is also available.
.IP
.EX
\f[B]const\f[R] bottomBar = document.getElementById(\(dqbottom\-bar\(dq);
\f[B]const\f[R] viewport = window.visualViewport;
\f[B]function\f[R] viewportHandler() {
  \f[B]const\f[R] layoutViewport = document.getElementById(\(dqlayoutViewport\(dq);

  \f[I]// Since the bar is position: fixed we need to offset it by the visual\f[R]
  \f[I]// viewport\(aqs offset from the layout viewport origin.\f[R]
  \f[B]const\f[R] offsetLeft = viewport.offsetLeft;
  \f[B]const\f[R] offsetTop =
    viewport.height \-
    layoutViewport.getBoundingClientRect().height +
    viewport.offsetTop;

  \f[I]// You could also do this by setting style.left and style.top if you\f[R]
  \f[I]// use width: 100% instead.\f[R]
  bottomBar.style.transform = \(gatranslate(${offsetLeft}px, ${offsetTop}px) scale(${
    1 / viewport.scale
  })\(ga;
}
window.visualViewport.addEventListener(\(dqscroll\(dq, viewportHandler);
window.visualViewport.addEventListener(\(dqresize\(dq, viewportHandler);
.EE
.RS
.PP
\f[B]Note:\f[R] This technique should be used with care; emulating
\f[CR]position: device\-fixed\f[R] in this way can result in the fixed
element flickering during scrolling.
.RE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/bokand/bokand.github.io/blob/master/web_viewports_explainer.md
Web Viewports Explainer
.UE \c
\ \(em useful explanation of web viewports concepts, including the
difference between visual viewport and layout viewport.
