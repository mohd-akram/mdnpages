.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "WebGLRenderingContext.vertexAttribPointer" "JS" "March 12, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
WebGLRenderingContext.vertexAttribPointer \- WebGLRenderingContext:
vertexAttribPointer() method
.SH SYNOPSIS
The \f[B]\f[CB]WebGLRenderingContext.vertexAttribPointer()\f[B]\f[R]
method of the WebGL API binds the buffer currently bound to
\f[CR]gl.ARRAY_BUFFER\f[R] to a generic vertex attribute of the current
vertex buffer object and specifies its layout.
.SH SYNTAX
.IP
.EX
vertexAttribPointer(index, size, type, normalized, stride, offset)
.EE
.SS Parameters
.TP
\f[B]index\f[R]
A \f[CR]GLuint\f[R] specifying the index of the vertex attribute that is
to be modified.
.TP
\f[B]size\f[R]
A \f[CR]GLint\f[R] specifying the number of components per vertex
attribute.
Must be 1, 2, 3, or 4.
.TP
\f[B]type\f[R]
A \f[CR]GLenum\f[R] specifying the data type of each component in the
array.
Possible values:
.RS
.IP \[bu] 2
\f[CR]gl.BYTE\f[R]: signed 8\-bit integer, with values in [\-128, 127]
.IP \[bu] 2
\f[CR]gl.SHORT\f[R]: signed 16\-bit integer, with values in [\-32768,
32767]
.IP \[bu] 2
\f[CR]gl.UNSIGNED_BYTE\f[R]: unsigned 8\-bit integer, with values in [0,
255]
.IP \[bu] 2
\f[CR]gl.UNSIGNED_SHORT\f[R]: unsigned 16\-bit integer, with values in
[0,65535]
.IP \[bu] 2
\f[CR]gl.FLOAT\f[R]: 32\-bit IEEE floating point number
.PP
When using a WebGL 2 context, the following values are available
additionally:
.IP \[bu] 2
\f[CR]gl.HALF_FLOAT\f[R]: 16\-bit IEEE floating point number
.IP \[bu] 2
\f[CR]gl.INT\f[R]: 32\-bit signed binary integer
.IP \[bu] 2
\f[CR]gl.UNSIGNED_INT\f[R]: 32\-bit unsigned binary integer
.IP \[bu] 2
\f[CR]gl.INT_2_10_10_10_REV\f[R]: 32\-bit signed integer with values in
[\-512, 511]
.IP \[bu] 2
\f[CR]gl.UNSIGNED_INT_2_10_10_10_REV\f[R]: 32\-bit unsigned integer with
values in [0, 1023]
.RE
.TP
\f[B]normalized\f[R]
A \f[CR]GLboolean\f[R] specifying whether integer data values should be
normalized into a certain range when being cast to a float.
.RS
.IP \[bu] 2
For types \f[CR]gl.BYTE\f[R] and \f[CR]gl.SHORT\f[R], normalizes the
values to [\-1, 1] if true.
.IP \[bu] 2
For types \f[CR]gl.UNSIGNED_BYTE\f[R] and \f[CR]gl.UNSIGNED_SHORT\f[R],
normalizes the values to [0, 1] if true.
.IP \[bu] 2
For types \f[CR]gl.FLOAT\f[R] and \f[CR]gl.HALF_FLOAT\f[R], this
parameter has no effect.
.RE
.TP
\f[B]stride\f[R]
A \f[CR]GLsizei\f[R] specifying the offset in bytes between the
beginning of consecutive vertex attributes.
Cannot be negative or larger than 255.
If stride is 0, the attribute is assumed to be tightly packed, that is,
the attributes are not interleaved but each attribute is in a separate
block, and the next vertex\[cq] attribute follows immediately after the
current vertex.
.TP
\f[B]offset\f[R]
A \f[CR]GLintptr\f[R] specifying an offset in bytes of the first
component in the vertex attribute array.
Must be a multiple of the byte length of \f[CR]type\f[R].
.SS Return value
None (\f[CR]undefined\f[R]).
.SS Exceptions
.IP \[bu] 2
A \f[CR]gl.INVALID_VALUE\f[R] error is thrown if \f[CR]stride\f[R] or
\f[CR]offset\f[R] are negative.
.IP \[bu] 2
A \f[CR]gl.INVALID_OPERATION\f[R] error is thrown if \f[CR]stride\f[R]
and \f[CR]offset\f[R] are not multiples of the size of the data type.
.IP \[bu] 2
A \f[CR]gl.INVALID_OPERATION\f[R] error is thrown if no WebGLBuffer is
bound to the ARRAY_BUFFER target.
.IP \[bu] 2
When using a WebGL 2 context, a \f[CR]gl.INVALID_OPERATION\f[R] error is
thrown if this vertex attribute is defined as an integer in the vertex
shader (e.g.\ \f[CR]uvec4\f[R] or \f[CR]ivec4\f[R], instead of
\f[CR]vec4\f[R]).
.SH DESCRIPTION
Let\[cq]s assume we want to render some 3D geometry, and for that we
will need to supply our vertices to the Vertex Shader.
Each vertex has a few attributes, like position, normal vector, or
texture coordinate, that are defined in an \f[CR]ArrayBuffer\f[R] and
will be supplied to the Vertex Buffer Object (VBO).
First, we need to bind the \f[CR]WebGLBuffer\f[R] we want to use to
\f[CR]gl.ARRAY_BUFFER\f[R], then, with this method,
\f[CR]gl.vertexAttribPointer()\f[R], we specify in what order the
attributes are stored, and what data type they are in.
In addition, we need to include the stride, which is the total byte
length of all attributes for one vertex.
Also, we have to call \f[CR]gl.enableVertexAttribArray()\f[R] to tell
WebGL that this attribute should be filled with data from our array
buffer.
.PP
Usually, your 3D geometry is already in a certain binary format, so you
need to read the specification of that specific format to figure out the
memory layout.
However, if you are designing the format yourself, or your geometry is
in text files (like \c
.UR https://en.wikipedia.org/wiki/Wavefront_.obj_file
Wavefront .obj files
.UE \c
) and must be converted into an \f[CR]ArrayBuffer\f[R] at runtime, you
have free choice on how to structure the memory.
For highest performance, \c
.UR https://en.wikipedia.org/wiki/Interleaved_memory
interleave
.UE \c
\ the attributes and use the smallest data type that still accurately
represents your geometry.
.PP
The maximum number of vertex attributes depends on the graphics card,
and you can call \f[CR]gl.getParameter(gl.MAX_VERTEX_ATTRIBS)\f[R] to
get this value.
On high\-end graphics cards, the maximum is 16, on lower\-end graphics
cards, the value will be lower.
.SS Attribute index
For each attribute, you must specify its index.
This is independent from the location inside the array buffer, so your
attributes can be sent in a different order than how they are stored in
the array buffer.
You have two options:
.IP \[bu] 2
Either you specify the index yourself.
In this case, you call \f[CR]gl.bindAttribLocation()\f[R] to connect a
named attribute from the vertex shader to the index you want to use.
This must be done before calling \f[CR]gl.linkProgram()\f[R].
You can then provide this same index to
\f[CR]gl.vertexAttribPointer()\f[R].
.IP \[bu] 2
Alternatively, you use the index that is assigned by the graphics card
when compiling the vertex shader.
Depending on the graphics card, the index will vary, so you must call
\f[CR]gl.getAttribLocation()\f[R] to find out the index, and then
provide this index to \f[CR]gl.vertexAttribPointer()\f[R].
If you are using WebGL 2, you can specify the index yourself in the
vertex shader code and override the default used by the graphics card,
e.g.
\f[CR]layout(location = 3) in vec4 position;\f[R] would set the
\f[CR]\[dq]position\[dq]\f[R] attribute to index 3.
.SS Integer attributes
While the \f[CR]ArrayBuffer\f[R] can be filled with both integers and
floats, the attributes will always be converted to a float when they are
sent to the vertex shader.
If you need to use integers in your vertex shader code, you can either
cast the float back to an integer in the vertex shader
(e.g.\ \f[CR](int) floatNumber\f[R]), or use
\f[CR]gl.vertexAttribIPointer()\f[R] from WebGL2.
.SS Default attribute values
The vertex shader code may include a number of attributes, but we
don\[cq]t need to specify the values for each attribute.
Instead, we can supply a default value that will be identical for all
vertices.
We can call \f[CR]gl.disableVertexAttribArray()\f[R] to tell WebGL to
use the default value, while calling
\f[CR]gl.enableVertexAttribArray()\f[R] will read the values from the
array buffer as specified with \f[CR]gl.vertexAttribPointer()\f[R].
.PP
Similarly, if our vertex shader expects e.g.\ a 4\-component attribute
with \f[CR]vec4\f[R] but in our \f[CR]gl.vertexAttribPointer()\f[R] call
we set the \f[CR]size\f[R] to \f[CR]2\f[R], then WebGL will set the
first two components based on the array buffer, while the third and
fourth components are taken from the default value.
.PP
The default value is \f[CR]vec4(0.0, 0.0, 0.0, 1.0)\f[R] by default but
we can specify a different default value with
\f[CR]gl.vertexAttrib[1234]f[v]()\f[R].
.PP
For example, your vertex shader may be using a position and a color
attribute.
Most meshes have the color specified at a per\-vertex level, but some
meshes are of a uniform shade.
For those meshes, it is not necessary to place the same color for each
vertex into the array buffer, so you use \f[CR]gl.vertexAttrib4fv()\f[R]
to set a constant color.
.SS Querying current settings
You can call \f[CR]gl.getVertexAttrib()\f[R] and
\f[CR]gl.getVertexAttribOffset()\f[R] to get the current parameters for
an attribute, e.g.\ the data type or whether the attribute should be
normalized.
Keep in mind that these WebGL functions have a slow performance and it
is better to store the state inside your JavaScript application.
However, these functions are great for debugging a WebGL context without
touching the application code.
.SH EXAMPLES
This example shows how to send your vertex attributes to the shader
program.
We use an imaginary data structure where the attributes of each vertex
are stored interleaved with a length of 20 bytes per vertex:
.IP "1." 3
\f[B]position:\f[R] We need to store the X, Y and Z coordinates.
For highest precision, we use 32\-bit floats; in total this uses 12
bytes.
.IP "2." 3
\f[B]normal vector:\f[R] We need to store the X, Y and Z components of
the normal vector, but since precision is not that important, we use
8\-bit signed integers.
For better performance, we align the data to 32 bits by also storing a
fourth zero\-valued component, bringing the total size to 4 bytes.
Also, we tell WebGL to normalize the values because our normals are
always in range [\-1, 1].
.IP "3." 3
\f[B]texture coordinate:\f[R] We need to store the U and V coordinates;
for this 16\-bit unsigned integers offer enough precision, the total
size is 4 bytes.
We also tell WebGL to normalize the values to [0, 1].
.PP
For example, the following vertex:
.IP
.EX
{
  \[dq]position\[dq]: [1.0, 2.0, 1.5],
  \[dq]normal\[dq]: [1.0, 0\f[B].\f[R]0, 0\f[B].\f[R]0],
  \[dq]texCoord\[dq]: [0\f[B].\f[R]5, 0\f[B].\f[R]25]
}
.EE
.PP
Will be stored in the array buffer as follows:
[IMAGE: WebGL array buffer contents]
WebGL array buffer contents
.SS Creating the array buffer
First, we dynamically create the array buffer from JSON data using a
\f[CR]DataView\f[R].
Note the use of \f[CR]true\f[R] because WebGL expects our data to be in
little\-endian.
.IP
.EX
\f[I]// Load geometry with fetch() and Response.json()\f[R]
\f[B]const\f[R] response = \f[B]await\f[R] fetch(\[dq]assets/geometry.json\[dq]);
\f[B]const\f[R] vertices = \f[B]await\f[R] response.json();

\f[I]// Create array buffer\f[R]
\f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(20 * vertices.length);
\f[I]// Fill array buffer\f[R]
\f[B]const\f[R] dv = \f[B]new\f[R] DataView(buffer);
vertices.forEach((vertex, i) \f[B]=>\f[R] {
  dv.setFloat32(20 * i, vertex.position[0], \f[B]true\f[R]);
  dv.setFloat32(20 * i + 4, vertex.position[1], \f[B]true\f[R]);
  dv.setFloat32(20 * i + 8, vertex.position[2], \f[B]true\f[R]);
  dv.setInt8(20 * i + 12, vertex.normal[0] * 0x7f);
  dv.setInt8(20 * i + 13, vertex.normal[1] * 0x7f);
  dv.setInt8(20 * i + 14, vertex.normal[2] * 0x7f);
  dv.setInt8(20 * i + 15, 0);
  dv.setUint16(20 * i + 16, vertex.texCoord[0] * 0xffff, \f[B]true\f[R]);
  dv.setUint16(20 * i + 18, vertex.texCoord[1] * 0xffff, \f[B]true\f[R]);
});
.EE
.PP
For higher performance, we could also do the previous JSON to
ArrayBuffer conversion on the server\-side, e.g.\ with Node.js.
Then we could load the binary file and interpret it as an array buffer:
.IP
.EX
\f[B]const\f[R] response = \f[B]await\f[R] fetch(\[dq]assets/geometry.bin\[dq]);
\f[B]const\f[R] buffer = \f[B]await\f[R] response.arrayBuffer();
.EE
.SS Consume array buffer with WebGL
First, we create a new Vertex Buffer Object (VBO) and supply it with our
array buffer:
.IP
.EX
\f[I]//Bind array buffer to a Vertex Buffer Object\f[R]
\f[B]const\f[R] vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW);
.EE
.PP
Then, we specify the memory layout of the array buffer, either by
setting the index ourselves:
.IP
.EX
\f[I]//Describe the layout of the buffer:\f[R]
\f[I]//1. position, not normalized\f[R]
gl.vertexAttribPointer(0, 3, gl.FLOAT, \f[B]false\f[R], 20, 0);
gl.enableVertexAttribArray(0);
\f[I]//2. normal vector, normalized to [\-1, 1]\f[R]
gl.vertexAttribPointer(1, 4, gl.BYTE, \f[B]true\f[R], 20, 12);
gl.enableVertexAttribArray(1);
\f[I]//3. texture coordinates, normalized to [0, 1]\f[R]
gl.vertexAttribPointer(2, 2, gl.UNSIGNED_SHORT, \f[B]true\f[R], 20, 16);
gl.enableVertexAttribArray(2);

\f[I]//Set the attributes in the vertex shader to the same indices\f[R]
gl.bindAttribLocation(shaderProgram, 0, \[dq]position\[dq]);
gl.bindAttribLocation(shaderProgram, 1, \[dq]normal\[dq]);
gl.bindAttribLocation(shaderProgram, 2, \[dq]texUV\[dq]);
\f[I]//Since the attribute indices have changed, we must re\-link the shader\f[R]
\f[I]//Note that this will reset all uniforms that were previously set.\f[R]
gl.linkProgram(shaderProgram);
.EE
.PP
Or we can use the index provided by the graphics card instead of setting
the index ourselves; this avoids the re\-linking of the shader program.
.IP
.EX
\f[B]const\f[R] locPosition = gl.getAttribLocation(shaderProgram, \[dq]position\[dq]);
gl.vertexAttribPointer(locPosition, 3, gl.FLOAT, \f[B]false\f[R], 20, 0);
gl.enableVertexAttribArray(locPosition);

\f[B]const\f[R] locNormal = gl.getAttribLocation(shaderProgram, \[dq]normal\[dq]);
gl.vertexAttribPointer(locNormal, 4, gl.BYTE, \f[B]true\f[R], 20, 12);
gl.enableVertexAttribArray(locNormal);

\f[B]const\f[R] locTexUV = gl.getAttribLocation(shaderProgram, \[dq]texUV\[dq]);
gl.vertexAttribPointer(locTexUV, 2, gl.UNSIGNED_SHORT, \f[B]true\f[R], 20, 16);
gl.enableVertexAttribArray(locTexUV);
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://www.khronos.org/opengl/wiki/Vertex_Specification
Vertex Specification
.UE \c
\ on the OpenGL wiki
.IP \[bu] 2
\f[CR]WebGL2RenderingContext.vertexAttribIPointer()\f[R]
