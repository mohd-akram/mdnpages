.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "GPUCOMPUTEPASSENCODER.SETBINDGROUP" "3JS" "June 18, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
GPUComputePassEncoder.setBindGroup \- GPUComputePassEncoder:
setBindGroup() method
.SH SYNOPSIS
\f[B]Secure context:\f[R] This feature is available only in secure
contexts (HTTPS).
.PP
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]setBindGroup()\f[B]\f[R] method of the
\f[CR]GPUComputePassEncoder\f[R] interface sets the
\f[CR]GPUBindGroup\f[R] to use for subsequent compute commands, for a
given index.
.SH SYNTAX
.IP
.EX
setBindGroup(index, bindGroup)
setBindGroup(index, bindGroup, dynamicOffsets)
setBindGroup(index, bindGroup, dynamicOffsets, dynamicOffsetsStart,
             dynamicOffsetsLength)
.EE
.SS Parameters
.TP
\f[B]index\f[R]
The index to set the bind group at.
This matches the \f[CR]n\f[R] index value of the corresponding \c
.UR https://gpuweb.github.io/gpuweb/wgsl/#attribute-group
\f[CR]\(atgroup(n)\f[R]
.UE \c
\ attribute in the shader code (\f[CR]GPUShaderModule\f[R]) used in the
related pipeline.
.TP
\f[B]bindGroup\f[R]
The \f[CR]GPUBindGroup\f[R] to use for subsequent compute commands, or
\f[CR]null\f[R], in which case any previously\-set bind group in the
given slot is unset.
.TP
\f[B]dynamicOffsets\f[R] \f[I](optional)\f[R]
A value specifying the offset, in bytes, for each entry in
\f[CR]bindGroup\f[R] with \f[CR]hasDynamicOffset: true\f[R] set (i.e.,
in the descriptor of the \f[CR]GPUDevice.createBindGroupLayout()\f[R]
call that created the \f[CR]GPUBindGroupLayout\f[R] object that the
\f[CR]bindGroup\f[R] is based on).
This value can be:
.RS
.IP \(bu 2
An array of numbers specifying the different offsets.
.IP \(bu 2
A \f[CR]Uint32Array\f[R] containing numbers specifying the offsets.
.RE
.PP
If a \f[CR]Uint32Array\f[R] value is specified for
\f[CR]dynamicOffsets\f[R], both of the following parameters are also
required:
.TP
\f[B]dynamicOffsetsStart\f[R]
A number specifying the offset, in array elements, into
\f[CR]dynamicOffsetsData\f[R], where the dynamic offset data begins.
.TP
\f[B]dynamicOffsetsLength\f[R]
A number specifying the number of dynamic offset values to be read from
in \f[CR]dynamicOffsetsData\f[R].
.SS Return value
None (\f[CR]Undefined\f[R]).
.SS Exceptions
For \f[CR]setBindGroup()\f[R] calls that use a \f[CR]Uint32Array\f[R]
value for \f[CR]dynamicOffsets\f[R], the call will throw with a
\f[CR]RangeError\f[R] \f[CR]DOMException\f[R] if:
.IP \(bu 2
\f[CR]dynamicOffsetsStart\f[R] is less than 0.
.IP \(bu 2
\f[CR]dynamicOffsetsStart\f[R] + \f[CR]dynamicOffsetsLength\f[R] is
greater than \f[CR]dynamicOffsets.length\f[R].
.SS Validation
The following criteria must be met when calling
\f[B]\f[CB]dispatchWorkgroups()\f[B]\f[R], otherwise a
\f[CR]GPUValidationError\f[R] is generated and the
\f[CR]GPUComputePassEncoder\f[R] becomes invalid:
.IP \(bu 2
\f[CR]index\f[R] is less than or equal to the \f[CR]GPUDevice\f[R]\(cqs
\f[CR]maxBindGroups\f[R] limit.
.IP \(bu 2
\f[CR]dynamicOffsets.length\f[R] is the same as the number of entries in
\f[CR]bindGroup\f[R] with \f[CR]hasDynamicOffset: true\f[R] set.
.IP \(bu 2
For \f[CR]bindGroup\f[R] entries where the bound \f[CR]buffer\f[R]\(cqs
\f[CR]type\f[R] is \f[CR]\(dquniform\(dq\f[R] (see
\f[CR]GPUDevice.createBindGroupLayout()\f[R]), each number in
\f[CR]dynamicOffsets\f[R] is a multiple of the \f[CR]GPUDevice\f[R]\(cqs
\f[CR]minUniformBufferOffsetAlignment\f[R] limit.
.IP \(bu 2
For \f[CR]bindGroup\f[R] entries where the bound \f[CR]buffer\f[R]\(cqs
\f[CR]type\f[R] is \f[CR]\(dqstorage\(dq\f[R] or
\f[CR]\(dqread\-only\-storage\(dq\f[R] (see
\f[CR]GPUDevice.createBindGroupLayout()\f[R]), each number in
\f[CR]dynamicOffsets\f[R] is a multiple of the \f[CR]GPUDevice\f[R]\(cqs
\f[CR]minStorageBufferOffsetAlignment\f[R] limit.
.IP \(bu 2
For each \f[CR]bindGroup\f[R] entry, the bound \f[CR]buffer\f[R]\(cqs
\f[CR]offset\f[R], plus the corresponding layout entry\(cqs
\f[CR]minBindingSize\f[R], plus the corresponding dynamic offset
specified in \f[CR]dynamicOffsets\f[R], is less than or equal to the
bound \f[CR]buffer\f[R]\(cqs \f[CR]size\f[R].
.SH EXAMPLES
.SS Set bind group
In our \c
.UR https://mdn.github.io/dom-examples/webgpu-compute-demo/
basic compute demo
.UE \c
, several commands are recorded via a \f[CR]GPUCommandEncoder\f[R].
Most of these commands originate from the
\f[CR]GPUComputePassEncoder\f[R] created via
\f[CR]beginComputePass()\f[R].
The \f[CR]setBindGroup()\f[R] call used here is the simplest form, just
specifying index and bind group.
.IP
.EX
\f[B]const\f[R] BUFFER_SIZE = 1000;

\f[I]// \&...\f[R]

\f[I]// Create GPUCommandEncoder to encode commands to issue to the GPU\f[R]
\f[B]const\f[R] commandEncoder = device.createCommandEncoder();

\f[I]// Initiate render pass\f[R]
\f[B]const\f[R] passEncoder = commandEncoder.beginComputePass();

\f[I]// Issue commands\f[R]
passEncoder.setPipeline(computePipeline);
passEncoder.setBindGroup(0, bindGroup);
passEncoder.dispatchWorkgroups(Math.ceil(BUFFER_SIZE / 64));

\f[I]// End the render pass\f[R]
passEncoder.end();

\f[I]// Copy output buffer to staging buffer\f[R]
commandEncoder.copyBufferToBuffer(
  output,
  0, \f[I]// Source offset\f[R]
  stagingBuffer,
  0, \f[I]// Destination offset\f[R]
  BUFFER_SIZE,
);

\f[I]// End frame by passing array of command buffers to command queue for execution\f[R]
device.queue.submit([commandEncoder.finish()]);

\f[I]// \&...\f[R]
.EE
.SS Unset bind group
.IP
.EX
\f[I]// Set bind group in slot 0\f[R]
passEncoder.setBindGroup(0, bindGroup);

\f[I]// Later, unset bind group in slot 0\f[R]
passEncoder.setBindGroup(0, \f[B]null\f[R]);
.EE
.SH SEE ALSO
.IP \(bu 2
The WebGPU API
