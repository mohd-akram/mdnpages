.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "MATH.RANDOM" "3JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Math.random \- Math.random()
.SH SYNOPSIS
The \f[B]\f[CB]Math.random()\f[B]\f[R] static method returns a
floating\-point, pseudo\-random number that\(cqs greater than or equal
to 0 and less than 1, with approximately uniform distribution over that
range \(em which you can then scale to your desired range.
The implementation selects the initial seed to the random number
generation algorithm; it cannot be chosen or reset by the user.
.RS
.PP
\f[B]Note:\f[R] \f[CR]Math.random()\f[R] \f[I]does not\f[R] provide
cryptographically secure random numbers.
Do not use them for anything related to security.
Use the Web Crypto API instead, and more precisely the
\f[CR]Crypto.getRandomValues()\f[R] method.
.RE
.IP
.EX
\f[B]function\f[R] getRandomInt(max) {
  \f[B]return\f[R] Math.floor(Math.random() * max);
}

console.log(getRandomInt(3));
\f[I]// Expected output: 0, 1 or 2\f[R]

console.log(getRandomInt(1));
\f[I]// Expected output: 0\f[R]

console.log(Math.random());
\f[I]// Expected output: a number from 0 to <1\f[R]
.EE
.SH SYNTAX
.IP
.EX
Math.random()
.EE
.SS Parameters
None.
.SS Return value
A floating\-point, pseudo\-random number between 0 (inclusive) and 1
(exclusive).
.SH EXAMPLES
Note that as numbers in JavaScript are IEEE 754 floating point numbers
with round\-to\-nearest\-even behavior, the ranges claimed for the
functions below (excluding the one for \f[CR]Math.random()\f[R] itself)
aren\(cqt exact.
Usually, the claimed upper bound is not attainable, but if
\f[CR]Math.random()\f[R] returns a number very close to 1, the tiny
difference may not be representable at the requested maximum, therefore
causing the upper bound to be attained.
.SS Getting a random number between 0 (inclusive) and 1 (exclusive)
.IP
.EX
\f[B]function\f[R] getRandom() {
  \f[B]return\f[R] Math.random();
}
.EE
.SS Getting a random number between two values
This example returns a random number between the specified values.
The returned value is no lower than (and may possibly equal)
\f[CR]min\f[R], and is less than (and not equal) \f[CR]max\f[R].
.IP
.EX
\f[B]function\f[R] getRandomArbitrary(min, max) {
  \f[B]return\f[R] Math.random() * (max \- min) + min;
}
.EE
.SS Getting a random integer between two values
This example returns a random \f[I]integer\f[R] between the specified
values.
The value is no lower than \f[CR]min\f[R] (or the next integer greater
than \f[CR]min\f[R] if \f[CR]min\f[R] isn\(cqt an integer), and is less
than (but not equal to) \f[CR]max\f[R].
.IP
.EX
\f[B]function\f[R] getRandomInt(min, max) {
  \f[B]const\f[R] minCeiled = Math.ceil(min);
  \f[B]const\f[R] maxFloored = Math.floor(max);
  \f[B]return\f[R] Math.floor(Math.random() * (maxFloored \- minCeiled) + minCeiled); \f[I]// The maximum is exclusive and the minimum is inclusive\f[R]
}
.EE
.RS
.PP
\f[B]Note:\f[R] It might be tempting to use \f[CR]Math.round()\f[R] to
accomplish that, but doing so would cause your random numbers to follow
a non\-uniform distribution, which may not be acceptable for your needs.
.RE
.SS Getting a random integer between two values, inclusive
While the \f[CR]getRandomInt()\f[R] function above is inclusive at the
minimum, it\(cqs exclusive at the maximum.
What if you need the results to be inclusive at both the minimum and the
maximum?
The \f[CR]getRandomIntInclusive()\f[R] function below accomplishes that.
.IP
.EX
\f[B]function\f[R] getRandomIntInclusive(min, max) {
  \f[B]const\f[R] minCeiled = Math.ceil(min);
  \f[B]const\f[R] maxFloored = Math.floor(max);
  \f[B]return\f[R] Math.floor(Math.random() * (maxFloored \- minCeiled + 1) + minCeiled); \f[I]// The maximum is inclusive and the minimum is inclusive\f[R]
}
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Crypto.getRandomValues()\f[R]
