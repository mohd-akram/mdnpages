.\" Automatically generated by Pandoc 3.4
.\"
.TH "Promise.withResolvers" "JS" "November 23, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Promise.withResolvers \- Promise.withResolvers()
.SH SYNOPSIS
The \f[B]\f[CB]Promise.withResolvers()\f[B]\f[R] static method returns
an object containing a new \f[CR]Promise\f[R] object and two functions
to resolve or reject it, corresponding to the two parameters passed to
the executor of the \f[CR]Promise()\f[R] constructor.
.SH SYNTAX
.IP
.EX
Promise.withResolvers()
.EE
.SS Parameters
None.
.SS Return value
A plain object containing the following properties:
.TP
\f[B]promise\f[R]
A \f[CR]Promise\f[R] object.
.TP
\f[B]resolve\f[R]
A function that resolves the promise.
For its semantics, see the \f[CR]Promise()\f[R] constructor reference.
.TP
\f[B]reject\f[R]
A function that rejects the promise.
For its semantics, see the \f[CR]Promise()\f[R] constructor reference.
.SH DESCRIPTION
\f[CR]Promise.withResolvers()\f[R] is exactly equivalent to the
following code:
.IP
.EX
\f[B]let\f[R] resolve, reject;
\f[B]const\f[R] promise = \f[B]new\f[R] Promise((res, rej) \f[B]=>\f[R] {
  resolve = res;
  reject = rej;
});
.EE
.PP
Except that it is more concise and does not require the use of
\f[CR]let\f[R].
.PP
The key difference when using \f[CR]Promise.withResolvers()\f[R] is that
the resolution and rejection functions now live in the same scope as the
promise itself, instead of being created and used once within the
executor.
This may enable some more advanced use cases, such as when reusing them
for recurring events, particularly with streams and queues.
This also generally results in less nesting than wrapping a lot of logic
within the executor.
.PP
\f[CR]Promise.withResolvers()\f[R] is generic and supports subclassing,
which means it can be called on subclasses of \f[CR]Promise\f[R], and
the result will contain a promise of the subclass type.
To do so, the subclass\[cq]s constructor must implement the same
signature as the \f[CR]Promise()\f[R] constructor \[em] accepting a
single \f[CR]executor\f[R] function that can be called with the
\f[CR]resolve\f[R] and \f[CR]reject\f[R] callbacks as parameters.
.SH EXAMPLES
.SS Transforming a stream to an async iterable
The use case of \f[CR]Promise.withResolvers()\f[R] is when you have a
promise that should be resolved or rejected by some event listener that
cannot be wrapped inside the promise executor.
The following example transforms a Node.js \c
.UR https://nodejs.org/api/stream.html#class-streamreadable
readable stream
.UE \c
\ to an async iterable.
Each \f[CR]promise\f[R] here represents a single batch of data
available, and each time the current batch is read, a new promise is
created for the next batch.
Note how the event listeners are only attached once, but actually call a
different version of the \f[CR]resolve\f[R] and \f[CR]reject\f[R]
functions each time.
.IP
.EX
\f[B]async\f[R] \f[B]function\f[R]* readableToAsyncIterable(stream) {
  \f[B]let\f[R] { promise, resolve, reject } = Promise.withResolvers();
  stream.on(\[dq]error\[dq], (error) \f[B]=>\f[R] reject(error));
  stream.on(\[dq]end\[dq], () \f[B]=>\f[R] resolve());
  stream.on(\[dq]readable\[dq], () \f[B]=>\f[R] resolve());

  \f[B]while\f[R] (stream.readable) {
    \f[B]await\f[R] promise;
    \f[B]let\f[R] chunk;
    \f[B]while\f[R] ((chunk = stream.read())) {
      \f[B]yield\f[R] chunk;
    }
    ({ promise, resolve, reject } = Promise.withResolvers());
  }
}
.EE
.SS Calling withResolvers() on a non\-Promise constructor
\f[CR]Promise.withResolvers()\f[R] is a generic method.
It can be called on any constructor that implements the same signature
as the \f[CR]Promise()\f[R] constructor.
For example, we can call it on a constructor that passes
\f[CR]console.log\f[R] as the \f[CR]resolve\f[R] and \f[CR]reject\f[R]
functions to \f[CR]executor\f[R]:
.IP
.EX
\f[B]class\f[R] NotPromise {
  constructor(executor) {
    \f[I]// The \[dq]resolve\[dq] and \[dq]reject\[dq] functions behave nothing like the native\f[R]
    \f[I]// promise\[aq]s, but Promise.withResolvers() just returns them, as is.\f[R]
    executor(
      (value) \f[B]=>\f[R] console.log(\[dq]Resolved\[dq], value),
      (reason) \f[B]=>\f[R] console.log(\[dq]Rejected\[dq], reason),
    );
  }
}

\f[B]const\f[R] { promise, resolve, reject } = Promise.withResolvers.call(NotPromise);
resolve(\[dq]hello\[dq]);
\f[I]// Logs: Resolved hello\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#promisewithresolvers
Polyfill of \f[CR]Promise.withResolvers\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Using promises guide
.IP \[bu] 2
\f[CR]Promise\f[R]
.IP \[bu] 2
\f[CR]Promise()\f[R] constructor
