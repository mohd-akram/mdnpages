.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Atomics.wait" "JS" "July 26, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Atomics.wait \- Atomics.wait()
.SH SYNOPSIS
The \f[B]\f[CB]Atomics.wait()\f[B]\f[R] static method verifies that a
shared memory location still contains a given value and if so sleeps,
awaiting a wake\-up notification or times out.
It returns a string which is either \f[CR]\[dq]ok\[dq]\f[R],
\f[CR]\[dq]not\-equal\[dq]\f[R], or \f[CR]\[dq]timed\-out\[dq]\f[R].
.RS
.PP
\f[B]Note:\f[R] This operation only works with an \f[CR]Int32Array\f[R]
or \f[CR]BigInt64Array\f[R] that views a \f[CR]SharedArrayBuffer\f[R],
and may not be allowed on the main thread.
For a non\-blocking, asynchronous version of this method, see
\f[CR]Atomics.waitAsync()\f[R].
.RE
.SH SYNTAX
.IP
.EX
Atomics.wait(typedArray, index, value)
Atomics.wait(typedArray, index, value, timeout)
.EE
.SS Parameters
.TP
\f[B]typedArray\f[R]
An \f[CR]Int32Array\f[R] or \f[CR]BigInt64Array\f[R] that views a
\f[CR]SharedArrayBuffer\f[R].
.TP
\f[B]index\f[R]
The position in the \f[CR]typedArray\f[R] to wait on.
.TP
\f[B]value\f[R]
The expected value to test.
.TP
\f[B]timeout\f[R] \f[I](optional)\f[R]
Time to wait in milliseconds.
\f[CR]NaN\f[R] (and values that get converted to \f[CR]NaN\f[R], such as
\f[CR]undefined\f[R]) becomes \f[CR]Infinity\f[R].
Negative values become \f[CR]0\f[R].
.SS Return value
A string which is either \f[CR]\[dq]ok\[dq]\f[R],
\f[CR]\[dq]not\-equal\[dq]\f[R], or \f[CR]\[dq]timed\-out\[dq]\f[R].
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown in one of the following cases:
.RS
.IP \[bu] 2
If \f[CR]typedArray\f[R] is not an \f[CR]Int32Array\f[R] or
\f[CR]BigInt64Array\f[R] that views a \f[CR]SharedArrayBuffer\f[R].
.IP \[bu] 2
If the current thread cannot be blocked (for example, because it\[cq]s
the main thread).
.RE
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]index\f[R] is out of bounds in the
\f[CR]typedArray\f[R].
.SH EXAMPLES
.SS Using wait()
Given a shared \f[CR]Int32Array\f[R]:
.IP
.EX
\f[B]const\f[R] sab = \f[B]new\f[R] SharedArrayBuffer(1024);
\f[B]const\f[R] int32 = \f[B]new\f[R] Int32Array(sab);
.EE
.PP
A reading thread is sleeping and waiting on location 0 which is expected
to be 0.
As long as that is true, it will not go on.
However, once the writing thread has stored a new value, it will be
notified by the writing thread and return the new value (123).
.IP
.EX
Atomics.wait(int32, 0, 0);
console.log(int32[0]); \f[I]// 123\f[R]
.EE
.PP
A writing thread stores a new value and notifies the waiting thread once
it has written:
.IP
.EX
console.log(int32[0]); \f[I]// 0;\f[R]
Atomics.store(int32, 0, 123);
Atomics.notify(int32, 0, 1);
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Atomics\f[R]
.IP \[bu] 2
\f[CR]Atomics.waitAsync()\f[R]
.IP \[bu] 2
\f[CR]Atomics.notify()\f[R]
