.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "ATOMICS.WAIT" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Atomics.wait \- Atomics.wait()
.SH SYNOPSIS
The \f[B]\f[CB]Atomics.wait()\f[B]\f[R] static method verifies that a
shared memory location contains a given value and if so sleeps, awaiting
a wake\-up notification or a time out.
It returns a string which is \f[CR]\(dqnot\-equal\(dq\f[R] if the memory
location does not match the given value, \f[CR]\(dqok\(dq\f[R] if woken
by \f[CR]Atomics.notify()\f[R], or \f[CR]\(dqtimed\-out\(dq\f[R] if the
timeout expires.
.PP
\f[CR]Atomics.wait()\f[R] and \f[CR]Atomics.notify()\f[R] are used
together to enable thread synchronization based on a value in shared
memory.
A thread can proceed immediately if the synchronization value has
changed, or it can wait for notification from another thread when it
reaches the synchronization point.
.PP
This method only works with an \f[CR]Int32Array\f[R] or
\f[CR]BigInt64Array\f[R] that views a \f[CR]SharedArrayBuffer\f[R].
It is blocking and cannot be used in the main thread.
For a non\-blocking, asynchronous version of this method, see
\f[CR]Atomics.waitAsync()\f[R].
.SH SYNTAX
.IP
.EX
Atomics.wait(typedArray, index, value)
Atomics.wait(typedArray, index, value, timeout)
.EE
.SS Parameters
.TP
\f[B]typedArray\f[R]
An \f[CR]Int32Array\f[R] or \f[CR]BigInt64Array\f[R] that views a
\f[CR]SharedArrayBuffer\f[R].
.TP
\f[B]index\f[R]
The position in the \f[CR]typedArray\f[R] to wait on.
.TP
\f[B]value\f[R]
The expected value to test.
.TP
\f[B]timeout\f[R] \f[I](optional)\f[R]
Time to wait in milliseconds.
\f[CR]NaN\f[R] (and values that get converted to \f[CR]NaN\f[R], such as
\f[CR]undefined\f[R]) becomes \f[CR]Infinity\f[R].
Negative values become \f[CR]0\f[R].
.SS Return value
A string which is either \f[CR]\(dqnot\-equal\(dq\f[R],
\f[CR]\(dqok\(dq\f[R], or \f[CR]\(dqtimed\-out\(dq\f[R].
.IP \(bu 2
\f[CR]\(dqnot\-equal\(dq\f[R] is returned immediately if the initial
\f[CR]value\f[R] does not equal what is stored at \f[CR]index\f[R].
.IP \(bu 2
\f[CR]\(dqok\(dq\f[R] is returned if woken up by a call to
\f[CR]Atomics.notify()\f[R], \f[B]regardless of whether the expected
value has changed\f[R].
.IP \(bu 2
\f[CR]\(dqtimed\-out\(dq\f[R] is returned if a sleeping wait exceeds the
specified \f[CR]timeout\f[R] without being woken up by
\f[CR]Atomics.notify()\f[R].
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown in one of the following cases:
.RS
.IP \(bu 2
If \f[CR]typedArray\f[R] is not an \f[CR]Int32Array\f[R] or
\f[CR]BigInt64Array\f[R] that views a \f[CR]SharedArrayBuffer\f[R].
.IP \(bu 2
If the current thread cannot be blocked (for example, because it\(cqs
the main thread).
.RE
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]index\f[R] is out of bounds in the
\f[CR]typedArray\f[R].
.SH EXAMPLES
.SS Using wait()
Given a shared \f[CR]Int32Array\f[R]:
.IP
.EX
\f[B]const\f[R] sab = \f[B]new\f[R] SharedArrayBuffer(1024);
\f[B]const\f[R] int32 = \f[B]new\f[R] Int32Array(sab);
.EE
.PP
A reading thread is sleeping and waiting on location 0 because the
provided \f[CR]value\f[R] matches what is stored at the provided
\f[CR]index\f[R].
The reading thread will not move on until the writing thread has called
\f[CR]Atomics.notify()\f[R] on position 0 of the provided
\f[CR]typedArray\f[R].
Note that if, after being woken up, the value of location 0 has not been
changed by the writing thread, the reading thread will \f[B]not\f[R] go
back to sleep, but will continue on.
.IP
.EX
Atomics.wait(int32, 0, 0);
console.log(int32[0]); \f[I]// 123\f[R]
.EE
.PP
A writing thread stores a new value and notifies the waiting thread once
it has written:
.IP
.EX
console.log(int32[0]); \f[I]// 0;\f[R]
Atomics.store(int32, 0, 123);
Atomics.notify(int32, 0, 1);
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Atomics\f[R]
.IP \(bu 2
\f[CR]Atomics.waitAsync()\f[R]
.IP \(bu 2
\f[CR]Atomics.notify()\f[R]
