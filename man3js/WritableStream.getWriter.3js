.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "WritableStream.getWriter" "JS" "April 22, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
WritableStream.getWriter \- WritableStream: getWriter() method
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]getWriter()\f[B]\f[R] method of the
\f[CR]WritableStream\f[R] interface returns a new instance of
\f[CR]WritableStreamDefaultWriter\f[R] and locks the stream to that
instance.
While the stream is locked, no other writer can be acquired until this
one is released.
.SH SYNTAX
.IP
.EX
getWriter()
.EE
.SS Parameters
None.
.SS Return value
A \f[CR]WritableStreamDefaultWriter\f[R] object instance.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
The stream you are trying to create a writer for is not a
\f[CR]WritableStream\f[R] or it is already locked to another writer.
.SH EXAMPLES
The following example illustrates several features of this interface.
It shows the creation of the \f[CR]WritableStream\f[R] with a custom
sink and an API\-supplied queuing strategy.
t then calls a function called \f[CR]sendMessage()\f[R], passing the
newly created stream and a string.
Inside this function it calls the stream\[cq]s \f[CR]getWriter()\f[R]
method, which returns an instance of
\f[CR]WritableStreamDefaultWriter\f[R].
A \f[CR]forEach()\f[R] call is used to write each chunk of the string to
the stream.
Finally, \f[CR]write()\f[R] and \f[CR]close()\f[R] return promises that
are processed to deal with success or failure of chunks and streams.
.IP
.EX
\f[B]const\f[R] list = document.querySelector(\[dq]ul\[dq]);

\f[B]function\f[R] sendMessage(message, writableStream) {
  \f[I]// defaultWriter is of type WritableStreamDefaultWriter\f[R]
  \f[B]const\f[R] defaultWriter = writableStream.getWriter();
  \f[B]const\f[R] encoder = \f[B]new\f[R] TextEncoder();
  \f[B]const\f[R] encoded = encoder.encode(message, { stream: \f[B]true\f[R] });
  encoded.forEach((chunk) \f[B]=>\f[R] {
    defaultWriter.ready
      .then(() \f[B]=>\f[R] defaultWriter.write(chunk))
      .then(() \f[B]=>\f[R] {
        console.log(\[dq]Chunk written to sink.\[dq]);
      })
      .catch((err) \f[B]=>\f[R] {
        console.log(\[dq]Chunk error:\[dq], err);
      });
  });
  \f[I]// Call ready again to ensure that all chunks are written\f[R]
  \f[I]//   before closing the writer.\f[R]
  defaultWriter.ready
    .then(() \f[B]=>\f[R] {
      defaultWriter.close();
    })
    .then(() \f[B]=>\f[R] {
      console.log(\[dq]All chunks written\[dq]);
    })
    .catch((err) \f[B]=>\f[R] {
      console.log(\[dq]Stream error:\[dq], err);
    });
}

\f[B]const\f[R] decoder = \f[B]new\f[R] TextDecoder(\[dq]utf\-8\[dq]);
\f[B]const\f[R] queuingStrategy = \f[B]new\f[R] CountQueuingStrategy({ highWaterMark: 1 });
\f[B]let\f[R] result = \[dq]\[dq];
\f[B]const\f[R] writableStream = \f[B]new\f[R] WritableStream(
  {
    \f[I]// Implement the sink\f[R]
    write(chunk) {
      \f[B]return\f[R] \f[B]new\f[R] Promise((resolve, reject) \f[B]=>\f[R] {
        \f[B]const\f[R] buffer = \f[B]new\f[R] ArrayBuffer(1);
        \f[B]const\f[R] view = \f[B]new\f[R] Uint8Array(buffer);
        view[0] = chunk;
        \f[B]const\f[R] decoded = decoder.decode(view, { stream: \f[B]true\f[R] });
        \f[B]const\f[R] listItem = document.createElement(\[dq]li\[dq]);
        listItem.textContent = \[ga]Chunk decoded: ${decoded}\[ga];
        list.appendChild(listItem);
        result += decoded;
        resolve();
      });
    },
    close() {
      \f[B]const\f[R] listItem = document.createElement(\[dq]li\[dq]);
      listItem.textContent = \[ga][MESSAGE RECEIVED] ${result}\[ga];
      list.appendChild(listItem);
    },
    abort(err) {
      console.log(\[dq]Sink error:\[dq], err);
    },
  },
  queuingStrategy,
);

sendMessage(\[dq]Hello, world.\[dq], writableStream);
.EE
.PP
You can find the full code in our \c
.UR https://mdn.github.io/dom-examples/streams/simple-writer/
Simple writer example
.UE \c
\&.
