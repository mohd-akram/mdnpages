.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "PerformanceObserver.PerformanceObserver" "JS" "October 12, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
PerformanceObserver.PerformanceObserver \- PerformanceObserver:
PerformanceObserver() constructor
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
The \f[B]\f[CB]PerformanceObserver()\f[B]\f[R] constructor creates a new
\f[CR]PerformanceObserver\f[R] object with the given observer
\f[CR]callback\f[R].
The observer callback is invoked when performance entry events are
recorded for the entry types that have been registered, via the
\f[CR]observe()\f[R] method.
.SH SYNTAX
.IP
.EX
new PerformanceObserver(callback)
.EE
.SS Parameters
.TP
\f[B]callback\f[R]
A \f[CR]PerformanceObserverCallback\f[R] callback that will be invoked
when observed performance events are recorded.
When the callback is invoked, the following parameters are available:
.RS
.TP
\f[B]entries\f[R]
The list of performance observer entries.
.TP
\f[B]observer\f[R]
The \f[CR]observer\f[R] object that is receiving the above entries.
.TP
\f[B]options\f[R]
An object with the following properties:
.RS
.TP
\f[B]droppedEntriesCount\f[R]
The number of entries which could not be recorded because the
\f[CR]Performance\f[R] object\[cq]s internal buffer was full.
.RS
.PP
Note that this is only provided the first time the observer calls the
callback, when the buffered entries are replayed.
Once the observer starts making future observations, it no longer needs
to use the buffer.
After the first time, \f[CR]options\f[R] will be an empty object
(\f[CR]{}\f[R]).
.RE
.RE
.RE
.SS Return value
A new \f[CR]PerformanceObserver\f[R] object which will call the
specified \f[CR]callback\f[R] when observed performance events occur.
.SH EXAMPLES
.SS Creating a PerformanceObserver
The following example creates a \f[CR]PerformanceObserver\f[R] watching
for \[lq]mark\[rq] (\f[CR]PerformanceMark\f[R]) and \[lq]measure\[rq]
(\f[CR]PerformanceMeasure\f[R]) events.
The \f[CR]perfObserver\f[R] callback provides a \f[CR]list\f[R]
(\f[CR]PerformanceObserverEntryList\f[R]) which allows you get observed
performance entries.
.IP
.EX
\f[B]function\f[R] perfObserver(list, observer) {
  list.getEntries().forEach((entry) \f[B]=>\f[R] {
    \f[B]if\f[R] (entry.entryType === \[dq]mark\[dq]) {
      console.log(\[ga]${entry.name}\[aq]s startTime: ${entry.startTime}\[ga]);
    }
    \f[B]if\f[R] (entry.entryType === \[dq]measure\[dq]) {
      console.log(\[ga]${entry.name}\[aq]s duration: ${entry.duration}\[ga]);
    }
  });
}
\f[B]const\f[R] observer = \f[B]new\f[R] PerformanceObserver(perfObserver);
observer.observe({ entryTypes: [\[dq]measure\[dq], \[dq]mark\[dq]] });
.EE
.SS Dropped buffer entries
You can use \f[CR]PerformanceObserver\f[R] with a \f[CR]buffered\f[R]
flag to listen to past performance entries.
There is a buffer size limit, though.
The performance observer callback contains an \f[CR]options\f[R] object:
the first time the observer calls the callback, the \f[CR]options\f[R]
parameter will have a \f[CR]droppedEntriesCount\f[R] property that tells
you how many entries were dropped due to the buffer storage being full.
Subsequent callbacks will have an empty \f[CR]options\f[R] parameter.
.IP
.EX
\f[B]function\f[R] perfObserver(list, observer, options) {
  list.getEntries().forEach((entry) \f[B]=>\f[R] {
    \f[I]// do something with the entries\f[R]
  });
  \f[B]if\f[R] (options?.droppedEntriesCount > 0) {
    console.warn(
      \[ga]${options?.droppedEntriesCount} entries got dropped due to the buffer being full.\[ga],
    );
  }
}

\f[B]const\f[R] observer = \f[B]new\f[R] PerformanceObserver(perfObserver);
observer.observe({ type: \[dq]resource\[dq], buffered: \f[B]true\f[R] });
.EE
.PP
Usually, there are a lot of resource timing entries, and for these
entries specifically, you can also set a larger buffer using
\f[CR]performance.setResourceTimingBufferSize()\f[R] and watch for the
\f[CR]resourcetimingbufferfull\f[R] event.
