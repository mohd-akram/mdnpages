.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "PerformanceObserver.PerformanceObserver" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
PerformanceObserver.PerformanceObserver \- PerformanceObserver:
PerformanceObserver() constructor
.SH SYNOPSIS
The \f[B]\f[CB]PerformanceObserver()\f[B]\f[R] constructor creates a new
\f[CR]PerformanceObserver\f[R] object with the given observer
\f[CR]callback\f[R].
The observer callback is invoked when performance entry events are
recorded for the entry types that have been registered, via the
\f[CR]observe()\f[R] method.
.SH SYNTAX
.IP
.EX
new PerformanceObserver(callback)
.EE
.SS Parameters
.TP
\f[B]callback\f[R]
A \f[CR]PerformanceObserverCallback\f[R] callback that will be invoked
when observed performance events are recorded.
When the callback is invoked, the following parameters are available:
.RS
.TP
\f[B]entries\f[R]
The list of performance observer entries.
.TP
\f[B]observer\f[R]
The \f[CR]observer\f[R] object that is receiving the above entries.
.TP
\f[B]droppedEntriesCount\f[R] \f[I](optional)\f[R]
The number of buffered entries which got dropped from the buffer due to
the buffer being full.
See the \f[CR]buffered\f[R] flag.
.RE
.SS Return value
A new \f[CR]PerformanceObserver\f[R] object which will call the
specified \f[CR]callback\f[R] when observed performance events occur.
.SH EXAMPLES
.SS Creating a PerformanceObserver
The following example creates a \f[CR]PerformanceObserver\f[R] watching
for \[lq]mark\[rq] (\f[CR]PerformanceMark\f[R]) and \[lq]measure\[rq]
(\f[CR]PerformanceMeasure\f[R]) events.
The \f[CR]perfObserver\f[R] callback provides a \f[CR]list\f[R]
(\f[CR]PerformanceObserverEntryList\f[R]) which allows you get observed
performance entries.
.IP
.EX
\f[B]function\f[R] perfObserver(list, observer) {
  list.getEntries().forEach((entry) \f[B]=>\f[R] {
    \f[B]if\f[R] (entry.entryType === \[dq]mark\[dq]) {
      console.log(\[ga]${entry.name}\[aq]s startTime: ${entry.startTime}\[ga]);
    }
    \f[B]if\f[R] (entry.entryType === \[dq]measure\[dq]) {
      console.log(\[ga]${entry.name}\[aq]s duration: ${entry.duration}\[ga]);
    }
  });
}
\f[B]const\f[R] observer = \f[B]new\f[R] PerformanceObserver(perfObserver);
observer.observe({ entryTypes: [\[dq]measure\[dq], \[dq]mark\[dq]] });
.EE
.SS Dropped buffer entries
You can use \f[CR]PerformanceObserver\f[R] with a \f[CR]buffered\f[R]
flag to listen to past performance entries.
There is a buffer size limit, though.
The performance observer callback contains an optional
\f[CR]droppedEntriesCount\f[R] parameter that informs you about the
amount of lost entries due to the buffer storage being full.
.IP
.EX
\f[B]function\f[R] perfObserver(list, observer, droppedEntriesCount) {
  list.getEntries().forEach((entry) \f[B]=>\f[R] {
    \f[I]// do something with the entries\f[R]
  });
  \f[B]if\f[R] (droppedEntriesCount > 0) {
    console.warn(
      \[ga]${droppedEntriesCount} entries got dropped due to the buffer being full.\[ga],
    );
  }
}
\f[B]const\f[R] observer = \f[B]new\f[R] PerformanceObserver(perfObserver);
observer.observe({ type: \[dq]resource\[dq], buffered: \f[B]true\f[R] });
.EE
.PP
Usually, there are a lot of resource timing entries, and for these
entries specifically, you can also set a larger buffer using
\f[CR]performance.setResourceTimingBufferSize()\f[R] and watch for the
\f[CR]resourcetimingbufferfull\f[R] event.
