.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "AudioBufferSourceNode.buffer" "JS" "March 12, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
AudioBufferSourceNode.buffer \- AudioBufferSourceNode: buffer property
.SH SYNOPSIS
The \f[B]\f[CB]buffer\f[B]\f[R] property of the
\f[CR]AudioBufferSourceNode\f[R] interface provides the ability to play
back audio using an \f[CR]AudioBuffer\f[R] as the source of the sound
data.
.PP
If the \f[CR]buffer\f[R] property is set to the value \f[CR]null\f[R],
the node generates a single channel containing silence (that is, every
sample is 0).
.SH VALUE
An \f[CR]AudioBuffer\f[R] which contains the data representing the sound
which the node will play.
.SH EXAMPLES
.RS
.PP
\f[B]Note:\f[R] For a full working example, see \c
.UR https://mdn.github.io/webaudio-examples/audio-buffer/
this code running live
.UE \c
, or \c
.UR https://github.com/mdn/webaudio-examples/blob/main/audio-buffer/index.html
view the source
.UE \c
\&.
.RE
.IP
.EX
\f[B]const\f[R] myArrayBuffer = audioCtx.createBuffer(2, frameCount, audioCtx.sampleRate);

button.onclick = () \f[B]=>\f[R] {
  \f[I]// Fill the buffer with white noise;\f[R]
  \f[I]//just random values between \-1.0 and 1.0\f[R]
  \f[B]for\f[R] (\f[B]let\f[R] channel = 0; channel < channels; channel++) {
    \f[I]// This gives us the actual ArrayBuffer that contains the data\f[R]
    \f[B]const\f[R] nowBuffering = myArrayBuffer.getChannelData(channel);
    \f[B]for\f[R] (\f[B]let\f[R] i = 0; i < frameCount; i++) {
      \f[I]// Math.random() is in [0; 1.0]\f[R]
      \f[I]// audio needs to be in [\-1.0; 1.0]\f[R]
      nowBuffering[i] = Math.random() * 2 \- 1;
    }
  }

  \f[I]// Get an AudioBufferSourceNode.\f[R]
  \f[I]// This is the AudioNode to use when we want to play an AudioBuffer\f[R]
  \f[B]const\f[R] source = audioCtx.createBufferSource();
  \f[I]// set the buffer in the AudioBufferSourceNode\f[R]
  source.buffer = myArrayBuffer;
};
.EE
.SH SEE ALSO
.IP \[bu] 2
Using the Web Audio API
.IP \[bu] 2
Web Audio API
