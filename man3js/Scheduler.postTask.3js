.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Scheduler.postTask" "JS" "May 17, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Scheduler.postTask \- Scheduler: postTask() method
.SH SYNOPSIS
The \f[B]\f[CB]postTask()\f[B]\f[R] method of the \f[CR]Scheduler\f[R]
interface is used for adding tasks to be scheduled according to their
priority.
.PP
The method allows users to optionally specify a minimum delay before the
task will run, a priority for the task, and a signal that can be used to
modify the task priority and/or abort the task.
It returns a promise that is resolved with the result of the task
callback function, or rejected with the abort reason or an error thrown
in the task.
.PP
Task priority can be mutable or immutable.
If the task priority will never need to change then it should be set
using the \f[CR]options.priority\f[R] parameter (any priority set
through a signal will then be ignored).
You can still pass an \f[CR]AbortSignal\f[R] (which has no priority) or
\f[CR]TaskSignal\f[R] to the \f[CR]options.signal\f[R] parameter for
aborting the task.
.PP
If the task priority might need to be changed the
\f[CR]options.priority\f[R] parameter must not be set.
Instead a \f[CR]TaskController\f[R] should be created and its
\f[CR]TaskSignal\f[R] should be passed to \f[CR]options.signal\f[R].
The task priority will be initialized from the signal priority, and can
later be modified using the signal\[cq]s associated
\f[CR]TaskController\f[R].
.PP
If no priority is set then the task priority defaults to
\f[CR]\[dq]user\-visible\[dq]\f[R].
.PP
If a delay is specified and greater than 0, then the execution of the
task will be delayed for at least that many milliseconds.
Otherwise the task is immediately scheduled for prioritization.
.SH SYNTAX
.IP
.EX
postTask(callback)
postTask(callback, options)
.EE
.SS Parameters
.TP
\f[B]callback\f[R]
An callback function that implements the task.
The return value of the callback is used to resolve the promise returned
by this function.
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
Task options, including:
.RS
.TP
\f[B]priority\f[R] \f[I](optional)\f[R]
The immutable priority of the task.
One of: \f[CR]\[dq]user\-blocking\[dq]\f[R],
\f[CR]\[dq]user\-visible\[dq]\f[R], \f[CR]\[dq]background\[dq]\f[R].
If set, this priority is used for the lifetime of the task and priority
set on the \f[CR]signal\f[R] is ignored.
.TP
\f[B]signal\f[R] \f[I](optional)\f[R]
A \f[CR]TaskSignal\f[R] or \f[CR]AbortSignal\f[R] that can be used to
abort the task (from its associated controller).
.RS
.PP
If the \f[CR]options.priority\f[R] parameter is set then the task
priority cannot be changed, and any priority on the signal is ignored.
Otherwise, if the signal is a \f[CR]TaskSignal\f[R] its priority is used
to set the initial task priority, and the signal\[cq]s controller may
later use it to change the task priority.
.RE
.TP
\f[B]delay\f[R] \f[I](optional)\f[R]
The minimum amount of time after which the task will be added to the
scheduler queue, in whole milliseconds.
The actual delay may be higher than specified, but will not be less.
The default delay is 0.
.RE
.SS Return Value
Returns a \f[CR]Promise\f[R] that is resolved with the return value of
the \f[CR]callback\f[R] function, or which may be rejected with the
\f[CR]signal\f[R]\[cq]s abort reason (\f[CR]AbortSignal.reason\f[R]).
The promise may also be rejected with an error thrown by the callback
during execution.
.SH EXAMPLES
The following examples are slightly simplified versions of the live
examples provided in Prioritized Task Scheduling API > Examples.
.SS Feature checking
Check whether prioritized task scheduling is supported by testing for
the \f[CR]scheduler\f[R] property in the global
\[lq]\f[CR]this\f[R]\[rq] (such as \f[CR]Window.scheduler\f[R] in
window\[cq]s scope or \f[CR]WorkerGlobalScope.scheduler\f[R] in
worker\[cq]s scope).
.PP
For example, the code below logs \[lq]Feature: Supported\[rq] if the API
is supported on this browser.
.IP
.EX
\f[I]// Check that feature is supported\f[R]
\f[B]if\f[R] (\[dq]scheduler\[dq] \f[B]in\f[R] \f[B]this\f[R]) {
  console.log(\[dq]Feature: Supported\[dq]);
} \f[B]else\f[R] {
  console.error(\[dq]Feature: NOT Supported\[dq]);
}
.EE
.SS Basic usage
Tasks are posted specifying a callback function (task) in the first
argument, and an optional second argument that can be used to specify a
task priority, signal, and/or delay.
The method returns a \f[CR]Promise\f[R] that resolves with the return
value of the callback function, or rejects with either an abort error or
an error thrown in the function.
.PP
Because it returns a promise, \f[CR]postTask()\f[R] can be chained with
other promises.
Below we show how to wait on the promise to resolve using
\f[CR]then\f[R] or reject using \f[CR]catch\f[R].
The priority is not specified, so the default priority of
\f[CR]user\-visible\f[R] will be used.
.IP
.EX
\f[I]// A function that defines a task\f[R]
\f[B]function\f[R] myTask() {
  \f[B]return\f[R] \[dq]Task 1: user\-visible\[dq];
}

\f[I]// Post task with default priority: \[aq]user\-visible\[aq] (no other options)\f[R]
\f[I]// When the task resolves, Promise.then() logs the result.\f[R]
scheduler
  .postTask(myTask, { signal: abortTaskController.signal })
  .then((taskResult) \f[B]=>\f[R] console.log(\[ga]${taskResult}\[ga])) \f[I]// Log resolved value\f[R]
  .catch((error) \f[B]=>\f[R] console.error(\[dq]Error:\[dq], error)); \f[I]// Log error or abort\f[R]
.EE
.PP
The method can also be used with \f[CR]await\f[R] inside an async
function.
The code below shows how you might use this approach to wait on a
\f[CR]user\-blocking\f[R] task.
.IP
.EX
\f[B]function\f[R] myTask2() {
  \f[B]return\f[R] \[dq]Task 2: user\-blocking\[dq];
}

\f[B]async\f[R] \f[B]function\f[R] runTask2() {
  \f[B]const\f[R] result = \f[B]await\f[R] scheduler.postTask(myTask2, {
    priority: \[dq]user\-blocking\[dq],
  });
  console.log(result); \f[I]// \[aq]Task 2: user\-blocking\[aq].\f[R]
}
runTask2();
.EE
.SS Permanent priorities
Task priorities may be set using \f[CR]priority\f[R] parameter in the
optional second argument.
Priorities that are set in this way cannot be changed (are immutable).
.PP
Below we post two groups of three tasks, each member in reverse order of
priority.
The final task has the default priority.
When run, each task simply logs it\[cq]s expected order (we\[cq]re not
waiting on the result because we don\[cq]t need to in order to show
execution order).
.IP
.EX
\f[I]// three tasks, in reverse order of priority\f[R]
scheduler.postTask(() \f[B]=>\f[R] console.log(\[dq]bckg 1\[dq]), { priority: \[dq]background\[dq] });
scheduler.postTask(() \f[B]=>\f[R] console.log(\[dq]usr\-vis 1\[dq]), {
  priority: \[dq]user\-visible\[dq],
});
scheduler.postTask(() \f[B]=>\f[R] console.log(\[dq]usr\-blk 1\[dq]), {
  priority: \[dq]user\-blocking\[dq],
});

\f[I]// three more tasks, in reverse order of priority\f[R]
scheduler.postTask(() \f[B]=>\f[R] console.log(\[dq]bckg 2\[dq]), { priority: \[dq]background\[dq] });
scheduler.postTask(() \f[B]=>\f[R] console.log(\[dq]usr\-vis 2\[dq]), {
  priority: \[dq]user\-visible\[dq],
});
scheduler.postTask(() \f[B]=>\f[R] console.log(\[dq]usr\-blk 2\[dq]), {
  priority: \[dq]user\-blocking\[dq],
});

\f[I]// Task with default priority: user\-visible\f[R]
scheduler.postTask(() \f[B]=>\f[R] {
  console.log(\[dq]usr\-vis 3 (default)\[dq]);
});
.EE
.PP
The expected output is shown below: tasks are executed in priority
order, and then declaration order.
.IP
.EX
usr\-blk 1
usr\-blk 2
usr\-vis 1
usr\-vis 2
usr\-vis 3 (default)
bckg 1
bckg 2
.EE
.SS Changing task priorities
Task priorities can also take their initial value from a
\f[CR]TaskSignal\f[R] passed to \f[CR]postTask()\f[R] in the optional
second argument.
If set in this way, the priority of the task can then be changed using
the controller associated with the signal.
.RS
.PP
\f[B]Note:\f[R] Setting and changing task priorities using a signal only
works when the \f[CR]options.priority\f[R] argument to
\f[CR]postTask()\f[R] is not set, and when the \f[CR]options.signal\f[R]
is a \f[CR]TaskSignal\f[R] (and not an \f[CR]AbortSignal\f[R]).
.RE
.PP
The code below first shows how to create a \f[CR]TaskController\f[R],
setting the initial priority of its signal to \f[CR]user\-blocking\f[R]
in the \f[CR]TaskController()\f[R] constructor.
.PP
We then use \f[CR]addEventListener()\f[R] to add an event listener to
the controller\[cq]s signal (we could alternatively use the
\f[CR]TaskSignal.onprioritychange\f[R] property to add an event
handler).
The event handler uses \f[CR]previousPriority\f[R] on the event to get
the original priority and \f[CR]TaskSignal.priority\f[R] on the event
target to get the new/current priority.
.IP
.EX
\f[I]// Create a TaskController, setting its signal priority to \[aq]user\-blocking\[aq]\f[R]
\f[B]const\f[R] controller = \f[B]new\f[R] TaskController({ priority: \[dq]user\-blocking\[dq] });

\f[I]// Listen for \[aq]prioritychange\[aq] events on the controller\[aq]s signal.\f[R]
controller.signal.addEventListener(\[dq]prioritychange\[dq], (event) \f[B]=>\f[R] {
  \f[B]const\f[R] previousPriority = event.previousPriority;
  \f[B]const\f[R] newPriority = event.target.priority;
  console.log(\[ga]Priority changed from ${previousPriority} to ${newPriority}.\[ga]);
});
.EE
.PP
Finally, the task is posted, passing in the signal, and then we
immediately change the priority to \f[CR]background\f[R] by calling
\f[CR]TaskController.setPriority()\f[R] on the controller.
.IP
.EX
\f[I]// Post task using the controller\[aq]s signal.\f[R]
\f[I]// The signal priority sets the initial priority of the task\f[R]
scheduler.postTask(() \f[B]=>\f[R] console.log(\[dq]Task 1\[dq]), { signal: controller.signal });

\f[I]// Change the priority to \[aq]background\[aq] using the controller\f[R]
controller.setPriority(\[dq]background\[dq]);
.EE
.PP
The expected output is shown below.
Note that in this case the priority is changed before the task is
executed, but it could equally have been changed while the task was
running.
.IP
.EX
\f[I]// Expected output\f[R]
\f[I]// Priority changed from user\-blocking to background.\f[R]
\f[I]// Task 1\f[R]
.EE
.SS Aborting tasks
Tasks can be aborted using either \f[CR]TaskController\f[R] and
\f[CR]AbortController\f[R], in exactly the same way.
The only difference is that you must use \f[CR]TaskController\f[R] if
you also want to set the task priority.
.PP
The code below creates a controller and passes its signal to the task.
The task is then immediately aborted.
This causes the promise to be rejected with an \f[CR]AbortError\f[R],
which is caught in the \f[CR]catch\f[R] block and logged.
Note that we could also have listened for the \f[CR]abort\f[R] event
fired on the \f[CR]TaskSignal\f[R] or \f[CR]AbortSignal\f[R] and logged
the abort there.
.IP
.EX
\f[I]// Declare a TaskController with default priority\f[R]
\f[B]const\f[R] abortTaskController = \f[B]new\f[R] TaskController();
\f[I]// Post task passing the controller\[aq]s signal\f[R]
scheduler
  .postTask(() \f[B]=>\f[R] console.log(\[dq]Task executing\[dq]), {
    signal: abortTaskController.signal,
  })
  .then((taskResult) \f[B]=>\f[R] console.log(\[ga]${taskResult}\[ga])) \f[I]//This won\[aq]t run!\f[R]
  .catch((error) \f[B]=>\f[R] console.error(\[dq]Error:\[dq], error)); \f[I]// Log the error\f[R]

\f[I]// Abort the task\f[R]
abortTaskController.abort();
.EE
.SS Delaying tasks
Tasks can be delayed by specifying an integer number of milliseconds in
the \f[CR]options.delay\f[R] parameter to \f[CR]postTask()\f[R].
This effectively adds the task to the prioritized queue on a timeout, as
might be created using \f[CR]setTimeout()\f[R].
The \f[CR]delay\f[R] is the minimum amount of time before the task is
added to the scheduler; it may be longer.
.PP
The code below shows two tasks added (as arrow functions) with a delay.
.IP
.EX
\f[I]// Post task as arrow function with delay of 2 seconds\f[R]
scheduler
  .postTask(() \f[B]=>\f[R] \[dq]Task delayed by 2000ms\[dq], { delay: 2000 })
  .then((taskResult) \f[B]=>\f[R] console.log(\[ga]${taskResult}\[ga]));
scheduler
  .postTask(() \f[B]=>\f[R] \[dq]Next task should complete in about 2000ms\[dq], { delay: 1 })
  .then((taskResult) \f[B]=>\f[R] console.log(\[ga]${taskResult}\[ga]));
.EE
