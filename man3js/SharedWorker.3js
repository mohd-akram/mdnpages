.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "SharedWorker" "JS" "January 21, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SharedWorker \- SharedWorker
.SH SYNOPSIS
The \f[B]\f[CB]SharedWorker\f[B]\f[R] interface represents a specific
kind of worker that can be \f[I]accessed\f[R] from several browsing
contexts, such as several windows, iframes or even workers.
They implement an interface different than dedicated workers and have a
different global scope, \f[CR]SharedWorkerGlobalScope\f[R].
.RS
.PP
\f[B]Note:\f[R] If SharedWorker can be accessed from several browsing
contexts, all those browsing contexts must share the exact same origin
(same protocol, host and port).
.RE
.SH CONSTRUCTORS
.TP
\f[B]SharedWorker()\f[R]
Creates a shared web worker that executes the script at the specified
URL.
.SH INSTANCE PROPERTIES
\f[I]Inherits properties from its parent, \f[CI]EventTarget\f[I].\f[R]
.TP
\f[B]SharedWorker.port\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]MessagePort\f[R] object used to communicate with and
control the shared worker.
.SH EVENTS
.TP
\f[B]error\f[R]
Fires when an error occurs in the shared worker.
.SH INSTANCE METHODS
\f[I]Inherits methods from its parent, \f[CI]EventTarget\f[I].\f[R]
.SH EXAMPLE
In our \c
.UR https://github.com/mdn/dom-examples/tree/main/web-workers/simple-shared-worker
Basic shared worker example
.UE \c
\ (\c
.UR https://mdn.github.io/dom-examples/web-workers/simple-shared-worker/
run shared worker
.UE \c
), we have two HTML pages, each of which uses some JavaScript to perform
a simple calculation.
The different scripts are using the same worker file to perform the
calculation \[em] they can both access it, even if their pages are
running inside different windows.
.PP
The following code snippet shows creation of a \f[CR]SharedWorker\f[R]
object using the \f[CR]SharedWorker()\f[R] constructor.
Both scripts contain this:
.IP
.EX
\f[B]const\f[R] myWorker = \f[B]new\f[R] SharedWorker(\[dq]worker.js\[dq]);
.EE
.RS
.PP
\f[B]Note:\f[R] Once a shared worker is created, any script running in
the same origin can obtain a reference to that worker and communicate
with it.
The shared worker will be alive as long as its global scope\[cq]s owner
set (a set of \f[CR]Document\f[R] and \f[CR]WorkerGlobalScope\f[R]
objects) is not empty (for example, if there is any live page holding a
reference to it, maybe through \f[CR]new SharedWorker()\f[R]).
To read more about shared worker lifetime, see \c
.UR https://html.spec.whatwg.org/multipage/workers.html#the-worker's-lifetime
The worker\[cq]s lifetime
.UE \c
\ section of the HTML specification.
.RE
.PP
Both scripts then access the worker through a \f[CR]MessagePort\f[R]
object created using the \f[CR]SharedWorker.port\f[R] property.
If the onmessage event is attached using addEventListener, the port is
manually started using its \f[CR]start()\f[R] method:
.IP
.EX
myWorker.port.start();
.EE
.PP
When the port is started, both scripts post messages to the worker and
handle messages sent from it using \f[CR]port.postMessage()\f[R] and
\f[CR]port.onmessage\f[R], respectively:
.RS
.PP
\f[B]Note:\f[R] You can use browser devtools to debug your SharedWorker,
by entering a URL in your browser address bar to access the devtools
workers inspector; for example, in Chrome, the URL
\f[CR]chrome://inspect/#workers\f[R], and in FireFox, the URL
\f[CR]about:debugging#workers\f[R].
.RE
.IP
.EX
first.onchange = () \f[B]=>\f[R] {
  myWorker.port.postMessage([first.value, second.value]);
  console.log(\[dq]Message posted to worker\[dq]);
};

second.onchange = () \f[B]=>\f[R] {
  myWorker.port.postMessage([first.value, second.value]);
  console.log(\[dq]Message posted to worker\[dq]);
};

myWorker.port.onmessage = (e) \f[B]=>\f[R] {
  result1.textContent = e.data;
  console.log(\[dq]Message received from worker\[dq]);
};
.EE
.PP
Inside the worker we use the \f[CR]onconnect\f[R] handler to connect to
the same port discussed above.
The ports associated with that worker are accessible in the
\f[CR]connect\f[R] event\[cq]s \f[CR]ports\f[R] property \[em] we then
use \f[CR]MessagePort\f[R] \f[CR]start()\f[R] method to start the port,
and the \f[CR]onmessage\f[R] handler to deal with messages sent from the
main threads.
.IP
.EX
onconnect = (e) \f[B]=>\f[R] {
  \f[B]const\f[R] port = e.ports[0];

  port.addEventListener(\[dq]message\[dq], (e) \f[B]=>\f[R] {
    \f[B]const\f[R] workerResult = \[ga]Result: ${e.data[0] * e.data[1]}\[ga];
    port.postMessage(workerResult);
  });

  port.start(); \f[I]// Required when using addEventListener. Otherwise called implicitly by onmessage setter.\f[R]
};
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Worker\f[R]
