.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Array.indexOf" "JS" "February 8, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.indexOf \- Array.prototype.indexOf()
.SH SYNOPSIS
The \f[B]\f[CB]indexOf()\f[B]\f[R] method of \f[CR]Array\f[R] instances
returns the first index at which a given element can be found in the
array, or \-1 if it is not present.
.SH SYNTAX
.IP
.EX
indexOf(searchElement)
indexOf(searchElement, fromIndex)
.EE
.SS Parameters
.TP
\f[B]searchElement\f[R]
Element to locate in the array.
.TP
\f[B]fromIndex\f[R] \f[I](optional)\f[R]
Zero\-based index at which to start searching, converted to an integer.
.RS
.IP \[bu] 2
Negative index counts back from the end of the array \[em] if
\f[CR]\-array.length <= fromIndex < 0\f[R],
\f[CR]fromIndex + array.length\f[R] is used.
Note, the array is still searched from front to back in this case.
.IP \[bu] 2
If \f[CR]fromIndex < \-array.length\f[R] or \f[CR]fromIndex\f[R] is
omitted, \f[CR]0\f[R] is used, causing the entire array to be searched.
.IP \[bu] 2
If \f[CR]fromIndex >= array.length\f[R], the array is not searched and
\f[CR]\-1\f[R] is returned.
.RE
.SS Return value
The first index of \f[CR]searchElement\f[R] in the array; \f[CR]\-1\f[R]
if not found.
.SH DESCRIPTION
The \f[CR]indexOf()\f[R] method compares \f[CR]searchElement\f[R] to
elements of the array using strict equality (the same algorithm used by
the \f[CR]===\f[R] operator).
\f[CR]NaN\f[R] values are never compared as equal, so
\f[CR]indexOf()\f[R] always returns \f[CR]\-1\f[R] when
\f[CR]searchElement\f[R] is \f[CR]NaN\f[R].
.PP
The \f[CR]indexOf()\f[R] method skips empty slots in sparse arrays.
.PP
The \f[CR]indexOf()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
.SH EXAMPLES
.SS Using indexOf()
The following example uses \f[CR]indexOf()\f[R] to locate values in an
array.
.IP
.EX
\f[B]const\f[R] array = [2, 9, 9];
array.indexOf(2); \f[I]// 0\f[R]
array.indexOf(7); \f[I]// \-1\f[R]
array.indexOf(9, 2); \f[I]// 2\f[R]
array.indexOf(2, \-1); \f[I]// \-1\f[R]
array.indexOf(2, \-3); \f[I]// 0\f[R]
.EE
.PP
You cannot use \f[CR]indexOf()\f[R] to search for \f[CR]NaN\f[R].
.IP
.EX
\f[B]const\f[R] array = [\f[B]NaN\f[R]];
array.indexOf(\f[B]NaN\f[R]); \f[I]// \-1\f[R]
.EE
.SS Finding all the occurrences of an element
.IP
.EX
\f[B]const\f[R] indices = [];
\f[B]const\f[R] array = [\[dq]a\[dq], \[dq]b\[dq], \[dq]a\[dq], \[dq]c\[dq], \[dq]a\[dq], \[dq]d\[dq]];
\f[B]const\f[R] element = \[dq]a\[dq];
\f[B]let\f[R] idx = array.indexOf(element);
\f[B]while\f[R] (idx !== \-1) {
  indices.push(idx);
  idx = array.indexOf(element, idx + 1);
}
console.log(indices);
\f[I]// [0, 2, 4]\f[R]
.EE
.SS Finding if an element exists in the array or not and updating the array
.IP
.EX
\f[B]function\f[R] updateVegetablesCollection(veggies, veggie) {
  \f[B]if\f[R] (veggies.indexOf(veggie) === \-1) {
    veggies.push(veggie);
    console.log(\[ga]New veggies collection is: ${veggies}\[ga]);
  } \f[B]else\f[R] {
    console.log(\[ga]${veggie} already exists in the veggies collection.\[ga]);
  }
}

\f[B]const\f[R] veggies = [\[dq]potato\[dq], \[dq]tomato\[dq], \[dq]chillies\[dq], \[dq]green\-pepper\[dq]];

updateVegetablesCollection(veggies, \[dq]spinach\[dq]);
\f[I]// New veggies collection is: potato,tomato,chillies,green\-pepper,spinach\f[R]
updateVegetablesCollection(veggies, \[dq]spinach\[dq]);
\f[I]// spinach already exists in the veggies collection.\f[R]
.EE
.SS Using indexOf() on sparse arrays
You cannot use \f[CR]indexOf()\f[R] to search for empty slots in sparse
arrays.
.IP
.EX
console.log([1, , 3].indexOf(\f[B]undefined\f[R])); \f[I]// \-1\f[R]
.EE
.SS Calling indexOf() on non\-array objects
The \f[CR]indexOf()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R] and then accesses each property whose key is a
nonnegative integer less than \f[CR]length\f[R].
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
  3: 5, \f[I]// ignored by indexOf() since length is 3\f[R]
};
console.log(Array.prototype.indexOf.call(arrayLike, 2));
\f[I]// 0\f[R]
console.log(Array.prototype.indexOf.call(arrayLike, 5));
\f[I]// \-1\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype.indexOf\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Indexed collections guide
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.findIndex()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.findLastIndex()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.lastIndexOf()\f[R]
.IP \[bu] 2
\f[CR]TypedArray.prototype.indexOf()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.indexOf()\f[R]
