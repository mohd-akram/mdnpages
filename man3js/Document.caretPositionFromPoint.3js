.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "DOCUMENT.CARETPOSITIONFROMPOINT" "3JS" "October 1, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Document.caretPositionFromPoint \- Document: caretPositionFromPoint()
method
.SH SYNOPSIS
The \f[B]\f[CB]caretPositionFromPoint()\f[B]\f[R] method of the
\f[CR]Document\f[R] interface returns a \f[CR]CaretPosition\f[R] object,
containing the DOM node, along with the caret and caret\(cqs character
offset within that node.
.SH SYNTAX
.IP
.EX
caretPositionFromPoint(x, y)
caretPositionFromPoint(x, y, options)
.EE
.SS Parameters
.TP
\f[B]x\f[R]
The horizontal coordinate of a point.
.TP
\f[B]y\f[R]
The vertical coordinate of a point.
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
The following optional properties may also be specified.
.RS
.TP
\f[B]shadowRoots\f[R] \f[I](optional)\f[R]
An array of \f[CR]ShadowRoot\f[R] objects.
The method can return a caret position for a node that is defined within
the shadow DOM of a supplied shadow root.
If the caret position falls within a shadow root that is not supplied,
the returned \f[CR]CaretPosition\f[R] will be remapped to the node that
is the host of the shadow root.
.RE
.SS Return value
A \f[CR]CaretPosition\f[R] object or \f[CR]null\f[R].
.PP
The returned value is \f[CR]null\f[R] if there is no viewport associated
with the document, if the \f[CR]x\f[R] or \f[CR]y\f[R] are negative or
outside of the viewport region, or if the coordinates indicate a point
where no text insertion point indicator could be inserted.
.SH EXAMPLES
.SS Split text nodes at caret position in DOM
This example demonstrates how to get the caret position from a selected
DOM node, use the position to split the node, and insert a line break
between the two nodes.
The example uses \f[CR]caretPositionFromPoint()\f[R] to get the caret
position if supported, with the non\-standard
\f[CR]Document.caretRangeFromPoint()\f[R] method as a fallback.
.PP
Note that some parts of the code are hidden, including code used for
logging, as this is not useful for understanding this method.
.SS HTML
The HTML defines a paragraph of text.
.IP
.EX
<\f[B]p\f[R]>
  Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy
  eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam
  voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita
  kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.
</\f[B]p\f[R]>
.EE
.SS JavaScript
The method below first checks for
\f[CR]document.caretPositionFromPoint\f[R] support and uses it to get
the text node and offset at the caret position.
If the browser doesn\(cqt support that method, the code then checks for
\f[CR]document.caretRangeFromPoint\f[R], and uses that instead.
.PP
If the node at the caret position is a text node, the code then splits
the node into two at the selected offset, and inserts a line break
between the two nodes.
.IP
.EX
\f[B]function\f[R] insertBreakAtPoint(e) {
  \f[B]let\f[R] range;
  \f[B]let\f[R] textNode;
  \f[B]let\f[R] offset;

  \f[B]if\f[R] (document.caretPositionFromPoint) {
    range = document.caretPositionFromPoint(e.clientX, e.clientY);
    textNode = range.offsetNode;
    offset = range.offset;
  } \f[B]else\f[R] \f[B]if\f[R] (document.caretRangeFromPoint) {
    \f[I]// Use WebKit\-proprietary fallback method\f[R]
    range = document.caretRangeFromPoint(e.clientX, e.clientY);
    textNode = range.startContainer;
    offset = range.startOffset;
  } \f[B]else\f[R] {
    \f[I]// Neither method is supported, do nothing\f[R]
    \f[B]return\f[R];
  }

  \f[I]// Logging code (uses hidden method to get substring with \(ha at offset)\f[R]
  \f[B]if\f[R] (textNode?.nodeType === 3) {
    \f[B]const\f[R] caretInText = getSubstringAroundOffset(textNode.textContent, offset);
    log(
      \(ganode: ${textNode.nodeName}, offset: ${offset}, insert: ${caretInText}\(ga,
    );
  }

  \f[I]// Only split TEXT_NODEs\f[R]
  \f[B]if\f[R] (textNode?.nodeType === 3) {
    \f[B]let\f[R] replacement = textNode.splitText(offset);
    \f[B]let\f[R] br = document.createElement(\(dqbr\(dq);
    textNode.parentNode.insertBefore(br, replacement);
  }
}
.EE
.PP
The method is the added as the click event handler for any paragraph
elements.
.IP
.EX
\f[B]const\f[R] paragraphs = document.getElementsByTagName(\(dqp\(dq);
\f[B]for\f[R] (\f[B]const\f[R] paragraph \f[B]of\f[R] paragraphs) {
  paragraph.addEventListener(\(dqclick\(dq, insertBreakAtPoint, \f[B]false\f[R]);
}
.EE
.SS Results
Click anywhere in the \f[B]Lorem ipsum \&...\f[R] paragraph below to
insert a line break at the point where you click.
Note that the log shows the \f[CR]nodeName\f[R], the offset, and a
fragment of the selected node with a \f[CR]\(ha\f[R] character at the
offset.
.SS Split text nodes at caret positions in a Shadow DOM
This example demonstrates how to get the caret position from a selected
node within a shadow root.
The example is very similar to the DOM\-only example above, except that
some of the text is inside a shadow root.
We provide a button to allow you to see the difference when a shadow
root is passed/not passed to \f[CR]caretPositionFromPoint()\f[R].
.PP
Note that some parts of the code are hidden, including code used for
logging, as this is not useful for understanding this method.
.SS HTML
The HTML defines a paragraph of text inside a \f[CR]<div>\f[R] element.
The paragraph contains a \f[CR]<span>\f[R] element with the
\f[CR]id\f[R] of \(lqhost\(rq that we will use as the host for a shadow
root.
There are also some buttons that we\(cqll use to reset the example, and
to Add/Remove the shadow root option argument to
\f[CR]caretPositionFromPoint()\f[R].
.IP
.EX
<\f[B]button\f[R] id=\(dqreset\(dq type=\(dqbutton\(dq>Reset</\f[B]button\f[R]>
<\f[B]button\f[R] id=\(dqshadowButton\(dq type=\(dqbutton\(dq>Add Shadow</\f[B]button\f[R]>
<\f[B]div\f[R]>
  <\f[B]p\f[R]>
    Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy
    eirmod tempor invidunt ut <\f[B]span\f[R] id=\(dqhost\(dq></\f[B]span\f[R]> labore et dolore magna
    aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo
    dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est
    Lorem ipsum dolor sit amet.
  </\f[B]p\f[R]>
</\f[B]div\f[R]>
.EE
.SS CSS
Here we use CSS to make the \f[CR]#host\f[R] element red and bold.
This makes it easier to distinguish between text in the DOM and text in
the shadow DOM.
.IP
.EX
host {
  \f[B]color\f[R]: red;
  \f[B]font\-weight\f[R]: bold;
}
.EE
.SS JavaScript
First we have some code to populate our shadow DOM.
We\(cqre using JavaScript to attach a shadow root dynamically, because
the MDN example system does not allow us to do this declaratively using
the \f[CR]<template>\f[R] element.
The content of the shadow DOM is a \f[CR]<span>\f[R] element that
contains the text \(lqI\(cqm in the shadow DOM\(rq.
.IP
.EX
\f[B]const\f[R] host = document.querySelector(\(dq#host\(dq);
\f[B]const\f[R] shadow = host.attachShadow({ mode: \(dqopen\(dq });
\f[B]const\f[R] shadowSpan = document.createElement(\(dqspan\(dq);
shadowSpan.textContent = \(dqI\(aqm in the shadow DOM\(dq;
shadow.appendChild(shadowSpan);
.EE
.PP
Next we add a handler for our \(lqEnable/Disable shadow\(rq button.
This code toggles the value of the \f[CR]useShadows\f[R] variable and
updates the button text appropriately.
.IP
.EX
\f[B]let\f[R] useShadows = \f[B]false\f[R];

\f[B]const\f[R] shadowButton = document.querySelector(\(dq#shadowButton\(dq);
shadowButton.addEventListener(\(dqclick\(dq, () \f[B]=>\f[R] {
  useShadows = !useShadows;
  shadowButton.innerText = useShadows ? \(dqRemove Shadow\(dq : \(dqAdd Shadow\(dq;
});
.EE
.PP
The method below first checks for
\f[CR]document.caretPositionFromPoint\f[R] support and uses it to get
the text node and offset at the caret position.
The value of the \f[CR]useShadows\f[R] variable is used to determine
whether the shadow root hosted in our text is passed to
\f[CR]caretPositionFromPoint()\f[R].
.IP \(bu 2
If the browser doesn\(cqt support that method, the code then checks for
\f[CR]document.caretRangeFromPoint\f[R], and uses that instead.
.IP \(bu 2
If the node at the caret position is a text node, the code then splits
the node at the selected offset, and inserts a line break between them.
.IP \(bu 2
If the node is an element node, then the code inserts a line break
element node at the offset.
.IP
.EX
\f[B]function\f[R] insertBreakAtPoint(e) {
  \f[B]let\f[R] range;
  \f[B]let\f[R] textNode;
  \f[B]let\f[R] offset;

  \f[B]if\f[R] (document.caretPositionFromPoint) {
    range = document.caretPositionFromPoint(
      e.clientX,
      e.clientY,
      useShadows ? { shadowRoots: [shadow] } : \f[B]null\f[R],
    );
    textNode = range.offsetNode;
    offset = range.offset;
  } \f[B]else\f[R] \f[B]if\f[R] (document.caretRangeFromPoint) {
    \f[I]// Use WebKit\-proprietary fallback method\f[R]
    range = document.caretRangeFromPoint(e.clientX, e.clientY);
    textNode = range.startContainer;
    offset = range.startOffset;
  } \f[B]else\f[R] {
    \f[I]// Neither method is supported, do nothing\f[R]
    \f[B]return\f[R];
  }

  \f[I]// Logging code (uses hidden method to get substring with \(ha at offset)\f[R]
  \f[B]if\f[R] (textNode) {
    \f[B]if\f[R] (textNode.nodeType === 3) {
      \f[B]const\f[R] caretInText = getSubstringAroundOffset(
        textNode.textContent,
        offset,
      );
      log(
        \(gatype: TEXT_NODE, name: ${textNode.nodeName}, offset: ${offset}:
${caretInText}\(ga,
      );
    } \f[B]else\f[R] \f[B]if\f[R] (textNode.nodeType === 1) {
      log(\(gatype: ELEMENT_NODE, name: ${textNode.nodeName}, offset: ${offset}\(ga);
    } \f[B]else\f[R] {
      log(
        \(gatype: ${textNode.nodeType}, name: ${textNode.nodeName}, offset: ${offset}\(ga,
      );
    }
  }

  \f[I]// Insert line at caret\f[R]
  \f[B]if\f[R] (textNode?.nodeType === 3) {
    \f[I]// TEXT_NODE \- split text at offset and add br\f[R]
    \f[B]let\f[R] replacement = textNode.splitText(offset);
    \f[B]let\f[R] br = document.createElement(\(dqbr\(dq);
    textNode.parentNode.insertBefore(br, replacement);
  } \f[B]else\f[R] \f[B]if\f[R] (textNode?.nodeType === 1) {
    \f[I]// ELEMENT_NODE \- Add br node at offset node\f[R]
    \f[B]let\f[R] br = document.createElement(\(dqbr\(dq);
    \f[B]const\f[R] targetNode = textNode.childNodes[offset];
    textNode.insertBefore(br, targetNode);
  } \f[B]else\f[R] {
    \f[I]// Do nothing\f[R]
  }
}
.EE
.PP
Finally we add two click event handlers for paragraph elements in the
DOM and in the shadow root, respectively.
Note that we need to specifically query the elements within the
\f[CR]shadowRoot\f[R] as they are not visible to normal DOM query
methods.
.IP
.EX
\f[I]// Click event handler <p> elements in the DOM\f[R]
\f[B]const\f[R] paragraphs = document.getElementsByTagName(\(dqp\(dq);
\f[B]for\f[R] (\f[B]const\f[R] paragraph \f[B]of\f[R] paragraphs) {
  paragraph.addEventListener(\(dqclick\(dq, insertBreakAtPoint, \f[B]false\f[R]);
}

\f[I]// Click event handler <p> elements in the Shadow DOM\f[R]
\f[B]const\f[R] shadowParagraphs = host.shadowRoot.querySelectorAll(\(dqp\(dq);
\f[B]for\f[R] (\f[B]const\f[R] paragraph \f[B]of\f[R] shadowParagraphs) {
  console.log(paragraph);
  paragraph.addEventListener(\(dqclick\(dq, insertBreakAtPoint, \f[B]false\f[R]);
}
.EE
.SS Results
Click in the \f[B]Lorem ipsum \&...\f[R] paragraph before or after the
shadow DOM text to insert a line break at the point where you click.
Note that in this case the log shows you have selected a
\f[CR]TEXT_NODE\f[R], the offset, and a fragment of the selected node
with a \f[CR]\(ha\f[R] character at the offset.
.PP
Initially the shadow root is not passed to
\f[CR]caretPositionFromPoint()\f[R], so if you click on the text
\(lqI\(cqm in the shadow DOM\(rq, the returned caret position node is
the parent node of the host, at the offset of the shadow root.
The line break therefore gets added before the node rather than the
point you selected.
Note that the caret position node in this case has the type
\f[CR]ELEMENT_NODE\f[R].
.PP
If you click the \(lqAdd shadow\(rq button, the shadow root is passed to
\f[CR]caretPositionFromPoint()\f[R], so the returned caret position is
the specific selected node within the shadow DOM.
This makes the shadow DOM text behave like the other paragraph text.
.SH SEE ALSO
.IP \(bu 2
\f[CR]CaretPosition\f[R]
