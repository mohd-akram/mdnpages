.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "Atomics" "JS" "July 13, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Atomics \- Atomics
.SH SYNOPSIS
The \f[B]\f[CB]Atomics\f[B]\f[R] namespace object contains static
methods for carrying out atomic operations.
They are used with \f[CR]SharedArrayBuffer\f[R] and
\f[CR]ArrayBuffer\f[R] objects.
.SH DESCRIPTION
Unlike most global objects, \f[CR]Atomics\f[R] is not a constructor.
You cannot use it with the \f[CR]new\f[R] operator or invoke the
\f[CR]Atomics\f[R] object as a function.
All properties and methods of \f[CR]Atomics\f[R] are static (just like
the \f[CR]Math\f[R] object).
.SS Atomic operations
When memory is shared, multiple threads can read and write the same data
in memory.
Atomic operations make sure that predictable values are written and
read, that operations are finished before the next operation starts and
that operations are not interrupted.
.SS Wait and notify
The \f[CR]wait()\f[R] and \f[CR]notify()\f[R] methods are modeled on
Linux futexes (\[lq]fast user\-space mutex\[rq]) and provide ways for
waiting until a certain condition becomes true and are typically used as
blocking constructs.
.SH STATIC PROPERTIES
.TP
\f[B]Atomics[Symbol.toStringTag]\f[R]
The initial value of the \f[CR][Symbol.toStringTag]\f[R] property is the
string \f[CR]\[dq]Atomics\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH STATIC METHODS
.TP
\f[B]Atomics.add()\f[R]
Adds the provided value to the existing value at the specified index of
the array.
Returns the old value at that index.
.TP
\f[B]Atomics.and()\f[R]
Computes a bitwise AND on the value at the specified index of the array
with the provided value.
Returns the old value at that index.
.TP
\f[B]Atomics.compareExchange()\f[R]
Stores a value at the specified index of the array, if it equals a
value.
Returns the old value.
.TP
\f[B]Atomics.exchange()\f[R]
Stores a value at the specified index of the array.
Returns the old value.
.TP
\f[B]Atomics.isLockFree()\f[R]
An optimization primitive that can be used to determine whether to use
locks or atomic operations.
Returns \f[CR]true\f[R] if an atomic operation on arrays of the given
element size will be implemented using a hardware atomic operation (as
opposed to a lock).
Experts only.
.TP
\f[B]Atomics.load()\f[R]
Returns the value at the specified index of the array.
.TP
\f[B]Atomics.notify()\f[R]
Notifies agents that are waiting on the specified index of the array.
Returns the number of agents that were notified.
.TP
\f[B]Atomics.or()\f[R]
Computes a bitwise OR on the value at the specified index of the array
with the provided value.
Returns the old value at that index.
.TP
\f[B]Atomics.store()\f[R]
Stores a value at the specified index of the array.
Returns the value.
.TP
\f[B]Atomics.sub()\f[R]
Subtracts a value at the specified index of the array.
Returns the old value at that index.
.TP
\f[B]Atomics.wait()\f[R]
Verifies that the specified index of the array still contains a value
and sleeps awaiting or times out.
Returns either \f[CR]\[dq]ok\[dq]\f[R], \f[CR]\[dq]not\-equal\[dq]\f[R],
or \f[CR]\[dq]timed\-out\[dq]\f[R].
If waiting is not allowed in the calling agent then it throws an
exception.
(Most browsers will not allow \f[CR]wait()\f[R] on the browser\[cq]s
main thread.)
.TP
\f[B]Atomics.waitAsync()\f[R]
Waits asynchronously (i.e.\ without blocking, unlike
\f[CR]Atomics.wait\f[R]) on a shared memory location and returns a
\f[CR]Promise\f[R].
.TP
\f[B]Atomics.xor()\f[R]
Computes a bitwise XOR on the value at the specified index of the array
with the provided value.
Returns the old value at that index.
.SH EXAMPLES
.SS Using Atomics
.IP
.EX
\f[B]const\f[R] sab = \f[B]new\f[R] SharedArrayBuffer(1024);
\f[B]const\f[R] ta = \f[B]new\f[R] Uint8Array(sab);

ta[0]; \f[I]// 0\f[R]
ta[0] = 5; \f[I]// 5\f[R]

Atomics.add(ta, 0, 12); \f[I]// 5\f[R]
Atomics.load(ta, 0); \f[I]// 17\f[R]

Atomics.and(ta, 0, 1); \f[I]// 17\f[R]
Atomics.load(ta, 0); \f[I]// 1\f[R]

Atomics.compareExchange(ta, 0, 5, 12); \f[I]// 1\f[R]
Atomics.load(ta, 0); \f[I]// 1\f[R]

Atomics.exchange(ta, 0, 12); \f[I]// 1\f[R]
Atomics.load(ta, 0); \f[I]// 12\f[R]

Atomics.isLockFree(1); \f[I]// true\f[R]
Atomics.isLockFree(2); \f[I]// true\f[R]
Atomics.isLockFree(3); \f[I]// false\f[R]
Atomics.isLockFree(4); \f[I]// true\f[R]

Atomics.or(ta, 0, 1); \f[I]// 12\f[R]
Atomics.load(ta, 0); \f[I]// 13\f[R]

Atomics.store(ta, 0, 12); \f[I]// 12\f[R]

Atomics.sub(ta, 0, 2); \f[I]// 12\f[R]
Atomics.load(ta, 0); \f[I]// 10\f[R]

Atomics.xor(ta, 0, 1); \f[I]// 10\f[R]
Atomics.load(ta, 0); \f[I]// 11\f[R]
.EE
.SS Waiting and notifying
Given a shared \f[CR]Int32Array\f[R]:
.IP
.EX
\f[B]const\f[R] sab = \f[B]new\f[R] SharedArrayBuffer(1024);
\f[B]const\f[R] int32 = \f[B]new\f[R] Int32Array(sab);
.EE
.PP
A reading thread is sleeping and waiting on location 0 which is expected
to be 0.
As long as that is true, it will not go on.
However, once the writing thread has stored a new value, it will be
notified by the writing thread and return the new value (123).
.IP
.EX
Atomics.wait(int32, 0, 0);
console.log(int32[0]); \f[I]// 123\f[R]
.EE
.PP
A writing thread stores a new value and notifies the waiting thread once
it has written:
.IP
.EX
console.log(int32[0]); \f[I]// 0;\f[R]
Atomics.store(int32, 0, 123);
Atomics.notify(int32, 0, 1);
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]ArrayBuffer\f[R]
.IP \[bu] 2
JavaScript typed arrays guide
.IP \[bu] 2
Web Workers
.IP \[bu] 2
\c
.UR https://github.com/tc39/proposal-ecmascript-sharedmem/blob/main/TUTORIAL.md
Shared Memory \[en] a brief tutorial
.UE \c
\ in the TC39 ecmascript\-sharedmem proposal
.IP \[bu] 2
\c
.UR https://hacks.mozilla.org/2016/05/a-taste-of-javascripts-new-parallel-primitives/
A Taste of JavaScript\[cq]s New Parallel Primitives
.UE \c
\ on hacks.mozilla.org (2016)
