'\" t
.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "NUMBER.EPSILON" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Number.EPSILON \- Number.EPSILON
.SH SYNOPSIS
The \f[B]\f[CB]Number.EPSILON\f[B]\f[R] static data property represents
the difference between 1 and the smallest floating point number greater
than 1.
.IP
.EX
\f[B]const\f[R] result = Math.abs(0.2 \- 0.3 + 0.1);

console.log(result);
\f[I]// Expected output: 2.7755575615628914e\-17\f[R]

console.log(result < Number.EPSILON);
\f[I]// Expected output: true\f[R]
.EE
.SH VALUE
2\(ha\-52, or approximately
\f[CR]2.2204460492503130808472633361816E\-16\f[R].
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
no
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
no
T}
.TE
.SH DESCRIPTION
\f[CR]Number.EPSILON\f[R] is the difference between 1 and the next
greater number representable in the Number format, because \c
.UR https://en.wikipedia.org/wiki/Double_precision_floating-point_format
double precision floating point format
.UE \c
\ only has 52 bits to represent the mantissa, and the lowest bit has a
significance of 2\(ha\-52.
.PP
Note that the absolute accuracy of floating numbers decreases as the
number gets larger, because the exponent grows while the mantissa\(cqs
accuracy stays the same.
\f[CR]Number.MIN_VALUE\f[R] is the smallest representable positive
number, which is much smaller than \f[CR]Number.EPSILON\f[R].
.PP
Because \f[CR]EPSILON\f[R] is a static property of \f[CR]Number\f[R],
you always use it as \f[CR]Number.EPSILON\f[R], rather than as a
property of a number value.
.SH EXAMPLES
.SS Testing equality
Any number encoding system occupying a finite number of bits, of
whatever base you choose (e.g., decimal or binary), will
\f[I]necessarily\f[R] be unable to represent all numbers exactly,
because you are trying to represent an infinite number of points on the
number line using a finite amount of memory.
For example, a base\-10 (decimal) system cannot represent 1/3 exactly,
and a base\-2 (binary) system cannot represent \f[CR]0.1\f[R] exactly.
Thus, for example, \f[CR]0.1 + 0.2\f[R] is not exactly equal to
\f[CR]0.3\f[R]:
.IP
.EX
console.log(0.1 + 0.2); \f[I]// 0.30000000000000004\f[R]
console.log(0.1 + 0.2 === 0.3); \f[I]// false\f[R]
.EE
.PP
For this reason, it is often advised that \f[B]floating point numbers
should never be compared with \f[CB]===\f[B]\f[R].
Instead, we can deem two numbers as equal if they are \f[I]close
enough\f[R] to each other.
The \f[CR]Number.EPSILON\f[R] constant is usually a reasonable threshold
for errors if the arithmetic is around the magnitude of \f[CR]1\f[R],
because \f[CR]EPSILON\f[R], in essence, specifies how accurate the
number \(lq1\(rq is.
.IP
.EX
\f[B]function\f[R] equal(x, y) {
  \f[B]return\f[R] Math.abs(x \- y) < Number.EPSILON;
}

\f[B]const\f[R] x = 0.2;
\f[B]const\f[R] y = 0.3;
\f[B]const\f[R] z = 0.1;
console.log(equal(x + z, y)); \f[I]// true\f[R]
.EE
.PP
However, \f[CR]Number.EPSILON\f[R] is inappropriate for any arithmetic
operating on a larger magnitude.
If your data is on the 10\(ha3 order of magnitude, the decimal part will
have a much smaller accuracy than \f[CR]Number.EPSILON\f[R]:
.IP
.EX
\f[B]function\f[R] equal(x, y) {
  \f[B]return\f[R] Math.abs(x \- y) < Number.EPSILON;
}

\f[B]const\f[R] x = 1000.1;
\f[B]const\f[R] y = 1000.2;
\f[B]const\f[R] z = 2000.3;
console.log(x + y); \f[I]// 2000.3000000000002; error of 10\(ha\-13 instead of 10\(ha\-16\f[R]
console.log(equal(x + y, z)); \f[I]// false\f[R]
.EE
.PP
In this case, a larger tolerance is required.
As the numbers compared have a magnitude of approximately
\f[CR]2000\f[R], a multiplier such as \f[CR]2000 * Number.EPSILON\f[R]
creates enough tolerance for this instance.
.IP
.EX
\f[B]function\f[R] equal(x, y, tolerance = Number.EPSILON) {
  \f[B]return\f[R] Math.abs(x \- y) < tolerance;
}

\f[B]const\f[R] x = 1000.1;
\f[B]const\f[R] y = 1000.2;
\f[B]const\f[R] z = 2000.3;
console.log(equal(x + y, z, 2000 * Number.EPSILON)); \f[I]// true\f[R]
.EE
.PP
In addition to magnitude, it is important to consider the
\f[I]accuracy\f[R] of your input.
For example, if the numbers are collected from a form input and the
input value can only be adjusted by steps of \f[CR]0.1\f[R] (i.e.,
\f[CR]<input type=\(dqnumber\(dq step=\(dq0.1\(dq>\f[R]), it usually
makes sense to allow a much larger tolerance, such as \f[CR]0.01\f[R],
since the data only has a precision of \f[CR]0.1\f[R].
.RS
.PP
\f[B]Note:\f[R] Important takeaway: do not simply use
\f[CR]Number.EPSILON\f[R] as a threshold for equality testing.
Use a threshold that is appropriate for the magnitude and accuracy of
the numbers you are comparing.
.RE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-number
Polyfill of \f[CR]Number.EPSILON\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/es-constants
es\-shims polyfill of \f[CR]Number.EPSILON\f[R]
.UE \c
.IP \(bu 2
\f[CR]Number\f[R]
