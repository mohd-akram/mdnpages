.\" Automatically generated by Pandoc 3.2.1
.\"
.TH "OffscreenCanvas" "JS" "August 5, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
OffscreenCanvas \- OffscreenCanvas
.SH SYNOPSIS
\f[B]Note:\f[R] This feature is available in Web Workers.
.PP
When using the \f[CR]<canvas>\f[R] element or the Canvas API, rendering,
animation, and user interaction usually happen on the main execution
thread of a web application.
The computation relating to canvas animations and rendering can have a
significant impact on application performance.
.PP
The \f[B]\f[CB]OffscreenCanvas\f[B]\f[R] interface provides a canvas
that can be rendered off screen, decoupling the DOM and the Canvas API
so that the \f[CR]<canvas>\f[R] element is no longer entirely dependent
on the DOM.
Rendering operations can also be run inside a worker context, allowing
you to run some tasks in a separate thread and avoid heavy work on the
main thread.
.PP
\f[CR]OffscreenCanvas\f[R] is a transferable object.
.SH CONSTRUCTORS
.TP
\f[B]OffscreenCanvas()\f[R]
\f[CR]OffscreenCanvas\f[R] constructor.
Creates a new \f[CR]OffscreenCanvas\f[R] object.
.SH INSTANCE PROPERTIES
.TP
\f[B]OffscreenCanvas.height\f[R]
The height of the offscreen canvas.
.TP
\f[B]OffscreenCanvas.width\f[R]
The width of the offscreen canvas.
.SH INSTANCE METHODS
.TP
\f[B]OffscreenCanvas.getContext()\f[R]
Returns a rendering context for the offscreen canvas.
.TP
\f[B]OffscreenCanvas.convertToBlob()\f[R]
Creates a \f[CR]Blob\f[R] object representing the image contained in the
canvas.
.TP
\f[B]OffscreenCanvas.transferToImageBitmap()\f[R]
Creates an \f[CR]ImageBitmap\f[R] object from the most recently rendered
image of the \f[CR]OffscreenCanvas\f[R].
See its reference for important notes on managing this
\f[CR]ImageBitmap\f[R].
.SH EVENTS
\f[I]Inherits events from its parent, \f[CI]EventTarget\f[I].\f[R]
.PP
Listen to these events using \f[CR]addEventListener()\f[R] or by
assigning an event listener to the \f[CR]oneventname\f[R] property of
this interface.
.TP
\f[B]contextlost\f[R]
Fired if the browser detects that an
\f[CR]OffscreenCanvasRenderingContext2D\f[R] context is lost.
.TP
\f[B]contextrestored\f[R]
Fired if the browser successfully restores an
\f[CR]OffscreenCanvasRenderingContext2D\f[R] context.
.SH EXAMPLES
.SS Synchronous display of frames produced by an \f[CR]OffscreenCanvas\f[R]
One way to use the \f[CR]OffscreenCanvas\f[R] API is to use a rendering
context that has been obtained from an \f[CR]OffscreenCanvas\f[R] object
to generate new frames.
Once a new frame has finished rendering in this context, the
\f[CR]transferToImageBitmap()\f[R] method can be called to save the most
recent rendered image.
This method returns an \f[CR]ImageBitmap\f[R] object, which can be used
in a variety of Web APIs and also in a second canvas without creating a
transfer copy.
.PP
To display the \f[CR]ImageBitmap\f[R], you can use an
\f[CR]ImageBitmapRenderingContext\f[R] context, which can be created by
calling \f[CR]canvas.getContext(\[dq]bitmaprenderer\[dq])\f[R] on a
(visible) canvas element.
This context only provides functionality to replace the canvas\[cq]s
contents with the given \f[CR]ImageBitmap\f[R].
A call to
\f[CR]ImageBitmapRenderingContext.transferFromImageBitmap()\f[R] with
the previously rendered and saved \f[CR]ImageBitmap\f[R] from the
OffscreenCanvas, will display the \f[CR]ImageBitmap\f[R] on the canvas
and transfer its ownership to the canvas.
A single \f[CR]OffscreenCanvas\f[R] may transfer frames into an
arbitrary number of other \f[CR]ImageBitmapRenderingContext\f[R]
objects.
.PP
Given these two \f[CR]<canvas>\f[R] elements
.IP
.EX
<\f[B]canvas\f[R] id=\[dq]one\[dq]></\f[B]canvas\f[R]> <\f[B]canvas\f[R] id=\[dq]two\[dq]></\f[B]canvas\f[R]>
.EE
.PP
the following code will provide the rendering using
\f[CR]OffscreenCanvas\f[R] as described above.
.IP
.EX
\f[B]const\f[R] one = document.getElementById(\[dq]one\[dq]).getContext(\[dq]bitmaprenderer\[dq]);
\f[B]const\f[R] two = document.getElementById(\[dq]two\[dq]).getContext(\[dq]bitmaprenderer\[dq]);

\f[B]const\f[R] offscreen = \f[B]new\f[R] OffscreenCanvas(256, 256);
\f[B]const\f[R] gl = offscreen.getContext(\[dq]webgl\[dq]);

\f[I]// Perform some drawing for the first canvas using the gl context\f[R]
\f[B]const\f[R] bitmapOne = offscreen.transferToImageBitmap();
one.transferFromImageBitmap(bitmapOne);

\f[I]// Perform some more drawing for the second canvas\f[R]
\f[B]const\f[R] bitmapTwo = offscreen.transferToImageBitmap();
two.transferFromImageBitmap(bitmapTwo);
.EE
.SS Asynchronous display of frames produced by an \f[CR]OffscreenCanvas\f[R]
Another way to use the \f[CR]OffscreenCanvas\f[R] API, is to call
\f[CR]transferControlToOffscreen()\f[R] on a \f[CR]<canvas>\f[R]
element, either on a worker or the main thread, which will return an
\f[CR]OffscreenCanvas\f[R] object from an \f[CR]HTMLCanvasElement\f[R]
object from the main thread.
Calling \f[CR]getContext()\f[R] will then obtain a rendering context
from that \f[CR]OffscreenCanvas\f[R].
.PP
The \f[CR]main.js\f[R] script (main thread) may look like this:
.IP
.EX
\f[B]const\f[R] htmlCanvas = document.getElementById(\[dq]canvas\[dq]);
\f[B]const\f[R] offscreen = htmlCanvas.transferControlToOffscreen();

\f[B]const\f[R] worker = \f[B]new\f[R] Worker(\[dq]offscreencanvas.js\[dq]);
worker.postMessage({ canvas: offscreen }, [offscreen]);
.EE
.PP
While the \f[CR]offscreencanvas.js\f[R] script (worker thread) can look
like this:
.IP
.EX
onmessage = (evt) \f[B]=>\f[R] {
  \f[B]const\f[R] canvas = evt.data.canvas;
  \f[B]const\f[R] gl = canvas.getContext(\[dq]webgl\[dq]);
  \f[I]// Perform some drawing using the gl context\f[R]
};
.EE
.PP
It\[cq]s also possible to use \f[CR]requestAnimationFrame()\f[R] in
workers:
.IP
.EX
onmessage = (evt) \f[B]=>\f[R] {
  \f[B]const\f[R] canvas = evt.data.canvas;
  \f[B]const\f[R] gl = canvas.getContext(\[dq]webgl\[dq]);

  \f[B]function\f[R] render(time) {
    \f[I]// Perform some drawing using the gl context\f[R]
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
};
.EE
.PP
For a full example, see the \c
.UR https://github.com/mdn/dom-examples/tree/main/web-workers/offscreen-canvas-worker
OffscreenCanvas example source
.UE \c
\ on GitHub or run the \c
.UR https://mdn.github.io/dom-examples/web-workers/offscreen-canvas-worker/
OffscreenCanvas example live
.UE \c
\&.
.SH SEE ALSO
.IP \[bu] 2
\f[CR]CanvasRenderingContext2D\f[R]
.IP \[bu] 2
\f[CR]OffscreenCanvasRenderingContext2D\f[R]
.IP \[bu] 2
\f[CR]ImageBitmap\f[R]
.IP \[bu] 2
\f[CR]ImageBitmapRenderingContext\f[R]
.IP \[bu] 2
\f[CR]HTMLCanvasElement.transferControlToOffscreen()\f[R]
.IP \[bu] 2
\f[CR]requestAnimationFrame()\f[R]
.IP \[bu] 2
\c
.UR https://hacks.mozilla.org/2016/01/webgl-off-the-main-thread/
WebGL Off the Main Thread \[en] Mozilla Hacks
.UE \c
\ (2016)
