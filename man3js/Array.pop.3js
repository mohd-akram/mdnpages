.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Array.pop" "JS" "September 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.pop \- Array.prototype.pop()
.SH SYNOPSIS
The \f[B]\f[CB]pop()\f[B]\f[R] method of \f[CR]Array\f[R] instances
removes the \f[B]last\f[R] element from an array and returns that
element.
This method changes the length of the array.
.SH SYNTAX
.IP
.EX
pop()
.EE
.SS Parameters
None.
.SS Return value
The removed element from the array; \f[CR]undefined\f[R] if the array is
empty.
.SH DESCRIPTION
The \f[CR]pop()\f[R] method removes the last element from an array and
returns that value to the caller.
If you call \f[CR]pop()\f[R] on an empty array, it returns
\f[CR]undefined\f[R].
.PP
\f[CR]Array.prototype.shift()\f[R] has similar behavior to
\f[CR]pop()\f[R], but applied to the first element in an array.
.PP
The \f[CR]pop()\f[R] method is a mutating method.
It changes the length and the content of \f[CR]this\f[R].
In case you want the value of \f[CR]this\f[R] to be the same, but return
a new array with the last element removed, you can use
\f[CR]arr.slice(0, \-1)\f[R] instead.
.PP
The \f[CR]pop()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
Although strings are also array\-like, this method is not suitable to be
applied on them, as strings are immutable.
.SH EXAMPLES
.SS Removing the last element of an array
The following code creates the \f[CR]myFish\f[R] array containing four
elements, then removes its last element.
.IP
.EX
\f[B]const\f[R] myFish = [\[dq]angel\[dq], \[dq]clown\[dq], \[dq]mandarin\[dq], \[dq]sturgeon\[dq]];

\f[B]const\f[R] popped = myFish.pop();

console.log(myFish); \f[I]// [\[aq]angel\[aq], \[aq]clown\[aq], \[aq]mandarin\[aq] ]\f[R]

console.log(popped); \f[I]// \[aq]sturgeon\[aq]\f[R]
.EE
.SS Calling pop() on non\-array objects
The \f[CR]pop()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R].
If the normalized length is 0, \f[CR]length\f[R] is set to \f[CR]0\f[R]
again (whereas it may be negative or \f[CR]undefined\f[R] before).
Otherwise, the property at \f[CR]length \- 1\f[R] is returned and
deleted.
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  unrelated: \[dq]foo\[dq],
  2: 4,
};
console.log(Array.prototype.pop.call(arrayLike));
\f[I]// 4\f[R]
console.log(arrayLike);
\f[I]// { length: 2, unrelated: \[aq]foo\[aq] }\f[R]

\f[B]const\f[R] plainObj = {};
\f[I]// There\[aq]s no length property, so the length is 0\f[R]
Array.prototype.pop.call(plainObj);
console.log(plainObj);
\f[I]// { length: 0 }\f[R]
.EE
.SS Using an object in an array\-like fashion
\f[CR]push\f[R] and \f[CR]pop\f[R] are intentionally generic, and we can
use that to our advantage \[em] as the following example shows.
.PP
Note that in this example, we don\[cq]t create an array to store a
collection of objects.
Instead, we store the collection on the object itself and use
\f[CR]call\f[R] on \f[CR]Array.prototype.push\f[R] and
\f[CR]Array.prototype.pop\f[R] to trick those methods into thinking
we\[cq]re dealing with an array.
.IP
.EX
\f[B]const\f[R] collection = {
  length: 0,
  addElements(...elements) {
    \f[I]// obj.length will be incremented automatically\f[R]
    \f[I]// every time an element is added.\f[R]

    \f[I]// Returning what push returns; that is\f[R]
    \f[I]// the new value of length property.\f[R]
    \f[B]return\f[R] [].push.call(\f[B]this\f[R], ...elements);
  },
  removeElement() {
    \f[I]// obj.length will be decremented automatically\f[R]
    \f[I]// every time an element is removed.\f[R]

    \f[I]// Returning what pop returns; that is\f[R]
    \f[I]// the removed element.\f[R]
    \f[B]return\f[R] [].pop.call(\f[B]this\f[R]);
  },
};

collection.addElements(10, 20, 30);
console.log(collection.length); \f[I]// 3\f[R]
collection.removeElement();
console.log(collection.length); \f[I]// 2\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
Indexed collections guide
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.push()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.shift()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.unshift()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.concat()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.splice()\f[R]
