.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "PROXY.PROXY.GETPROTOTYPEOF" "3JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Proxy.Proxy.getPrototypeOf \- handler.getPrototypeOf()
.SH SYNOPSIS
The \f[B]\f[CB]handler.getPrototypeOf()\f[B]\f[R] method is a trap for
the \f[CR][[GetPrototypeOf]]\f[R] object internal method, which is used
by operations such as \f[CR]Object.getPrototypeOf()\f[R].
.IP
.EX
\f[B]const\f[R] monster1 = {
  eyeCount: 4,
};

\f[B]const\f[R] monsterPrototype = {
  eyeCount: 2,
};

\f[B]const\f[R] handler = {
  getPrototypeOf(target) {
    \f[B]return\f[R] monsterPrototype;
  },
};

\f[B]const\f[R] proxy1 = \f[B]new\f[R] Proxy(monster1, handler);

console.log(Object.getPrototypeOf(proxy1) === monsterPrototype);
\f[I]// Expected output: true\f[R]

console.log(Object.getPrototypeOf(proxy1).eyeCount);
\f[I]// Expected output: 2\f[R]
.EE
.SH SYNTAX
.IP
.EX
new Proxy(target, {
  getPrototypeOf(target) {
  }
})
.EE
.SS Parameters
The following parameter is passed to the \f[CR]getPrototypeOf()\f[R]
method.
\f[CR]this\f[R] is bound to the handler.
.TP
\f[B]target\f[R]
The target object.
.SS Return value
The \f[CR]getPrototypeOf()\f[R] method must return an object or
\f[CR]null\f[R], representing the prototype of the target object.
.SH DESCRIPTION
.SS Interceptions
This trap can intercept these operations:
.IP \(bu 2
\f[CR]Object.getPrototypeOf()\f[R]
.IP \(bu 2
\f[CR]Reflect.getPrototypeOf()\f[R]
.IP \(bu 2
\f[CR]__proto__\f[R]
.IP \(bu 2
\f[CR]Object.prototype.isPrototypeOf()\f[R]
.IP \(bu 2
\f[CR]instanceof\f[R]
.PP
Or any other operation that invokes the \f[CR][[GetPrototypeOf]]\f[R]
internal method.
.SS Invariants
The proxy\(cqs \f[CR][[GetPrototypeOf]]\f[R] internal method throws a
\f[CR]TypeError\f[R] if the handler definition violates one of the
following invariants:
.IP \(bu 2
The result must be either an \f[CR]Object\f[R] or \f[CR]null\f[R].
.IP \(bu 2
If the target object is not extensible (that is,
\f[CR]Reflect.isExtensible()\f[R] returns \f[CR]false\f[R] on
\f[CR]target\f[R]), the result must be the same as the result of
\f[CR]Reflect.getPrototypeOf(target)\f[R].
.SH EXAMPLES
.SS Basic usage
.IP
.EX
\f[B]const\f[R] obj = {};
\f[B]const\f[R] proto = {};
\f[B]const\f[R] handler = {
  getPrototypeOf(target) {
    console.log(target === obj); \f[I]// true\f[R]
    console.log(\f[B]this\f[R] === handler); \f[I]// true\f[R]
    \f[B]return\f[R] proto;
  },
};

\f[B]const\f[R] p = \f[B]new\f[R] Proxy(obj, handler);
console.log(Object.getPrototypeOf(p) === proto); \f[I]// true\f[R]
.EE
.SS Five ways to trigger the getPrototypeOf trap
.IP
.EX
\f[B]const\f[R] obj = {};
\f[B]const\f[R] p = \f[B]new\f[R] Proxy(obj, {
  getPrototypeOf(target) {
    \f[B]return\f[R] Array.prototype;
  },
});
console.log(
  Object.getPrototypeOf(p) === Array.prototype, \f[I]// true\f[R]
  Reflect.getPrototypeOf(p) === Array.prototype, \f[I]// true\f[R]
  p.__proto__ === Array.prototype, \f[I]// true\f[R]
  Array.prototype.isPrototypeOf(p), \f[I]// true\f[R]
  p \f[B]instanceof\f[R] Array, \f[I]// true\f[R]
);
.EE
.SS Two kinds of exceptions
\f[B]Bad\f[R]
.IP
.EX
\f[B]const\f[R] obj = {};
\f[B]const\f[R] p = \f[B]new\f[R] Proxy(obj, {
  getPrototypeOf(target) {
    \f[B]return\f[R] \(dqfoo\(dq;
  },
});
Object.getPrototypeOf(p); \f[I]// TypeError: \(dqfoo\(dq is not an object or null\f[R]

\f[B]const\f[R] obj2 = Object.preventExtensions({});
\f[B]const\f[R] p2 = \f[B]new\f[R] Proxy(obj2, {
  getPrototypeOf(target) {
    \f[B]return\f[R] {};
  },
});
Object.getPrototypeOf(p2); \f[I]// TypeError: expected same prototype value\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]Proxy\f[R]
.IP \(bu 2
\f[CR]Proxy()\f[R] constructor
.IP \(bu 2
\f[CR]Object.getPrototypeOf()\f[R]
.IP \(bu 2
\f[CR]Reflect.getPrototypeOf()\f[R]
