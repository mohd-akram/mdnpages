.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Proxy.Proxy.getPrototypeOf" "JS" "August 11, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Proxy.Proxy.getPrototypeOf \- handler.getPrototypeOf()
.SH SYNOPSIS
The \f[B]\f[CB]handler.getPrototypeOf()\f[B]\f[R] method is a trap for
the \f[CR][[GetPrototypeOf]]\f[R] object internal method, which is used
by operations such as \f[CR]Object.getPrototypeOf()\f[R].
.SH SYNTAX
.IP
.EX
new Proxy(obj, {
  getPrototypeOf(target) {
    // \&...
  }
});
.EE
.SS Parameters
The following parameter is passed to the \f[CR]getPrototypeOf()\f[R]
method.
\f[CR]this\f[R] is bound to the handler.
.TP
\f[B]target\f[R]
The target object.
.SS Return value
The \f[CR]getPrototypeOf()\f[R] method must return an object or
\f[CR]null\f[R].
.SH DESCRIPTION
.SS Interceptions
This trap can intercept these operations:
.IP \[bu] 2
\f[CR]Object.getPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Reflect.getPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]__proto__\f[R]
.IP \[bu] 2
\f[CR]Object.prototype.isPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]instanceof\f[R]
.PP
Or any other operation that invokes the \f[CR][[GetPrototypeOf]]\f[R]
internal method.
.SS Invariants
If the following invariants are violated, the trap throws a
\f[CR]TypeError\f[R] when invoked.
.IP \[bu] 2
\f[CR]getPrototypeOf()\f[R] method must return an object or
\f[CR]null\f[R].
.IP \[bu] 2
If \f[CR]target\f[R] is not extensible,
\f[CR]Object.getPrototypeOf(proxy)\f[R] method must return the same
value as \f[CR]Object.getPrototypeOf(target)\f[R].
.SH EXAMPLES
.SS Basic usage
.IP
.EX
\f[B]const\f[R] obj = {};
\f[B]const\f[R] proto = {};
\f[B]const\f[R] handler = {
  getPrototypeOf(target) {
    console.log(target === obj); \f[I]// true\f[R]
    console.log(\f[B]this\f[R] === handler); \f[I]// true\f[R]
    \f[B]return\f[R] proto;
  },
};

\f[B]const\f[R] p = \f[B]new\f[R] Proxy(obj, handler);
console.log(Object.getPrototypeOf(p) === proto); \f[I]// true\f[R]
.EE
.SS Five ways to trigger the getPrototypeOf trap
.IP
.EX
\f[B]const\f[R] obj = {};
\f[B]const\f[R] p = \f[B]new\f[R] Proxy(obj, {
  getPrototypeOf(target) {
    \f[B]return\f[R] Array.prototype;
  },
});
console.log(
  Object.getPrototypeOf(p) === Array.prototype, \f[I]// true\f[R]
  Reflect.getPrototypeOf(p) === Array.prototype, \f[I]// true\f[R]
  p.__proto__ === Array.prototype, \f[I]// true\f[R]
  Array.prototype.isPrototypeOf(p), \f[I]// true\f[R]
  p \f[B]instanceof\f[R] Array, \f[I]// true\f[R]
);
.EE
.SS Two kinds of exceptions
\f[B]Bad\f[R]
.IP
.EX
\f[B]const\f[R] obj = {};
\f[B]const\f[R] p = \f[B]new\f[R] Proxy(obj, {
  getPrototypeOf(target) {
    \f[B]return\f[R] \[dq]foo\[dq];
  },
});
Object.getPrototypeOf(p); \f[I]// TypeError: \[dq]foo\[dq] is not an object or null\f[R]

\f[B]const\f[R] obj2 = Object.preventExtensions({});
\f[B]const\f[R] p2 = \f[B]new\f[R] Proxy(obj2, {
  getPrototypeOf(target) {
    \f[B]return\f[R] {};
  },
});
Object.getPrototypeOf(p2); \f[I]// TypeError: expected same prototype value\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Proxy\f[R]
.IP \[bu] 2
\f[CR]Proxy()\f[R] constructor
.IP \[bu] 2
\f[CR]Object.getPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Reflect.getPrototypeOf()\f[R]
