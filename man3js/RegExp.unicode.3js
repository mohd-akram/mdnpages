.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "REGEXP.UNICODE" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RegExp.unicode \- RegExp.prototype.unicode
.SH SYNOPSIS
The \f[B]\f[CB]unicode\f[B]\f[R] accessor property of \f[CR]RegExp\f[R]
instances returns whether or not the \f[CR]u\f[R] flag is used with this
regular expression.
.IP
.EX
\f[B]const\f[R] regex1 = /\(rsu{61}/;
\f[B]const\f[R] regex2 = /\(rsu{61}/u;

console.log(regex1.unicode);
\f[I]// Expected output: false\f[R]

console.log(regex2.unicode);
\f[I]// Expected output: true\f[R]
.EE
.SH DESCRIPTION
\f[CR]RegExp.prototype.unicode\f[R] has the value \f[CR]true\f[R] if the
\f[CR]u\f[R] flag was used; otherwise, \f[CR]false\f[R].
The \f[CR]u\f[R] flag enables various Unicode\-related features.
With the \(lqu\(rq flag:
.IP \(bu 2
Any Unicode code point escapes (\f[CR]\(rsu{xxxx}\f[R],
\f[CR]\(rsp{UnicodePropertyValue}\f[R]) will be interpreted as such
instead of identity escapes.
For example \f[CR]/\(rsu{61}/u\f[R] matches \f[CR]\(dqa\(dq\f[R], but
\f[CR]/\(rsu{61}/\f[R] (without \f[CR]u\f[R] flag) matches
\f[CR]\(dqu\(dq.repeat(61)\f[R], where the \f[CR]\(rsu\f[R] is
equivalent to a single \f[CR]u\f[R].
.IP \(bu 2
Surrogate pairs will be interpreted as whole characters instead of two
separate characters.
For example, \f[CR]/[ðŸ˜„]/u\f[R] would only match \f[CR]\(dqðŸ˜„\(dq\f[R]
but not \f[CR]\(dq\(rsud83d\(dq\f[R].
.IP \(bu 2
When \f[CR]lastIndex\f[R] is automatically advanced (such as when
calling \f[CR]exec()\f[R]), unicode regexes advance by Unicode code
points instead of UTF\-16 code units.
.PP
There are other changes to the parsing behavior that prevent possible
syntax mistakes (which are analogous to strict mode for regex syntax).
These syntaxes are all deprecated and only kept for web compatibility,
and you should not rely on them.
.PP
The set accessor of \f[CR]unicode\f[R] is \f[CR]undefined\f[R].
You cannot change this property directly.
.SS Unicode\-aware mode
When we refer to \f[I]Unicode\-aware mode\f[R], we mean the regex has
either the \f[CR]u\f[R] or the \f[CR]v\f[R] flag, in which case the
regex enables Unicode\-related features (such as Unicode character class
escape) and has much stricter syntax rules.
Because \f[CR]u\f[R] and \f[CR]v\f[R] interpret the same regex in
incompatible ways, using both flags results in a \f[CR]SyntaxError\f[R].
.PP
Similarly, a regex is \f[I]Unicode\-unaware\f[R] if it has neither the
\f[CR]u\f[R] nor the \f[CR]v\f[R] flag.
In this case, the regex is interpreted as a sequence of UTF\-16 code
units, and there are many legacy syntaxes that do not become syntax
errors.
.SH EXAMPLES
.SS Using the unicode property
.IP
.EX
\f[B]const\f[R] regex = /\(rsu{61}/u;

console.log(regex.unicode); \f[I]// true\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\f[CR]RegExp.prototype.lastIndex\f[R]
.IP \(bu 2
\f[CR]RegExp.prototype.dotAll\f[R]
.IP \(bu 2
\f[CR]RegExp.prototype.global\f[R]
.IP \(bu 2
\f[CR]RegExp.prototype.hasIndices\f[R]
.IP \(bu 2
\f[CR]RegExp.prototype.ignoreCase\f[R]
.IP \(bu 2
\f[CR]RegExp.prototype.multiline\f[R]
.IP \(bu 2
\f[CR]RegExp.prototype.source\f[R]
.IP \(bu 2
\f[CR]RegExp.prototype.sticky\f[R]
