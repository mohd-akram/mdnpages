.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "String.fromCodePoint" "JS" "September 12, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.fromCodePoint \- String.fromCodePoint()
.SH SYNOPSIS
The \f[B]\f[CB]String.fromCodePoint()\f[B]\f[R] static method returns a
string created from the specified sequence of code points.
.SH SYNTAX
.IP
.EX
String.fromCodePoint()
String.fromCodePoint(num1)
String.fromCodePoint(num1, num2)
String.fromCodePoint(num1, num2, /* \&..., */ numN)
.EE
.SS Parameters
.TP
\f[B]num1\f[R], \&..., \f[B]numN\f[R]
An integer between \f[CR]0\f[R] and \f[CR]0x10FFFF\f[R] (inclusive)
representing a Unicode code point.
.SS Return value
A string created by using the specified sequence of code points.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]numN\f[R] is not an integer, is less than \f[CR]0\f[R],
or is greater than \f[CR]0x10FFFF\f[R] after being converted to a
number.
.SH DESCRIPTION
Because \f[CR]fromCodePoint()\f[R] is a static method of
\f[CR]String\f[R], you always use it as
\f[CR]String.fromCodePoint()\f[R], rather than as a method of a
\f[CR]String\f[R] value you created.
.PP
Unicode code points range from \f[CR]0\f[R] to \f[CR]1114111\f[R]
(\f[CR]0x10FFFF\f[R]).
In UTF\-16, each string index is a code unit with value \f[CR]0\f[R]
\[en] \f[CR]65535\f[R].
Higher code points are represented by \f[I]a pair\f[R] of 16\-bit
surrogate pseudo\-characters.
Therefore, \f[CR]fromCodePoint()\f[R] may return a string whose
\f[CR]length\f[R] (in UTF\-16 code units) is larger than the number of
arguments passed.
For information on Unicode, see UTF\-16 characters, Unicode code points,
and grapheme clusters.
.SH EXAMPLES
.SS Using fromCodePoint()
Valid input:
.IP
.EX
String.fromCodePoint(42); \f[I]// \[dq]*\[dq]\f[R]
String.fromCodePoint(65, 90); \f[I]// \[dq]AZ\[dq]\f[R]
String.fromCodePoint(0x404); \f[I]// \[dq]\[rs]u0404\[dq] === \[dq]Ð„\[dq]\f[R]
String.fromCodePoint(0x2f804); \f[I]// \[dq]\[rs]uD87E\[rs]uDC04\[dq]\f[R]
String.fromCodePoint(194564); \f[I]// \[dq]\[rs]uD87E\[rs]uDC04\[dq]\f[R]
String.fromCodePoint(0x1d306, 0x61, 0x1d307); \f[I]// \[dq]\[rs]uD834\[rs]uDF06a\[rs]uD834\[rs]uDF07\[dq]\f[R]
.EE
.PP
Invalid input:
.IP
.EX
String.fromCodePoint(\[dq]_\[dq]); \f[I]// RangeError\f[R]
String.fromCodePoint(\f[B]Infinity\f[R]); \f[I]// RangeError\f[R]
String.fromCodePoint(\-1); \f[I]// RangeError\f[R]
String.fromCodePoint(3.14); \f[I]// RangeError\f[R]
String.fromCodePoint(3e\-2); \f[I]// RangeError\f[R]
String.fromCodePoint(\f[B]NaN\f[R]); \f[I]// RangeError\f[R]
.EE
.SS Compared to fromCharCode()
\f[CR]String.fromCharCode()\f[R] cannot return supplementary characters
(i.e.\ code points \f[CR]0x010000\f[R] \[en] \f[CR]0x10FFFF\f[R]) by
specifying their code point.
Instead, it requires the UTF\-16 surrogate pair in order to return a
supplementary character:
.IP
.EX
String.fromCharCode(0xd83c, 0xdf03); \f[I]// Code Point U+1F303 \[dq]Night with\f[R]
String.fromCharCode(55356, 57091); \f[I]// Stars\[dq] === \[dq]\[rs]uD83C\[rs]uDF03\[dq]\f[R]
.EE
.PP
\f[CR]String.fromCodePoint()\f[R], on the other hand, can return 4\-byte
supplementary characters, as well as the more common 2\-byte BMP
characters, by specifying their code point (which is equivalent to the
UTF\-32 code unit):
.IP
.EX
String.fromCodePoint(0x1f303); \f[I]// or 127747 in decimal\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-string-and-regexp
Polyfill of \f[CR]String.fromCodePoint\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]String.fromCharCode()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.charAt()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.codePointAt()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.charCodeAt()\f[R]
