.\" Automatically generated by Pandoc 3.7.0.1
.\"
.TH "STRING.FROMCODEPOINT" "3JS" "June 20, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.fromCodePoint \- String.fromCodePoint()
.SH SYNOPSIS
The \f[B]\f[CB]String.fromCodePoint()\f[B]\f[R] static method returns a
string created from the specified sequence of code points.
.IP
.EX
console.log(String.fromCodePoint(9731, 9733, 9842, 0x2f804));
\f[I]// Expected output: \(dq☃★♲你\(dq\f[R]
.EE
.SH SYNTAX
.IP
.EX
String.fromCodePoint()
String.fromCodePoint(num1)
String.fromCodePoint(num1, num2)
String.fromCodePoint(num1, num2, /* \&..., */ numN)
.EE
.SS Parameters
.TP
\f[B]num1\f[R], \&..., \f[B]numN\f[R]
An integer between \f[CR]0\f[R] and \f[CR]0x10FFFF\f[R] (inclusive)
representing a Unicode code point.
.SS Return value
A string created by using the specified sequence of code points.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]numN\f[R] is not an integer, is less than \f[CR]0\f[R],
or is greater than \f[CR]0x10FFFF\f[R] after being converted to a
number.
.SH DESCRIPTION
Because \f[CR]fromCodePoint()\f[R] is a static method of
\f[CR]String\f[R], you always use it as
\f[CR]String.fromCodePoint()\f[R], rather than as a method of a
\f[CR]String\f[R] value you created.
.PP
Unicode code points range from \f[CR]0\f[R] to \f[CR]1114111\f[R]
(\f[CR]0x10FFFF\f[R]).
In UTF\-16, each string index is a code unit with value \f[CR]0\f[R]
\(en \f[CR]65535\f[R].
Higher code points are represented by \f[I]a pair\f[R] of 16\-bit
surrogate pseudo\-characters.
Therefore, \f[CR]fromCodePoint()\f[R] may return a string whose
\f[CR]length\f[R] (in UTF\-16 code units) is larger than the number of
arguments passed.
For information on Unicode, see UTF\-16 characters, Unicode code points,
and grapheme clusters.
.SH EXAMPLES
.SS Using fromCodePoint()
Valid input:
.IP
.EX
String.fromCodePoint(42); \f[I]// \(dq*\(dq\f[R]
String.fromCodePoint(65, 90); \f[I]// \(dqAZ\(dq\f[R]
String.fromCodePoint(0x404); \f[I]// \(dq\(rsu0404\(dq === \(dqЄ\(dq\f[R]
String.fromCodePoint(0x2f804); \f[I]// \(dq\(rsuD87E\(rsuDC04\(dq\f[R]
String.fromCodePoint(194564); \f[I]// \(dq\(rsuD87E\(rsuDC04\(dq\f[R]
String.fromCodePoint(0x1d306, 0x61, 0x1d307); \f[I]// \(dq\(rsuD834\(rsuDF06a\(rsuD834\(rsuDF07\(dq\f[R]
.EE
.PP
Invalid input:
.IP
.EX
String.fromCodePoint(\(dq_\(dq); \f[I]// RangeError\f[R]
String.fromCodePoint(\f[B]Infinity\f[R]); \f[I]// RangeError\f[R]
String.fromCodePoint(\-1); \f[I]// RangeError\f[R]
String.fromCodePoint(3.14); \f[I]// RangeError\f[R]
String.fromCodePoint(3e\-2); \f[I]// RangeError\f[R]
String.fromCodePoint(\f[B]NaN\f[R]); \f[I]// RangeError\f[R]
.EE
.SS Compared to fromCharCode()
\f[CR]String.fromCharCode()\f[R] cannot return supplementary characters
(i.e., code points \f[CR]0x010000\f[R] \(en \f[CR]0x10FFFF\f[R]) by
specifying their code point.
Instead, it requires the UTF\-16 surrogate pair in order to return a
supplementary character:
.IP
.EX
String.fromCharCode(0xd83c, 0xdf03); \f[I]// Code Point U+1F303 \(dqNight with\f[R]
String.fromCharCode(55356, 57091); \f[I]// Stars\(dq === \(dq\(rsuD83C\(rsuDF03\(dq\f[R]
.EE
.PP
\f[CR]String.fromCodePoint()\f[R], on the other hand, can return 4\-byte
supplementary characters, as well as the more common 2\-byte BMP
characters, by specifying their code point (which is equivalent to the
UTF\-32 code unit):
.IP
.EX
String.fromCodePoint(0x1f303); \f[I]// or 127747 in decimal\f[R]
.EE
.SH SEE ALSO
.IP \(bu 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-string-and-regexp
Polyfill of \f[CR]String.fromCodePoint\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \(bu 2
\c
.UR https://www.npmjs.com/package/string.fromcodepoint
es\-shims polyfill of \f[CR]String.fromCodePoint\f[R]
.UE \c
.IP \(bu 2
\f[CR]String.fromCharCode()\f[R]
.IP \(bu 2
\f[CR]String.prototype.charAt()\f[R]
.IP \(bu 2
\f[CR]String.prototype.codePointAt()\f[R]
.IP \(bu 2
\f[CR]String.prototype.charCodeAt()\f[R]
