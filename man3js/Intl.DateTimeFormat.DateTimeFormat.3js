.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Intl.DateTimeFormat.DateTimeFormat" "JS" "November 1, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.DateTimeFormat.DateTimeFormat \- Intl.DateTimeFormat() constructor
.SH SYNOPSIS
The \f[B]\f[CB]Intl.DateTimeFormat()\f[B]\f[R] constructor creates
\f[CR]Intl.DateTimeFormat\f[R] objects.
.SH SYNTAX
.IP
.EX
new Intl.DateTimeFormat()
new Intl.DateTimeFormat(locales)
new Intl.DateTimeFormat(locales, options)

Intl.DateTimeFormat()
Intl.DateTimeFormat(locales)
Intl.DateTimeFormat(locales, options)
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]Intl.DateTimeFormat()\f[R] can be called with or
without \f[CR]new\f[R].
Both create a new \f[CR]Intl.DateTimeFormat\f[R] instance.
However, there\[cq]s a special behavior when it\[cq]s called without
\f[CR]new\f[R] and the \f[CR]this\f[R] value is another
\f[CR]Intl.DateTimeFormat\f[R] instance; see Return value.
.RE
.SS Parameters
.TP
\f[B]locales\f[R] \f[I](optional)\f[R]
A string with a BCP 47 language tag or an \f[CR]Intl.Locale\f[R]
instance, or an array of such locale identifiers.
For the general form and interpretation of the \f[CR]locales\f[R]
argument, see the parameter description on the \f[CR]Intl\f[R] main
page.
.RS
.PP
The following Unicode extension key is allowed:
.TP
\f[B]nu\f[R]
See \f[CR]numberingSystem\f[R].
.TP
\f[B]ca\f[R]
See \f[CR]calendar\f[R].
.TP
\f[B]hc\f[R]
See \f[CR]hourCycle\f[R].
.PP
These keys can also be set with \f[CR]options\f[R] (as listed below).
When both are set, the \f[CR]options\f[R] property takes precedence.
.RE
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object.
For ease of reading, the property list is broken into sections based on
their purposes, including locale options, date\-time component options,
and style shortcuts.
.SS Locale options
.TP
\f[B]localeMatcher\f[R]
The locale matching algorithm to use.
Possible values are \f[CR]\[dq]lookup\[dq]\f[R] and
\f[CR]\[dq]best fit\[dq]\f[R]; the default is
\f[CR]\[dq]best fit\[dq]\f[R].
For information about this option, see Locale identification and
negotiation.
.TP
\f[B]calendar\f[R]
The calendar to use, such as \f[CR]\[dq]chinese\[dq]\f[R],
\f[CR]\[dq]gregory\[dq]\f[R], \f[CR]\[dq]persian\[dq]\f[R], and so on.
For a list of supported calendar types, see
\f[CR]Intl.Locale.prototype.getCalendars()\f[R].
This option can also be set through the \f[CR]ca\f[R] Unicode extension
key; if both are provided, this \f[CR]options\f[R] property takes
precedence.
.TP
\f[B]numberingSystem\f[R]
The numbering system to use for number formatting, such as
\f[CR]\[dq]arab\[dq]\f[R], \f[CR]\[dq]hans\[dq]\f[R],
\f[CR]\[dq]mathsans\[dq]\f[R], and so on.
For a list of supported numbering system types, see
\f[CR]Intl.Locale.prototype.getNumberingSystems()\f[R].
This option can also be set through the \f[CR]nu\f[R] Unicode extension
key; if both are provided, this \f[CR]options\f[R] property takes
precedence.
.TP
\f[B]hour12\f[R]
Whether to use 12\-hour time (as opposed to 24\-hour time).
Possible values are \f[CR]true\f[R] and \f[CR]false\f[R]; the default is
locale dependent.
This option overrides the \f[CR]hc\f[R] locale extension tag and/or the
\f[CR]hourCycle\f[R] option in case both are present.
It sets \f[CR]hourCycle\f[R] to \f[CR]\[dq]h11\[dq]\f[R] or
\f[CR]\[dq]h12\[dq]\f[R] when \f[CR]true\f[R], and
\f[CR]\[dq]h23\[dq]\f[R] or \f[CR]\[dq]h24\[dq]\f[R] when
\f[CR]false\f[R], the exact choice depending on the locale \[em] for
example, if the locale most prefers \f[CR]\[dq]h23\[dq]\f[R] but
\f[CR]hour12\f[R] is \f[CR]true\f[R], then the final hour cycle is
\f[CR]\[dq]h11\[dq]\f[R].
.TP
\f[B]hourCycle\f[R]
The hour cycle to use.
Possible values are \f[CR]\[dq]h11\[dq]\f[R], \f[CR]\[dq]h12\[dq]\f[R],
\f[CR]\[dq]h23\[dq]\f[R], and \f[CR]\[dq]h24\[dq]\f[R].
This option can also be set through the \f[CR]hc\f[R] Unicode extension
key; if both are provided, this \f[CR]options\f[R] property takes
precedence.
.TP
\f[B]timeZone\f[R]
The time zone to use.
The only value implementations must recognize is
\f[CR]\[dq]UTC\[dq]\f[R]; the default is the runtime\[cq]s default time
zone.
Implementations may also recognize the time zone names of the \c
.UR https://www.iana.org/time-zones
IANA time zone database
.UE \c
, such as \f[CR]\[dq]Asia/Shanghai\[dq]\f[R],
\f[CR]\[dq]Asia/Kolkata\[dq]\f[R],
\f[CR]\[dq]America/New_York\[dq]\f[R].
.SS Date\-time component options
.TP
\f[B]weekday\f[R]
The representation of the weekday.
Possible values are:
.RS
.TP
\f[B]\[dq]long\[dq]\f[R]
E.g., \f[CR]Thursday\f[R]
.TP
\f[B]\[dq]short\[dq]\f[R]
E.g., \f[CR]Thu\f[R]
.TP
\f[B]\[dq]narrow\[dq]\f[R]
E.g., \f[CR]T\f[R].
Two weekdays may have the same narrow style for some locales
(e.g.\ \f[CR]Tuesday\f[R]\[cq]s narrow style is also \f[CR]T\f[R]).
.RE
.TP
\f[B]era\f[R]
The representation of the era.
Possible values are:
.RS
.TP
\f[B]\[dq]long\[dq]\f[R]
E.g., \f[CR]Anno Domini\f[R]
.TP
\f[B]\[dq]short\[dq]\f[R]
E.g., \f[CR]AD\f[R]
.TP
\f[B]\[dq]narrow\[dq]\f[R]
E.g., \f[CR]A\f[R]
.RE
.TP
\f[B]year\f[R]
The representation of the year.
Possible values are \f[CR]\[dq]numeric\[dq]\f[R] and
\f[CR]\[dq]2\-digit\[dq]\f[R].
.TP
\f[B]month\f[R]
The representation of the month.
Possible values are:
.RS
.TP
\f[B]\[dq]numeric\[dq]\f[R]
E.g., \f[CR]3\f[R]
.TP
\f[B]\[dq]2\-digit\[dq]\f[R]
E.g., \f[CR]03\f[R]
.TP
\f[B]\[dq]long\[dq]\f[R]
E.g., \f[CR]March\f[R]
.TP
\f[B]\[dq]short\[dq]\f[R]
E.g., \f[CR]Mar\f[R]
.TP
\f[B]\[dq]narrow\[dq]\f[R]
E.g., \f[CR]M\f[R]).
Two months may have the same narrow style for some locales
(e.g.\ \f[CR]May\f[R]\[cq]s narrow style is also \f[CR]M\f[R]).
.RE
.TP
\f[B]day\f[R]
The representation of the day.
Possible values are \f[CR]\[dq]numeric\[dq]\f[R] and
\f[CR]\[dq]2\-digit\[dq]\f[R].
.TP
\f[B]dayPeriod\f[R]
The formatting style used for day periods like \[lq]in the morning\[rq],
\[lq]am\[rq], \[lq]noon\[rq], \[lq]n\[rq] etc.
Possible values are \f[CR]\[dq]narrow\[dq]\f[R],
\f[CR]\[dq]short\[dq]\f[R], and \f[CR]\[dq]long\[dq]\f[R].
.RS
.RS
.PP
\f[B]Note:\f[R] This option only has an effect if a 12\-hour clock
(\f[CR]hourCycle: \[dq]h12\[dq]\f[R] or
\f[CR]hourCycle: \[dq]h11\[dq]\f[R]) is used.
Many locales use the same string irrespective of the width specified.
.RE
.RE
.TP
\f[B]hour\f[R]
The representation of the hour.
Possible values are \f[CR]\[dq]numeric\[dq]\f[R] and
\f[CR]\[dq]2\-digit\[dq]\f[R].
.TP
\f[B]minute\f[R]
The representation of the minute.
Possible values are \f[CR]\[dq]numeric\[dq]\f[R] and
\f[CR]\[dq]2\-digit\[dq]\f[R].
.TP
\f[B]second\f[R]
The representation of the second.
Possible values are \f[CR]\[dq]numeric\[dq]\f[R] and
\f[CR]\[dq]2\-digit\[dq]\f[R].
.TP
\f[B]fractionalSecondDigits\f[R]
The number of digits used to represent fractions of a second (any
additional digits are truncated).
Possible values are from \f[CR]1\f[R] to \f[CR]3\f[R].
.TP
\f[B]timeZoneName\f[R]
The localized representation of the time zone name.
Possible values are:
.RS
.TP
\f[B]\[dq]long\[dq]\f[R]
Long localized form (e.g., \f[CR]Pacific Standard Time\f[R],
\f[CR]Nordamerikanische Westküsten\-Normalzeit\f[R])
.TP
\f[B]\[dq]short\[dq]\f[R]
Short localized form (e.g.: \f[CR]PST\f[R], \f[CR]GMT\-8\f[R])
.TP
\f[B]\[dq]shortOffset\[dq]\f[R]
Short localized GMT format (e.g., \f[CR]GMT\-8\f[R])
.TP
\f[B]\[dq]longOffset\[dq]\f[R]
Long localized GMT format (e.g., \f[CR]GMT\-08:00\f[R])
.TP
\f[B]\[dq]shortGeneric\[dq]\f[R]
Short generic non\-location format (e.g.: \f[CR]PT\f[R],
\f[CR]Los Angeles Zeit\f[R]).
.TP
\f[B]\[dq]longGeneric\[dq]\f[R]
Long generic non\-location format (e.g.: \f[CR]Pacific Time\f[R],
\f[CR]Nordamerikanische Westküstenzeit\f[R])
.RS
.PP
\f[B]Note:\f[R] Timezone display may fall back to another format if a
required string is unavailable.
For example, the non\-location formats should display the timezone
without a specific country/city location like \[lq]Pacific Time\[rq],
but may fall back to a timezone like \[lq]Los Angeles Time\[rq].
.RE
.RE
.PP
The default value for each date\-time component option is
\f[CR]undefined\f[R], but if all component properties are
\f[CR]undefined\f[R], then \f[CR]year\f[R], \f[CR]month\f[R], and
\f[CR]day\f[R] default to \f[CR]\[dq]numeric\[dq]\f[R].
If any of the date\-time component options is specified, then
\f[CR]dateStyle\f[R] and \f[CR]timeStyle\f[R] must be
\f[CR]undefined\f[R].
.TP
\f[B]formatMatcher\f[R]
The format matching algorithm to use.
Possible values are \f[CR]\[dq]basic\[dq]\f[R] and
\f[CR]\[dq]best fit\[dq]\f[R]; the default is
\f[CR]\[dq]best fit\[dq]\f[R].
Implementations are required to support displaying at least the
following subsets of date\-time components:
.RS
.IP \[bu] 2
\f[CR]weekday\f[R], \f[CR]year\f[R], \f[CR]month\f[R], \f[CR]day\f[R],
\f[CR]hour\f[R], \f[CR]minute\f[R], \f[CR]second\f[R]
.IP \[bu] 2
\f[CR]weekday\f[R], \f[CR]year\f[R], \f[CR]month\f[R], \f[CR]day\f[R]
.IP \[bu] 2
\f[CR]year\f[R], \f[CR]month\f[R], \f[CR]day\f[R]
.IP \[bu] 2
\f[CR]year\f[R], \f[CR]month\f[R]
.IP \[bu] 2
\f[CR]month\f[R], \f[CR]day\f[R]
.IP \[bu] 2
\f[CR]hour\f[R], \f[CR]minute\f[R], \f[CR]second\f[R]
.IP \[bu] 2
\f[CR]hour\f[R], \f[CR]minute\f[R]
.PP
Implementations may support other subsets, and requests will be
negotiated against all available subset\-representation combinations to
find the best match.
The algorithm for \f[CR]\[dq]best fit\[dq]\f[R] is
implementation\-defined, and \f[CR]\[dq]basic\[dq]\f[R] is \c
.UR https://tc39.es/ecma402/#sec-basicformatmatcher
defined by the spec
.UE \c
\&.
This option is only used when both \f[CR]dateStyle\f[R] and
\f[CR]timeStyle\f[R] are \f[CR]undefined\f[R] (so that each date\-time
component\[cq]s format is individually customizable).
.RE
.SS Style shortcuts
.TP
\f[B]dateStyle\f[R]
The date formatting style to use when calling \f[CR]format()\f[R].
Possible values are \f[CR]\[dq]full\[dq]\f[R],
\f[CR]\[dq]long\[dq]\f[R], \f[CR]\[dq]medium\[dq]\f[R], and
\f[CR]\[dq]short\[dq]\f[R].
.TP
\f[B]timeStyle\f[R]
The time formatting style to use when calling \f[CR]format()\f[R].
Possible values are \f[CR]\[dq]full\[dq]\f[R],
\f[CR]\[dq]long\[dq]\f[R], \f[CR]\[dq]medium\[dq]\f[R], and
\f[CR]\[dq]short\[dq]\f[R].
.RS
.PP
\f[B]Note:\f[R] \f[CR]dateStyle\f[R] and \f[CR]timeStyle\f[R] can be
used with each other, but not with other date\-time component options
(e.g.\ \f[CR]weekday\f[R], \f[CR]hour\f[R], \f[CR]month\f[R], etc.).
.RE
.SS Return value
A new \f[CR]Intl.DateTimeFormat\f[R] object.
.RS
.PP
\f[B]Note:\f[R] The text below describes behavior that is marked by the
specification as \[lq]optional\[rq].
It may not work in all environments.
Check the browser compatibility table.
.RE
.PP
Normally, \f[CR]Intl.DateTimeFormat()\f[R] can be called with or without
\f[CR]new\f[R], and a new \f[CR]Intl.DateTimeFormat\f[R] instance is
returned in both cases.
However, if the \f[CR]this\f[R] value is an object that is
\f[CR]instanceof\f[R] \f[CR]Intl.DateTimeFormat\f[R] (doesn\[cq]t
necessarily mean it\[cq]s created via
\f[CR]new Intl.DateTimeFormat\f[R]; just that it has
\f[CR]Intl.DateTimeFormat.prototype\f[R] in its prototype chain), then
the value of \f[CR]this\f[R] is returned instead, with the newly created
\f[CR]Intl.DateTimeFormat\f[R] object hidden in a
\f[CR][Symbol(IntlLegacyConstructedSymbol)]\f[R] property (a unique
symbol that\[cq]s reused between instances).
.IP
.EX
const formatter = Intl.DateTimeFormat.call(
  { __proto__: Intl.DateTimeFormat.prototype },
  \[dq]en\-US\[dq],
  { dateStyle: \[dq]full\[dq] },
);
console.log(Object.getOwnPropertyDescriptors(formatter));
// {
//   [Symbol(IntlLegacyConstructedSymbol)]: {
//     value: DateTimeFormat [Intl.DateTimeFormat] {},
//     writable: false,
//     enumerable: false,
//     configurable: false
//   }
// }
.EE
.PP
Note that there\[cq]s only one actual \f[CR]Intl.DateTimeFormat\f[R]
instance here: the one hidden in
\f[CR][Symbol(IntlLegacyConstructedSymbol)]\f[R].
Calling the \f[CR]format()\f[R] and \f[CR]resolvedOptions()\f[R] methods
on \f[CR]formatter\f[R] would correctly use the options stored in that
instance, but calling all other methods (e.g.\ \f[CR]formatRange()\f[R])
would fail: \[lq]TypeError: formatRange method called on incompatible
Object\[rq], because those methods don\[cq]t consult the hidden
instance\[cq]s options.
.PP
This behavior, called \f[CR]ChainDateTimeFormat\f[R], does not happen
when \f[CR]Intl.DateTimeFormat()\f[R] is called without \f[CR]new\f[R]
but with \f[CR]this\f[R] set to anything else that\[cq]s not an
\f[CR]instanceof Intl.DateTimeFormat\f[R].
If you call it directly as \f[CR]Intl.DateTimeFormat()\f[R], the
\f[CR]this\f[R] value is \f[CR]Intl\f[R], and a new
\f[CR]Intl.DateTimeFormat\f[R] instance is created normally.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]locales\f[R] or \f[CR]options\f[R] contain invalid
values.
.SH EXAMPLES
.SS Using DateTimeFormat
In basic use without specifying a locale, \f[CR]DateTimeFormat\f[R] uses
the default locale and default options.
.IP
.EX
const date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));

// toLocaleString without arguments depends on the implementation,
// the default locale, and the default time zone
console.log(new Intl.DateTimeFormat().format(date));
// \[dq]12/19/2012\[dq] if run with en\-US locale (language) and time zone America/Los_Angeles (UTC\-0800)
.EE
.SS Using timeStyle and dateStyle
.IP
.EX
const shortTime = new Intl.DateTimeFormat(\[dq]en\[dq], {
  timeStyle: \[dq]short\[dq],
});
console.log(shortTime.format(Date.now())); // \[dq]1:31 PM\[dq]

const shortDate = new Intl.DateTimeFormat(\[dq]en\[dq], {
  dateStyle: \[dq]short\[dq],
});
console.log(shortDate.format(Date.now())); // \[dq]07/07/20\[dq]

const mediumTime = new Intl.DateTimeFormat(\[dq]en\[dq], {
  timeStyle: \[dq]medium\[dq],
  dateStyle: \[dq]short\[dq],
});
console.log(mediumTime.format(Date.now())); // \[dq]07/07/20, 1:31:55 PM\[dq]
.EE
.SS Using dayPeriod
Use the \f[CR]dayPeriod\f[R] option to output a string for the times of
day (\[lq]in the morning\[rq], \[lq]at night\[rq], \[lq]noon\[rq],
etc.).
Note, that this only works when formatting for a 12 hour clock
(\f[CR]hourCycle: \[aq]h12\[aq]\f[R] or
\f[CR]hourCycle: \[aq]h11\[aq]\f[R]) and that for many locales the
strings are the same irrespective of the value passed for the
\f[CR]dayPeriod\f[R].
.IP
.EX
const date = Date.UTC(2012, 11, 17, 4, 0, 42);

console.log(
  new Intl.DateTimeFormat(\[dq]en\-GB\[dq], {
    hour: \[dq]numeric\[dq],
    hourCycle: \[dq]h12\[dq],
    dayPeriod: \[dq]short\[dq],
    timeZone: \[dq]UTC\[dq],
  }).format(date),
);
// 4 at night\[dq]  (same formatting in en\-GB for all dayPeriod values)

console.log(
  new Intl.DateTimeFormat(\[dq]fr\[dq], {
    hour: \[dq]numeric\[dq],
    hourCycle: \[dq]h12\[dq],
    dayPeriod: \[dq]narrow\[dq],
    timeZone: \[dq]UTC\[dq],
  }).format(date),
);
// \[dq]4 mat.\[dq]  (same output in French for both narrow/short dayPeriod)

console.log(
  new Intl.DateTimeFormat(\[dq]fr\[dq], {
    hour: \[dq]numeric\[dq],
    hourCycle: \[dq]h12\[dq],
    dayPeriod: \[dq]long\[dq],
    timeZone: \[dq]UTC\[dq],
  }).format(date),
);
// \[dq]4 du matin\[dq]
.EE
.SS Using timeZoneName
Use the \f[CR]timeZoneName\f[R] option to output a string for the
timezone (\[lq]GMT\[rq], \[lq]Pacific Time\[rq], etc.).
.IP
.EX
const date = Date.UTC(2021, 11, 17, 3, 0, 42);
const timezoneNames = [
  \[dq]short\[dq],
  \[dq]long\[dq],
  \[dq]shortOffset\[dq],
  \[dq]longOffset\[dq],
  \[dq]shortGeneric\[dq],
  \[dq]longGeneric\[dq],
];

for (const zoneName of timezoneNames) {
  // Do something with currentValue
  const formatter = new Intl.DateTimeFormat(\[dq]en\-US\[dq], {
    timeZone: \[dq]America/Los_Angeles\[dq],
    timeZoneName: zoneName,
  });
  console.log(\[ga]${zoneName}: ${formatter.format(date)}\[ga]);
}

// Logs:
// short: 12/16/2021, PST
// long: 12/16/2021, Pacific Standard Time
// shortOffset: 12/16/2021, GMT\-8
// longOffset: 12/16/2021, GMT\-08:00
// shortGeneric: 12/16/2021, PT
// longGeneric: 12/16/2021, Pacific Time
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Intl.DateTimeFormat\f[R]
.IP \[bu] 2
\f[CR]Intl.supportedValuesOf()\f[R]
.IP \[bu] 2
\f[CR]Intl\f[R]
