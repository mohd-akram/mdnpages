.\" Automatically generated by Pandoc 3.4
.\"
.TH "Date.Date" "JS" "July 5, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Date.Date \- Date() constructor
.SH SYNOPSIS
The \f[B]\f[CB]Date()\f[B]\f[R] constructor creates \f[CR]Date\f[R]
objects.
When called as a function, it returns a string representing the current
time.
.SH SYNTAX
.IP
.EX
new Date()
new Date(value)
new Date(dateString)
new Date(dateObject)

new Date(year, monthIndex)
new Date(year, monthIndex, day)
new Date(year, monthIndex, day, hours)
new Date(year, monthIndex, day, hours, minutes)
new Date(year, monthIndex, day, hours, minutes, seconds)
new Date(year, monthIndex, day, hours, minutes, seconds, milliseconds)

Date()
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]Date()\f[R] can be called with or without
\f[CR]new\f[R], but with different effects.
See Return value.
.RE
.SS Parameters
There are five basic forms for the \f[CR]Date()\f[R] constructor:
.SS No parameters
When no parameters are provided, the newly\-created \f[CR]Date\f[R]
object represents the current date and time as of the time of
instantiation.
The returned date\[cq]s timestamp is the same as the number returned by
\f[CR]Date.now()\f[R].
.SS Time value or timestamp number
.TP
\f[B]value\f[R]
An integer value representing the timestamp (the number of milliseconds
since midnight at the beginning of January 1, 1970, UTC \[em] a.k.a.
the epoch).
.SS Date string
.TP
\f[B]dateString\f[R]
A string value representing a date, parsed and interpreted using the
same algorithm implemented by \f[CR]Date.parse()\f[R].
See date time string format for caveats on using different formats.
.SS Date object
.TP
\f[B]dateObject\f[R]
An existing \f[CR]Date\f[R] object.
This effectively makes a copy of the existing \f[CR]Date\f[R] object
with the same date and time.
This is equivalent to \f[CR]new Date(dateObject.valueOf())\f[R], except
the \f[CR]valueOf()\f[R] method is not called.
.PP
When one parameter is passed to the \f[CR]Date()\f[R] constructor,
\f[CR]Date\f[R] instances are specially treated.
All other values are converted to primitives.
If the result is a string, it will be parsed as a date string.
Otherwise, the resulting primitive is further coerced to a number and
treated as a timestamp.
.SS Individual date and time component values
Given at least a year and month, this form of \f[CR]Date()\f[R] returns
a \f[CR]Date\f[R] object whose component values (year, month, day, hour,
minute, second, and millisecond) all come from the following parameters.
Any missing fields are given the lowest possible value (\f[CR]1\f[R] for
\f[CR]day\f[R] and \f[CR]0\f[R] for every other component).
The parameter values are all evaluated against the local time zone,
rather than UTC.
\f[CR]Date.UTC()\f[R] accepts similar parameters but interprets the
components as UTC and returns a timestamp.
.PP
If any parameter overflows its defined bounds, it \[lq]carries
over\[rq].
For example, if a \f[CR]monthIndex\f[R] greater than \f[CR]11\f[R] is
passed in, those months will cause the year to increment; if a
\f[CR]minutes\f[R] greater than \f[CR]59\f[R] is passed in,
\f[CR]hours\f[R] will increment accordingly, etc.
Therefore, \f[CR]new Date(1990, 12, 1)\f[R] will return January 1st,
1991; \f[CR]new Date(2020, 5, 19, 25, 65)\f[R] will return 2:05 A.M.
June 20th, 2020.
.PP
Similarly, if any parameter underflows, it \[lq]borrows\[rq] from the
higher positions.
For example, \f[CR]new Date(2020, 5, 0)\f[R] will return May 31st, 2020.
.TP
\f[B]year\f[R]
Integer value representing the year.
Values from \f[CR]0\f[R] to \f[CR]99\f[R] map to the years
\f[CR]1900\f[R] to \f[CR]1999\f[R].
All other values are the actual year.
See the example.
.TP
\f[B]monthIndex\f[R]
Integer value representing the month, beginning with \f[CR]0\f[R] for
January to \f[CR]11\f[R] for December.
.TP
\f[B]day\f[R] \f[I](optional)\f[R]
Integer value representing the day of the month.
Defaults to \f[CR]1\f[R].
.TP
\f[B]hours\f[R] \f[I](optional)\f[R]
Integer value between \f[CR]0\f[R] and \f[CR]23\f[R] representing the
hour of the day.
Defaults to \f[CR]0\f[R].
.TP
\f[B]minutes\f[R] \f[I](optional)\f[R]
Integer value representing the minute segment of a time.
Defaults to \f[CR]0\f[R].
.TP
\f[B]seconds\f[R] \f[I](optional)\f[R]
Integer value representing the second segment of a time.
Defaults to \f[CR]0\f[R].
.TP
\f[B]milliseconds\f[R] \f[I](optional)\f[R]
Integer value representing the millisecond segment of a time.
Defaults to \f[CR]0\f[R].
.SS Return value
Calling \f[CR]new Date()\f[R] (the \f[CR]Date()\f[R] constructor)
returns a \f[CR]Date\f[R] object.
If called with an invalid date string, or if the date to be constructed
will have a timestamp less than \f[CR]\-8,640,000,000,000,000\f[R] or
greater than \f[CR]8,640,000,000,000,000\f[R] milliseconds, it returns
an invalid date (a \f[CR]Date\f[R] object whose \f[CR]toString()\f[R]
method returns \f[CR]\[dq]Invalid Date\[dq]\f[R] and
\f[CR]valueOf()\f[R] method returns \f[CR]NaN\f[R]).
.PP
Calling the \f[CR]Date()\f[R] function (without the \f[CR]new\f[R]
keyword) returns a string representation of the current date and time,
exactly as \f[CR]new Date().toString()\f[R] does.
Any arguments given in a \f[CR]Date()\f[R] function call (without the
\f[CR]new\f[R] keyword) are ignored; regardless of whether it\[cq]s
called with an invalid date string \[em] or even called with any
arbitrary object or other primitive as an argument \[em] it always
returns a string representation of the current date and time.
.SH DESCRIPTION
.SS Reduced time precision
To offer protection against timing attacks and fingerprinting, the
precision of \f[CR]new Date()\f[R] might get rounded depending on
browser settings.
In Firefox, the \f[CR]privacy.reduceTimerPrecision\f[R] preference is
enabled by default and defaults to 2ms.
You can also enable \f[CR]privacy.resistFingerprinting\f[R], in which
case the precision will be 100ms or the value of
\f[CR]privacy.resistFingerprinting.reduceTimerPrecision.microseconds\f[R],
whichever is larger.
.PP
For example, with reduced time precision, the result of
\f[CR]new Date().getTime()\f[R] will always be a multiple of 2, or a
multiple of 100 (or
\f[CR]privacy.resistFingerprinting.reduceTimerPrecision.microseconds\f[R])
with \f[CR]privacy.resistFingerprinting\f[R] enabled.
.IP
.EX
\f[I]// reduced time precision (2ms) in Firefox 60\f[R]
\f[B]new\f[R] Date().getTime();
\f[I]// Might be:\f[R]
\f[I]// 1519211809934\f[R]
\f[I]// 1519211810362\f[R]
\f[I]// 1519211811670\f[R]
\f[I]// \&...\f[R]

\f[I]// reduced time precision with \[ga]privacy.resistFingerprinting\[ga] enabled\f[R]
\f[B]new\f[R] Date().getTime();
\f[I]// Might be:\f[R]
\f[I]// 1519129853500\f[R]
\f[I]// 1519129858900\f[R]
\f[I]// 1519129864400\f[R]
\f[I]// \&...\f[R]
.EE
.SH EXAMPLES
.SS Several ways to create a Date object
The following examples show several ways to create JavaScript dates:
.IP
.EX
\f[B]const\f[R] today = \f[B]new\f[R] Date();
\f[B]const\f[R] birthday = \f[B]new\f[R] Date(\[dq]December 17, 1995 03:24:00\[dq]); \f[I]// DISCOURAGED: may not work in all runtimes\f[R]
\f[B]const\f[R] birthday = \f[B]new\f[R] Date(\[dq]1995\-12\-17T03:24:00\[dq]); \f[I]// This is standardized and will work reliably\f[R]
\f[B]const\f[R] birthday = \f[B]new\f[R] Date(1995, 11, 17); \f[I]// the month is 0\-indexed\f[R]
\f[B]const\f[R] birthday = \f[B]new\f[R] Date(1995, 11, 17, 3, 24, 0);
\f[B]const\f[R] birthday = \f[B]new\f[R] Date(628021800000); \f[I]// passing epoch timestamp\f[R]
.EE
.SS Passing a non\-Date, non\-string, non\-number value
If the \f[CR]Date()\f[R] constructor is called with one parameter which
is not a \f[CR]Date\f[R] instance, it will be coerced to a primitive and
then checked whether it\[cq]s a string.
For example, \f[CR]new Date(undefined)\f[R] is different from
\f[CR]new Date()\f[R]:
.IP
.EX
console.log(\f[B]new\f[R] Date(\f[B]undefined\f[R])); \f[I]// Invalid Date\f[R]
.EE
.PP
This is because \f[CR]undefined\f[R] is already a primitive but not a
string, so it will be coerced to a number, which is \f[CR]NaN\f[R] and
therefore not a valid timestamp.
On the other hand, \f[CR]null\f[R] will be coerced to \f[CR]0\f[R].
.IP
.EX
console.log(\f[B]new\f[R] Date(\f[B]null\f[R])); \f[I]// 1970\-01\-01T00:00:00.000Z\f[R]
.EE
.PP
Arrays would be coerced to a string via
\f[CR]Array.prototype.toString()\f[R], which joins the elements with
commas.
However, the resulting string for any array with more than one element
is not a valid ISO 8601 date string, so its parsing behavior would be
implementation\-defined.
\f[B]Do not pass arrays to the \f[CB]Date()\f[B] constructor.\f[R]
.IP
.EX
console.log(\f[B]new\f[R] Date([\[dq]2020\-06\-19\[dq], \[dq]17:13\[dq]]));
\f[I]// 2020\-06\-19T17:13:00.000Z in Chrome, since it recognizes \[dq]2020\-06\-19,17:13\[dq]\f[R]
\f[I]// \[dq]Invalid Date\[dq] in Firefox\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Date\f[R]
