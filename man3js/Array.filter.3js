.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "Array.filter" "JS" "November 27, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.filter \- Array.prototype.filter()
.SH SYNOPSIS
The \f[B]\f[CB]filter()\f[B]\f[R] method of \f[CR]Array\f[R] instances
creates a shallow copy of a portion of a given array, filtered down to
just the elements from the given array that pass the test implemented by
the provided function.
.SH SYNTAX
.IP
.EX
filter(callbackFn)
filter(callbackFn, thisArg)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element in the array.
It should return a truthy value to keep the element in the resulting
array, and a falsy value otherwise.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.TP
\f[B]array\f[R]
The array \f[CR]filter()\f[R] was called upon.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
A value to use as \f[CR]this\f[R] when executing \f[CR]callbackFn\f[R].
See iterative methods.
.SS Return value
A shallow copy of the given array containing just the elements that pass
the test.
If no elements pass the test, an empty array is returned.
.SH DESCRIPTION
The \f[CR]filter()\f[R] method is an iterative method.
It calls a provided \f[CR]callbackFn\f[R] function once for each element
in an array, and constructs a new array of all the values for which
\f[CR]callbackFn\f[R] returns a truthy value.
Array elements which do not pass the \f[CR]callbackFn\f[R] test are not
included in the new array.
Read the iterative methods section for more information about how these
methods work in general.
.PP
\f[CR]callbackFn\f[R] is invoked only for array indexes which have
assigned values.
It is not invoked for empty slots in sparse arrays.
.PP
The \f[CR]filter()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer\-keyed properties.
.SH EXAMPLES
.SS Filtering out all small values
The following example uses \f[CR]filter()\f[R] to create a filtered
array that has all elements with values less than 10 removed.
.IP
.EX
\f[B]function\f[R] isBigEnough(value) {
  \f[B]return\f[R] value >= 10;
}

\f[B]const\f[R] filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
\f[I]// filtered is [12, 130, 44]\f[R]
.EE
.SS Find all prime numbers in an array
The following example returns all prime numbers in the array:
.IP
.EX
\f[B]const\f[R] array = [\-3, \-2, \-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];

\f[B]function\f[R] isPrime(num) {
  \f[B]for\f[R] (\f[B]let\f[R] i = 2; num > i; i++) {
    \f[B]if\f[R] (num % i === 0) {
      \f[B]return\f[R] \f[B]false\f[R];
    }
  }
  \f[B]return\f[R] num > 1;
}

console.log(array.filter(isPrime)); \f[I]// [2, 3, 5, 7, 11, 13]\f[R]
.EE
.SS Filtering invalid entries from JSON
The following example uses \f[CR]filter()\f[R] to create a filtered JSON
of all elements with non\-zero, numeric \f[CR]id\f[R].
.IP
.EX
\f[B]const\f[R] arr = [
  { id: 15 },
  { id: \-1 },
  { id: 0 },
  { id: 3 },
  { id: 12.2 },
  {},
  { id: \f[B]null\f[R] },
  { id: \f[B]NaN\f[R] },
  { id: \[dq]undefined\[dq] },
];

\f[B]let\f[R] invalidEntries = 0;

\f[B]function\f[R] filterByID(item) {
  \f[B]if\f[R] (Number.isFinite(item.id) && item.id !== 0) {
    \f[B]return\f[R] \f[B]true\f[R];
  }
  invalidEntries++;
  \f[B]return\f[R] \f[B]false\f[R];
}

\f[B]const\f[R] arrByID = arr.filter(filterByID);

console.log(\[dq]Filtered Array\[rs]n\[dq], arrByID);
\f[I]// Filtered Array\f[R]
\f[I]// [{ id: 15 }, { id: \-1 }, { id: 3 }, { id: 12.2 }]\f[R]

console.log(\[dq]Number of Invalid Entries =\[dq], invalidEntries);
\f[I]// Number of Invalid Entries = 5\f[R]
.EE
.SS Searching in array
Following example uses \f[CR]filter()\f[R] to filter array content based
on search criteria.
.IP
.EX
\f[B]const\f[R] fruits = [\[dq]apple\[dq], \[dq]banana\[dq], \[dq]grapes\[dq], \[dq]mango\[dq], \[dq]orange\[dq]];

\f[I]/**\f[R]
\f[I] * Filter array items based on search criteria (query)\f[R]
\f[I] */\f[R]
\f[B]function\f[R] filterItems(arr, query) {
  \f[B]return\f[R] arr.filter((el) \f[B]=>\f[R] el.toLowerCase().includes(query.toLowerCase()));
}

console.log(filterItems(fruits, \[dq]ap\[dq])); \f[I]// [\[aq]apple\[aq], \[aq]grapes\[aq]]\f[R]
console.log(filterItems(fruits, \[dq]an\[dq])); \f[I]// [\[aq]banana\[aq], \[aq]mango\[aq], \[aq]orange\[aq]]\f[R]
.EE
.SS Using the third argument of callbackFn
The \f[CR]array\f[R] argument is useful if you want to access another
element in the array, especially when you don\[cq]t have an existing
variable that refers to the array.
The following example first uses \f[CR]map()\f[R] to extract the
numerical ID from each name and then uses \f[CR]filter()\f[R] to select
the ones that are greater than its neighbors.
.IP
.EX
\f[B]const\f[R] names = [\[dq]JC63\[dq], \[dq]Bob132\[dq], \[dq]Ursula89\[dq], \[dq]Ben96\[dq]];
\f[B]const\f[R] greatIDs = names
  .map((name) \f[B]=>\f[R] parseInt(name.match(/[0\-9]+/)[0], 10))
  .filter((id, idx, arr) \f[B]=>\f[R] {
    \f[I]// Without the arr argument, there\[aq]s no way to easily access the\f[R]
    \f[I]// intermediate array without saving it to a variable.\f[R]
    \f[B]if\f[R] (idx > 0 && id <= arr[idx \- 1]) \f[B]return\f[R] \f[B]false\f[R];
    \f[B]if\f[R] (idx < arr.length \- 1 && id <= arr[idx + 1]) \f[B]return\f[R] \f[B]false\f[R];
    \f[B]return\f[R] \f[B]true\f[R];
  });
console.log(greatIDs); \f[I]// [132, 96]\f[R]
.EE
.PP
The \f[CR]array\f[R] argument is \f[I]not\f[R] the array that is being
built \[em] there is no way to access the array being built from the
callback function.
.SS Using filter() on sparse arrays
\f[CR]filter()\f[R] will skip empty slots.
.IP
.EX
console.log([1, , \f[B]undefined\f[R]].filter((x) \f[B]=>\f[R] x === \f[B]undefined\f[R])); \f[I]// [undefined]\f[R]
console.log([1, , \f[B]undefined\f[R]].filter((x) \f[B]=>\f[R] x !== 2)); \f[I]// [1, undefined]\f[R]
.EE
.SS Calling filter() on non\-array objects
The \f[CR]filter()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R] and then accesses each property whose key is a
nonnegative integer less than \f[CR]length\f[R].
.IP
.EX
\f[B]const\f[R] arrayLike = {
  length: 3,
  0: \[dq]a\[dq],
  1: \[dq]b\[dq],
  2: \[dq]c\[dq],
  3: \[dq]a\[dq], \f[I]// ignored by filter() since length is 3\f[R]
};
console.log(Array.prototype.filter.call(arrayLike, (x) \f[B]=>\f[R] x <= \[dq]b\[dq]));
\f[I]// [ \[aq]a\[aq], \[aq]b\[aq] ]\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.prototype.filter\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Indexed collections guide
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.forEach()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.every()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.map()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.some()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.reduce()\f[R]
.IP \[bu] 2
\f[CR]TypedArray.prototype.filter()\f[R]
