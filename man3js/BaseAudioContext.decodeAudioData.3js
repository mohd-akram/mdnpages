.\" Automatically generated by Pandoc 3.4
.\"
.TH "BaseAudioContext.decodeAudioData" "JS" "July 30, 2024" "JavaScript" "JavaScript Reference Manual"
.SH NAME
BaseAudioContext.decodeAudioData \- BaseAudioContext: decodeAudioData()
method
.SH SYNOPSIS
The \f[CR]decodeAudioData()\f[R] method of the
\f[CR]BaseAudioContext\f[R] Interface is used to asynchronously decode
audio file data contained in an \f[CR]ArrayBuffer\f[R] that is loaded
from \f[CR]fetch()\f[R], \f[CR]XMLHttpRequest\f[R], or
\f[CR]FileReader\f[R].
The decoded \f[CR]AudioBuffer\f[R] is resampled to the
\f[CR]AudioContext\f[R]\[cq]s sampling rate, then passed to a callback
or promise.
.PP
This is the preferred method of creating an audio source for Web Audio
API from an audio track.
This method only works on complete file data, not fragments of audio
file data.
.PP
This function implements two alternative ways to asynchronously return
the audio data or error messages: it returns a \f[CR]Promise\f[R] that
fulfills with the audio data, and also accepts callback arguments to
handle success or failure.
The primary method of interfacing with this function is via its Promise
return value, and the callback parameters are provided for legacy
reasons.
.SH SYNTAX
.IP
.EX
// Promise\-based syntax returns a Promise:
decodeAudioData(arrayBuffer)

// Callback syntax has no return value:
decodeAudioData(arrayBuffer, successCallback)
decodeAudioData(arrayBuffer, successCallback, errorCallback)
.EE
.SS Parameters
.TP
\f[B]arrayBuffer\f[R]
An ArrayBuffer containing the audio data to be decoded, usually grabbed
from \f[CR]fetch()\f[R], \f[CR]XMLHttpRequest\f[R] or
\f[CR]FileReader\f[R].
.TP
\f[B]successCallback\f[R] \f[I](optional)\f[R]
A callback function to be invoked when the decoding successfully
finishes.
The single argument to this callback is an \f[CR]AudioBuffer\f[R]
representing the \f[I]decodedData\f[R] (the decoded PCM audio data).
Usually you\[cq]ll want to put the decoded data into an
\f[CR]AudioBufferSourceNode\f[R], from which it can be played and
manipulated how you want.
.TP
\f[B]errorCallback\f[R] \f[I](optional)\f[R]
An optional error callback, to be invoked if an error occurs when the
audio data is being decoded.
.SS Return value
A \f[CR]Promise\f[R] object that fulfills with the
\f[I]decodedData\f[R].
If you are using the XHR syntax you will ignore this return value and
use a callback function instead.
.SH EXAMPLES
In this section we will first cover the promise\-based syntax and then
the callback syntax.
.SS Promise\-based syntax
In this example \f[CR]loadAudio()\f[R] uses \f[CR]fetch()\f[R] to
retrieve an audio file and decodes it into an \f[CR]AudioBuffer\f[R].
It then caches the \f[CR]audioBuffer\f[R] in the global
\f[CR]buffer\f[R] variable for later playback.
.RS
.PP
\f[B]Note:\f[R] You can \c
.UR https://mdn.github.io/webaudio-examples/decode-audio-data/promise/
run the full example live
.UE \c
, or \c
.UR https://github.com/mdn/webaudio-examples/tree/main/decode-audio-data/promise
view the source
.UE \c
\&.
.RE
.IP
.EX
\f[B]let\f[R] audioCtx;
\f[B]let\f[R] buffer;
\f[B]let\f[R] source;

\f[B]async\f[R] \f[B]function\f[R] loadAudio() {
  \f[B]try\f[R] {
    \f[I]// Load an audio file\f[R]
    \f[B]const\f[R] response = \f[B]await\f[R] fetch(\[dq]viper.mp3\[dq]);
    \f[I]// Decode it\f[R]
    buffer = \f[B]await\f[R] audioCtx.decodeAudioData(\f[B]await\f[R] response.arrayBuffer());
  } \f[B]catch\f[R] (err) {
    console.error(\[ga]Unable to fetch the audio file. Error: ${err.message}\[ga]);
  }
}
.EE
.SS Callback syntax
In this example \f[CR]loadAudio()\f[R] uses \f[CR]fetch()\f[R] to
retrieve an audio file and decodes it into an \f[CR]AudioBuffer\f[R]
using the callback\-based version of \f[CR]decodeAudioData()\f[R].
In the callback, it plays the decoded buffer.
.RS
.PP
\f[B]Note:\f[R] You can \c
.UR https://mdn.github.io/webaudio-examples/decode-audio-data/callback/
run the full example live
.UE \c
, or \c
.UR https://github.com/mdn/webaudio-examples/tree/main/decode-audio-data/callback
view the source
.UE \c
\&.
.RE
.IP
.EX
\f[B]let\f[R] audioCtx;
\f[B]let\f[R] source;

\f[B]function\f[R] playBuffer(buffer) {
  source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(audioCtx.destination);
  source.loop = \f[B]true\f[R];
  source.start();
}

\f[B]async\f[R] \f[B]function\f[R] loadAudio() {
  \f[B]try\f[R] {
    \f[I]// Load an audio file\f[R]
    \f[B]const\f[R] response = \f[B]await\f[R] fetch(\[dq]viper.mp3\[dq]);
    \f[I]// Decode it\f[R]
    audioCtx.decodeAudioData(\f[B]await\f[R] response.arrayBuffer(), playBuffer);
  } \f[B]catch\f[R] (err) {
    console.error(\[ga]Unable to fetch the audio file. Error: ${err.message}\[ga]);
  }
}
.EE
.SH SEE ALSO
.IP \[bu] 2
Using the Web Audio API
