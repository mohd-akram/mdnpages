.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "Object.isSealed" "JS" "February 11, 2025" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.isSealed \- Object.isSealed()
.SH SYNOPSIS
The \f[B]\f[CB]Object.isSealed()\f[B]\f[R] static method determines if
an object is sealed.
.IP
.EX
\f[B]const\f[R] object1 = {
  property1: 42,
};

console.log(Object.isSealed(object1));
\f[I]// Expected output: false\f[R]

Object.seal(object1);

console.log(Object.isSealed(object1));
\f[I]// Expected output: true\f[R]
.EE
.SH SYNTAX
.IP
.EX
Object.isSealed(obj)
.EE
.SS Parameters
.TP
\f[B]obj\f[R]
The object which should be checked.
.SS Return value
A \f[CR]Boolean\f[R] indicating whether or not the given object is
sealed.
.SH DESCRIPTION
Returns \f[CR]true\f[R] if the object is sealed, otherwise
\f[CR]false\f[R].
An object is sealed if it is not extensible and if all its properties
are non\-configurable and therefore not removable (but not necessarily
non\-writable).
.SH EXAMPLES
.SS Using Object.isSealed
.IP
.EX
\f[I]// Objects aren\[aq]t sealed by default.\f[R]
\f[B]const\f[R] empty = {};
Object.isSealed(empty); \f[I]// false\f[R]

\f[I]// If you make an empty object non\-extensible,\f[R]
\f[I]// it is vacuously sealed.\f[R]
Object.preventExtensions(empty);
Object.isSealed(empty); \f[I]// true\f[R]

\f[I]// The same is not true of a non\-empty object,\f[R]
\f[I]// unless its properties are all non\-configurable.\f[R]
\f[B]const\f[R] hasProp = { fee: \[dq]fie foe fum\[dq] };
Object.preventExtensions(hasProp);
Object.isSealed(hasProp); \f[I]// false\f[R]

\f[I]// But make them all non\-configurable\f[R]
\f[I]// and the object becomes sealed.\f[R]
Object.defineProperty(hasProp, \[dq]fee\[dq], {
  configurable: \f[B]false\f[R],
});
Object.isSealed(hasProp); \f[I]// true\f[R]

\f[I]// The easiest way to seal an object, of course,\f[R]
\f[I]// is Object.seal.\f[R]
\f[B]const\f[R] sealed = {};
Object.seal(sealed);
Object.isSealed(sealed); \f[I]// true\f[R]

\f[I]// A sealed object is, by definition, non\-extensible.\f[R]
Object.isExtensible(sealed); \f[I]// false\f[R]

\f[I]// A sealed object might be frozen,\f[R]
\f[I]// but it doesn\[aq]t have to be.\f[R]
Object.isFrozen(sealed); \f[I]// true\f[R]
\f[I]// (all properties also non\-writable)\f[R]

\f[B]const\f[R] s2 = Object.seal({ p: 3 });
Object.isFrozen(s2); \f[I]// false\f[R]
\f[I]// (\[aq]p\[aq] is still writable)\f[R]

\f[B]const\f[R] s3 = Object.seal({
  \f[B]get\f[R] p() {
    \f[B]return\f[R] 0;
  },
});
Object.isFrozen(s3); \f[I]// true\f[R]
\f[I]// (only configurability matters for accessor properties)\f[R]
.EE
.SS Non\-object argument
In ES5, if the argument to this method is not an object (a primitive),
then it will cause a \f[CR]TypeError\f[R].
In ES2015, it will return \f[CR]true\f[R] without any errors if a
non\-object argument is passed, since primitives are, by definition,
immutable.
.IP
.EX
Object.isSealed(1);
\f[I]// TypeError: 1 is not an object (ES5 code)\f[R]

Object.isSealed(1);
\f[I]// true                          (ES2015 code)\f[R]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Object.seal()\f[R]
.IP \[bu] 2
\f[CR]Object.preventExtensions()\f[R]
.IP \[bu] 2
\f[CR]Object.isExtensible()\f[R]
.IP \[bu] 2
\f[CR]Object.freeze()\f[R]
.IP \[bu] 2
\f[CR]Object.isFrozen()\f[R]
